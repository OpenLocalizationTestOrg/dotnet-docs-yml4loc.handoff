{"nodes":[{"content":"Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <xref href=\"System.Reflection.Emit.ILGenerator\"></xref> class members (such as <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\"></xref>).","nodes":[{"pos":[0,282],"content":"Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Emit.ILGenerator\"&gt;&lt;/xref&gt;</ph> class members (such as <ph id=\"ph2\">&lt;xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\"&gt;&lt;/xref&gt;</ph>).","source":"Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <xref href=\"System.Reflection.Emit.ILGenerator\"></xref> class members (such as <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\"></xref>)."}],"pos":[10229,10512],"yaml":true},{"content":"For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially \"Partition III: CIL Instruction Set\" and \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.","nodes":[{"pos":[0,509],"content":"For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially \"Partition III: CIL Instruction Set\" and \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.","nodes":[{"content":"For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially \"Partition III: CIL Instruction Set\" and \"Partition II: Metadata Definition and Semantics\".","pos":[0,212]},{"content":"The documentation is available online; see <bpt id=\"p1\">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id=\"p2\">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.","pos":[213,509],"source":" The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site."}]}],"pos":[10523,11035],"yaml":true,"extradata":"MT"},{"content":"Adds two values and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,64],"content":"Adds two values and pushes the result onto the evaluation stack.","nodes":[{"content":"Adds two values and pushes the result onto the evaluation stack.","pos":[0,64]}]}],"pos":[13730,13795],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|58|add|Adds two numeric values, returning a new numeric value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is added to `value2`.  \n  \n4.  The result is pushed onto the stack.  \n  \n Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  \n  \n Integer addition wraps, rather than saturates. For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.  \n  \n Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).  \n  \n The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.  \n  \n|operand|value1 type|value2 type|result type|  \n|-------------|-----------------|-----------------|-----------------|  \n|add|`int32`|`int32`|`int32`|  \n|add|`int32`|`native int`|`native int`|  \n|add|`int32`|`&`|`&`|  \n|add|`int32`|`*`|`*`|  \n|add|`int64`|`int64`|`int64`|  \n|add|`native int`|`int32`|`native int`|  \n|add|`native int`|`native int`|`native int`|  \n|add|`native int`|`&`|`&`|  \n|add|`native int`|`*`|`*`|  \n|add|`F`|`F`|`F`|  \n|add|`&`|`int32`|`&`|  \n|add|`&`|`native int`|`&`|  \n|add|`*`|`int32`|`*`|  \n|add|`*`|`native int`|`*`|  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"58","nodes":[{"content":"58","pos":[0,2]}]},{"pos":[259,262],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[263,318],"content":"Adds two numeric values, returning a new numeric value.","nodes":[{"content":"Adds two numeric values, returning a new numeric value.","pos":[0,55]}]},{"pos":[326,383],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[393,427],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[437,471],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[481,560],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is added to <ph id=\"ph4\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `value1` is added to `value2`."},{"pos":[570,606],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[613,743],"content":"Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).","nodes":[{"content":"Overflow is not detected for integer operations (for proper overflow handling, see <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).","pos":[0,130],"source":"Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>)."}]},{"pos":[750,929],"content":"Integer addition wraps, rather than saturates. For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.","nodes":[{"content":"Integer addition wraps, rather than saturates.","pos":[0,46]},{"content":"For example, assuming 8-bit integers where <ph id=\"ph1\">`value1`</ph> is set to 255 and <ph id=\"ph2\">`value2`</ph> is set to 1, the wrapped result is 0 rather than 256.","pos":[47,179],"source":" For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256."}]},{"pos":[936,1027],"content":"Floating-point overflow returns <ph id=\"ph1\">`+inf`</ph> (<ph id=\"ph2\">`PositiveInfinity`</ph>) or <ph id=\"ph3\">`-inf`</ph> (<ph id=\"ph4\">`NegativeInfinity`</ph>).","source":"Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`)."},{"pos":[1034,1326],"content":"The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.","nodes":[{"content":"The acceptable operand types and their corresponding result data type are listed in the table below.","pos":[0,100]},{"content":"If there is no entry for a particular type combination (for example, <ph id=\"ph1\">`int32`</ph> and <ph id=\"ph2\">`float`</ph>; <ph id=\"ph3\">`int32`</ph> and <ph id=\"ph4\">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.","pos":[101,292],"source":" If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error."}]},{"pos":[1333,1340],"content":"operand","nodes":[{"content":"operand","pos":[0,7]}]},{"pos":[1341,1352],"content":"value1 type","nodes":[{"content":"value1 type","pos":[0,11]}]},{"pos":[1353,1364],"content":"value2 type","nodes":[{"content":"value2 type","pos":[0,11]}]},{"pos":[1365,1376],"content":"result type","nodes":[{"content":"result type","pos":[0,11]}]},{"pos":[1453,1456],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1485,1488],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1527,1530],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1551,1554],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1575,1578],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1607,1610],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1649,1652],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1696,1699],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1725,1728],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1754,1757],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1774,1777],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1798,1801],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1827,1830],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1851,1854],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1883,1988],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`add`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:"},{"pos":[1998,2022],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[13806,15874],"yaml":true,"extradata":"MT"},{"content":"Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,95],"content":"Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"content":"Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.","pos":[0,95]}]}],"pos":[17467,17563],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D6|add.ovf|Adds two signed integer values with an overflow check.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.  \n  \n4.  The result is pushed onto the stack.  \n  \n <xref:System.OverflowException> is thrown if the result is not represented in the result type.  \n  \n You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.  \n  \n The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.  \n  \n|operand|value1 type|value2 type|result type|  \n|-------------|-----------------|-----------------|-----------------|  \n|add|`int32`|`int32`|`int32`|  \n|add|`int32`|`native int`|`native int`|  \n|add|`int32`|`&`|`&`|  \n|add|`int32`|`*`|`*`|  \n|add|`int64`|`int64`|`int64`|  \n|add|`native int`|`int32`|`native int`|  \n|add|`native int`|`native int`|`native int`|  \n|add|`native int`|`&`|`&`|  \n|add|`native int`|`*`|`*`|  \n|add|`F`|`F`|`F`|  \n|add|`&`|`int32`|`&`|  \n|add|`&`|`native int`|`&`|  \n|add|`*`|`int32`|`*`|  \n|add|`*`|`native int`|`*`|  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D6","nodes":[{"content":"D6","pos":[0,2]}]},{"pos":[259,266],"content":"add.ovf","nodes":[{"content":"add.ovf","pos":[0,7]}]},{"pos":[267,321],"content":"Adds two signed integer values with an overflow check.","nodes":[{"content":"Adds two signed integer values with an overflow check.","pos":[0,54]}]},{"pos":[329,386],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[396,430],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[440,474],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[484,589],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is added to <ph id=\"ph4\">`value2`</ph> with a check for overflow.","source":"`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow."},{"pos":[599,635],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[642,736],"content":"<xref:System.OverflowException> is thrown if the result is not represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.","pos":[0,94],"source":"<xref:System.OverflowException> is thrown if the result is not represented in the result type."}]},{"pos":[743,867],"content":"You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.","nodes":[{"content":"You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.","pos":[0,124],"nodes":[{"content":"You can perform this operation on signed integers.","pos":[0,50]},{"content":"For floating-point values, use <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.","pos":[51,124],"source":" For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>."}]}]},{"pos":[874,1178],"content":"The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.","nodes":[{"content":"The acceptable operand types and their corresponding result data type are listed in the table below.","pos":[0,100]},{"content":"If there is no entry for a particular type combination (for example, <ph id=\"ph1\">`int32`</ph> and <ph id=\"ph2\">`float`</ph>; <ph id=\"ph3\">`int32`</ph> and <ph id=\"ph4\">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.","pos":[101,304],"source":" If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error."}]},{"pos":[1185,1192],"content":"operand","nodes":[{"content":"operand","pos":[0,7]}]},{"pos":[1193,1204],"content":"value1 type","nodes":[{"content":"value1 type","pos":[0,11]}]},{"pos":[1205,1216],"content":"value2 type","nodes":[{"content":"value2 type","pos":[0,11]}]},{"pos":[1217,1228],"content":"result type","nodes":[{"content":"result type","pos":[0,11]}]},{"pos":[1305,1308],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1337,1340],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1379,1382],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1403,1406],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1427,1430],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1459,1462],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1501,1504],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1548,1551],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1577,1580],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1606,1609],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1626,1629],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1650,1653],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1679,1682],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1703,1706],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1735,1844],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`add.ovf`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:"},{"pos":[1854,1878],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[17574,19496],"yaml":true,"extradata":"MT"},{"content":"Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,110],"content":"Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"content":"Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.","pos":[0,110]}]}],"pos":[21111,21222],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D7|add.ovf.un|Adds two unsigned integer values with an overflow check.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.  \n  \n4.  The result is pushed onto the stack.  \n  \n <xref:System.OverflowException> is thrown if the result is not represented in the result type.  \n  \n You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.  \n  \n The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.  \n  \n|operand|value1 type|value2 type|result type|  \n|-------------|-----------------|-----------------|-----------------|  \n|add|`int32`|`int32`|`int32`|  \n|add|`int32`|`native int`|`native int`|  \n|add|`int32`|`&`|`&`|  \n|add|`int32`|`*`|`*`|  \n|add|`int64`|`int64`|`int64`|  \n|add|`native int`|`int32`|`native int`|  \n|add|`native int`|`native int`|`native int`|  \n|add|`native int`|`&`|`&`|  \n|add|`native int`|`*`|`*`|  \n|add|`F`|`F`|`F`|  \n|add|`&`|`int32`|`&`|  \n|add|`&`|`native int`|`&`|  \n|add|`*`|`int32`|`*`|  \n|add|`*`|`native int`|`*`|  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D7","nodes":[{"content":"D7","pos":[0,2]}]},{"pos":[259,269],"content":"add.ovf.un","nodes":[{"content":"add.ovf.un","pos":[0,10]}]},{"pos":[270,326],"content":"Adds two unsigned integer values with an overflow check.","nodes":[{"content":"Adds two unsigned integer values with an overflow check.","pos":[0,56]}]},{"pos":[334,391],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[401,435],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[445,479],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[489,594],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is added to <ph id=\"ph4\">`value2`</ph> with a check for overflow.","source":"`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow."},{"pos":[604,640],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[647,741],"content":"<xref:System.OverflowException> is thrown if the result is not represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.","pos":[0,94],"source":"<xref:System.OverflowException> is thrown if the result is not represented in the result type."}]},{"pos":[748,872],"content":"You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.","nodes":[{"content":"You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.","pos":[0,124],"nodes":[{"content":"You can perform this operation on signed integers.","pos":[0,50]},{"content":"For floating-point values, use <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.","pos":[51,124],"source":" For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>."}]}]},{"pos":[879,1183],"content":"The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.","nodes":[{"content":"The acceptable operand types and their corresponding result data type are listed in the table below.","pos":[0,100]},{"content":"If there is no entry for a particular type combination (for example, <ph id=\"ph1\">`int32`</ph> and <ph id=\"ph2\">`float`</ph>; <ph id=\"ph3\">`int32`</ph> and <ph id=\"ph4\">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.","pos":[101,304],"source":" If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error."}]},{"pos":[1190,1197],"content":"operand","nodes":[{"content":"operand","pos":[0,7]}]},{"pos":[1198,1209],"content":"value1 type","nodes":[{"content":"value1 type","pos":[0,11]}]},{"pos":[1210,1221],"content":"value2 type","nodes":[{"content":"value2 type","pos":[0,11]}]},{"pos":[1222,1233],"content":"result type","nodes":[{"content":"result type","pos":[0,11]}]},{"pos":[1310,1313],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1342,1345],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1384,1387],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1408,1411],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1432,1435],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1464,1467],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1506,1509],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1553,1556],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1582,1585],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1611,1614],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1631,1634],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1655,1658],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1684,1687],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1708,1711],"content":"add","nodes":[{"content":"add","pos":[0,3]}]},{"pos":[1740,1852],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`add.ovf.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:"},{"pos":[1862,1886],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[21233,23163],"yaml":true,"extradata":"MT"},{"content":"Computes the bitwise AND of two values and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,87],"content":"Computes the bitwise AND of two values and pushes the result onto the evaluation stack.","nodes":[{"content":"Computes the bitwise AND of two values and pushes the result onto the evaluation stack.","pos":[0,87]}]}],"pos":[24739,24827],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Instruction|Description|  \n|------------|-----------------|-----------------|  \n|5F|and|Determines the bitwise AND of two integer values.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.  \n  \n `And` is an integer-specific operation.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,178],"content":"Instruction","nodes":[{"content":"Instruction","pos":[0,11]}]},{"pos":[179,190],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[248,250],"content":"5F","nodes":[{"content":"5F","pos":[0,2]}]},{"pos":[251,254],"content":"and","nodes":[{"content":"and","pos":[0,3]}]},{"pos":[255,304],"content":"Determines the bitwise AND of two integer values.","nodes":[{"content":"Determines the bitwise AND of two integer values.","pos":[0,49]}]},{"pos":[312,369],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[379,413],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[423,457],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[467,562],"content":"<ph id=\"ph1\">`value1`</ph> and <ph id=\"ph2\">`value2`</ph> are popped from the stack; the bitwise AND of the two values is computed.","source":"`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed."},{"pos":[572,608],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[615,732],"content":"The <ph id=\"ph1\">`and`</ph> instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.","source":"The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack."},{"pos":[739,778],"content":"<ph id=\"ph1\">`And`</ph> is an integer-specific operation.","source":"`And` is an integer-specific operation."},{"pos":[785,890],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`and`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:"},{"pos":[900,924],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[24838,25787],"yaml":true,"extradata":"MT"},{"content":"Returns an unmanaged pointer to the argument list of the current method.","nodes":[{"pos":[0,72],"content":"Returns an unmanaged pointer to the argument list of the current method.","nodes":[{"content":"Returns an unmanaged pointer to the argument list of the current method.","pos":[0,72]}]}],"pos":[27380,27453],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 00|arglist|Returns an argument list handle for the current method.|  \n  \n No evaluation stack behaviors are performed by this operation.  \n  \n The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method. This handle is valid only during the lifetime of the current method. You can, however, pass the handle to other methods as long as the current method is on the thread of control. You can only execute the `arglist` instruction within a method that takes a variable number of arguments.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 00","nodes":[{"content":"FE 00","pos":[0,5]}]},{"pos":[262,269],"content":"arglist","nodes":[{"content":"arglist","pos":[0,7]}]},{"pos":[270,325],"content":"Returns an argument list handle for the current method.","nodes":[{"content":"Returns an argument list handle for the current method.","pos":[0,55]}]},{"pos":[333,395],"content":"No evaluation stack behaviors are performed by this operation.","nodes":[{"content":"No evaluation stack behaviors are performed by this operation.","pos":[0,62]}]},{"pos":[402,839],"content":"The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method. This handle is valid only during the lifetime of the current method. You can, however, pass the handle to other methods as long as the current method is on the thread of control. You can only execute the `arglist` instruction within a method that takes a variable number of arguments.","nodes":[{"content":"The <ph id=\"ph1\">`arglist`</ph> instruction returns an opaque handle (an unmanaged pointer, of type <ph id=\"ph2\">`native int`</ph>) that represents the argument list of the current method.","pos":[0,152],"source":"The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method."},{"content":"This handle is valid only during the lifetime of the current method.","pos":[153,221]},{"content":"You can, however, pass the handle to other methods as long as the current method is on the thread of control.","pos":[222,331]},{"content":"You can only execute the <ph id=\"ph1\">`arglist`</ph> instruction within a method that takes a variable number of arguments.","pos":[332,437],"source":" You can only execute the `arglist` instruction within a method that takes a variable number of arguments."}]},{"pos":[846,955],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`arglist`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:"},{"pos":[965,989],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[27464,28468],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if two values are equal.","nodes":[{"pos":[0,66],"content":"Transfers control to a target instruction if two values are equal.","nodes":[{"content":"Transfers control to a target instruction if two values are equal.","pos":[0,66]}]}],"pos":[30041,30108],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|3B < `int32` >|beq `target`|Branch to the target instruction at offset `target` if the two values are equal.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.  \n  \n The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`. The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n The acceptable operand types are encapsulated below:  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \n  \n Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"3B &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"3B < `int32` >"},{"pos":[271,283],"content":"beq <ph id=\"ph1\">`target`</ph>","source":"beq `target`"},{"pos":[284,364],"content":"Branch to the target instruction at offset <ph id=\"ph1\">`target`</ph> if the two values are equal.","source":"Branch to the target instruction at offset `target` if the two values are equal."},{"pos":[372,429],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[439,473],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[483,517],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[527,644],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed."},{"pos":[651,1020],"content":"The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`. The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`beq`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is equal to <ph id=\"ph3\">`value2`</ph>.","pos":[0,109],"source":"The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`."},{"content":"The effect is the same as performing a <ph id=\"ph1\">`ceq`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[110,232],"source":" The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[233,369]}]},{"pos":[1027,1079],"content":"The acceptable operand types are encapsulated below:","nodes":[{"content":"The acceptable operand types are encapsulated below:","pos":[0,52]}]},{"pos":[1086,1205],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]}]},{"pos":[1212,1455],"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id=\"ph5\">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).","source":"Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead)."},{"pos":[1462,1567],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`beq`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:"},{"pos":[1577,1608],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[30119,31754],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if two values are equal.","nodes":[{"pos":[0,79],"content":"Transfers control to a target instruction (short form) if two values are equal.","nodes":[{"content":"Transfers control to a target instruction (short form) if two values are equal.","pos":[0,79]}]}],"pos":[33335,33415],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|2E < `int8` >|beq.s `target`|Branch to the target instruction at offset `target` if equal, short form|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.  \n  \n The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`. The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n The acceptable operand types are encapsulated below:  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \n  \n Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"2E &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"2E < `int8` >"},{"pos":[270,284],"content":"beq.s <ph id=\"ph1\">`target`</ph>","source":"beq.s `target`"},{"pos":[285,357],"content":"Branch to the target instruction at offset <ph id=\"ph1\">`target`</ph> if equal, short form","source":"Branch to the target instruction at offset `target` if equal, short form"},{"pos":[365,422],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[432,466],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[476,510],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[520,637],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed."},{"pos":[644,1015],"content":"The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`. The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`beq.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is equal to <ph id=\"ph3\">`value2`</ph>.","pos":[0,111],"source":"The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`."},{"content":"The effect is the same as performing a <ph id=\"ph1\">`ceq`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[112,234],"source":" The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[235,371]}]},{"pos":[1022,1074],"content":"The acceptable operand types are encapsulated below:","nodes":[{"content":"The acceptable operand types are encapsulated below:","pos":[0,52]}]},{"pos":[1081,1200],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]}]},{"pos":[1207,1450],"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id=\"ph5\">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).","source":"Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead)."},{"pos":[1457,1564],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`beq.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:"},{"pos":[1574,1605],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[33426,35058],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is greater than or equal to the second value.","nodes":[{"pos":[0,106],"content":"Transfers control to a target instruction if the first value is greater than or equal to the second value.","nodes":[{"content":"Transfers control to a target instruction if the first value is greater than or equal to the second value.","pos":[0,106]}]}],"pos":[36629,36736],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|3C `<int32>`|bge `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \n  \n The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`. The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,268],"content":"3C <ph id=\"ph1\">`&lt;int32&gt;`</ph>","source":"3C `<int32>`"},{"pos":[269,281],"content":"bge <ph id=\"ph1\">`target`</ph>","source":"bge `target`"},{"pos":[282,403],"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.","pos":[0,121]}]},{"pos":[411,468],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[478,512],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[522,556],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[566,699],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed."},{"pos":[706,1096],"content":"The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`. The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bge`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than or equal to <ph id=\"ph3\">`value2`</ph>.","pos":[0,125],"source":"The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt.un`</ph> instruction followed by a <ph id=\"ph2\">`brfalse`</ph> branch to the specific target instruction.","pos":[126,253],"source":" The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[254,390]}]},{"pos":[1103,1344],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1351,1456],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bge`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:"},{"pos":[1466,1497],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[36747,38267],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.","nodes":[{"pos":[0,119],"content":"Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.","pos":[0,119]}]}],"pos":[39848,39968],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|2F `<int8>`|bge.s `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \n  \n The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`. The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,267],"content":"2F <ph id=\"ph1\">`&lt;int8&gt;`</ph>","source":"2F `<int8>`"},{"pos":[268,282],"content":"bge.s <ph id=\"ph1\">`target`</ph>","source":"bge.s `target`"},{"pos":[283,416],"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.","pos":[0,133]}]},{"pos":[424,481],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[491,525],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[535,569],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[579,712],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed."},{"pos":[719,1111],"content":"The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`. The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bge.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than or equal to <ph id=\"ph3\">`value2`</ph>.","pos":[0,127],"source":"The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt.un`</ph> instruction followed by a <ph id=\"ph2\">`brfalse`</ph> branch to the specific target instruction.","pos":[128,255],"source":" The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[256,392]}]},{"pos":[1118,1359],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1366,1473],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bge.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:"},{"pos":[1483,1514],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[39979,41516],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,160],"content":"Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","pos":[0,160]}]}],"pos":[43105,43266],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|41 `<int32>`|bge.un `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \n  \n The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,268],"content":"41 <ph id=\"ph1\">`&lt;int32&gt;`</ph>","source":"41 `<int32>`"},{"pos":[269,284],"content":"bge.un <ph id=\"ph1\">`target`</ph>","source":"bge.un `target`"},{"pos":[285,424],"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).","pos":[0,139]}]},{"pos":[432,489],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[499,533],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[543,577],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[587,720],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed."},{"pos":[727,1181],"content":"The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bge.un`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than or equal to <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,192],"source":"The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt`</ph> instruction followed by a <ph id=\"ph2\">`brfalse`</ph> branch to the specific target instruction.","pos":[193,317],"source":" The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[318,454]}]},{"pos":[1188,1429],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1436,1544],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bge.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:"},{"pos":[1554,1585],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[43277,44885],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,173],"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","pos":[0,173]}]}],"pos":[46487,46661],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|34 < `int8` >|bge.un.s `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \n  \n The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"34 &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"34 < `int8` >"},{"pos":[270,287],"content":"bge.un.s <ph id=\"ph1\">`target`</ph>","source":"bge.un.s `target`"},{"pos":[288,439],"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.","pos":[0,151]}]},{"pos":[447,504],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[514,548],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[558,592],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[602,735],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed."},{"pos":[742,1198],"content":"The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bge.un.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than or equal to <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,194],"source":"The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt`</ph> instruction followed by a <ph id=\"ph2\">`brfalse`</ph> branch to the specific target instruction.","pos":[195,319],"source":" The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[320,456]}]},{"pos":[1205,1446],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1453,1563],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bge.un.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:"},{"pos":[1573,1604],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[46672,48299],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is greater than the second value.","nodes":[{"pos":[0,94],"content":"Transfers control to a target instruction if the first value is greater than the second value.","nodes":[{"content":"Transfers control to a target instruction if the first value is greater than the second value.","pos":[0,94]}]}],"pos":[49873,49968],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|3D < `int32` >|bgt `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \n  \n The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`. The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"3D &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"3D < `int32` >"},{"pos":[271,283],"content":"bgt <ph id=\"ph1\">`target`</ph>","source":"bgt `target`"},{"pos":[284,393],"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value.","pos":[0,109]}]},{"pos":[401,458],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[468,502],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[512,546],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[556,677],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed."},{"pos":[684,1058],"content":"The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`. The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bgt`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than <ph id=\"ph3\">`value2`</ph>.","pos":[0,113],"source":"The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[114,237],"source":" The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[238,374]}]},{"pos":[1065,1306],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1313,1418],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bgt`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:"},{"pos":[1428,1459],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[49979,51461],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value.","nodes":[{"pos":[0,107],"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value.","pos":[0,107]}]}],"pos":[53042,53150],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|30 < `int8` >|bgt.s `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \n  \n The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`. The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"30 &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"30 < `int8` >"},{"pos":[270,284],"content":"bgt.s <ph id=\"ph1\">`target`</ph>","source":"bgt.s `target`"},{"pos":[285,406],"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.","pos":[0,121]}]},{"pos":[414,471],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[481,515],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[525,559],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[569,690],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed."},{"pos":[697,1073],"content":"The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`. The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bgt.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than <ph id=\"ph3\">`value2`</ph>.","pos":[0,115],"source":"The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[116,239],"source":" The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[240,376]}]},{"pos":[1080,1321],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1328,1435],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bgt.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:"},{"pos":[1445,1476],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[53161,54660],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,160],"content":"Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","pos":[0,160]}]}],"pos":[56249,56410],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|42 < `int32` >|bgt.un `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \n  \n The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"42 &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"42 < `int32` >"},{"pos":[271,286],"content":"bgt.un <ph id=\"ph1\">`target`</ph>","source":"bgt.un `target`"},{"pos":[287,414],"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).","pos":[0,127]}]},{"pos":[422,479],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[489,523],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[533,567],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[577,698],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed."},{"pos":[705,1149],"content":"The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bgt.un`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,180],"source":"The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt.un`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[181,307],"source":" The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[308,444]}]},{"pos":[1156,1397],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1404,1512],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bgt.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:"},{"pos":[1522,1553],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[56421,57997],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,173],"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.","pos":[0,173]}]}],"pos":[59599,59773],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|35 < `int8` >|bgt.un.s `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \n  \n The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"35 &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"35 < `int8` >"},{"pos":[270,287],"content":"bgt.un.s <ph id=\"ph1\">`target`</ph>","source":"bgt.un.s `target`"},{"pos":[288,427],"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.","pos":[0,139]}]},{"pos":[435,492],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[502,536],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[546,580],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[590,711],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is greater than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed."},{"pos":[718,1164],"content":"The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bgt.un.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is greater than <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,182],"source":"The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt.un`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[183,309],"source":" The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[310,446]}]},{"pos":[1171,1412],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1419,1529],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bgt.un.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:"},{"pos":[1539,1570],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[59784,61377],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is less than or equal to the second value.","nodes":[{"pos":[0,103],"content":"Transfers control to a target instruction if the first value is less than or equal to the second value.","nodes":[{"content":"Transfers control to a target instruction if the first value is less than or equal to the second value.","pos":[0,103]}]}],"pos":[62951,63055],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|3E `<int32>`|ble `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \n  \n The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,268],"content":"3E <ph id=\"ph1\">`&lt;int32&gt;`</ph>","source":"3E `<int32>`"},{"pos":[269,281],"content":"ble <ph id=\"ph1\">`target`</ph>","source":"ble `target`"},{"pos":[282,400],"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.","pos":[0,118]}]},{"pos":[408,465],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[475,509],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[519,553],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[563,693],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed."},{"pos":[700,1106],"content":"The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`ble`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than or equal to <ph id=\"ph3\">`value2`</ph>.","pos":[0,122],"source":"The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt`</ph> instruction (<ph id=\"ph2\">`cgt.un`</ph> for floats) followed by a <ph id=\"ph3\">`brfalse`</ph> branch to the specific target instruction.","pos":[123,269],"source":" The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[270,406]}]},{"pos":[1113,1354],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1361,1466],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ble`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:"},{"pos":[1476,1507],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[63066,64596],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.","nodes":[{"pos":[0,116],"content":"Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.","pos":[0,116]}]}],"pos":[66177,66294],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|31 `<int8>`|ble.s `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \n  \n The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,267],"content":"31 <ph id=\"ph1\">`&lt;int8&gt;`</ph>","source":"31 `<int8>`"},{"pos":[268,282],"content":"ble.s <ph id=\"ph1\">`target`</ph>","source":"ble.s `target`"},{"pos":[283,413],"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.","pos":[0,130]}]},{"pos":[421,478],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[488,522],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[532,566],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[576,706],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed."},{"pos":[713,1132],"content":"The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`ble.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than or equal to <ph id=\"ph3\">`value2`</ph>.","pos":[0,124],"source":"The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt`</ph> instruction (<ph id=\"ph2\">`cgt.un`</ph> for floats) instruction followed by a<ph id=\"ph3\">`brfalse`</ph> branch to the specific target instruction.","pos":[125,282],"source":" The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[283,419]}]},{"pos":[1139,1380],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1387,1494],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ble.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:"},{"pos":[1504,1535],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[66305,67863],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,169],"content":"Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.","pos":[0,169]}]}],"pos":[69452,69622],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|43 `<int32>`|ble.un `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \n  \n The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,268],"content":"43 <ph id=\"ph1\">`&lt;int32&gt;`</ph>","source":"43 `<int32>`"},{"pos":[269,284],"content":"ble.un <ph id=\"ph1\">`target`</ph>","source":"ble.un `target`"},{"pos":[285,421],"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).","pos":[0,136]}]},{"pos":[429,486],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[496,530],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[540,574],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[584,714],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed."},{"pos":[721,1194],"content":"The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`ble.un`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than or equal to <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,189],"source":"The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt.un`</ph> instruction (<ph id=\"ph2\">`cgt`</ph> for floats) followed by a <ph id=\"ph3\">`brfalse`</ph> branch to the specific target instruction.","pos":[190,336],"source":" The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[337,473]}]},{"pos":[1201,1442],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1449,1557],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ble.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:"},{"pos":[1567,1598],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[69633,71254],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,182],"content":"Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.","pos":[0,182]}]}],"pos":[72856,73039],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|36 `<int8>`|ble.un.s `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \n  \n The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,267],"content":"36 <ph id=\"ph1\">`&lt;int8&gt;`</ph>","source":"36 `<int8>`"},{"pos":[268,285],"content":"ble.un.s <ph id=\"ph1\">`target`</ph>","source":"ble.un.s `target`"},{"pos":[286,434],"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.","pos":[0,148]}]},{"pos":[442,499],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[509,543],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[553,587],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[597,727],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than or equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed."},{"pos":[734,1209],"content":"The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`ble.un.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than or equal to <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,191],"source":"The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`cgt.un`</ph> instruction (<ph id=\"ph2\">`cgt`</ph> for floats) followed by a <ph id=\"ph3\">`brfalse`</ph> branch to the specific target instruction.","pos":[192,338],"source":" The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[339,475]}]},{"pos":[1216,1457],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1464,1574],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ble.un.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:"},{"pos":[1584,1615],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[73050,74688],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is less than the second value.","nodes":[{"pos":[0,91],"content":"Transfers control to a target instruction if the first value is less than the second value.","nodes":[{"content":"Transfers control to a target instruction if the first value is less than the second value.","pos":[0,91]}]}],"pos":[76262,76354],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|3F < `int32` >|blt `target`|Branch to the target instruction at the specified offset if the first value is less than the second value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \n  \n The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"3F &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"3F < `int32` >"},{"pos":[271,283],"content":"blt <ph id=\"ph1\">`target`</ph>","source":"blt `target`"},{"pos":[284,390],"content":"Branch to the target instruction at the specified offset if the first value is less than the second value.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than the second value.","pos":[0,106]}]},{"pos":[398,455],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[465,499],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[509,543],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[553,671],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed."},{"pos":[678,1061],"content":"The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`blt`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than or equal to <ph id=\"ph3\">`value2`</ph>.","pos":[0,122],"source":"The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[123,246],"source":" The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[247,383]}]},{"pos":[1068,1309],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1316,1421],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`blt`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:"},{"pos":[1431,1462],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[76365,77850],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is less than the second value.","nodes":[{"pos":[0,104],"content":"Transfers control to a target instruction (short form) if the first value is less than the second value.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is less than the second value.","pos":[0,104]}]}],"pos":[79431,79536],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|32 < `int8` >|blt.s `target`|Branch to the target instruction at the specified offset if the first value is less than the second value, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \n  \n The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`. The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"32 &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"32 < `int8` >"},{"pos":[270,284],"content":"blt.s <ph id=\"ph1\">`target`</ph>","source":"blt.s `target`"},{"pos":[285,403],"content":"Branch to the target instruction at the specified offset if the first value is less than the second value, short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than the second value, short form.","pos":[0,118]}]},{"pos":[411,468],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[478,512],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[522,556],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[566,684],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed."},{"pos":[691,1064],"content":"The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`. The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`blt.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than <ph id=\"ph3\">`value2`</ph>.","pos":[0,112],"source":"The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[113,236],"source":" The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[237,373]}]},{"pos":[1071,1312],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1319,1426],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`blt.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:"},{"pos":[1436,1467],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[79547,81037],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,157],"content":"Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.","pos":[0,157]}]}],"pos":[82626,82784],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|44 < `int32` >|blt.un `target`|Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \n  \n The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"44 &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"44 < `int32` >"},{"pos":[271,286],"content":"blt.un <ph id=\"ph1\">`target`</ph>","source":"blt.un `target`"},{"pos":[287,411],"content":"Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).","pos":[0,124]}]},{"pos":[419,476],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[486,520],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[530,564],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[574,692],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed."},{"pos":[699,1140],"content":"The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,177],"source":"The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt.un`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[178,304],"source":" The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[305,441]}]},{"pos":[1147,1388],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1395,1503],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`blt.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:"},{"pos":[1513,1544],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[82795,84362],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"pos":[0,170],"content":"Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.","nodes":[{"content":"Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.","pos":[0,170]}]}],"pos":[85964,86135],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|37 < `int8` >|blt.un.s `target`|Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \n  \n The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"37 &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"37 < `int8` >"},{"pos":[270,287],"content":"blt.un.s <ph id=\"ph1\">`target`</ph>","source":"blt.un.s `target`"},{"pos":[288,424],"content":"Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.","pos":[0,136]}]},{"pos":[432,489],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[499,533],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[543,577],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[587,705],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is less than <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed."},{"pos":[712,1153],"content":"The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is less than <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,177],"source":"The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`clt.un`</ph> instruction followed by a <ph id=\"ph2\">`brtrue`</ph> branch to the specific target instruction.","pos":[178,304],"source":" The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[305,441]}]},{"pos":[1160,1401],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1408,1518],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`blt.un.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:"},{"pos":[1528,1559],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[86146,87728],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.","nodes":[{"pos":[0,115],"content":"Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.","nodes":[{"content":"Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.","pos":[0,115]}]}],"pos":[89320,89436],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|40 < `int32` >|bne.un `target`|Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.  \n  \n The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"40 &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"40 < `int32` >"},{"pos":[271,286],"content":"bne.un <ph id=\"ph1\">`target`</ph>","source":"bne.un `target`"},{"pos":[287,407],"content":"Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).","nodes":[{"content":"Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).","pos":[0,120]}]},{"pos":[415,472],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[482,516],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[526,560],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[570,691],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is not equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed."},{"pos":[698,1140],"content":"The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is not equal to <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,180],"source":"The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`ceq`</ph> instruction followed by a <ph id=\"ph2\">`brfalse`</ph> branch to the specific target instruction.","pos":[181,305],"source":" The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[306,442]}]},{"pos":[1147,1388],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1395,1503],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bne.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:"},{"pos":[1513,1544],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[89447,91014],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.","nodes":[{"pos":[0,128],"content":"Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.","nodes":[{"content":"Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.","pos":[0,128]}]}],"pos":[92616,92745],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|33 < `int8` >|bne.un.s `target`|Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.  \n  \n The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"33 &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"33 < `int8` >"},{"pos":[270,287],"content":"bne.un.s <ph id=\"ph1\">`target`</ph>","source":"bne.un.s `target`"},{"pos":[288,420],"content":"Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.","nodes":[{"content":"Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.","pos":[0,132]}]},{"pos":[428,485],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[495,529],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[539,573],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[583,704],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; if <ph id=\"ph3\">`value1`</ph> is not equal to <ph id=\"ph4\">`value2`</ph>, the branch operation is performed.","source":"`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed."},{"pos":[711,1153],"content":"The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value1`</ph> is not equal to <ph id=\"ph3\">`value2`</ph>, when compared using unsigned integer or unordered float values.","pos":[0,180],"source":"The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values."},{"content":"The effect is identical to performing a <ph id=\"ph1\">`ceq`</ph> instruction followed by a <ph id=\"ph2\">`brfalse`</ph> branch to the specific target instruction.","pos":[181,305],"source":" The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[306,442]}]},{"pos":[1160,1401],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1408,1518],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`bne.un.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:"},{"pos":[1528,1559],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[92756,94338],"yaml":true,"extradata":"MT"},{"content":"Converts a value type to an object reference (type `O`).","nodes":[{"pos":[0,56],"content":"Converts a value type to an object reference (type <ph id=\"ph1\">`O`</ph>).","source":"Converts a value type to an object reference (type `O`)."}],"pos":[95912,95969],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|8C < `T` >|box `valTypeToken`|Convert a value type (of the type specified in `valTypeToken`) to a true object reference.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value type is pushed onto the stack.  \n  \n2.  The value type is popped from the stack; the `box` operation is performed.  \n  \n3.  An object reference to the resulting \"boxed\" value type is pushed onto the stack.  \n  \n A value type has two separate representations within the Common Language Infrastructure (CLI):  \n  \n-   A 'raw' form used when a value type is embedded within another object or on the stack.  \n  \n-   A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.  \n  \n The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`). This is accomplished by creating a new object and copying the data from the value type into the newly allocated object. `valTypeToken` is a metadata token indicating the type of the value type on the stack.  \n  \n <xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.  \n  \n <xref:System.TypeLoadException> is thrown if the class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"8C &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"8C < `T` >"},{"pos":[267,285],"content":"box <ph id=\"ph1\">`valTypeToken`</ph>","source":"box `valTypeToken`"},{"pos":[286,376],"content":"Convert a value type (of the type specified in <ph id=\"ph1\">`valTypeToken`</ph>) to a true object reference.","source":"Convert a value type (of the type specified in `valTypeToken`) to a true object reference."},{"pos":[384,441],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[451,489],"content":"A value type is pushed onto the stack.","nodes":[{"content":"A value type is pushed onto the stack.","pos":[0,38]}]},{"pos":[499,573],"content":"The value type is popped from the stack; the <ph id=\"ph1\">`box`</ph> operation is performed.","source":"The value type is popped from the stack; the `box` operation is performed."},{"pos":[583,664],"content":"An object reference to the resulting \"boxed\" value type is pushed onto the stack.","nodes":[{"content":"An object reference to the resulting \"boxed\" value type is pushed onto the stack.","pos":[0,81]}]},{"pos":[671,765],"content":"A value type has two separate representations within the Common Language Infrastructure (CLI):","nodes":[{"content":"A value type has two separate representations within the Common Language Infrastructure (CLI):","pos":[0,94]}]},{"pos":[775,861],"content":"A 'raw' form used when a value type is embedded within another object or on the stack.","nodes":[{"content":"A 'raw' form used when a value type is embedded within another object or on the stack.","pos":[0,86]}]},{"pos":[871,995],"content":"A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.","nodes":[{"content":"A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.","pos":[0,124]}]},{"pos":[1002,1307],"content":"The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`). This is accomplished by creating a new object and copying the data from the value type into the newly allocated object. `valTypeToken` is a metadata token indicating the type of the value type on the stack.","nodes":[{"content":"The <ph id=\"ph1\">`box`</ph> instruction converts the 'raw' (unboxed) value type into an object reference (type <ph id=\"ph2\">`O`</ph>).","pos":[0,98],"source":"The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`)."},{"content":"This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.","pos":[99,218]},{"content":"<ph id=\"ph1\">`valTypeToken`</ph> is a metadata token indicating the type of the value type on the stack.","pos":[219,305],"source":"`valTypeToken` is a metadata token indicating the type of the value type on the stack."}]},{"pos":[1314,1414],"content":"<xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.","pos":[0,100],"source":"<xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request."}]},{"pos":[1421,1616],"content":"<xref:System.TypeLoadException> is thrown if the class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.","nodes":[{"content":"<xref:System.TypeLoadException> is thrown if the class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.","pos":[0,195],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the class cannot be found.","pos":[0,71],"source":"<xref:System.TypeLoadException> is thrown if the class cannot be found."},{"content":"This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.","pos":[72,195]}]}]},{"pos":[1623,1728],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`box`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:"},{"pos":[1738,1768],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[95980,97781],"yaml":true,"extradata":"MT"},{"content":"Unconditionally transfers control to a target instruction.","nodes":[{"pos":[0,58],"content":"Unconditionally transfers control to a target instruction.","nodes":[{"content":"Unconditionally transfers control to a target instruction.","pos":[0,58]}]}],"pos":[99344,99403],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|38 < `int32` >|br `target`|Branches to a target instruction at the specified offset.|  \n  \n No evaluation stack behaviors are performed by this operation.  \n  \n The `br` instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"38 &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"38 < `int32` >"},{"pos":[271,282],"content":"br <ph id=\"ph1\">`target`</ph>","source":"br `target`"},{"pos":[283,340],"content":"Branches to a target instruction at the specified offset.","nodes":[{"content":"Branches to a target instruction at the specified offset.","pos":[0,57]}]},{"pos":[348,410],"content":"No evaluation stack behaviors are performed by this operation.","nodes":[{"content":"No evaluation stack behaviors are performed by this operation.","pos":[0,62]}]},{"pos":[417,633],"content":"The `br` instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`br`</ph> instruction unconditionally transfers control to a target instruction.","pos":[0,79],"source":"The `br` instruction unconditionally transfers control to a target instruction."},{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[80,216]}]},{"pos":[640,881],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[888,992],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`br`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:"},{"pos":[1002,1033],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[99414,100464],"yaml":true,"extradata":"MT"},{"content":"Unconditionally transfers control to a target instruction (short form).","nodes":[{"pos":[0,71],"content":"Unconditionally transfers control to a target instruction (short form).","nodes":[{"content":"Unconditionally transfers control to a target instruction (short form).","pos":[0,71]}]}],"pos":[102038,102110],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|2B < `int8` >|br.s `target`|Branches to a target instruction at the specified offset, short form.|  \n  \n No evaluation stack behaviors are performed by this operation.  \n  \n The `br.s` instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"2B &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"2B < `int8` >"},{"pos":[270,283],"content":"br.s <ph id=\"ph1\">`target`</ph>","source":"br.s `target`"},{"pos":[284,353],"content":"Branches to a target instruction at the specified offset, short form.","nodes":[{"content":"Branches to a target instruction at the specified offset, short form.","pos":[0,69]}]},{"pos":[361,423],"content":"No evaluation stack behaviors are performed by this operation.","nodes":[{"content":"No evaluation stack behaviors are performed by this operation.","pos":[0,62]}]},{"pos":[430,648],"content":"The `br.s` instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The <ph id=\"ph1\">`br.s`</ph> instruction unconditionally transfers control to a target instruction.","pos":[0,81],"source":"The `br.s` instruction unconditionally transfers control to a target instruction."},{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[82,218]}]},{"pos":[655,896],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[903,1009],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`br.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:"},{"pos":[1019,1050],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[102121,103188],"yaml":true,"extradata":"MT"},{"content":"Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.","nodes":[{"pos":[0,108],"content":"Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.","nodes":[{"content":"Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.","pos":[0,108]}]}],"pos":[104770,104879],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|01|break|inform a debugger that a breakpoint has been reached.|  \n  \n No evaluation stack behaviors are performed by this operation.  \n  \n The `break` instruction is for debugging support. It signals the CLI to inform the debugger that a break point has been tripped. It has no other effect on the interpreter state.  \n  \n The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.  \n  \n The `break` instruction can trap to a debugger, do nothing, or raise a security exception. The exact behavior is implementation-defined.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"01","nodes":[{"content":"01","pos":[0,2]}]},{"pos":[259,264],"content":"break","nodes":[{"content":"break","pos":[0,5]}]},{"pos":[265,318],"content":"inform a debugger that a breakpoint has been reached.","nodes":[{"content":"inform a debugger that a breakpoint has been reached.","pos":[0,53]}]},{"pos":[326,388],"content":"No evaluation stack behaviors are performed by this operation.","nodes":[{"content":"No evaluation stack behaviors are performed by this operation.","pos":[0,62]}]},{"pos":[395,572],"content":"The `break` instruction is for debugging support. It signals the CLI to inform the debugger that a break point has been tripped. It has no other effect on the interpreter state.","nodes":[{"content":"The <ph id=\"ph1\">`break`</ph> instruction is for debugging support.","pos":[0,49],"source":"The `break` instruction is for debugging support."},{"content":"It signals the CLI to inform the debugger that a break point has been tripped.","pos":[50,128]},{"content":"It has no other effect on the interpreter state.","pos":[129,177]}]},{"pos":[579,747],"content":"The <ph id=\"ph1\">`break`</ph> instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.","source":"The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code."},{"pos":[754,890],"content":"The `break` instruction can trap to a debugger, do nothing, or raise a security exception. The exact behavior is implementation-defined.","nodes":[{"content":"The <ph id=\"ph1\">`break`</ph> instruction can trap to a debugger, do nothing, or raise a security exception.","pos":[0,90],"source":"The `break` instruction can trap to a debugger, do nothing, or raise a security exception."},{"content":"The exact behavior is implementation-defined.","pos":[91,136]}]},{"pos":[897,1004],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`break`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:"},{"pos":[1014,1038],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[104890,105947],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if <code>value</code> is `false`, a null reference (`Nothing` in Visual Basic), or zero.","nodes":[{"pos":[0,130],"content":"Transfers control to a target instruction if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">value</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`false`</ph>, a null reference (<ph id=\"ph3\">`Nothing`</ph> in Visual Basic), or zero.","source":"Transfers control to a target instruction if <code>value</code> is `false`, a null reference (`Nothing` in Visual Basic), or zero."}],"pos":[107542,107673],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Branches to a target instruction at the specified offset if `false`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack by a previous operation.  \n  \n2.  `value` is popped from the stack; if `value` is `false`, branch to `target`.  \n  \n The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`). If `value` is non-zero (`true`) execution continues at the next instruction.  \n  \n The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"39 &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"39 < `int32` >"},{"pos":[271,343],"content":"brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`","nodes":[{"content":"brfalse <ph id=\"ph1\">`target`</ph>","pos":[0,16],"source":"brfalse `target`"},{"content":"brnull <ph id=\"ph1\">`target`</ph>","pos":[29,44],"source":" brnull `target`"},{"content":"brzero <ph id=\"ph1\">`target`</ph>","pos":[57,72],"source":" brzero `target`"}]},{"pos":[344,412],"content":"Branches to a target instruction at the specified offset if <ph id=\"ph1\">`false`</ph>.","source":"Branches to a target instruction at the specified offset if `false`."},{"pos":[420,477],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[487,544],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack by a previous operation.","source":"`value` is pushed onto the stack by a previous operation."},{"pos":[554,630],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack; if <ph id=\"ph2\">`value`</ph> is <ph id=\"ph3\">`false`</ph>, branch to <ph id=\"ph4\">`target`</ph>.","source":"`value` is popped from the stack; if `value` is `false`, branch to `target`."},{"pos":[637,970],"content":"The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`). If `value` is non-zero (`true`) execution continues at the next instruction.","nodes":[{"content":"The <ph id=\"ph1\">`brfalse`</ph> instruction (and its aliases <ph id=\"ph2\">`brnull`</ph> and <ph id=\"ph3\">`brzero`</ph>) transfers control to the specified target instruction if <ph id=\"ph4\">`value`</ph> (of type <ph id=\"ph5\">`int32`</ph>, <ph id=\"ph6\">`int64`</ph>, object reference <ph id=\"ph7\">`O`</ph>, managed pointer <ph id=\"ph8\">`&amp;`</ph>, transient pointer <ph id=\"ph9\">`*`</ph>, <ph id=\"ph10\">`native int`</ph>) is zero (<ph id=\"ph11\">`false`</ph>).","pos":[0,256],"source":"The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`)."},{"content":"If <ph id=\"ph1\">`value`</ph> is non-zero (<ph id=\"ph2\">`true`</ph>) execution continues at the next instruction.","pos":[257,333],"source":" If `value` is non-zero (`true`) execution continues at the next instruction."}]},{"pos":[977,1113],"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[0,136]}]},{"pos":[1120,1361],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1368,1477],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`brfalse`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:"},{"pos":[1487,1518],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[107684,109225],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if <code>value</code> is `false`, a null reference, or zero.","nodes":[{"pos":[0,102],"content":"Transfers control to a target instruction if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">value</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`false`</ph>, a null reference, or zero.","source":"Transfers control to a target instruction if <code>value</code> is `false`, a null reference, or zero."}],"pos":[110834,110937],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Branches to a target instruction at the specified offset if `false`, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack by a previous operation.  \n  \n2.  `value` is popped from the stack; if `value` is `false`, branch to `target`.  \n  \n The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`). If `value` is non-zero (`true`) execution continues at the next instruction.  \n  \n The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,268],"content":"2C &lt;<ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"2C <`int8` >"},{"pos":[269,347],"content":"brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`","nodes":[{"content":"brfalse.s <ph id=\"ph1\">`target`</ph>","pos":[0,18],"source":"brfalse.s `target`"},{"content":"brnull.s <ph id=\"ph1\">`target`</ph>","pos":[31,48],"source":" brnull.s `target`"},{"content":"brzero.s <ph id=\"ph1\">`target`</ph>","pos":[61,78],"source":" brzero.s `target`"}]},{"pos":[348,428],"content":"Branches to a target instruction at the specified offset if <ph id=\"ph1\">`false`</ph>, short form.","source":"Branches to a target instruction at the specified offset if `false`, short form."},{"pos":[436,493],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[503,560],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack by a previous operation.","source":"`value` is pushed onto the stack by a previous operation."},{"pos":[570,646],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack; if <ph id=\"ph2\">`value`</ph> is <ph id=\"ph3\">`false`</ph>, branch to <ph id=\"ph4\">`target`</ph>.","source":"`value` is popped from the stack; if `value` is `false`, branch to `target`."},{"pos":[653,988],"content":"The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`). If `value` is non-zero (`true`) execution continues at the next instruction.","nodes":[{"content":"The <ph id=\"ph1\">`brfalse.s`</ph> instruction (and its aliases <ph id=\"ph2\">`brnull`</ph> and <ph id=\"ph3\">`brzero`</ph>) transfers control to the specified target instruction if <ph id=\"ph4\">`value`</ph> (of type <ph id=\"ph5\">`int32`</ph>, <ph id=\"ph6\">`int64`</ph>, object reference <ph id=\"ph7\">`O`</ph>, managed pointer <ph id=\"ph8\">`&amp;`</ph>, transient pointer <ph id=\"ph9\">`*`</ph>, <ph id=\"ph10\">`native int`</ph>) is zero (<ph id=\"ph11\">`false`</ph>).","pos":[0,258],"source":"The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`)."},{"content":"If <ph id=\"ph1\">`value`</ph> is non-zero (<ph id=\"ph2\">`true`</ph>) execution continues at the next instruction.","pos":[259,335],"source":" If `value` is non-zero (`true`) execution continues at the next instruction."}]},{"pos":[995,1131],"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[0,136]}]},{"pos":[1138,1379],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1386,1497],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`brfalse.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:"},{"pos":[1507,1538],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[110948,112509],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction if <code>value</code> is `true`, not null, or non-zero.","nodes":[{"pos":[0,97],"content":"Transfers control to a target instruction if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">value</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`true`</ph>, not null, or non-zero.","source":"Transfers control to a target instruction if <code>value</code> is `true`, not null, or non-zero."}],"pos":[114102,114200],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Branch to a target instruction at the specified offset if non-zero (`true`).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack by a previous operation.  \n  \n2.  `value` is popped from the stack; if `value` is `true`, branch to `target`.  \n  \n The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`). If `value` is zero (`false`) execution continues at the next instruction.  \n  \n If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).  \n  \n The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"3A &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"3A < `int32` >"},{"pos":[271,314],"content":"brtrue `target`<br /><br /> brinst `target`","nodes":[{"content":"brtrue <ph id=\"ph1\">`target`</ph>","pos":[0,15],"source":"brtrue `target`"},{"content":"brinst <ph id=\"ph1\">`target`</ph>","pos":[28,43],"source":" brinst `target`"}]},{"pos":[315,391],"content":"Branch to a target instruction at the specified offset if non-zero (<ph id=\"ph1\">`true`</ph>).","source":"Branch to a target instruction at the specified offset if non-zero (`true`)."},{"pos":[399,456],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[466,523],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack by a previous operation.","source":"`value` is pushed onto the stack by a previous operation."},{"pos":[533,608],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack; if <ph id=\"ph2\">`value`</ph> is <ph id=\"ph3\">`true`</ph>, branch to <ph id=\"ph4\">`target`</ph>.","source":"`value` is popped from the stack; if `value` is `true`, branch to `target`."},{"pos":[615,819],"content":"The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`). If `value` is zero (`false`) execution continues at the next instruction.","nodes":[{"content":"The <ph id=\"ph1\">`brtrue`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value`</ph> (type <ph id=\"ph3\">`native int`</ph>) is nonzero (<ph id=\"ph4\">`true`</ph>).","pos":[0,130],"source":"The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`)."},{"content":"If <ph id=\"ph1\">`value`</ph> is zero (<ph id=\"ph2\">`false`</ph>) execution continues at the next instruction.","pos":[131,204],"source":" If `value` is zero (`false`) execution continues at the next instruction."}]},{"pos":[826,1073],"content":"If <ph id=\"ph1\">`value`</ph> is an object reference (type <ph id=\"ph2\">`O`</ph>) then <ph id=\"ph3\">`brinst`</ph> (an alias for <ph id=\"ph4\">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id=\"ph5\">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).","source":"If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>)."},{"pos":[1080,1216],"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","pos":[0,136]}]},{"pos":[1223,1464],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1471,1579],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`brtrue`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:"},{"pos":[1589,1620],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[114211,115856],"yaml":true,"extradata":"MT"},{"content":"Transfers control to a target instruction (short form) if <code>value</code> is `true`, not null, or non-zero.","nodes":[{"pos":[0,110],"content":"Transfers control to a target instruction (short form) if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">value</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`true`</ph>, not null, or non-zero.","source":"Transfers control to a target instruction (short form) if <code>value</code> is `true`, not null, or non-zero."}],"pos":[117458,117569],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Branch to a target instruction at the specified offset if non-zero (`true`), short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack by a previous operation.  \n  \n2.  `value` is popped from the stack; if `value` is `true`, branch to `target`.  \n  \n The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`). If `value` is zero (`false`) execution continues at the next instruction.  \n  \n If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).  \n  \n The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"2D &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"2D < `int8` >"},{"pos":[270,317],"content":"brtrue.s `target`<br /><br /> brinst.s `target`","nodes":[{"content":"brtrue.s <ph id=\"ph1\">`target`</ph>","pos":[0,17],"source":"brtrue.s `target`"},{"content":"brinst.s <ph id=\"ph1\">`target`</ph>","pos":[30,47],"source":" brinst.s `target`"}]},{"pos":[318,406],"content":"Branch to a target instruction at the specified offset if non-zero (<ph id=\"ph1\">`true`</ph>), short form.","source":"Branch to a target instruction at the specified offset if non-zero (`true`), short form."},{"pos":[414,471],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[481,538],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack by a previous operation.","source":"`value` is pushed onto the stack by a previous operation."},{"pos":[548,623],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack; if <ph id=\"ph2\">`value`</ph> is <ph id=\"ph3\">`true`</ph>, branch to <ph id=\"ph4\">`target`</ph>.","source":"`value` is popped from the stack; if `value` is `true`, branch to `target`."},{"pos":[630,836],"content":"The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`). If `value` is zero (`false`) execution continues at the next instruction.","nodes":[{"content":"The <ph id=\"ph1\">`brtrue.s`</ph> instruction transfers control to the specified target instruction if <ph id=\"ph2\">`value`</ph> (type <ph id=\"ph3\">`native int`</ph>) is nonzero (<ph id=\"ph4\">`true`</ph>).","pos":[0,132],"source":"The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`)."},{"content":"If <ph id=\"ph1\">`value`</ph> is zero (<ph id=\"ph2\">`false`</ph>) execution continues at the next instruction.","pos":[133,206],"source":" If `value` is zero (`false`) execution continues at the next instruction."}]},{"pos":[843,1090],"content":"If <ph id=\"ph1\">`value`</ph> is an object reference (type <ph id=\"ph2\">`O`</ph>) then <ph id=\"ph3\">`brinst`</ph> (an alias for <ph id=\"ph4\">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id=\"ph5\">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).","source":"If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>)."},{"pos":[1097,1233],"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","nodes":[{"content":"The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","pos":[0,136]}]},{"pos":[1240,1481],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]},{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[120,241],"source":" Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."}]},{"pos":[1488,1598],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`brtrue.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:"},{"pos":[1608,1639],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[117580,119244],"yaml":true,"extradata":"MT"},{"content":"Calls the method indicated by the passed method descriptor.","nodes":[{"pos":[0,59],"content":"Calls the method indicated by the passed method descriptor.","nodes":[{"content":"Calls the method indicated by the passed method descriptor.","pos":[0,59]}]}],"pos":[120824,120884],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|28 < `T` >|call `methodDesc`|Call the method described by `methodDesc`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  Method arguments `arg1` through `argN` are pushed onto the stack.  \n  \n2.  Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor. When complete, a return value is generated by the callee method and sent to the caller.  \n  \n3.  The return value is pushed onto the stack.  \n  \n The `call` instruction calls the method indicated by the method descriptor passed with the instruction. The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used. The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control. If the call transfers control to a method of higher trust than the origin method, the stack frame is not released. Instead, the execution continues silently as if the `tail` had not been supplied. The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function. In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).  \n  \n The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. There are three important special cases:  \n  \n 1. Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments. The instance reference must not be a null reference. The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.  \n  \n 2. It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.  \n  \n 3. Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.  \n  \n <xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method. The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.  \n  \n> [!NOTE]\n>  When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:  \n  \n-   ILGenerator.Emit(OpCode, MethodInfo)  \n  \n-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  \n  \n> [!NOTE]\n>  The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls. Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"28 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"28 < `T` >"},{"pos":[267,284],"content":"call <ph id=\"ph1\">`methodDesc`</ph>","source":"call `methodDesc`"},{"pos":[285,327],"content":"Call the method described by <ph id=\"ph1\">`methodDesc`</ph>.","source":"Call the method described by `methodDesc`."},{"pos":[335,392],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[402,467],"content":"Method arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argN`</ph> are pushed onto the stack.","source":"Method arguments `arg1` through `argN` are pushed onto the stack."},{"pos":[477,759],"content":"Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor. When complete, a return value is generated by the callee method and sent to the caller.","nodes":[{"content":"Method arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argN`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.","pos":[0,194],"source":"Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor."},{"content":"When complete, a return value is generated by the callee method and sent to the caller.","pos":[195,282]}]},{"pos":[769,811],"content":"The return value is pushed onto the stack.","nodes":[{"content":"The return value is pushed onto the stack.","pos":[0,42]}]},{"pos":[818,2101],"content":"The `call` instruction calls the method indicated by the method descriptor passed with the instruction. The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used. The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control. If the call transfers control to a method of higher trust than the origin method, the stack frame is not released. Instead, the execution continues silently as if the `tail` had not been supplied. The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function. In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).","nodes":[{"content":"The <ph id=\"ph1\">`call`</ph> instruction calls the method indicated by the method descriptor passed with the instruction.","pos":[0,103],"source":"The `call` instruction calls the method indicated by the method descriptor passed with the instruction."},{"content":"The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.","pos":[104,337]},{"content":"The <ph id=\"ph1\">`call`</ph> instruction can be immediately preceded by a <ph id=\"ph2\">`tail`</ph> (<ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix instruction to specify that the current method state should be released before transferring control.","pos":[338,557],"source":" The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control."},{"content":"If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.","pos":[558,672]},{"content":"Instead, the execution continues silently as if the <ph id=\"ph1\">`tail`</ph> had not been supplied.","pos":[673,754],"source":" Instead, the execution continues silently as if the `tail` had not been supplied."},{"content":"The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.","pos":[755,917]},{"content":"In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).","pos":[918,1283],"source":" In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>)."}]},{"pos":[2108,2387],"content":"The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. There are three important special cases:","nodes":[{"content":"The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. There are three important special cases:","pos":[0,279],"nodes":[{"content":"The arguments are placed on the stack in left-to-right order.","pos":[0,61]},{"content":"That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.","pos":[62,238]},{"content":"There are three important special cases:","pos":[239,279]}]}]},{"pos":[2397,2767],"content":"Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments. The instance reference must not be a null reference. The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.","nodes":[{"content":"Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.","pos":[0,116]},{"content":"The instance reference must not be a null reference.","pos":[117,169]},{"content":"The signature carried in the metadata does not contain an entry in the parameter list for the <ph id=\"ph1\">`this`</ph> pointer; instead, it uses a bit to indicate whether the method requires passing the <ph id=\"ph2\">`this`</ph> pointer.","pos":[170,370],"source":" The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer."}]},{"pos":[2777,3005],"content":"It is valid to call a virtual method using <ph id=\"ph1\">`call`</ph> (rather than <ph id=\"ph2\">`callvirt`</ph>); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.","source":"It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked."},{"pos":[3015,3117],"content":"Note that a delegate's <ph id=\"ph1\">`Invoke`</ph> method can be called with either the <ph id=\"ph2\">`call`</ph> or <ph id=\"ph3\">`callvirt`</ph> instruction.","source":"Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction."},{"pos":[3124,3396],"content":"<xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method. The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.","nodes":[{"content":"<xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method. The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.","pos":[0,272],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if system security does not grant the caller access to the called method.","pos":[0,128],"source":"<xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method."},{"content":"The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.","pos":[129,272]}]}]},{"pos":[3404,4025],"content":"[!NOTE]\n When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.","leadings":["","> "],"nodes":[{"content":" When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.","pos":[8,619],"nodes":[{"content":"When calling methods of System.Object on value types, consider using the <ph id=\"ph1\">`constrained`</ph> prefix with the <ph id=\"ph2\">`callvirt`</ph> instruction instead of emitting a <ph id=\"ph3\">`call`</ph> instruction.","pos":[1,168],"source":" When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction."},{"content":"This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.","pos":[169,317]},{"content":"Consider using the <ph id=\"ph1\">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id=\"ph2\">`MethodImpl`</ph>.","pos":[318,504],"source":" Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`."},{"content":"These issues are described in more detail in the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.","pos":[505,611],"source":" These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode."}]}]},{"pos":[4032,4139],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`call`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:"},{"pos":[4149,4185],"content":"ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, MethodInfo)","pos":[0,36]}]},{"pos":[4195,4243],"content":"ILGenerator.EmitCall(OpCode, MethodInfo, Type[])","nodes":[{"content":"ILGenerator.EmitCall(OpCode, MethodInfo, Type[])","pos":[0,48]}]},{"pos":[4251,4442],"content":"[!NOTE]\n The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls. Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.","leadings":["","> "],"nodes":[{"content":" The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls. Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.","pos":[8,189],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> method is provided for <ph id=\"ph2\">`varargs`</ph> calls.","pos":[1,98],"source":" The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method for normal calls.","pos":[99,181],"source":" Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls."}]}]}],"pos":[120895,125376],"yaml":true,"extradata":"MT"},{"content":"Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.","nodes":[{"pos":[0,133],"content":"Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.","nodes":[{"content":"Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.","pos":[0,133]}]}],"pos":[126958,127092],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|29 < `T` >|calli `callSiteDescr`|Calls the method pointed to with arguments described by the calling convention.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  Method arguments `arg1` through `argN` are pushed onto the stack.  \n  \n2.  The method entry pointer is pushed onto the stack.  \n  \n3.  Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed. When complete, a return value is generated by the callee method and sent to the caller.  \n  \n4.  The return value is pushed onto the stack.  \n  \n The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`. The types of these arguments are described by the specific calling convention (`callSiteDesc`). The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control. If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.  \n  \n The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature). Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.  \n  \n The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.  \n  \n The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.  \n  \n <xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method. The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack. Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.  \n  \n-   ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.  \n  \n-   ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"29 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"29 < `T` >"},{"pos":[267,288],"content":"calli <ph id=\"ph1\">`callSiteDescr`</ph>","source":"calli `callSiteDescr`"},{"pos":[289,368],"content":"Calls the method pointed to with arguments described by the calling convention.","nodes":[{"content":"Calls the method pointed to with arguments described by the calling convention.","pos":[0,79]}]},{"pos":[376,433],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[443,508],"content":"Method arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argN`</ph> are pushed onto the stack.","source":"Method arguments `arg1` through `argN` are pushed onto the stack."},{"pos":[518,568],"content":"The method entry pointer is pushed onto the stack.","nodes":[{"content":"The method entry pointer is pushed onto the stack.","pos":[0,50]}]},{"pos":[578,797],"content":"Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed. When complete, a return value is generated by the callee method and sent to the caller.","nodes":[{"content":"Method arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argN`</ph> and the method entry pointer are popped from the stack; the call to the method is performed.","pos":[0,131],"source":"Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed."},{"content":"When complete, a return value is generated by the callee method and sent to the caller.","pos":[132,219]}]},{"pos":[807,849],"content":"The return value is pushed onto the stack.","nodes":[{"content":"The return value is pushed onto the stack.","pos":[0,42]}]},{"pos":[856,1467],"content":"The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`. The types of these arguments are described by the specific calling convention (`callSiteDesc`). The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control. If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.","nodes":[{"content":"The <ph id=\"ph1\">`calli`</ph> instruction calls the method entry pointer with the arguments <ph id=\"ph2\">`arg1`</ph> through <ph id=\"ph3\">`argN`</ph>.","pos":[0,96],"source":"The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`."},{"content":"The types of these arguments are described by the specific calling convention (<ph id=\"ph1\">`callSiteDesc`</ph>).","pos":[97,192],"source":" The types of these arguments are described by the specific calling convention (`callSiteDesc`)."},{"content":"The <ph id=\"ph1\">`calli`</ph> instruction may be immediately preceded by a <ph id=\"ph2\">`tail`</ph> prefix (<ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) to specify that the current method state should be released before transferring control.","pos":[193,401],"source":" The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control."},{"content":"If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the <ph id=\"ph1\">`tail`</ph> had not been supplied.","pos":[402,611],"source":" If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied."}]},{"pos":[1474,1888],"content":"The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature). Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.","nodes":[{"content":"The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature). Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.","pos":[0,414],"nodes":[{"content":"The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).","pos":[0,234]},{"content":"Such a pointer can be created using the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> instructions, or passed in from native code.","pos":[235,414],"source":" Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code."}]}]},{"pos":[1895,2084],"content":"The calling convention is not checked dynamically, so code that uses a <ph id=\"ph1\">`calli`</ph> instruction does not work correctly if the destination does not actually use the specified calling convention.","source":"The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention."},{"pos":[2091,2512],"content":"The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.","nodes":[{"content":"The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.","pos":[0,421],"nodes":[{"content":"The arguments are placed on the stack in left-to-right order.","pos":[0,61]},{"content":"That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.","pos":[62,238]},{"content":"The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.","pos":[239,421]}]}]},{"pos":[2519,2794],"content":"<xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method. The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","nodes":[{"content":"<xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method. The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","pos":[0,275],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if the system security does not grant the caller access to the called method.","pos":[0,132],"source":"<xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method."},{"content":"The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","pos":[133,275]}]}]},{"pos":[2801,3123],"content":"The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack. Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> methods can be used to perform a <ph id=\"ph2\">`calli`</ph> instruction on the stack.","pos":[0,135],"source":"The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack."},{"content":"Note that <ph id=\"ph1\">`calli`</ph> should be called through the below methods rather than using the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> class to place the instruction directly on the stack.","pos":[136,322],"source":" Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack."}]},{"pos":[3133,3250],"content":"ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.","nodes":[{"content":"ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.","pos":[0,117]}]},{"pos":[3260,3371],"content":"ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.","nodes":[{"content":"ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.","pos":[0,111]}]}],"pos":[127103,130507],"yaml":true,"extradata":"MT"},{"content":"Calls a late-bound method on an object, pushing the return value onto the evaluation stack.","nodes":[{"pos":[0,91],"content":"Calls a late-bound method on an object, pushing the return value onto the evaluation stack.","nodes":[{"content":"Calls a late-bound method on an object, pushing the return value onto the evaluation stack.","pos":[0,91]}]}],"pos":[132108,132200],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|6F < `T` >|callvirt `method`|Calls a specific method associated with `obj`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `obj` is pushed onto the stack.  \n  \n2.  Method arguments `arg1` through `argN` are pushed onto the stack.  \n  \n3.  Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token. When complete, a return value is generated by the callee method and sent to the caller.  \n  \n4.  The return value is pushed onto the stack.  \n  \n The `callvirt` instruction calls a late-bound method on an object. That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer. `Callvirt` can be used to call both virtual and instance methods. The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control. If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.  \n  \n The method metadata token provides the name, class and signature of the method to call. The class associated with `obj` is the class of which it is an instance. If the class defines a non-static method that matches the indicated method name and signature, this method is called. Otherwise all classes in the base class chain of this class are checked in order. It is an error if no method is found.  \n  \n `Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method. If the method has a return value, it is pushed on the stack upon method completion. On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.  \n  \n The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments. The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.  \n  \n Note that a virtual method can also be called using the<xref:System.Reflection.Emit.OpCodes.Call> instruction.  \n  \n <xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.  \n  \n <xref:System.NullReferenceException> is thrown if obj is null.  \n  \n <xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method. The security check may occur when the CIL is converted to native code rather than at run time.  \n  \n> [!NOTE]\n>  When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:  \n  \n-   ILGenerator.Emit(OpCode, MethodInfo)  \n  \n-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"6F &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"6F < `T` >"},{"pos":[267,284],"content":"callvirt <ph id=\"ph1\">`method`</ph>","source":"callvirt `method`"},{"pos":[285,331],"content":"Calls a specific method associated with <ph id=\"ph1\">`obj`</ph>.","source":"Calls a specific method associated with `obj`."},{"pos":[339,396],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[406,457],"content":"An object reference <ph id=\"ph1\">`obj`</ph> is pushed onto the stack.","source":"An object reference `obj` is pushed onto the stack."},{"pos":[467,532],"content":"Method arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argN`</ph> are pushed onto the stack.","source":"Method arguments `arg1` through `argN` are pushed onto the stack."},{"pos":[542,868],"content":"Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token. When complete, a return value is generated by the callee method and sent to the caller.","nodes":[{"content":"Method arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argN`</ph> and the object reference <ph id=\"ph3\">`obj`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <ph id=\"ph4\">`obj`</ph> referred to by the method metadata token.","pos":[0,238],"source":"Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token."},{"content":"When complete, a return value is generated by the callee method and sent to the caller.","pos":[239,326]}]},{"pos":[878,920],"content":"The return value is pushed onto the stack.","nodes":[{"content":"The return value is pushed onto the stack.","pos":[0,42]}]},{"pos":[927,1527],"content":"The `callvirt` instruction calls a late-bound method on an object. That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer. `Callvirt` can be used to call both virtual and instance methods. The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control. If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.","nodes":[{"content":"The <ph id=\"ph1\">`callvirt`</ph> instruction calls a late-bound method on an object.","pos":[0,66],"source":"The `callvirt` instruction calls a late-bound method on an object."},{"content":"That is, the method is chosen based on the runtime type of <ph id=\"ph1\">`obj`</ph> rather than the compile-time class visible in the method pointer.","pos":[67,197],"source":" That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer."},{"content":"<ph id=\"ph1\">`Callvirt`</ph> can be used to call both virtual and instance methods.","pos":[198,263],"source":"`Callvirt` can be used to call both virtual and instance methods."},{"content":"The <ph id=\"ph1\">`callvirt`</ph> instruction may be immediately preceded by a <ph id=\"ph2\">`tail`</ph> (<ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix to specify that the current stack frame should be released before transferring control.","pos":[264,474],"source":" The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control."},{"content":"If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.","pos":[475,600]}]},{"pos":[1534,1932],"content":"The method metadata token provides the name, class and signature of the method to call. The class associated with `obj` is the class of which it is an instance. If the class defines a non-static method that matches the indicated method name and signature, this method is called. Otherwise all classes in the base class chain of this class are checked in order. It is an error if no method is found.","nodes":[{"content":"The method metadata token provides the name, class and signature of the method to call.","pos":[0,87]},{"content":"The class associated with <ph id=\"ph1\">`obj`</ph> is the class of which it is an instance.","pos":[88,160],"source":" The class associated with `obj` is the class of which it is an instance."},{"content":"If the class defines a non-static method that matches the indicated method name and signature, this method is called.","pos":[161,278]},{"content":"Otherwise all classes in the base class chain of this class are checked in order.","pos":[279,360]},{"content":"It is an error if no method is found.","pos":[361,398]}]},{"pos":[1939,2230],"content":"`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method. If the method has a return value, it is pushed on the stack upon method completion. On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.","nodes":[{"content":"<ph id=\"ph1\">`Callvirt`</ph> pops the object and the associated arguments off the evaluation stack before calling the method.","pos":[0,107],"source":"`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method."},{"content":"If the method has a return value, it is pushed on the stack upon method completion.","pos":[108,191]},{"content":"On the callee side, the <ph id=\"ph1\">`obj`</ph> parameter is accessed as argument 0, <ph id=\"ph2\">`arg1`</ph> as argument 1, and so on.","pos":[192,291],"source":" On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on."}]},{"pos":[2237,2710],"content":"The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments. The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.","nodes":[{"content":"The arguments are placed on the stack in left-to-right order.","pos":[0,61]},{"content":"That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.","pos":[62,238]},{"content":"The instance reference <ph id=\"ph1\">`obj`</ph> (always required for <ph id=\"ph2\">`callvirt`</ph>) must be pushed before any of the user-visible arguments.","pos":[239,357],"source":" The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments."},{"content":"The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.","pos":[358,473]}]},{"pos":[2717,2827],"content":"Note that a virtual method can also be called using the<xref:System.Reflection.Emit.OpCodes.Call> instruction.","nodes":[{"content":"Note that a virtual method can also be called using the<ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.","pos":[0,110],"source":"Note that a virtual method can also be called using the<xref:System.Reflection.Emit.OpCodes.Call> instruction."}]},{"pos":[2834,3161],"content":"<xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <ph id=\"ph2\">`obj`</ph> or any of its base classes.","pos":[0,189],"source":"<xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes."},{"content":"This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.","pos":[190,327]}]},{"pos":[3168,3230],"content":"<xref:System.NullReferenceException> is thrown if obj is null.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if obj is null.","pos":[0,62],"source":"<xref:System.NullReferenceException> is thrown if obj is null."}]},{"pos":[3237,3456],"content":"<xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method. The security check may occur when the CIL is converted to native code rather than at run time.","nodes":[{"content":"<xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method. The security check may occur when the CIL is converted to native code rather than at run time.","pos":[0,219],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown if system security does not grant the caller access to the called method.","pos":[0,124],"source":"<xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method."},{"content":"The security check may occur when the CIL is converted to native code rather than at run time.","pos":[125,219]}]}]},{"pos":[3464,4044],"content":"[!NOTE]\n When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.","leadings":["","> "],"nodes":[{"content":" When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.","pos":[8,578],"nodes":[{"content":"When calling methods of System.Object on value types, consider using the <ph id=\"ph1\">`constrained`</ph> prefix with the <ph id=\"ph2\">`callvirt`</ph> instruction.","pos":[1,127],"source":" When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction."},{"content":"This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.","pos":[128,276]},{"content":"Consider using the <ph id=\"ph1\">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id=\"ph2\">`MethodImpl`</ph>.","pos":[277,463],"source":" Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`."},{"content":"These issues are described in more detail in the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.","pos":[464,570],"source":" These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode."}]}]},{"pos":[4051,4161],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`callvirt`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:"},{"pos":[4171,4207],"content":"ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, MethodInfo)","pos":[0,36]}]},{"pos":[4217,4265],"content":"ILGenerator.EmitCall(OpCode, MethodInfo, Type[])","nodes":[{"content":"ILGenerator.EmitCall(OpCode, MethodInfo, Type[])","pos":[0,48]}]}],"pos":[132211,136518],"yaml":true,"extradata":"MT"},{"content":"Attempts to cast an object passed by reference to the specified class.","nodes":[{"pos":[0,70],"content":"Attempts to cast an object passed by reference to the specified class.","nodes":[{"content":"Attempts to cast an object passed by reference to the specified class.","pos":[0,70]}]}],"pos":[138128,138199],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|74 < `T` >|castclass `class`|Casts an object to a new object of type `class`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference is pushed onto the stack.  \n  \n2.  The object reference is popped from the stack; the referenced object is cast as the specified `class`.  \n  \n3.  If successful, a new object reference is pushed onto the stack.  \n  \n The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class. The new class is specified by a metadata token indicating the desired class. If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown. If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.  \n  \n <xref:System.InvalidCastException> is thrown if obj cannot be cast to class.  \n  \n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"74 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"74 < `T` >"},{"pos":[267,284],"content":"castclass <ph id=\"ph1\">`class`</ph>","source":"castclass `class`"},{"pos":[285,333],"content":"Casts an object to a new object of type <ph id=\"ph1\">`class`</ph>.","source":"Casts an object to a new object of type `class`."},{"pos":[341,398],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[408,453],"content":"An object reference is pushed onto the stack.","nodes":[{"content":"An object reference is pushed onto the stack.","pos":[0,45]}]},{"pos":[463,565],"content":"The object reference is popped from the stack; the referenced object is cast as the specified <ph id=\"ph1\">`class`</ph>.","source":"The object reference is popped from the stack; the referenced object is cast as the specified `class`."},{"pos":[575,638],"content":"If successful, a new object reference is pushed onto the stack.","nodes":[{"content":"If successful, a new object reference is pushed onto the stack.","pos":[0,63]}]},{"pos":[645,1172],"content":"The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class. The new class is specified by a metadata token indicating the desired class. If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown. If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.","nodes":[{"content":"The <ph id=\"ph1\">`castclass`</ph> instruction attempts to cast the object reference (type <ph id=\"ph2\">`O`</ph>) atop the stack to a specified class.","pos":[0,113],"source":"The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class."},{"content":"The new class is specified by a metadata token indicating the desired class.","pos":[114,190]},{"content":"If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <ph id=\"ph1\">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.","pos":[191,413],"source":" If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown."},{"content":"If the object reference is a null reference, <ph id=\"ph1\">`castclass`</ph> succeeds and returns the new object as a null reference.","pos":[414,527],"source":" If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference."}]},{"pos":[1179,1255],"content":"<xref:System.InvalidCastException> is thrown if obj cannot be cast to class.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if obj cannot be cast to class.","pos":[0,76],"source":"<xref:System.InvalidCastException> is thrown if obj cannot be cast to class."}]},{"pos":[1262,1465],"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.","nodes":[{"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.","pos":[0,203],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.","pos":[0,67],"source":"<xref:System.TypeLoadException> is thrown if class cannot be found."},{"content":"This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.","pos":[68,203]}]}]},{"pos":[1472,1583],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`castclass`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:"},{"pos":[1593,1623],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[138210,139858],"yaml":true,"extradata":"MT"},{"content":"Compares two values. If they are equal, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"pos":[0,165],"content":"Compares two values. If they are equal, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"content":"Compares two values.","pos":[0,20]},{"content":"If they are equal, the integer value 1 <ph id=\"ph1\">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id=\"ph2\">`int32`</ph>) is pushed onto the evaluation stack.","pos":[21,165],"source":" If they are equal, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack."}]}],"pos":[141574,141740],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 01|ceq|Pushes 1 if `value1` equals `value2`; else pushes 0.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is compared to `value2`.  \n  \n4.  If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \n  \n The `ceq` instruction compares `value1` and `value2`. If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack. Otherwise 0 (of type `int32`) is pushed on the stack.  \n  \n For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN). The infinite values are equal to themselves.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 01","nodes":[{"content":"FE 01","pos":[0,5]}]},{"pos":[262,265],"content":"ceq","nodes":[{"content":"ceq","pos":[0,3]}]},{"pos":[266,318],"content":"Pushes 1 if <ph id=\"ph1\">`value1`</ph> equals <ph id=\"ph2\">`value2`</ph>; else pushes 0.","source":"Pushes 1 if `value1` equals `value2`; else pushes 0."},{"pos":[326,383],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[393,427],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[437,471],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[481,563],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is compared to <ph id=\"ph4\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `value1` is compared to `value2`."},{"pos":[573,672],"content":"If <ph id=\"ph1\">`value1`</ph> is equal to <ph id=\"ph2\">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.","source":"If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack."},{"pos":[679,869],"content":"The `ceq` instruction compares `value1` and `value2`. If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack. Otherwise 0 (of type `int32`) is pushed on the stack.","nodes":[{"content":"The <ph id=\"ph1\">`ceq`</ph> instruction compares <ph id=\"ph2\">`value1`</ph> and <ph id=\"ph3\">`value2`</ph>.","pos":[0,53],"source":"The `ceq` instruction compares `value1` and `value2`."},{"content":"If <ph id=\"ph1\">`value1`</ph> is equal to <ph id=\"ph2\">`value2`</ph>, then 1 (of type <ph id=\"ph3\">`int32`</ph>) is pushed on the stack.","pos":[54,136],"source":" If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack."},{"content":"Otherwise 0 (of type <ph id=\"ph1\">`int32`</ph>) is pushed on the stack.","pos":[137,190],"source":" Otherwise 0 (of type `int32`) is pushed on the stack."}]},{"pos":[876,1022],"content":"For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN). The infinite values are equal to themselves.","nodes":[{"content":"For floating-point number, <ph id=\"ph1\">`ceq`</ph> will return 0 if the numbers are unordered (either or both are NaN).","pos":[0,101],"source":"For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN)."},{"content":"The infinite values are equal to themselves.","pos":[102,146]}]},{"pos":[1029,1134],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ceq`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:"},{"pos":[1144,1168],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[141751,142944],"yaml":true,"extradata":"MT"},{"content":"Compares two values. If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"pos":[0,193],"content":"Compares two values. If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"content":"Compares two values.","pos":[0,20]},{"content":"If the first value is greater than the second, the integer value 1 <ph id=\"ph1\">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id=\"ph2\">`int32`</ph>) is pushed onto the evaluation stack.","pos":[21,193],"source":" If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack."}]}],"pos":[144513,144707],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 02|cgt|Pushes 1 if `value1` is greater than `value2`; else pushes 0.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.  \n  \n4.  If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \n  \n The `cgt` instruction compares `value1` and `value2`. If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack. Otherwise, an `int32` value of 0 is pushed on the stack.  \n  \n-   For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 02","nodes":[{"content":"FE 02","pos":[0,5]}]},{"pos":[262,265],"content":"cgt","nodes":[{"content":"cgt","pos":[0,3]}]},{"pos":[266,327],"content":"Pushes 1 if <ph id=\"ph1\">`value1`</ph> is greater than <ph id=\"ph2\">`value2`</ph>; else pushes 0.","source":"Pushes 1 if `value1` is greater than `value2`; else pushes 0."},{"pos":[335,392],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[402,436],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[446,480],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[490,588],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`cgt`</ph> tests if <ph id=\"ph4\">`value1`</ph> is greater than <ph id=\"ph5\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`."},{"pos":[598,701],"content":"If <ph id=\"ph1\">`value1`</ph> is greater than <ph id=\"ph2\">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.","source":"If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack."},{"pos":[708,916],"content":"The `cgt` instruction compares `value1` and `value2`. If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack. Otherwise, an `int32` value of 0 is pushed on the stack.","nodes":[{"content":"The <ph id=\"ph1\">`cgt`</ph> instruction compares <ph id=\"ph2\">`value1`</ph> and <ph id=\"ph3\">`value2`</ph>.","pos":[0,53],"source":"The `cgt` instruction compares `value1` and `value2`."},{"content":"If <ph id=\"ph1\">`value1`</ph> is strictly greater than <ph id=\"ph2\">`value2`</ph>, then an <ph id=\"ph3\">`int32`</ph> value of 1 is pushed on the stack.","pos":[54,151],"source":" If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack."},{"content":"Otherwise, an <ph id=\"ph1\">`int32`</ph> value of 0 is pushed on the stack.","pos":[152,208],"source":" Otherwise, an `int32` value of 0 is pushed on the stack."}]},{"pos":[926,1050],"content":"For floating-point numbers, <ph id=\"ph1\">`cgt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).","source":"For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN)."},{"pos":[1057,1162],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`cgt`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:"},{"pos":[1172,1196],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[144718,145939],"yaml":true,"extradata":"MT"},{"content":"Compares two unsigned or unordered values. If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"pos":[0,215],"content":"Compares two unsigned or unordered values. If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"content":"Compares two unsigned or unordered values.","pos":[0,42]},{"content":"If the first value is greater than the second, the integer value 1 <ph id=\"ph1\">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id=\"ph2\">`int32`</ph>) is pushed onto the evaluation stack.","pos":[43,215],"source":" If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack."}]}],"pos":[147526,147742],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 03|cgt.un|Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.  \n  \n4.  If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \n  \n An `int32` value of 1 is pushed on the stack if any of the following is `true` :  \n  \n For floating-point numbers, `value1` is not ordered with respect to `value2`.  \n  \n For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.  \n  \n Otherwise an `int32` value of 0 is pushed on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 03","nodes":[{"content":"FE 03","pos":[0,5]}]},{"pos":[262,268],"content":"cgt.un","nodes":[{"content":"cgt.un","pos":[0,6]}]},{"pos":[269,348],"content":"Pushes 1 if <ph id=\"ph1\">`value1`</ph> is greater than <ph id=\"ph2\">`value2`</ph>; else pushes 0 (unsigned values).","source":"Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values)."},{"pos":[356,413],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[423,457],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[467,501],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[511,612],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`cgt.un`</ph> tests if <ph id=\"ph4\">`value1`</ph> is greater than <ph id=\"ph5\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`."},{"pos":[622,725],"content":"If <ph id=\"ph1\">`value1`</ph> is greater than <ph id=\"ph2\">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.","source":"If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack."},{"pos":[732,812],"content":"An <ph id=\"ph1\">`int32`</ph> value of 1 is pushed on the stack if any of the following is <ph id=\"ph2\">`true`</ph> :","source":"An `int32` value of 1 is pushed on the stack if any of the following is `true` :"},{"pos":[819,896],"content":"For floating-point numbers, <ph id=\"ph1\">`value1`</ph> is not ordered with respect to <ph id=\"ph2\">`value2`</ph>.","source":"For floating-point numbers, `value1` is not ordered with respect to `value2`."},{"pos":[903,1002],"content":"For integer values, <ph id=\"ph1\">`value1`</ph> is strictly greater than <ph id=\"ph2\">`value2`</ph> when considered as unsigned numbers.","source":"For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers."},{"pos":[1009,1064],"content":"Otherwise an <ph id=\"ph1\">`int32`</ph> value of 0 is pushed on the stack.","source":"Otherwise an `int32` value of 0 is pushed on the stack."},{"pos":[1071,1179],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`cgt.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:"},{"pos":[1189,1213],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[147753,148995],"yaml":true,"extradata":"MT"},{"content":"Throws <xref href=\"System.ArithmeticException\"></xref> if value is not a finite number.","nodes":[{"pos":[0,87],"content":"Throws <ph id=\"ph1\">&lt;xref href=\"System.ArithmeticException\"&gt;&lt;/xref&gt;</ph> if value is not a finite number.","source":"Throws <xref href=\"System.ArithmeticException\"></xref> if value is not a finite number."}],"pos":[150597,150685],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|C3|ckfinite|throw <xref:System.ArithmeticException> if value is not a finite number.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack..  \n  \n2.  `value` is popped from the stack and the `ckfinite` instruction is performed on it.  \n  \n3.  `value` is pushed back onto the stack if no exception is thrown.  \n  \n The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a \"not a number\" value (NaN) or a `+-` infinity value. `Ckfinite` leaves the value on the stack if no exception is thrown. Execution is unspecified if `value` is not a floating-point number.  \n  \n <xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.  \n  \n Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"C3","nodes":[{"content":"C3","pos":[0,2]}]},{"pos":[259,267],"content":"ckfinite","nodes":[{"content":"ckfinite","pos":[0,8]}]},{"pos":[268,340],"content":"throw <xref:System.ArithmeticException> if value is not a finite number.","nodes":[{"content":"throw <ph id=\"ph1\">&lt;xref:System.ArithmeticException&gt;</ph> if value is not a finite number.","pos":[0,72],"source":"throw <xref:System.ArithmeticException> if value is not a finite number."}]},{"pos":[348,405],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[415,449],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack..","source":"`value` is pushed onto the stack.."},{"pos":[459,542],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the <ph id=\"ph2\">`ckfinite`</ph> instruction is performed on it.","source":"`value` is popped from the stack and the `ckfinite` instruction is performed on it."},{"pos":[552,616],"content":"<ph id=\"ph1\">`value`</ph> is pushed back onto the stack if no exception is thrown.","source":"`value` is pushed back onto the stack if no exception is thrown."},{"pos":[623,928],"content":"The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a \"not a number\" value (NaN) or a `+-` infinity value. `Ckfinite` leaves the value on the stack if no exception is thrown. Execution is unspecified if `value` is not a floating-point number.","nodes":[{"content":"The <ph id=\"ph1\">`ckfinite instruction`</ph> throws <ph id=\"ph2\">&lt;xref:System.ArithmeticException&gt;</ph> if <ph id=\"ph3\">`value`</ph> (a floating-point number) is either a \"not a number\" value (NaN) or a <ph id=\"ph4\">`+-`</ph> infinity value.","pos":[0,169],"source":"The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a \"not a number\" value (NaN) or a `+-` infinity value."},{"content":"<ph id=\"ph1\">`Ckfinite`</ph> leaves the value on the stack if no exception is thrown.","pos":[170,237],"source":"`Ckfinite` leaves the value on the stack if no exception is thrown."},{"content":"Execution is unspecified if <ph id=\"ph1\">`value`</ph> is not a floating-point number.","pos":[238,305],"source":" Execution is unspecified if `value` is not a floating-point number."}]},{"pos":[935,1015],"content":"<ph id=\"ph1\">&lt;xref:System.ArithmeticException&gt;</ph> is thrown if <ph id=\"ph2\">`value`</ph> is not a 'normal' number.","source":"<xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number."},{"pos":[1022,1186],"content":"Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.","nodes":[{"content":"Note that a special exception or a derived class of <ph id=\"ph1\">&lt;xref:System.ArithmeticException&gt;</ph> may be more appropriate, passing the incorrect value to the exception handler.","pos":[0,164],"source":"Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler."}]},{"pos":[1193,1303],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ckfinite`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:"},{"pos":[1313,1337],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[150696,152060],"yaml":true,"extradata":"MT"},{"content":"Compares two values. If the first value is less than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"pos":[0,190],"content":"Compares two values. If the first value is less than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"content":"Compares two values.","pos":[0,20]},{"content":"If the first value is less than the second, the integer value 1 <ph id=\"ph1\">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id=\"ph2\">`int32`</ph>) is pushed onto the evaluation stack.","pos":[21,190],"source":" If the first value is less than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack."}]}],"pos":[153634,153825],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 04|clt|Pushes 1 if `value1` is less than `value2`; else pushes 0.|  \n  \n The stack transitional behavior, in sequential order, is: `value1` is pushed onto the stack.  \n  \n1.  `value2` is pushed onto the stack.  \n  \n2.  `value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.  \n  \n3.  If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \n  \n The `clt` instruction compares `value1` and `value2`. If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack. Otherwise, an `int32` value of 0 is pushed on the stack.  \n  \n-   For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 04","nodes":[{"content":"FE 04","pos":[0,5]}]},{"pos":[262,265],"content":"clt","nodes":[{"content":"clt","pos":[0,3]}]},{"pos":[266,324],"content":"Pushes 1 if <ph id=\"ph1\">`value1`</ph> is less than <ph id=\"ph2\">`value2`</ph>; else pushes 0.","source":"Pushes 1 if `value1` is less than `value2`; else pushes 0."},{"pos":[332,424],"content":"The stack transitional behavior, in sequential order, is: <ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"The stack transitional behavior, in sequential order, is: `value1` is pushed onto the stack."},{"pos":[434,468],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[478,573],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`clt`</ph> tests if <ph id=\"ph4\">`value1`</ph> is less than <ph id=\"ph5\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`."},{"pos":[583,683],"content":"If <ph id=\"ph1\">`value1`</ph> is less than <ph id=\"ph2\">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.","source":"If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack."},{"pos":[690,895],"content":"The `clt` instruction compares `value1` and `value2`. If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack. Otherwise, an `int32` value of 0 is pushed on the stack.","nodes":[{"content":"The <ph id=\"ph1\">`clt`</ph> instruction compares <ph id=\"ph2\">`value1`</ph> and <ph id=\"ph3\">`value2`</ph>.","pos":[0,53],"source":"The `clt` instruction compares `value1` and `value2`."},{"content":"If <ph id=\"ph1\">`value1`</ph> is strictly less than <ph id=\"ph2\">`value2`</ph>, then an <ph id=\"ph3\">`int32`</ph> value of 1 is pushed on the stack.","pos":[54,148],"source":" If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack."},{"content":"Otherwise, an <ph id=\"ph1\">`int32`</ph> value of 0 is pushed on the stack.","pos":[149,205],"source":" Otherwise, an `int32` value of 0 is pushed on the stack."}]},{"pos":[905,1029],"content":"For floating-point numbers, <ph id=\"ph1\">`clt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).","source":"For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN)."},{"pos":[1036,1141],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`clt`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:"},{"pos":[1151,1175],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[153836,155034],"yaml":true,"extradata":"MT"},{"content":"Compares the unsigned or unordered values <code>value1</code> and <code>value2</code>. If <code>value1</code> is less than <code>value2</code>, then the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"pos":[0,274],"content":"Compares the unsigned or unordered values <code>value1</code> and <code>value2</code>. If <code>value1</code> is less than <code>value2</code>, then the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.","nodes":[{"content":"Compares the unsigned or unordered values <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">value1</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">value2</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","pos":[0,86],"source":"Compares the unsigned or unordered values <code>value1</code> and <code>value2</code>."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">value1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is less than <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">value2</ph><ept id=\"p2\">&lt;/code&gt;</ept>, then the integer value 1 <ph id=\"ph3\">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id=\"ph4\">`int32`</ph>) is pushed onto the evaluation stack.","pos":[87,274],"source":" If <code>value1</code> is less than <code>value2</code>, then the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack."}]}],"pos":[156621,156896],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 05|clt.un|Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.  \n  \n4.  If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \n  \n The `clt.un` instruction compares `value1` and `value2`. An `int32` value of 1 is pushed on the stack if any of the following is true:  \n  \n-   `value1` is strictly less than `value2` (as for `clt`).  \n  \n-   For floating-point numbers, `value1` is not ordered with respect to `value2`.  \n  \n-   For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.  \n  \n Otherwise, an `int32` value of 0 is pushed on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 05","nodes":[{"content":"FE 05","pos":[0,5]}]},{"pos":[262,268],"content":"clt.un","nodes":[{"content":"clt.un","pos":[0,6]}]},{"pos":[269,345],"content":"Pushes 1 if <ph id=\"ph1\">`value1`</ph> is less than <ph id=\"ph2\">`value2`</ph>; else pushes 0 (unsigned values).","source":"Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values)."},{"pos":[353,410],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[420,454],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[464,498],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[508,606],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`clt.un`</ph> tests if <ph id=\"ph4\">`value1`</ph> is less than <ph id=\"ph5\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`."},{"pos":[616,716],"content":"If <ph id=\"ph1\">`value1`</ph> is less than <ph id=\"ph2\">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.","source":"If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack."},{"pos":[723,857],"content":"The `clt.un` instruction compares `value1` and `value2`. An `int32` value of 1 is pushed on the stack if any of the following is true:","nodes":[{"content":"The <ph id=\"ph1\">`clt.un`</ph> instruction compares <ph id=\"ph2\">`value1`</ph> and <ph id=\"ph3\">`value2`</ph>.","pos":[0,56],"source":"The `clt.un` instruction compares `value1` and `value2`."},{"content":"An <ph id=\"ph1\">`int32`</ph> value of 1 is pushed on the stack if any of the following is true:","pos":[57,134],"source":" An `int32` value of 1 is pushed on the stack if any of the following is true:"}]},{"pos":[867,922],"content":"<ph id=\"ph1\">`value1`</ph> is strictly less than <ph id=\"ph2\">`value2`</ph> (as for <ph id=\"ph3\">`clt`</ph>).","source":"`value1` is strictly less than `value2` (as for `clt`)."},{"pos":[932,1009],"content":"For floating-point numbers, <ph id=\"ph1\">`value1`</ph> is not ordered with respect to <ph id=\"ph2\">`value2`</ph>.","source":"For floating-point numbers, `value1` is not ordered with respect to `value2`."},{"pos":[1019,1115],"content":"For integer values, <ph id=\"ph1\">`value1`</ph> is strictly less than <ph id=\"ph2\">`value2`</ph> when considered as unsigned numbers.","source":"For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers."},{"pos":[1122,1178],"content":"Otherwise, an <ph id=\"ph1\">`int32`</ph> value of 0 is pushed on the stack.","source":"Otherwise, an `int32` value of 0 is pushed on the stack."},{"pos":[1185,1293],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`clt.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:"},{"pos":[1303,1327],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[156907,158265],"yaml":true,"extradata":"MT"},{"content":"Constrains the type on which a virtual method call is made.","nodes":[{"pos":[0,59],"content":"Constrains the type on which a virtual method call is made.","nodes":[{"content":"Constrains the type on which a virtual method call is made.","pos":[0,59]}]}],"pos":[159885,159945],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 16 < `T` >|constrained. `thisType`|Call a virtual method on a type constrained to be type `T`.|  \n  \n The `constrained` prefix is permitted only on a `callvirt` instruction.  \n  \n The state of the MSIL stack at this point must be as follows:  \n  \n1.  A managed pointer, `ptr`, is pushed onto the stack. The type of `ptr` must be a managed pointer (`&`) to `thisType`. Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.  \n  \n2.  Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.  \n  \n The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.  \n  \n When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:  \n  \n-   If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.  \n  \n-   If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.  \n  \n-   If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.  \n  \n This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or<xref:System.Enum> and not overridden by `thisType`. In this case, the boxing causes a copy of the original object to be made. However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.  \n  \n The `constrained` prefix supports IL generators that create generic code. Normally the `callvirt` instruction is not valid on value types. Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called. However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.  \n  \n The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type. Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.  \n  \n Using the `constrained` prefix also avoids potential versioning problems with value types. If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object. For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted. A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.  \n  \n The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`. If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time. Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"FE 16 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 16 < `T` >"},{"pos":[270,293],"content":"constrained. `thisType`","nodes":[{"content":"constrained.","pos":[0,12]}]},{"pos":[294,353],"content":"Call a virtual method on a type constrained to be type <ph id=\"ph1\">`T`</ph>.","source":"Call a virtual method on a type constrained to be type `T`."},{"pos":[361,432],"content":"The <ph id=\"ph1\">`constrained`</ph> prefix is permitted only on a <ph id=\"ph2\">`callvirt`</ph> instruction.","source":"The `constrained` prefix is permitted only on a `callvirt` instruction."},{"pos":[439,500],"content":"The state of the MSIL stack at this point must be as follows:","nodes":[{"content":"The state of the MSIL stack at this point must be as follows:","pos":[0,61]}]},{"pos":[510,750],"content":"A managed pointer, `ptr`, is pushed onto the stack. The type of `ptr` must be a managed pointer (`&`) to `thisType`. Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.","nodes":[{"content":"A managed pointer, <ph id=\"ph1\">`ptr`</ph>, is pushed onto the stack.","pos":[0,51],"source":"A managed pointer, `ptr`, is pushed onto the stack."},{"content":"The type of <ph id=\"ph1\">`ptr`</ph> must be a managed pointer (<ph id=\"ph2\">`&amp;`</ph>) to <ph id=\"ph3\">`thisType`</ph>.","pos":[52,116],"source":" The type of `ptr` must be a managed pointer (`&`) to `thisType`."},{"content":"Note that this is different from the case of an unprefixed <ph id=\"ph1\">`callvirt`</ph> instruction, which expects a reference of <ph id=\"ph2\">`thisType`</ph>.","pos":[117,240],"source":" Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`."}]},{"pos":[760,876],"content":"Method arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argN`</ph> are pushed onto the stack, just as with an unprefixed <ph id=\"ph3\">`callvirt`</ph> instruction.","source":"Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction."},{"pos":[883,1051],"content":"The <ph id=\"ph1\">`constrained`</ph> prefix is designed to allow <ph id=\"ph2\">`callvirt`</ph> instructions to be made in a uniform way independent of whether <ph id=\"ph3\">`thisType`</ph> is a value type or a reference type.","source":"The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type."},{"pos":[1058,1183],"content":"When a <ph id=\"ph1\">`callvirt`</ph> <ph id=\"ph2\">`method`</ph> instruction has been prefixed by <ph id=\"ph3\">`constrained`</ph> <ph id=\"ph4\">`thisType`</ph>, the instruction is executed as follows:","source":"When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:"},{"pos":[1193,1346],"content":"If <ph id=\"ph1\">`thisType`</ph> is a reference type (as opposed to a value type) then <ph id=\"ph2\">`ptr`</ph> is dereferenced and passed as the 'this' pointer to the <ph id=\"ph3\">`callvirt`</ph> of <ph id=\"ph4\">`method`</ph>.","source":"If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`."},{"pos":[1356,1558],"content":"If <ph id=\"ph1\">`thisType`</ph> is a value type and <ph id=\"ph2\">`thisType`</ph> implements <ph id=\"ph3\">`method`</ph> then <ph id=\"ph4\">`ptr`</ph> is passed unmodified as the 'this' pointer to a <ph id=\"ph5\">`call`</ph> <ph id=\"ph6\">`method`</ph> instruction, for the implementation of <ph id=\"ph7\">`method`</ph> by <ph id=\"ph8\">`thisType`</ph>.","source":"If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`."},{"pos":[1568,1748],"content":"If <ph id=\"ph1\">`thisType`</ph> is a value type and <ph id=\"ph2\">`thisType`</ph> does not implement <ph id=\"ph3\">`method`</ph> then <ph id=\"ph4\">`ptr`</ph> is dereferenced, boxed, and passed as the 'this' pointer to the <ph id=\"ph5\">`callvirt`</ph> <ph id=\"ph6\">`method`</ph> instruction.","source":"If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction."},{"pos":[1755,2161],"content":"This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or<xref:System.Enum> and not overridden by `thisType`. In this case, the boxing causes a copy of the original object to be made. However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.","nodes":[{"content":"This last case can occur only when <ph id=\"ph1\">`method`</ph> was defined on <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.ValueType&gt;</ph>, or<ph id=\"ph4\">&lt;xref:System.Enum&gt;</ph> and not overridden by <ph id=\"ph5\">`thisType`</ph>.","pos":[0,160],"source":"This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or<xref:System.Enum> and not overridden by `thisType`."},{"content":"In this case, the boxing causes a copy of the original object to be made.","pos":[161,234]},{"content":"However, because none of the methods of <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Enum&gt;</ph> modify the state of the object, this fact cannot be detected.","pos":[235,406],"source":" However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected."}]},{"pos":[2168,2620],"content":"The `constrained` prefix supports IL generators that create generic code. Normally the `callvirt` instruction is not valid on value types. Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called. However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.","nodes":[{"content":"The <ph id=\"ph1\">`constrained`</ph> prefix supports IL generators that create generic code.","pos":[0,73],"source":"The `constrained` prefix supports IL generators that create generic code."},{"content":"Normally the <ph id=\"ph1\">`callvirt`</ph> instruction is not valid on value types.","pos":[74,138],"source":" Normally the `callvirt` instruction is not valid on value types."},{"content":"Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <ph id=\"ph1\">`ptr`</ph> and the method being called.","pos":[139,317],"source":" Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called."},{"content":"However, when <ph id=\"ph1\">`ptr`</ph> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.","pos":[318,452],"source":" However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time."}]},{"pos":[2627,3068],"content":"The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type. Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.","nodes":[{"content":"The <ph id=\"ph1\">`constrained`</ph> opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <ph id=\"ph2\">`ptr`</ph> is a value type or a reference type.","pos":[0,164],"source":"The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type."},{"content":"Although it is intended for the case where <ph id=\"ph1\">`thisType`</ph> is a generic type variable, the <ph id=\"ph2\">`constrained`</ph> prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.","pos":[165,441],"source":" Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types."}]},{"pos":[3075,3670],"content":"Using the `constrained` prefix also avoids potential versioning problems with value types. If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object. For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted. A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.","nodes":[{"content":"Using the <ph id=\"ph1\">`constrained`</ph> prefix also avoids potential versioning problems with value types.","pos":[0,90],"source":"Using the `constrained` prefix also avoids potential versioning problems with value types."},{"content":"If the <ph id=\"ph1\">`constrained`</ph> prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.","pos":[91,238],"source":" If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object."},{"content":"For example, if a value type <ph id=\"ph1\">`V`</ph> overrides the Object.ToString() method, a <ph id=\"ph2\">`call`</ph> <ph id=\"ph3\">`V.ToString()`</ph> instruction is emitted; if it does not, a <ph id=\"ph4\">`box`</ph> instruction and a <ph id=\"ph5\">`callvirt`</ph> <ph id=\"ph6\">`Object.ToString()`</ph> instruction are emitted.","pos":[239,457],"source":" For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted."},{"content":"A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.","pos":[458,595]}]},{"pos":[3677,4155],"content":"The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`. If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time. Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.","nodes":[{"content":"The <ph id=\"ph1\">`constrained`</ph> prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a <ph id=\"ph2\">`MethodImpl`</ph>.","pos":[0,194],"source":"The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`."},{"content":"If the <ph id=\"ph1\">`constrained`</ph> prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.","pos":[195,330],"source":" If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time."},{"content":"Using the <ph id=\"ph1\">`constrained`</ph> prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.","pos":[331,478],"source":" Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time."}]},{"pos":[4162,4275],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`constrained`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:"},{"pos":[4285,4315],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[159956,164310],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `native int`.","nodes":[{"pos":[0,66],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`native int`</ph>.","source":"Converts the value on top of the evaluation stack to `native int`."}],"pos":[165905,165972],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D3|conv.i|Convert to `native int`, pushing `native int` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D3","nodes":[{"content":"D3","pos":[0,2]}]},{"pos":[259,265],"content":"conv.i","nodes":[{"content":"conv.i","pos":[0,6]}]},{"pos":[266,321],"content":"Convert to <ph id=\"ph1\">`native int`</ph>, pushing <ph id=\"ph2\">`native int`</ph> on stack.","source":"Convert to `native int`, pushing `native int` on stack."},{"pos":[329,386],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[396,429],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[439,514],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[524,602],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[609,1008],"content":"The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.i`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,153],"source":"The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[154,346],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[347,399],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1015,1511],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from a <ph id=\"ph1\">`float64`</ph> to a <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,162],"source":" When converting from a `float64` to a `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[163,315],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[316,409]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[410,496],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1518,1618],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1625,1909],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,284],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,284],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1916,2024],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.i`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:"},{"pos":[2034,2058],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[165983,168068],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `int8`, then extends (pads) it to `int32`.","nodes":[{"pos":[0,95],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`int8`</ph>, then extends (pads) it to <ph id=\"ph2\">`int32`</ph>.","source":"Converts the value on top of the evaluation stack to `int8`, then extends (pads) it to `int32`."}],"pos":[169664,169760],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|67|conv.i1|Convert to `int8`, pushing `int32` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"67","nodes":[{"content":"67","pos":[0,2]}]},{"pos":[259,266],"content":"conv.i1","nodes":[{"content":"conv.i1","pos":[0,7]}]},{"pos":[267,311],"content":"Convert to <ph id=\"ph1\">`int8`</ph>, pushing <ph id=\"ph2\">`int32`</ph> on stack.","source":"Convert to `int8`, pushing `int32` on stack."},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,419],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[429,504],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[514,592],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[599,999],"content":"The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.i1`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1006,1502],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from a <ph id=\"ph1\">`float64`</ph> to a <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,162],"source":" When converting from a `float64` to a `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[163,315],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[316,409]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[410,496],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1509,1609],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1616,1902],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1909,2018],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.i1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:"},{"pos":[2028,2052],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[169771,171850],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `int16`, then extends (pads) it to `int32`.","nodes":[{"pos":[0,96],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`int16`</ph>, then extends (pads) it to <ph id=\"ph2\">`int32`</ph>.","source":"Converts the value on top of the evaluation stack to `int16`, then extends (pads) it to `int32`."}],"pos":[173447,173544],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|68|conv.i2|Convert to `int16`, pushing `int32` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"68","nodes":[{"content":"68","pos":[0,2]}]},{"pos":[259,266],"content":"conv.i2","nodes":[{"content":"conv.i2","pos":[0,7]}]},{"pos":[267,312],"content":"Convert to <ph id=\"ph1\">`int16`</ph>, pushing <ph id=\"ph2\">`int32`</ph> on stack.","source":"Convert to `int16`, pushing `int32` on stack."},{"pos":[320,377],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[387,420],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[430,505],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[515,593],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[600,1000],"content":"The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.i2`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1007,1503],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from a <ph id=\"ph1\">`float64`</ph> to a <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,162],"source":" When converting from a `float64` to a `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[163,315],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[316,409]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[410,496],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1510,1610],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1617,1903],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1910,2019],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.i2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:"},{"pos":[2029,2053],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[173555,175635],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `int32`.","nodes":[{"pos":[0,61],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`int32`</ph>.","source":"Converts the value on top of the evaluation stack to `int32`."}],"pos":[177232,177294],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|69|conv.i4|Convert to `int32`, pushing `int32` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"69","nodes":[{"content":"69","pos":[0,2]}]},{"pos":[259,266],"content":"conv.i4","nodes":[{"content":"conv.i4","pos":[0,7]}]},{"pos":[267,312],"content":"Convert to <ph id=\"ph1\">`int32`</ph>, pushing <ph id=\"ph2\">`int32`</ph> on stack.","source":"Convert to `int32`, pushing `int32` on stack."},{"pos":[320,377],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[387,420],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[430,505],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[515,593],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[600,1000],"content":"The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.i4`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1007,1503],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from a <ph id=\"ph1\">`float64`</ph> to a <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,162],"source":" When converting from a `float64` to a `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[163,315],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[316,409]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[410,496],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1510,1610],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1617,1903],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1910,2019],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.i4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:"},{"pos":[2029,2053],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[177305,179385],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `int64`.","nodes":[{"pos":[0,61],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`int64`</ph>.","source":"Converts the value on top of the evaluation stack to `int64`."}],"pos":[180982,181044],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|6A|conv.i8|Convert to `int64`, pushing `int64` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"6A","nodes":[{"content":"6A","pos":[0,2]}]},{"pos":[259,266],"content":"conv.i8","nodes":[{"content":"conv.i8","pos":[0,7]}]},{"pos":[267,312],"content":"Convert to <ph id=\"ph1\">`int64`</ph>, pushing <ph id=\"ph2\">`int64`</ph> on stack.","source":"Convert to `int64`, pushing `int64` on stack."},{"pos":[320,377],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[387,420],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[430,505],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[515,593],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[600,1000],"content":"The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.i8`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1007,1503],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from a <ph id=\"ph1\">`float64`</ph> to a <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,162],"source":" When converting from a `float64` to a `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[163,315],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[316,409]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[410,496],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1510,1610],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1617,1903],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1910,2019],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.i8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:"},{"pos":[2029,2053],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[181055,183135],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to signed `native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,148],"content":"Converts the signed value on top of the evaluation stack to signed <ph id=\"ph1\">`native int`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to signed `native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[184750,184899],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D4|conv.ovf.i|Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D4","nodes":[{"content":"D4","pos":[0,2]}]},{"pos":[259,269],"content":"conv.ovf.i","nodes":[{"content":"conv.ovf.i","pos":[0,10]}]},{"pos":[270,362],"content":"Convert to a <ph id=\"ph1\">`native int`</ph> (on the stack as <ph id=\"ph2\">`native int`</ph>) and throw an exception on overflow.","source":"Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow."},{"pos":[370,427],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[437,470],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[480,599],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[609,687],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[694,953],"content":"The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,158],"source":"The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[159,259]}]},{"pos":[960,1262],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1269,1367],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1374,1486],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:"},{"pos":[1496,1520],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[184910,186455],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to signed `native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,150],"content":"Converts the unsigned value on top of the evaluation stack to signed <ph id=\"ph1\">`native int`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to signed `native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[188091,188242],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|8A|conv.ovf.i.un|Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"8A","nodes":[{"content":"8A","pos":[0,2]}]},{"pos":[259,272],"content":"conv.ovf.i.un","nodes":[{"content":"conv.ovf.i.un","pos":[0,13]}]},{"pos":[273,384],"content":"Converts an unsigned value to a <ph id=\"ph1\">`native int`</ph> (on the stack as <ph id=\"ph2\">`native int`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow."},{"pos":[392,449],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[459,492],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[502,621],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[631,709],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[716,978],"content":"The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,161],"source":"The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[162,262]}]},{"pos":[985,1287],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1294,1392],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1399,1514],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:"},{"pos":[1524,1548],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[188253,189826],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to signed `int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,168],"content":"Converts the signed value on top of the evaluation stack to signed <ph id=\"ph1\">`int8`</ph> and extends it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to signed `int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[191453,191622],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|B3|conv.ovf.i1|Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"B3","nodes":[{"content":"B3","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.i1","nodes":[{"content":"conv.ovf.i1","pos":[0,11]}]},{"pos":[271,353],"content":"Convert to an <ph id=\"ph1\">`int8`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[361,418],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[428,461],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[471,590],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[600,678],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[685,945],"content":"The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i1`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[952,1254],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1261,1359],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1366,1479],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:"},{"pos":[1489,1513],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[191633,193171],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to signed `int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,170],"content":"Converts the unsigned value on top of the evaluation stack to signed <ph id=\"ph1\">`int8`</ph> and extends it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to signed `int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[194814,194985],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|82|conv.ovf.i1.un|Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"82","nodes":[{"content":"82","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.i1.un","nodes":[{"content":"conv.ovf.i1.un","pos":[0,14]}]},{"pos":[274,375],"content":"Converts an unsigned value to an <ph id=\"ph1\">`int8`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[383,440],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[450,483],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[493,612],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[622,700],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[707,970],"content":"The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i1.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[977,1279],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1286,1384],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1391,1507],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i1.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:"},{"pos":[1517,1541],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[194996,196562],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to signed `int16` and extending it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,171],"content":"Converts the signed value on top of the evaluation stack to signed <ph id=\"ph1\">`int16`</ph> and extending it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to signed `int16` and extending it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[198190,198362],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|B5|conv.ovf.i2|Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"B5","nodes":[{"content":"B5","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.i2","nodes":[{"content":"conv.ovf.i2","pos":[0,11]}]},{"pos":[271,354],"content":"Convert to an <ph id=\"ph1\">`int16`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[362,419],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[429,462],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[472,591],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[601,679],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[686,946],"content":"The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i2`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[953,1255],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1262,1360],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1367,1480],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:"},{"pos":[1490,1514],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[198373,199912],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to signed `int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,171],"content":"Converts the unsigned value on top of the evaluation stack to signed <ph id=\"ph1\">`int16`</ph> and extends it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to signed `int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[201555,201727],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|83|conv.ovf.i2.un|Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"83","nodes":[{"content":"83","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.i2.un","nodes":[{"content":"conv.ovf.i2.un","pos":[0,14]}]},{"pos":[274,376],"content":"Converts an unsigned value to an <ph id=\"ph1\">`int16`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[384,441],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[451,484],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[494,613],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[623,701],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[708,971],"content":"The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i2.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[978,1280],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1287,1385],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1392,1508],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i2.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:"},{"pos":[1518,1542],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[201738,203305],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to signed `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,143],"content":"Converts the signed value on top of the evaluation stack to signed <ph id=\"ph1\">`int32`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to signed `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[204933,205077],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|B7|conv.ovf.i4|Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"B7","nodes":[{"content":"B7","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.i4","nodes":[{"content":"conv.ovf.i4","pos":[0,11]}]},{"pos":[271,354],"content":"Convert to an <ph id=\"ph1\">`int32`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[362,419],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[429,462],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[472,591],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[601,679],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[686,946],"content":"The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i4`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[953,1255],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1262,1360],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1367,1480],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:"},{"pos":[1490,1514],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[205088,206627],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to signed `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,145],"content":"Converts the unsigned value on top of the evaluation stack to signed <ph id=\"ph1\">`int32`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to signed `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[208270,208416],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|84|conv.ovf.i4.un|Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"84","nodes":[{"content":"84","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.i4.un","nodes":[{"content":"conv.ovf.i4.un","pos":[0,14]}]},{"pos":[274,376],"content":"Converts an unsigned value to an <ph id=\"ph1\">`int32`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[384,441],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[451,484],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[494,613],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[623,701],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[708,971],"content":"The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i4.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[978,1280],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1287,1385],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1392,1508],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i4.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:"},{"pos":[1518,1542],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[208427,209994],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to signed `int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,143],"content":"Converts the signed value on top of the evaluation stack to signed <ph id=\"ph1\">`int64`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to signed `int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[211622,211766],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|B9|conv.ovf.i8|Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"B9","nodes":[{"content":"B9","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.i8","nodes":[{"content":"conv.ovf.i8","pos":[0,11]}]},{"pos":[271,354],"content":"Convert to an <ph id=\"ph1\">`int64`</ph> (on the stack as <ph id=\"ph2\">`int64`</ph>) and throw an exception on overflow.","source":"Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow."},{"pos":[362,419],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[429,462],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[472,591],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[601,679],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[686,946],"content":"The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i8`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[953,1255],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1262,1360],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1367,1480],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:"},{"pos":[1490,1514],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[211777,213316],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to signed `int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,145],"content":"Converts the unsigned value on top of the evaluation stack to signed <ph id=\"ph1\">`int64`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to signed `int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[214959,215105],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|85|conv.ovf.i8.un|Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"85","nodes":[{"content":"85","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.i8.un","nodes":[{"content":"conv.ovf.i8.un","pos":[0,14]}]},{"pos":[274,376],"content":"Converts an unsigned value to an <ph id=\"ph1\">`int64`</ph> (on the stack as <ph id=\"ph2\">`int64`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow."},{"pos":[384,441],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[451,484],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[494,613],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[623,701],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[708,971],"content":"The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.i8.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[978,1280],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1287,1385],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1392,1508],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.i8.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:"},{"pos":[1518,1542],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[215116,216683],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to `unsigned native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,150],"content":"Converts the signed value on top of the evaluation stack to <ph id=\"ph1\">`unsigned native int`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to `unsigned native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[218305,218456],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D5|conv.ovf.u|Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D5","nodes":[{"content":"D5","pos":[0,2]}]},{"pos":[259,269],"content":"conv.ovf.u","nodes":[{"content":"conv.ovf.u","pos":[0,10]}]},{"pos":[270,372],"content":"Convert to an <ph id=\"ph1\">`unsigned native int`</ph> (on the stack as <ph id=\"ph2\">`native int`</ph>) and throw an exception on overflow.","source":"Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow."},{"pos":[380,437],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[447,480],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[490,609],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[619,697],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[704,963],"content":"The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,158],"source":"The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[159,259]}]},{"pos":[970,1272],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1279,1377],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1384,1496],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:"},{"pos":[1506,1530],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[218467,220022],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to `unsigned native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,152],"content":"Converts the unsigned value on top of the evaluation stack to <ph id=\"ph1\">`unsigned native int`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to `unsigned native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[221658,221811],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|8B|conv.ovf.u.un|Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"8B","nodes":[{"content":"8B","pos":[0,2]}]},{"pos":[259,272],"content":"conv.ovf.u.un","nodes":[{"content":"conv.ovf.u.un","pos":[0,13]}]},{"pos":[273,394],"content":"Converts un unsigned value to an <ph id=\"ph1\">`unsigned native int`</ph> (on the stack as <ph id=\"ph2\">`native int`</ph>) and throw an exception on overflow.","source":"Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow."},{"pos":[402,459],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[469,502],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[512,631],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[641,719],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[726,988],"content":"The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,161],"source":"The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[162,262]}]},{"pos":[995,1297],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1304,1402],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1409,1524],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.uvf.u.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:"},{"pos":[1534,1558],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[221822,223405],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to `unsigned int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,170],"content":"Converts the signed value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int8`</ph> and extends it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to `unsigned int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[225032,225203],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|B4|conv.ovf.u1|Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"B4","nodes":[{"content":"B4","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.u1","nodes":[{"content":"conv.ovf.u1","pos":[0,11]}]},{"pos":[271,362],"content":"Convert to an <ph id=\"ph1\">`unsigned int8`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[370,427],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[437,470],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[480,599],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[609,687],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[694,954],"content":"The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u1`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[961,1263],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1270,1368],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1375,1488],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:"},{"pos":[1498,1522],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[225214,226761],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to `unsigned int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,172],"content":"Converts the unsigned value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int8`</ph> and extends it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to `unsigned int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[228404,228577],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|86|conv.ovf.u1.un|Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"86","nodes":[{"content":"86","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.u1.un","nodes":[{"content":"conv.ovf.u1.un","pos":[0,14]}]},{"pos":[274,384],"content":"Converts an unsigned value to an <ph id=\"ph1\">`unsigned int8`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[392,449],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[459,492],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[502,621],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[631,709],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[716,979],"content":"The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u1.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[986,1288],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1295,1393],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1400,1516],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u1.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:"},{"pos":[1526,1550],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[228588,230163],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to `unsigned int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,171],"content":"Converts the signed value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int16`</ph> and extends it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to `unsigned int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[231791,231963],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|B6|conv.ovf.u2|Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"B6","nodes":[{"content":"B6","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.u2","nodes":[{"content":"conv.ovf.u2","pos":[0,11]}]},{"pos":[271,363],"content":"Convert to an <ph id=\"ph1\">`unsigned int16`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[371,428],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[438,471],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[481,600],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[610,688],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[695,955],"content":"The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u2`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[962,1264],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1271,1369],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1376,1489],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:"},{"pos":[1499,1523],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[231974,233522],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to `unsigned int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,173],"content":"Converts the unsigned value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int16`</ph> and extends it to <ph id=\"ph2\">`int32`</ph>, throwing <ph id=\"ph3\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to `unsigned int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[235165,235339],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|87|conv.ovf.u2.un|Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"87","nodes":[{"content":"87","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.u2.un","nodes":[{"content":"conv.ovf.u2.un","pos":[0,14]}]},{"pos":[274,385],"content":"Converts an unsigned value to an <ph id=\"ph1\">`unsigned int16`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[393,450],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[460,493],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[503,622],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[632,710],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[717,980],"content":"The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u2.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[987,1289],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1296,1394],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1401,1517],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u2.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:"},{"pos":[1527,1551],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[235350,236926],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to `unsigned int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,145],"content":"Converts the signed value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int32`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to `unsigned int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[238554,238700],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|B8|conv.ovf.u4|Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"B8","nodes":[{"content":"B8","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.u4","nodes":[{"content":"conv.ovf.u4","pos":[0,11]}]},{"pos":[271,363],"content":"Convert to an <ph id=\"ph1\">`unsigned int32`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[371,428],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[438,471],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[481,600],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[610,688],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[695,955],"content":"The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u4`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[962,1264],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1271,1369],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1376,1489],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:"},{"pos":[1499,1523],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[238711,240259],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to `unsigned int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,147],"content":"Converts the unsigned value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int32`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to `unsigned int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[241902,242050],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|88|conv.ovf.u4.un|Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"88","nodes":[{"content":"88","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.u4.un","nodes":[{"content":"conv.ovf.u4.un","pos":[0,14]}]},{"pos":[274,385],"content":"Converts an unsigned value to an <ph id=\"ph1\">`unsigned int32`</ph> (on the stack as <ph id=\"ph2\">`int32`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow."},{"pos":[393,450],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[460,493],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[503,622],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[632,710],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[717,980],"content":"The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u4.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[987,1289],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1296,1394],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1401,1517],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u4.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:"},{"pos":[1527,1551],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[242061,243637],"yaml":true,"extradata":"MT"},{"content":"Converts the signed value on top of the evaluation stack to `unsigned int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,145],"content":"Converts the signed value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int64`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the signed value on top of the evaluation stack to `unsigned int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[245265,245411],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|BA|conv.ovf.u8|Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"BA","nodes":[{"content":"BA","pos":[0,2]}]},{"pos":[259,270],"content":"conv.ovf.u8","nodes":[{"content":"conv.ovf.u8","pos":[0,11]}]},{"pos":[271,363],"content":"Convert to an <ph id=\"ph1\">`unsigned int64`</ph> (on the stack as <ph id=\"ph2\">`int64`</ph>) and throw an exception on overflow.","source":"Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow."},{"pos":[371,428],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[438,471],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[481,600],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[610,688],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[695,955],"content":"The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u8`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,159],"source":"The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[160,260]}]},{"pos":[962,1264],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1271,1369],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1376,1489],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:"},{"pos":[1499,1523],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[245422,246970],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned value on top of the evaluation stack to `unsigned int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.","nodes":[{"pos":[0,147],"content":"Converts the unsigned value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int64`</ph>, throwing <ph id=\"ph2\">&lt;xref href=\"System.OverflowException\"&gt;&lt;/xref&gt;</ph> on overflow.","source":"Converts the unsigned value on top of the evaluation stack to `unsigned int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow."}],"pos":[248613,248761],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|89|conv.ovf.u8.un|Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \n  \n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"89","nodes":[{"content":"89","pos":[0,2]}]},{"pos":[259,273],"content":"conv.ovf.u8.un","nodes":[{"content":"conv.ovf.u8.un","pos":[0,14]}]},{"pos":[274,385],"content":"Converts an unsigned value to an <ph id=\"ph1\">`unsigned int64`</ph> (on the stack as <ph id=\"ph2\">`int64`</ph>) and throw an exception on overflow.","source":"Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow."},{"pos":[393,450],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[460,493],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[503,622],"content":"`value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.","nodes":[{"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","pos":[0,75],"source":"`value` is popped from the stack and the conversion operation is attempted."},{"content":"If overflow occurs, an exception is thrown.","pos":[76,119]}]},{"pos":[632,710],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[717,980],"content":"The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`conv.ovf.u8.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.","pos":[0,162],"source":"The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack."},{"content":"If the value is too large or too small to be represented by the target type, an exception is thrown.","pos":[163,263]}]},{"pos":[987,1289],"content":"Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).","nodes":[{"content":"Conversions from floating-point numbers to integer values truncate the number toward zero.","pos":[0,90]},{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.ovf.i`</ph> or <ph id=\"ph3\">`conv.ovf.u`</ph> are used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[91,302],"source":" Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`)."}]},{"pos":[1296,1394],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[1401,1517],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.ovf.u8.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:"},{"pos":[1527,1551],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[248772,250348],"yaml":true,"extradata":"MT"},{"content":"Converts the unsigned integer value on top of the evaluation stack to `float32`.","nodes":[{"pos":[0,80],"content":"Converts the unsigned integer value on top of the evaluation stack to <ph id=\"ph1\">`float32`</ph>.","source":"Converts the unsigned integer value on top of the evaluation stack to `float32`."}],"pos":[251964,252045],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|76|conv.r.un|Convert unsigned integer to floating-point, pushing `F` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified. The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.  \n  \n No exceptions are ever thrown when using this field.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"76","nodes":[{"content":"76","pos":[0,2]}]},{"pos":[259,268],"content":"conv.r.un","nodes":[{"content":"conv.r.un","pos":[0,9]}]},{"pos":[269,334],"content":"Convert unsigned integer to floating-point, pushing <ph id=\"ph1\">`F`</ph> on stack.","source":"Convert unsigned integer to floating-point, pushing `F` on stack."},{"pos":[342,399],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[409,442],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[452,527],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[537,615],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[622,1024],"content":"The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.r.un`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,156],"source":"The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[157,349],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[350,402],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1031,1527],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from a <ph id=\"ph1\">`float64`</ph> to a <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,162],"source":" When converting from a `float64` to a `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[163,315],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[316,409]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[410,496],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1534,1909],"content":"If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified. The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the <ph id=\"ph1\">`result`</ph> returned is unspecified.","pos":[0,103],"source":"If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified."},{"content":"The <ph id=\"ph1\">`conv.r.un`</ph> operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a <ph id=\"ph2\">`float32`</ph>, if this is wide enough to represent the integer without loss of precision, or else a <ph id=\"ph3\">`float64`</ph>.","pos":[104,375],"source":" The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`."}]},{"pos":[1916,1968],"content":"No exceptions are ever thrown when using this field.","nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]}]},{"pos":[1975,2086],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.r.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:"},{"pos":[2096,2120],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[252056,254203],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `float32`.","nodes":[{"pos":[0,63],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`float32`</ph>.","source":"Converts the value on top of the evaluation stack to `float32`."}],"pos":[255802,255866],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|6B|conv.r4|Convert to `float32`, pushing `F` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"6B","nodes":[{"content":"6B","pos":[0,2]}]},{"pos":[259,266],"content":"conv.r4","nodes":[{"content":"conv.r4","pos":[0,7]}]},{"pos":[267,310],"content":"Convert to <ph id=\"ph1\">`float32`</ph>, pushing <ph id=\"ph2\">`F`</ph> on stack.","source":"Convert to `float32`, pushing `F` on stack."},{"pos":[318,375],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[385,418],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[428,503],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[513,591],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[598,998],"content":"The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.r4`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1005,1503],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from an <ph id=\"ph1\">`float64`</ph> to an <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,164],"source":" When converting from an `float64` to an `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[165,317],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[318,411]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[412,498],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1510,1610],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1617,1669],"content":"No exceptions are ever thrown when using this field.","nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]}]},{"pos":[1676,1785],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.r4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:"},{"pos":[1795,1819],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[255877,257723],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `float64`.","nodes":[{"pos":[0,63],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`float64`</ph>.","source":"Converts the value on top of the evaluation stack to `float64`."}],"pos":[259320,259384],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|6C|conv.r8|Convert to `float64`, pushing `F` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"6C","nodes":[{"content":"6C","pos":[0,2]}]},{"pos":[259,266],"content":"conv.r8","nodes":[{"content":"conv.r8","pos":[0,7]}]},{"pos":[267,310],"content":"Convert to <ph id=\"ph1\">`float64`</ph>, pushing <ph id=\"ph2\">`F`</ph> on stack.","source":"Convert to `float64`, pushing `F` on stack."},{"pos":[318,375],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[385,418],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[428,503],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[513,591],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[598,998],"content":"The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.r8`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1005,1503],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from an <ph id=\"ph1\">`float64`</ph> to an <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,164],"source":" When converting from an `float64` to an `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[165,317],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[318,411]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[412,498],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1510,1610],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1617,1669],"content":"No exceptions are ever thrown when using this field.","nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]}]},{"pos":[1676,1785],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.r8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:"},{"pos":[1795,1819],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[259395,261241],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `unsigned native int`, and extends it to `native int`.","nodes":[{"pos":[0,107],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`unsigned native int`</ph>, and extends it to <ph id=\"ph2\">`native int`</ph>.","source":"Converts the value on top of the evaluation stack to `unsigned native int`, and extends it to `native int`."}],"pos":[262832,262940],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|E0|conv.u|Convert to `unsigned native int`, pushing `native int` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"E0","nodes":[{"content":"E0","pos":[0,2]}]},{"pos":[259,265],"content":"conv.u","nodes":[{"content":"conv.u","pos":[0,6]}]},{"pos":[266,330],"content":"Convert to <ph id=\"ph1\">`unsigned native int`</ph>, pushing <ph id=\"ph2\">`native int`</ph> on stack.","source":"Convert to `unsigned native int`, pushing `native int` on stack."},{"pos":[338,395],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[405,438],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[448,523],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[533,611],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[618,1017],"content":"The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.u`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,153],"source":"The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[154,346],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[347,399],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1024,1522],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from an <ph id=\"ph1\">`float64`</ph> to an <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,164],"source":" When converting from an `float64` to an `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[165,317],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[318,411]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[412,498],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1529,1629],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1636,1920],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,284],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,284],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1927,2035],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.u`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:"},{"pos":[2045,2069],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[262951,265047],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `unsigned int8`, and extends it to `int32`.","nodes":[{"pos":[0,96],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int8`</ph>, and extends it to <ph id=\"ph2\">`int32`</ph>.","source":"Converts the value on top of the evaluation stack to `unsigned int8`, and extends it to `int32`."}],"pos":[266643,266740],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D2|conv.u1|Convert to `int8`, pushing `int32` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D2","nodes":[{"content":"D2","pos":[0,2]}]},{"pos":[259,266],"content":"conv.u1","nodes":[{"content":"conv.u1","pos":[0,7]}]},{"pos":[267,311],"content":"Convert to <ph id=\"ph1\">`int8`</ph>, pushing <ph id=\"ph2\">`int32`</ph> on stack.","source":"Convert to `int8`, pushing `int32` on stack."},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,419],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[429,504],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[514,592],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[599,999],"content":"The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.u1`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1006,1504],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from an <ph id=\"ph1\">`float64`</ph> to an <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,164],"source":" When converting from an `float64` to an `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[165,317],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[318,411]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[412,498],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1511,1611],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1618,1904],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1911,2020],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.u1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:"},{"pos":[2030,2054],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[266751,268832],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `unsigned int16`, and extends it to `int32`.","nodes":[{"pos":[0,97],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int16`</ph>, and extends it to <ph id=\"ph2\">`int32`</ph>.","source":"Converts the value on top of the evaluation stack to `unsigned int16`, and extends it to `int32`."}],"pos":[270429,270527],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D1|conv.u2|Convert to `int16`, pushing `int32` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D1","nodes":[{"content":"D1","pos":[0,2]}]},{"pos":[259,266],"content":"conv.u2","nodes":[{"content":"conv.u2","pos":[0,7]}]},{"pos":[267,312],"content":"Convert to <ph id=\"ph1\">`int16`</ph>, pushing <ph id=\"ph2\">`int32`</ph> on stack.","source":"Convert to `int16`, pushing `int32` on stack."},{"pos":[320,377],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[387,420],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[430,505],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[515,593],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[600,1000],"content":"The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.u2`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1007,1505],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from an <ph id=\"ph1\">`float64`</ph> to an <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,164],"source":" When converting from an `float64` to an `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[165,317],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[318,411]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[412,498],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1512,1612],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1619,1905],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1912,2021],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.u2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:"},{"pos":[2031,2055],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[270538,272620],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `unsigned int32`, and extends it to `int32`.","nodes":[{"pos":[0,97],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int32`</ph>, and extends it to <ph id=\"ph2\">`int32`</ph>.","source":"Converts the value on top of the evaluation stack to `unsigned int32`, and extends it to `int32`."}],"pos":[274217,274315],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|6D|conv.u4|Convert to `unsigned int32`, pushing `int32` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"6D","nodes":[{"content":"6D","pos":[0,2]}]},{"pos":[259,266],"content":"conv.u4","nodes":[{"content":"conv.u4","pos":[0,7]}]},{"pos":[267,321],"content":"Convert to <ph id=\"ph1\">`unsigned int32`</ph>, pushing <ph id=\"ph2\">`int32`</ph> on stack.","source":"Convert to `unsigned int32`, pushing `int32` on stack."},{"pos":[329,386],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[396,429],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[439,514],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[524,602],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[609,1009],"content":"The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.u4`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1016,1514],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from an <ph id=\"ph1\">`float64`</ph> to an <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,164],"source":" When converting from an `float64` to an `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[165,317],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[318,411]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[412,498],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1521,1621],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1628,1914],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1921,2030],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.u4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:"},{"pos":[2040,2064],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[274326,276417],"yaml":true,"extradata":"MT"},{"content":"Converts the value on top of the evaluation stack to `unsigned int64`, and extends it to `int64`.","nodes":[{"pos":[0,97],"content":"Converts the value on top of the evaluation stack to <ph id=\"ph1\">`unsigned int64`</ph>, and extends it to <ph id=\"ph2\">`int64`</ph>.","source":"Converts the value on top of the evaluation stack to `unsigned int64`, and extends it to `int64`."}],"pos":[278014,278112],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|6E|conv.u8|Convert to `int64`, pushing `int64` on stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and the conversion operation is attempted.  \n  \n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \n  \n The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \n  \n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \n  \n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \n  \n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"6E","nodes":[{"content":"6E","pos":[0,2]}]},{"pos":[259,266],"content":"conv.u8","nodes":[{"content":"conv.u8","pos":[0,7]}]},{"pos":[267,312],"content":"Convert to <ph id=\"ph1\">`int64`</ph>, pushing <ph id=\"ph2\">`int64`</ph> on stack.","source":"Convert to `int64`, pushing `int64` on stack."},{"pos":[320,377],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[387,420],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[430,505],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and the conversion operation is attempted.","source":"`value` is popped from the stack and the conversion operation is attempted."},{"pos":[515,593],"content":"If the conversion is successful, the resulting value is pushed onto the stack.","nodes":[{"content":"If the conversion is successful, the resulting value is pushed onto the stack.","pos":[0,78]}]},{"pos":[600,1000],"content":"The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.","nodes":[{"content":"The <ph id=\"ph1\">`conv.u8`</ph> opcode converts the <ph id=\"ph2\">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.","pos":[0,154],"source":"The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack."},{"content":"Integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id=\"ph2\">`conv.i`</ph> or <ph id=\"ph3\">`conv.u`</ph> is used, in which case the result is also <ph id=\"ph4\">`native int`</ph>).","pos":[155,347],"source":" Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`)."},{"content":"Floating-point values are converted to the <ph id=\"ph1\">`F`</ph> type.","pos":[348,400],"source":" Floating-point values are converted to the `F` type."}]},{"pos":[1007,1505],"content":"Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.","nodes":[{"content":"Conversion from floating-point numbers to integer values truncates the number toward zero.","pos":[0,90]},{"content":"When converting from an <ph id=\"ph1\">`float64`</ph> to an <ph id=\"ph2\">`float32`</ph>, precision can be lost.","pos":[91,164],"source":" When converting from an `float64` to an `float32`, precision can be lost."},{"content":"If <ph id=\"ph1\">`value`</ph> is too large to fit in a <ph id=\"ph2\">`float32 (F)`</ph>, positive infinity (if <ph id=\"ph3\">`value`</ph> is positive) or negative infinity (if <ph id=\"ph4\">`value`</ph> is negative) is returned.","pos":[165,317],"source":" If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned."},{"content":"If overflow occurs converting one integer type to another, the high order bits are truncated.","pos":[318,411]},{"content":"If the result is smaller than an <ph id=\"ph1\">`int32`</ph>, the value is sign-extended to fill the slot.","pos":[412,498],"source":" If the result is smaller than an `int32`, the value is sign-extended to fill the slot."}]},{"pos":[1512,1612],"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","nodes":[{"content":"If overflow occurs converting a floating-point type to an integer the value returned is unspecified.","pos":[0,100]}]},{"pos":[1619,1905],"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","nodes":[{"content":"No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[0,286],"nodes":[{"content":"No exceptions are ever thrown when using this field.","pos":[0,52]},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.","pos":[53,286],"source":" See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value."}]}]},{"pos":[1912,2021],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`conv.u8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:"},{"pos":[2031,2055],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[278123,280205],"yaml":true,"extradata":"MT"},{"content":"Copies a specified number bytes from a source address to a destination address.","nodes":[{"pos":[0,79],"content":"Copies a specified number bytes from a source address to a destination address.","nodes":[{"content":"Copies a specified number bytes from a source address to a destination address.","pos":[0,79]}]}],"pos":[281790,281870],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 17|cpblk|Copy data from one memory block to another.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The destination address is pushed onto the stack.  \n  \n2.  The source address is pushed onto the stack.  \n  \n3.  The number of bytes to copy is pushed onto the stack.  \n  \n4.  The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.  \n  \n The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`). The behavior of `cpblk` is unspecified if the source and destination areas overlap.  \n  \n `cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine. The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.  \n  \n The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned>prefix instruction.  \n  \n <xref:System.NullReferenceException> may be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 17","nodes":[{"content":"FE 17","pos":[0,5]}]},{"pos":[262,267],"content":"cpblk","nodes":[{"content":"cpblk","pos":[0,5]}]},{"pos":[268,311],"content":"Copy data from one memory block to another.","nodes":[{"content":"Copy data from one memory block to another.","pos":[0,43]}]},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,435],"content":"The destination address is pushed onto the stack.","nodes":[{"content":"The destination address is pushed onto the stack.","pos":[0,49]}]},{"pos":[445,489],"content":"The source address is pushed onto the stack.","nodes":[{"content":"The source address is pushed onto the stack.","pos":[0,44]}]},{"pos":[499,552],"content":"The number of bytes to copy is pushed onto the stack.","nodes":[{"content":"The number of bytes to copy is pushed onto the stack.","pos":[0,53]}]},{"pos":[562,750],"content":"The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.","nodes":[{"content":"The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.","pos":[0,188]}]},{"pos":[757,1033],"content":"The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`). The behavior of `cpblk` is unspecified if the source and destination areas overlap.","nodes":[{"content":"The <ph id=\"ph1\">`cpblk`</ph> instruction copies a number (type <ph id=\"ph2\">`unsigned int32`</ph>) of bytes from a source address (of type <ph id=\"ph3\">`*`</ph>, <ph id=\"ph4\">`native int`</ph>, or <ph id=\"ph5\">`&amp;`</ph>) to a destination address (of type <ph id=\"ph6\">`*`</ph>, <ph id=\"ph7\">`native int`</ph>, or <ph id=\"ph8\">`&amp;`</ph>).","pos":[0,192],"source":"The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`)."},{"content":"The behavior of <ph id=\"ph1\">`cpblk`</ph> is unspecified if the source and destination areas overlap.","pos":[193,276],"source":" The behavior of `cpblk` is unspecified if the source and destination areas overlap."}]},{"pos":[1040,1310],"content":"`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine. The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.","nodes":[{"content":"<ph id=\"ph1\">`cpblk`</ph> assumes that both the source and destination addressed are aligned to the natural size of the machine.","pos":[0,110],"source":"`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine."},{"content":"The <ph id=\"ph1\">`cpblk`</ph> instruction can be immediately preceded by the <ph id=\"ph2\">`unaligned.&lt;prefix&gt;`</ph> instruction to indicate that either the source or the destination is unaligned.","pos":[111,270],"source":" The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned."}]},{"pos":[1317,1517],"content":"The operation of the <ph id=\"ph1\">`cpblk`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>prefix instruction.","source":"The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned>prefix instruction."},{"pos":[1524,1609],"content":"<xref:System.NullReferenceException> may be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> may be thrown if an invalid address is detected."}]},{"pos":[1616,1723],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`cpblk`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:"},{"pos":[1733,1757],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[281881,283667],"yaml":true,"extradata":"MT"},{"content":"Copies the value type located at the address of an object (type `&`, `*` or `native int`) to the address of the destination object (type `&`, `*` or `native int`).","nodes":[{"pos":[0,163],"content":"Copies the value type located at the address of an object (type <ph id=\"ph1\">`&amp;`</ph>, <ph id=\"ph2\">`*`</ph> or <ph id=\"ph3\">`native int`</ph>) to the address of the destination object (type <ph id=\"ph4\">`&amp;`</ph>, <ph id=\"ph5\">`*`</ph> or <ph id=\"ph6\">`native int`</ph>).","source":"Copies the value type located at the address of an object (type `&`, `*` or `native int`) to the address of the destination object (type `&`, `*` or `native int`)."}],"pos":[285250,285414],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|70 < `T` >|cpobj `classTok`|Copies a value type from a source object to a destination object.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The destination object reference is pushed onto the stack.  \n  \n2.  The source object reference is pushed onto the stack.  \n  \n3.  The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.  \n  \n The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.  \n  \n <xref:System.NullReferenceException> may be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"70 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"70 < `T` >"},{"pos":[267,283],"content":"cpobj <ph id=\"ph1\">`classTok`</ph>","source":"cpobj `classTok`"},{"pos":[284,349],"content":"Copies a value type from a source object to a destination object.","nodes":[{"content":"Copies a value type from a source object to a destination object.","pos":[0,65]}]},{"pos":[357,414],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[424,482],"content":"The destination object reference is pushed onto the stack.","nodes":[{"content":"The destination object reference is pushed onto the stack.","pos":[0,58]}]},{"pos":[492,545],"content":"The source object reference is pushed onto the stack.","nodes":[{"content":"The source object reference is pushed onto the stack.","pos":[0,53]}]},{"pos":[555,710],"content":"The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.","nodes":[{"content":"The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.","pos":[0,155]}]},{"pos":[717,966],"content":"The behavior of <ph id=\"ph1\">`cpobj`</ph> is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <ph id=\"ph2\">`classTok`</ph> (a <ph id=\"ph3\">`typeref`</ph> or <ph id=\"ph4\">`typedef`</ph>), or if <ph id=\"ph5\">`classTok`</ph> does not represent a value type.","source":"The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type."},{"pos":[973,1058],"content":"<xref:System.NullReferenceException> may be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> may be thrown if an invalid address is detected."}]},{"pos":[1065,1172],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`cpobj`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:"},{"pos":[1182,1212],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[285425,286660],"yaml":true,"extradata":"MT"},{"content":"Divides two values and pushes the result as a floating-point (type `F`) or quotient (type `int32`) onto the evaluation stack.","nodes":[{"pos":[0,125],"content":"Divides two values and pushes the result as a floating-point (type <ph id=\"ph1\">`F`</ph>) or quotient (type <ph id=\"ph2\">`int32`</ph>) onto the evaluation stack.","source":"Divides two values and pushes the result as a floating-point (type `F`) or quotient (type `int32`) onto the evaluation stack."}],"pos":[288231,288357],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|5B|div|Divides two values to return a quotient or floating-point result.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is divided by `value2`.  \n  \n4.  The result is pushed onto the stack.  \n  \n `result` = `value1` div value2 satisfies the following conditions:  \n  \n &#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:  \n  \n sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)  \n  \n The `div` instruction computes the result and pushes it on the stack.  \n  \n Integer division truncates towards zero.  \n  \n Division of a finite number by zero produces the correctly signed infinite value.  \n  \n Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value. Any number divided by infinity will produce a zero value.  \n  \n Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type. This can happen if `value1` is the maximum negative value, and `value2` is -1.  \n  \n Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.  \n  \n Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1). Floating-point operations never throw an exception (they produce NaNs or infinities instead).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"5B","nodes":[{"content":"5B","pos":[0,2]}]},{"pos":[259,262],"content":"div","nodes":[{"content":"div","pos":[0,3]}]},{"pos":[263,328],"content":"Divides two values to return a quotient or floating-point result.","nodes":[{"content":"Divides two values to return a quotient or floating-point result.","pos":[0,65]}]},{"pos":[336,393],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[403,437],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[447,481],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[491,572],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is divided by <ph id=\"ph4\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `value1` is divided by `value2`."},{"pos":[582,618],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[625,691],"content":"<ph id=\"ph1\">`result`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`value1`</ph> div value2 satisfies the following conditions:","source":"`result` = `value1` div value2 satisfies the following conditions:"},{"pos":[698,776],"content":"&amp;#124; <ph id=\"ph1\">`result`</ph> &amp;#124; = &amp;#124; <ph id=\"ph2\">`value1`</ph> &amp;#124; / &amp;#124; <ph id=\"ph3\">`value2`</ph> &amp;#124;, and:","source":"&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:"},{"pos":[783,880],"content":"sign(<ph id=\"ph1\">`result`</ph>) = +, if sign(<ph id=\"ph2\">`value1`</ph>) = sign(<ph id=\"ph3\">`value2`</ph>), or -, if sign(<ph id=\"ph4\">`value1`</ph>) ~= sign(<ph id=\"ph5\">`value2`</ph>)","source":"sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)"},{"pos":[887,956],"content":"The <ph id=\"ph1\">`div`</ph> instruction computes the result and pushes it on the stack.","source":"The `div` instruction computes the result and pushes it on the stack."},{"pos":[963,1003],"content":"Integer division truncates towards zero.","nodes":[{"content":"Integer division truncates towards zero.","pos":[0,40]}]},{"pos":[1010,1091],"content":"Division of a finite number by zero produces the correctly signed infinite value.","nodes":[{"content":"Division of a finite number by zero produces the correctly signed infinite value.","pos":[0,81]}]},{"pos":[1098,1240],"content":"Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value. Any number divided by infinity will produce a zero value.","nodes":[{"content":"Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value. Any number divided by infinity will produce a zero value.","pos":[0,142],"nodes":[{"content":"Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.","pos":[0,84]},{"content":"Any number divided by infinity will produce a zero value.","pos":[85,142]}]}]},{"pos":[1247,1441],"content":"Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type. This can happen if `value1` is the maximum negative value, and `value2` is -1.","nodes":[{"content":"Integral operations throw <ph id=\"ph1\">&lt;xref:System.ArithmeticException&gt;</ph> if the result cannot be represented in the result type.","pos":[0,115],"source":"Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type."},{"content":"This can happen if <ph id=\"ph1\">`value1`</ph> is the maximum negative value, and <ph id=\"ph2\">`value2`</ph> is -1.","pos":[116,194],"source":" This can happen if `value1` is the maximum negative value, and `value2` is -1."}]},{"pos":[1448,1530],"content":"Integral operations throw <ph id=\"ph1\">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id=\"ph2\">`value2`</ph> is zero.","source":"Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero."},{"pos":[1537,1742],"content":"Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1). Floating-point operations never throw an exception (they produce NaNs or infinities instead).","nodes":[{"content":"Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1). Floating-point operations never throw an exception (they produce NaNs or infinities instead).","pos":[0,205],"nodes":[{"content":"Note that on Intel-based platforms an <ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint div -1).","pos":[0,111],"source":"Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1)."},{"content":"Floating-point operations never throw an exception (they produce NaNs or infinities instead).","pos":[112,205]}]}]},{"pos":[1749,1854],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`div`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:"},{"pos":[1864,1888],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[288368,290297],"yaml":true,"extradata":"MT"},{"content":"Divides two unsigned integer values and pushes the result (`int32`) onto the evaluation stack.","nodes":[{"pos":[0,94],"content":"Divides two unsigned integer values and pushes the result (<ph id=\"ph1\">`int32`</ph>) onto the evaluation stack.","source":"Divides two unsigned integer values and pushes the result (`int32`) onto the evaluation stack."}],"pos":[291884,291979],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|5C|div.un|Divides two values, unsigned, returning a quotient.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is divided by `value2`.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"5C","nodes":[{"content":"5C","pos":[0,2]}]},{"pos":[259,265],"content":"div.un","nodes":[{"content":"div.un","pos":[0,6]}]},{"pos":[266,317],"content":"Divides two values, unsigned, returning a quotient.","nodes":[{"content":"Divides two values, unsigned, returning a quotient.","pos":[0,51]}]},{"pos":[325,382],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[392,426],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[436,470],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[480,561],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is divided by <ph id=\"ph4\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `value1` is divided by `value2`."},{"pos":[571,607],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[614,748],"content":"The <ph id=\"ph1\">`div.un`</ph> instruction computes <ph id=\"ph2\">`value1`</ph> divided by <ph id=\"ph3\">`value2`</ph>, both taken as unsigned integers, and pushes the <ph id=\"ph4\">`result`</ph> on the stack.","source":"The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack."},{"pos":[755,863],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`div.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:"},{"pos":[873,897],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[291990,292910],"yaml":true,"extradata":"MT"},{"content":"Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.","nodes":[{"pos":[0,109],"content":"Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.","nodes":[{"content":"Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.","pos":[0,109]}]}],"pos":[294482,294592],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|25|dup|Duplicates the value on the top of the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped off of the stack for duplication.  \n  \n3.  `value` is pushed back onto the stack.  \n  \n4.  A duplicate value is pushed onto the stack.  \n  \n The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"25","nodes":[{"content":"25","pos":[0,2]}]},{"pos":[259,262],"content":"dup","nodes":[{"content":"dup","pos":[0,3]}]},{"pos":[263,308],"content":"Duplicates the value on the top of the stack.","nodes":[{"content":"Duplicates the value on the top of the stack.","pos":[0,45]}]},{"pos":[316,373],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[383,416],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[426,477],"content":"<ph id=\"ph1\">`value`</ph> is popped off of the stack for duplication.","source":"`value` is popped off of the stack for duplication."},{"pos":[487,525],"content":"<ph id=\"ph1\">`value`</ph> is pushed back onto the stack.","source":"`value` is pushed back onto the stack."},{"pos":[535,578],"content":"A duplicate value is pushed onto the stack.","nodes":[{"content":"A duplicate value is pushed onto the stack.","pos":[0,43]}]},{"pos":[585,688],"content":"The <ph id=\"ph1\">`dup`</ph> instruction duplicates the top element of the stack, and leaves two identical values atop it.","source":"The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it."},{"pos":[695,800],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`dup`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:"},{"pos":[810,834],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[294603,295460],"yaml":true,"extradata":"MT"},{"content":"Transfers control from the `filter` clause of an exception back to the Common Language Infrastructure (CLI) exception handler.","nodes":[{"pos":[0,126],"content":"Transfers control from the <ph id=\"ph1\">`filter`</ph> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.","source":"Transfers control from the `filter` clause of an exception back to the Common Language Infrastructure (CLI) exception handler."}],"pos":[297065,297192],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 11|endfilter|End filter clause of SEH exception handling.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.  \n  \n `Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause. It should be one of:  \n  \n-   `exception_continue_search` (`value` = 0) to continue searching for an exception handler  \n  \n-   `exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located. Upon discovery, the handler is executed.  \n  \n Other integer values will produce unspecified results.  \n  \n The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block. The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block). After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.  \n  \n Control cannot be transferred into a filter block except through the exception mechanism. Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction. You cannot embed a `try` block within a `filter` block. If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 11","nodes":[{"content":"FE 11","pos":[0,5]}]},{"pos":[262,271],"content":"endfilter","nodes":[{"content":"endfilter","pos":[0,9]}]},{"pos":[272,316],"content":"End filter clause of SEH exception handling.","nodes":[{"content":"End filter clause of SEH exception handling.","pos":[0,44]}]},{"pos":[324,381],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[391,424],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[434,544],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack; <ph id=\"ph2\">`endfilter`</ph> is executed and control is transferred to the exception handler.","source":"`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler."},{"pos":[551,686],"content":"`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause. It should be one of:","nodes":[{"content":"<ph id=\"ph1\">`Value`</ph> (which must be of type <ph id=\"ph2\">`int32`</ph> and is one of a specific set of values) is returned from the filter clause.","pos":[0,114],"source":"`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause."},{"content":"It should be one of:","pos":[115,135]}]},{"pos":[696,784],"content":"<ph id=\"ph1\">`exception_continue_search`</ph> (<ph id=\"ph2\">`value`</ph> = 0) to continue searching for an exception handler","source":"`exception_continue_search` (`value` = 0) to continue searching for an exception handler"},{"pos":[794,1018],"content":"`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located. Upon discovery, the handler is executed.","nodes":[{"content":"<ph id=\"ph1\">`exception_execute_handler`</ph> (<ph id=\"ph2\">`value`</ph> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.","pos":[0,183],"source":"`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located."},{"content":"Upon discovery, the handler is executed.","pos":[184,224]}]},{"pos":[1025,1079],"content":"Other integer values will produce unspecified results.","nodes":[{"content":"Other integer values will produce unspecified results.","pos":[0,54]}]},{"pos":[1086,1484],"content":"The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block. The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block). After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.","nodes":[{"content":"The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.","pos":[0,128]},{"content":"The <ph id=\"ph1\">`endfilter`</ph> instruction must be the last instruction in the filter's code block (hence there can only be one <ph id=\"ph2\">`endfilter`</ph> for any single filter block).","pos":[129,283],"source":" The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block)."},{"content":"After executing the <ph id=\"ph1\">`endfilter`</ph> instruction, control logically flows back to the CLI exception handling mechanism.","pos":[284,398],"source":" After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism."}]},{"pos":[1491,1918],"content":"Control cannot be transferred into a filter block except through the exception mechanism. Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction. You cannot embed a `try` block within a `filter` block. If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.","nodes":[{"content":"Control cannot be transferred into a filter block except through the exception mechanism.","pos":[0,89]},{"content":"Control cannot be transferred out of a filter block except through the use of a <ph id=\"ph1\">`throw`</ph> instruction or by executing the final <ph id=\"ph2\">`endfilter`</ph> instruction.","pos":[90,240],"source":" Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction."},{"content":"You cannot embed a <ph id=\"ph1\">`try`</ph> block within a <ph id=\"ph2\">`filter`</ph> block.","pos":[241,296],"source":" You cannot embed a `try` block within a `filter` block."},{"content":"If an exception is thrown inside the <ph id=\"ph1\">`filter`</ph> block, it is intercepted and a value of 0 (<ph id=\"ph2\">`exception_continue_search`</ph>) is returned.","pos":[297,427],"source":" If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned."}]},{"pos":[1925,2036],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`endfilter`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:"},{"pos":[2046,2070],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[297203,299302],"yaml":true,"extradata":"MT"},{"content":"Transfers control from the `fault` or `finally` clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.","nodes":[{"pos":[0,144],"content":"Transfers control from the <ph id=\"ph1\">`fault`</ph> or <ph id=\"ph2\">`finally`</ph> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.","source":"Transfers control from the `fault` or `finally` clause of an exception block back to the Common Language Infrastructure (CLI) exception handler."}],"pos":[300919,301064],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|DC|endfinally<br /><br /> endfault|Ends the `finally` or `fault` clause of an exception block.|  \n  \n There are no stack transition behaviors for this instruction.  \n  \n `Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked. The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism. The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction. If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.  \n  \n An `endfinally` instruction might only appear lexically within a `finally` block. Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required. These same restrictions apply to the `endfault` instruction and the `fault` block.  \n  \n Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism. Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction. In particular, you cannot \"fall out\" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.  \n  \n Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  \n  \n-   ILGenerator.Emit(OpCode)  \n  \n-   ILGenerator.EndExceptionBlock()","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"DC","nodes":[{"content":"DC","pos":[0,2]}]},{"pos":[259,290],"content":"endfinally<br /><br /> endfault","nodes":[{"content":"endfinally","pos":[0,10]},{"content":"endfault","pos":[23,31]}]},{"pos":[291,350],"content":"Ends the <ph id=\"ph1\">`finally`</ph> or <ph id=\"ph2\">`fault`</ph> clause of an exception block.","source":"Ends the `finally` or `fault` clause of an exception block."},{"pos":[358,419],"content":"There are no stack transition behaviors for this instruction.","nodes":[{"content":"There are no stack transition behaviors for this instruction.","pos":[0,61]}]},{"pos":[426,1000],"content":"`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked. The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism. The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction. If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.","nodes":[{"content":"<ph id=\"ph1\">`Endfinally`</ph> and <ph id=\"ph2\">`endfault`</ph> signal the end of the <ph id=\"ph3\">`finally`</ph> or <ph id=\"ph4\">`fault`</ph> clause so that stack unwinding can continue until the exception handler is invoked.","pos":[0,154],"source":"`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked."},{"content":"The <ph id=\"ph1\">`endfinally`</ph> or <ph id=\"ph2\">`endfault`</ph> instruction transfers control back to the CLI exception mechanism.","pos":[155,252],"source":" The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism."},{"content":"The mechanism then searches for the next <ph id=\"ph1\">`finally`</ph> clause in the chain if the protected block was exited with a leave instruction.","pos":[253,383],"source":" The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction."},{"content":"If the protected block was exited with an exception, the CLI will search for the next <ph id=\"ph1\">`finally`</ph> or <ph id=\"ph2\">`fault`</ph>, or enter the exception handler chosen during the first pass of exception handling.","pos":[384,574],"source":" If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling."}]},{"pos":[1007,1365],"content":"An `endfinally` instruction might only appear lexically within a `finally` block. Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required. These same restrictions apply to the `endfault` instruction and the `fault` block.","nodes":[{"content":"An <ph id=\"ph1\">`endfinally`</ph> instruction might only appear lexically within a <ph id=\"ph2\">`finally`</ph> block.","pos":[0,81],"source":"An `endfinally` instruction might only appear lexically within a `finally` block."},{"content":"Unlike the <ph id=\"ph1\">`endfilter`</ph> instruction, there is no requirement that the block end with an <ph id=\"ph2\">`endfinally`</ph> instruction, and there can be as many <ph id=\"ph3\">`endfinally`</ph> instructions within the block as required.","pos":[82,275],"source":" Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required."},{"content":"These same restrictions apply to the <ph id=\"ph1\">`endfault`</ph> instruction and the <ph id=\"ph2\">`fault`</ph> block.","pos":[276,358],"source":" These same restrictions apply to the `endfault` instruction and the `fault` block."}]},{"pos":[1372,1879],"content":"Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism. Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction. In particular, you cannot \"fall out\" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.","nodes":[{"content":"Control cannot be transferred into a <ph id=\"ph1\">`finally`</ph> (or <ph id=\"ph2\">`fault`</ph>) block except through the exception mechanism.","pos":[0,105],"source":"Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism."},{"content":"Control cannot be transferred out of a <ph id=\"ph1\">`finally`</ph> (or <ph id=\"ph2\">`fault`</ph>) block except through the use of a <ph id=\"ph3\">`throw`</ph> instruction or executing the <ph id=\"ph4\">`endfinally`</ph> (or <ph id=\"ph5\">`endfault`</ph>) instruction.","pos":[106,280],"source":" Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction."},{"content":"In particular, you cannot \"fall out\" of a <ph id=\"ph1\">`finally`</ph> (or <ph id=\"ph2\">`fault`</ph>) block or to execute a <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction within a <ph id=\"ph5\">`finally`</ph> (or <ph id=\"ph6\">`fault`</ph>) block.","pos":[281,507],"source":" In particular, you cannot \"fall out\" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block."}]},{"pos":[1886,1990],"content":"Note that the <ph id=\"ph1\">`endfault`</ph> and <ph id=\"ph2\">`endfinally`</ph> instructions are aliases - they correspond to the same opcode.","source":"Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode."},{"pos":[1997,2222],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`endfinally`</ph> (<ph id=\"ph3\">`endfault`</ph>) opcode, as well as the <ph id=\"ph4\">`ILGenerator`</ph> method <ph id=\"ph5\">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>."},{"pos":[2232,2256],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]},{"pos":[2266,2297],"content":"ILGenerator.EndExceptionBlock()","nodes":[{"content":"ILGenerator.EndExceptionBlock()","pos":[0,31]}]}],"pos":[301075,303397],"yaml":true,"extradata":"MT"},{"content":"Initializes a specified block of memory at a specific address to a given size and initial value.","nodes":[{"pos":[0,96],"content":"Initializes a specified block of memory at a specific address to a given size and initial value.","nodes":[{"content":"Initializes a specified block of memory at a specific address to a given size and initial value.","pos":[0,96]}]}],"pos":[304997,305094],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 18|initblk|Set each location in a block of memory to a given value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A starting address is pushed onto the stack.  \n  \n2.  An initialization value is pushed onto the stack.  \n  \n3.  The number of bytes to initialize is pushed onto the stack.  \n  \n4.  The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.  \n  \n The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`). `initblk` assumes that the starting address is aligned to the natural size of the machine.  \n  \n The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> may be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 18","nodes":[{"content":"FE 18","pos":[0,5]}]},{"pos":[262,269],"content":"initblk","nodes":[{"content":"initblk","pos":[0,7]}]},{"pos":[270,326],"content":"Set each location in a block of memory to a given value.","nodes":[{"content":"Set each location in a block of memory to a given value.","pos":[0,56]}]},{"pos":[334,391],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[401,445],"content":"A starting address is pushed onto the stack.","nodes":[{"content":"A starting address is pushed onto the stack.","pos":[0,44]}]},{"pos":[455,504],"content":"An initialization value is pushed onto the stack.","nodes":[{"content":"An initialization value is pushed onto the stack.","pos":[0,49]}]},{"pos":[514,573],"content":"The number of bytes to initialize is pushed onto the stack.","nodes":[{"content":"The number of bytes to initialize is pushed onto the stack.","pos":[0,59]}]},{"pos":[583,738],"content":"The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.","nodes":[{"content":"The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.","pos":[0,155]}]},{"pos":[745,1030],"content":"The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`). `initblk` assumes that the starting address is aligned to the natural size of the machine.","nodes":[{"content":"The <ph id=\"ph1\">`initblk`</ph> instruction sets the number (<ph id=\"ph2\">`unsigned int32`</ph>) of bytes starting at the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or <ph id=\"ph5\">`*`</ph>) to the initialization value (of type <ph id=\"ph6\">`unsigned int8`</ph>).","pos":[0,194],"source":"The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`)."},{"content":"<ph id=\"ph1\">`initblk`</ph> assumes that the starting address is aligned to the natural size of the machine.","pos":[195,285],"source":"`initblk` assumes that the starting address is aligned to the natural size of the machine."}]},{"pos":[1037,1241],"content":"The operation of the <ph id=\"ph1\">`initblk`</ph> instructions can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","source":"The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."},{"pos":[1248,1333],"content":"<xref:System.NullReferenceException> may be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> may be thrown if an invalid address is detected."}]},{"pos":[1340,1449],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`initblk`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:"},{"pos":[1459,1483],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[305105,306615],"yaml":true,"extradata":"MT"},{"content":"Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.","nodes":[{"pos":[0,125],"content":"Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.","nodes":[{"content":"Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.","pos":[0,125]}]}],"pos":[308212,308338],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 15 < `T` >|`initobj` `typeTok`|Initializes a value type.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The address of the value type to initialize is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.  \n  \n The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type. After this method is called, the instance is ready for a constructor method to be called. If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.  \n  \n Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method. `Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"FE 15 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 15 < `T` >"},{"pos":[270,289],"content":"<ph id=\"ph1\">`initobj`</ph> <ph id=\"ph2\">`typeTok`</ph>","source":"`initobj` `typeTok`"},{"pos":[290,315],"content":"Initializes a value type.","nodes":[{"content":"Initializes a value type.","pos":[0,25]}]},{"pos":[323,380],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[390,459],"content":"The address of the value type to initialize is pushed onto the stack.","nodes":[{"content":"The address of the value type to initialize is pushed onto the stack.","pos":[0,69]}]},{"pos":[469,580],"content":"The address is popped from the stack; the value type at the specified address is initialized as type <ph id=\"ph1\">`typeTok`</ph>.","source":"The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`."},{"pos":[587,981],"content":"The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type. After this method is called, the instance is ready for a constructor method to be called. If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.","nodes":[{"content":"The <ph id=\"ph1\">`initobj`</ph> instruction initializes each field of the value type specified by the pushed address (of type <ph id=\"ph2\">`native int`</ph>, <ph id=\"ph3\">`&amp;`</ph>, or <ph id=\"ph4\">`*`</ph>) to a null reference or a 0 of the appropriate primitive type.","pos":[0,196],"source":"The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type."},{"content":"After this method is called, the instance is ready for a constructor method to be called.","pos":[197,286]},{"content":"If <ph id=\"ph1\">`typeTok`</ph> is a reference type, this instruction has the same effect as <ph id=\"ph2\">`ldnull`</ph> followed by <ph id=\"ph3\">`stind.ref`</ph>.","pos":[287,394],"source":" If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`."}]},{"pos":[988,1199],"content":"Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method. `Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.","nodes":[{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id=\"ph2\">`initobj`</ph> does not call the constructor method.","pos":[0,100],"source":"Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method."},{"content":"<ph id=\"ph1\">`Initobj`</ph> is intended for initializing value types, while <ph id=\"ph2\">`newobj`</ph> is used to allocate and initialize objects.","pos":[101,211],"source":"`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects."}]},{"pos":[1206,1315],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`initobj`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:"},{"pos":[1325,1355],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[308349,309725],"yaml":true,"extradata":"MT"},{"content":"Tests whether an object reference (type `O`) is an instance of a particular class.","nodes":[{"pos":[0,82],"content":"Tests whether an object reference (type <ph id=\"ph1\">`O`</ph>) is an instance of a particular class.","source":"Tests whether an object reference (type `O`) is an instance of a particular class."}],"pos":[311316,311399],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|75 < `T` >|isinst `class`|Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference is pushed onto the stack.  \n  \n2.  The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.  \n  \n3.  The result (either an object reference or a null reference) is pushed onto the stack.  \n  \n `Class` is a metadata token indicating the desired class. If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called. Otherwise, a null reference is pushed on the stack. If the object reference itself is a null reference, then `isinst` likewise returns a null reference.  \n  \n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"75 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"75 < `T` >"},{"pos":[267,281],"content":"isinst <ph id=\"ph1\">`class`</ph>","source":"isinst `class`"},{"pos":[282,414],"content":"Tests if an object reference is an instance of <ph id=\"ph1\">`class`</ph>, returning either a null reference or an instance of that class or interface.","source":"Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface."},{"pos":[422,479],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[489,534],"content":"An object reference is pushed onto the stack.","nodes":[{"content":"An object reference is pushed onto the stack.","pos":[0,45]}]},{"pos":[544,660],"content":"The object reference is popped from the stack and tested to see if it is an instance of the class passed in <ph id=\"ph1\">`class`</ph>.","source":"The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`."},{"pos":[670,755],"content":"The result (either an object reference or a null reference) is pushed onto the stack.","nodes":[{"content":"The result (either an object reference or a null reference) is pushed onto the stack.","pos":[0,85]}]},{"pos":[762,1290],"content":"`Class` is a metadata token indicating the desired class. If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called. Otherwise, a null reference is pushed on the stack. If the object reference itself is a null reference, then `isinst` likewise returns a null reference.","nodes":[{"content":"<ph id=\"ph1\">`Class`</ph> is a metadata token indicating the desired class.","pos":[0,57],"source":"`Class` is a metadata token indicating the desired class."},{"content":"If the class of the object on the top of the stack implements <ph id=\"ph1\">`class`</ph> (if <ph id=\"ph2\">`class`</ph> is an interface) or is a derived class of <ph id=\"ph3\">`class`</ph> (if <ph id=\"ph4\">`class`</ph> is a regular class) then it is cast to type <ph id=\"ph5\">`class`</ph> and the result is pushed on the stack, exactly as though <ph id=\"ph6\">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> had been called.","pos":[58,375],"source":" If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called."},{"content":"Otherwise, a null reference is pushed on the stack.","pos":[376,427]},{"content":"If the object reference itself is a null reference, then <ph id=\"ph1\">`isinst`</ph> likewise returns a null reference.","pos":[428,528],"source":" If the object reference itself is a null reference, then `isinst` likewise returns a null reference."}]},{"pos":[1297,1505],"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","nodes":[{"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","pos":[0,208],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.","pos":[0,67],"source":"<xref:System.TypeLoadException> is thrown if class cannot be found."},{"content":"This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","pos":[68,208]}]}]},{"pos":[1512,1620],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`isinst`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:"},{"pos":[1630,1660],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[311410,313093],"yaml":true,"extradata":"MT"},{"content":"Exits current method and jumps to specified method.","nodes":[{"pos":[0,51],"content":"Exits current method and jumps to specified method.","nodes":[{"content":"Exits current method and jumps to specified method.","pos":[0,51]}]}],"pos":[314665,314717],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|27 < `T` >|jmp `method`|Exit current method and jump to specified method.|  \n  \n There are no stack transition behaviors for this instruction.  \n  \n The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference. The current arguments are transferred to the destination method.  \n  \n The evaluation stack must be empty when this instruction is executed. The calling convention, number and type of arguments at the destination address must match that of the current method.  \n  \n The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:  \n  \n-   ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"27 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"27 < `T` >"},{"pos":[267,279],"content":"jmp <ph id=\"ph1\">`method`</ph>","source":"jmp `method`"},{"pos":[280,329],"content":"Exit current method and jump to specified method.","nodes":[{"content":"Exit current method and jump to specified method.","pos":[0,49]}]},{"pos":[337,398],"content":"There are no stack transition behaviors for this instruction.","nodes":[{"content":"There are no stack transition behaviors for this instruction.","pos":[0,61]}]},{"pos":[405,603],"content":"The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference. The current arguments are transferred to the destination method.","nodes":[{"content":"The <ph id=\"ph1\">`jmp`</ph> (jump) instruction transfers control to the method specified by <ph id=\"ph2\">`method`</ph>, which is a metadata token for a method reference.","pos":[0,133],"source":"The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference."},{"content":"The current arguments are transferred to the destination method.","pos":[134,198]}]},{"pos":[610,798],"content":"The evaluation stack must be empty when this instruction is executed. The calling convention, number and type of arguments at the destination address must match that of the current method.","nodes":[{"content":"The evaluation stack must be empty when this instruction is executed. The calling convention, number and type of arguments at the destination address must match that of the current method.","pos":[0,188],"nodes":[{"content":"The evaluation stack must be empty when this instruction is executed.","pos":[0,69]},{"content":"The calling convention, number and type of arguments at the destination address must match that of the current method.","pos":[70,188]}]}]},{"pos":[805,919],"content":"The <ph id=\"ph1\">`jmp`</ph> instruction cannot be used to transferred control out of a <ph id=\"ph2\">`try`</ph>, <ph id=\"ph3\">`filter`</ph>, <ph id=\"ph4\">`catch`</ph>, or <ph id=\"ph5\">`finally`</ph> block.","source":"The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block."},{"pos":[926,1031],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`jmp`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:"},{"pos":[1041,1077],"content":"ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, MethodInfo)","pos":[0,36]}]}],"pos":[314728,315824],"yaml":true,"extradata":"MT"},{"content":"Loads an argument (referenced by a specified index value) onto the stack.","nodes":[{"pos":[0,73],"content":"Loads an argument (referenced by a specified index value) onto the stack.","nodes":[{"content":"Loads an argument (referenced by a specified index value) onto the stack.","pos":[0,73]}]}],"pos":[317405,317479],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 09 < `unsigned int16` >|ldarg `index`|Load argument at `index` onto stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The argument value at `index` is pushed onto the stack.  \n  \n The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack. The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \n  \n For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).  \n  \n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:  \n  \n-   ILGenerator.Emit(OpCode, short)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,282],"content":"FE 09 &lt; <ph id=\"ph1\">`unsigned int16`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 09 < `unsigned int16` >"},{"pos":[283,296],"content":"ldarg <ph id=\"ph1\">`index`</ph>","source":"ldarg `index`"},{"pos":[297,333],"content":"Load argument at <ph id=\"ph1\">`index`</ph> onto stack.","source":"Load argument at `index` onto stack."},{"pos":[341,398],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[408,463],"content":"The argument value at <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"The argument value at `index` is pushed onto the stack."},{"pos":[470,858],"content":"The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack. The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`ldarg`</ph> instruction pushes the argument indexed at <ph id=\"ph2\">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.","pos":[0,134],"source":"The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack."},{"content":"The <ph id=\"ph1\">`ldarg`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.","pos":[135,268],"source":" The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument."},{"content":"The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","pos":[269,388]}]},{"pos":[865,1130],"content":"For procedures that take a variable-length argument list, the <ph id=\"ph1\">`ldarg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).","source":"For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details)."},{"pos":[1137,1333],"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[0,128],"source":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[129,196],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1340,1447],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarg`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:"},{"pos":[1457,1488],"content":"ILGenerator.Emit(OpCode, short)","nodes":[{"content":"ILGenerator.Emit(OpCode, short)","pos":[0,31]}]}],"pos":[317490,318999],"yaml":true,"extradata":"MT"},{"content":"Loads the argument at index 0 onto the evaluation stack.","nodes":[{"pos":[0,56],"content":"Loads the argument at index 0 onto the evaluation stack.","nodes":[{"content":"Loads the argument at index 0 onto the evaluation stack.","pos":[0,56]}]}],"pos":[320594,320651],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|02|ldarg.0|Load argument 0 onto stack|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The argument value at index 0 is pushed onto the stack.  \n  \n The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.  \n  \n The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack. The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \n  \n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"02","nodes":[{"content":"02","pos":[0,2]}]},{"pos":[259,266],"content":"ldarg.0","nodes":[{"content":"ldarg.0","pos":[0,7]}]},{"pos":[267,293],"content":"Load argument 0 onto stack","nodes":[{"content":"Load argument 0 onto stack","pos":[0,26]}]},{"pos":[301,358],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[368,423],"content":"The argument value at index 0 is pushed onto the stack.","nodes":[{"content":"The argument value at index 0 is pushed onto the stack.","pos":[0,55]}]},{"pos":[430,523],"content":"The <ph id=\"ph1\">`ldarg.0`</ph> instruction is an efficient encoding for loading the argument value at index 0.","source":"The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0."},{"pos":[530,871],"content":"The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack. The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`ldarg.0`</ph> instruction pushes the argument indexed at 0 onto the evaluation stack.","pos":[0,85],"source":"The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack."},{"content":"The <ph id=\"ph1\">`ldarg.0`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.","pos":[86,221],"source":" The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument."},{"content":"The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","pos":[222,341]}]},{"pos":[878,1074],"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[0,128],"source":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[129,196],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1081,1190],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarg.0`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:"},{"pos":[1200,1224],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[320662,321907],"yaml":true,"extradata":"MT"},{"content":"Loads the argument at index 1 onto the evaluation stack.","nodes":[{"pos":[0,56],"content":"Loads the argument at index 1 onto the evaluation stack.","nodes":[{"content":"Loads the argument at index 1 onto the evaluation stack.","pos":[0,56]}]}],"pos":[323504,323561],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|03|ldarg.1|Load argument 1 onto stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The argument value at index 1 is pushed onto the stack.  \n  \n The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.  \n  \n The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack. The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \n  \n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"03","nodes":[{"content":"03","pos":[0,2]}]},{"pos":[259,266],"content":"ldarg.1","nodes":[{"content":"ldarg.1","pos":[0,7]}]},{"pos":[267,294],"content":"Load argument 1 onto stack.","nodes":[{"content":"Load argument 1 onto stack.","pos":[0,27]}]},{"pos":[302,359],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[369,424],"content":"The argument value at index 1 is pushed onto the stack.","nodes":[{"content":"The argument value at index 1 is pushed onto the stack.","pos":[0,55]}]},{"pos":[431,524],"content":"The <ph id=\"ph1\">`ldarg.1`</ph> instruction is an efficient encoding for loading the argument value at index 1.","source":"The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1."},{"pos":[531,872],"content":"The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack. The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`ldarg.1`</ph> instruction pushes the argument indexed at 1 onto the evaluation stack.","pos":[0,85],"source":"The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack."},{"content":"The <ph id=\"ph1\">`ldarg.1`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.","pos":[86,221],"source":" The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument."},{"content":"The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","pos":[222,341]}]},{"pos":[879,1075],"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[0,128],"source":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[129,196],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1082,1191],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarg.1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:"},{"pos":[1201,1225],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[323572,324818],"yaml":true,"extradata":"MT"},{"content":"Loads the argument at index 2 onto the evaluation stack.","nodes":[{"pos":[0,56],"content":"Loads the argument at index 2 onto the evaluation stack.","nodes":[{"content":"Loads the argument at index 2 onto the evaluation stack.","pos":[0,56]}]}],"pos":[326415,326472],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|04|ldarg.2|Load argument 2 onto stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The argument value at index 2 is pushed onto the stack.  \n  \n The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.  \n  \n The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack. The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \n  \n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"04","nodes":[{"content":"04","pos":[0,2]}]},{"pos":[259,266],"content":"ldarg.2","nodes":[{"content":"ldarg.2","pos":[0,7]}]},{"pos":[267,294],"content":"Load argument 2 onto stack.","nodes":[{"content":"Load argument 2 onto stack.","pos":[0,27]}]},{"pos":[302,359],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[369,424],"content":"The argument value at index 2 is pushed onto the stack.","nodes":[{"content":"The argument value at index 2 is pushed onto the stack.","pos":[0,55]}]},{"pos":[431,524],"content":"The <ph id=\"ph1\">`ldarg.2`</ph> instruction is an efficient encoding for loading the argument value at index 2.","source":"The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2."},{"pos":[531,872],"content":"The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack. The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`ldarg.2`</ph> instruction pushes the argument indexed at 2 onto the evaluation stack.","pos":[0,85],"source":"The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack."},{"content":"The <ph id=\"ph1\">`ldarg.2`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.","pos":[86,221],"source":" The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument."},{"content":"The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","pos":[222,341]}]},{"pos":[879,1075],"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[0,128],"source":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[129,196],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1082,1191],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarg.2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:"},{"pos":[1201,1225],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[326483,327729],"yaml":true,"extradata":"MT"},{"content":"Loads the argument at index 3 onto the evaluation stack.","nodes":[{"pos":[0,56],"content":"Loads the argument at index 3 onto the evaluation stack.","nodes":[{"content":"Loads the argument at index 3 onto the evaluation stack.","pos":[0,56]}]}],"pos":[329326,329383],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|05|ldarg.3|Load argument 3 onto stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The argument value at index 3 is pushed onto the stack.  \n  \n The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.  \n  \n The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack. The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \n  \n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"05","nodes":[{"content":"05","pos":[0,2]}]},{"pos":[259,266],"content":"ldarg.3","nodes":[{"content":"ldarg.3","pos":[0,7]}]},{"pos":[267,294],"content":"Load argument 3 onto stack.","nodes":[{"content":"Load argument 3 onto stack.","pos":[0,27]}]},{"pos":[302,359],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[369,424],"content":"The argument value at index 3 is pushed onto the stack.","nodes":[{"content":"The argument value at index 3 is pushed onto the stack.","pos":[0,55]}]},{"pos":[431,524],"content":"The <ph id=\"ph1\">`ldarg.3`</ph> instruction is an efficient encoding for loading the argument value at index 3.","source":"The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3."},{"pos":[531,872],"content":"The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack. The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`ldarg.3`</ph> instruction pushes the argument indexed at 3 onto the evaluation stack.","pos":[0,85],"source":"The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack."},{"content":"The <ph id=\"ph1\">`ldarg.3`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.","pos":[86,221],"source":" The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument."},{"content":"The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","pos":[222,341]}]},{"pos":[879,1075],"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[0,128],"source":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[129,196],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1082,1191],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarg.3`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:"},{"pos":[1201,1225],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[329394,330640],"yaml":true,"extradata":"MT"},{"content":"Loads the argument (referenced by a specified short form index) onto the evaluation stack.","nodes":[{"pos":[0,90],"content":"Loads the argument (referenced by a specified short form index) onto the evaluation stack.","nodes":[{"content":"Loads the argument (referenced by a specified short form index) onto the evaluation stack.","pos":[0,90]}]}],"pos":[332237,332328],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|0E < `unsigned int8` >|ldarg.s `index`|Load argument at `index` onto stack, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The argument value at `index` is pushed onto the stack.  \n  \n The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.  \n  \n The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack. The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \n  \n For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).  \n  \n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,278],"content":"0E &lt; <ph id=\"ph1\">`unsigned int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"0E < `unsigned int8` >"},{"pos":[279,294],"content":"ldarg.s <ph id=\"ph1\">`index`</ph>","source":"ldarg.s `index`"},{"pos":[295,343],"content":"Load argument at <ph id=\"ph1\">`index`</ph> onto stack, short form.","source":"Load argument at `index` onto stack, short form."},{"pos":[351,408],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[418,473],"content":"The argument value at <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"The argument value at `index` is pushed onto the stack."},{"pos":[480,580],"content":"The <ph id=\"ph1\">`ldarg.s`</ph> instruction is an efficient encoding for loading arguments indexed from 4 through 255.","source":"The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255."},{"pos":[587,979],"content":"The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack. The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`ldarg.s`</ph> instruction pushes the argument indexed at <ph id=\"ph2\">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.","pos":[0,136],"source":"The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack."},{"content":"The <ph id=\"ph1\">`ldarg.s`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.","pos":[137,272],"source":" The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument."},{"content":"The type of the argument value is the same as the type of the argument, as specified by the current method's signature.","pos":[273,392]}]},{"pos":[986,1253],"content":"For procedures that take a variable-length argument list, the <ph id=\"ph1\">`ldarg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).","source":"For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details)."},{"pos":[1260,1456],"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[0,128],"source":"Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[129,196],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1463,1572],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarg.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:"},{"pos":[1582,1612],"content":"ILGenerator.Emit(OpCode, byte)","nodes":[{"content":"ILGenerator.Emit(OpCode, byte)","pos":[0,30]}]}],"pos":[332339,333974],"yaml":true,"extradata":"MT"},{"content":"Load an argument address onto the evaluation stack.","nodes":[{"pos":[0,51],"content":"Load an argument address onto the evaluation stack.","nodes":[{"content":"Load an argument address onto the evaluation stack.","pos":[0,51]}]}],"pos":[335565,335617],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 0A < `unsigned int16` >|ldarga `index`|Fetch the address of argument indexed by `index`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The address `addr` of the argument indexed by `index` is pushed onto the stack.  \n  \n The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards. The address `addr` is always aligned to a natural boundary on the target machine.  \n  \n For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \n  \n `ldarga` is used for by-ref parameter passing. For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:  \n  \n-   ILGenerator.Emit(OpCode, short)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,282],"content":"FE 0A &lt; <ph id=\"ph1\">`unsigned int16`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 0A < `unsigned int16` >"},{"pos":[283,297],"content":"ldarga <ph id=\"ph1\">`index`</ph>","source":"ldarga `index`"},{"pos":[298,347],"content":"Fetch the address of argument indexed by <ph id=\"ph1\">`index`</ph>.","source":"Fetch the address of argument indexed by `index`."},{"pos":[355,412],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[422,501],"content":"The address <ph id=\"ph1\">`addr`</ph> of the argument indexed by <ph id=\"ph2\">`index`</ph> is pushed onto the stack.","source":"The address `addr` of the argument indexed by `index` is pushed onto the stack."},{"pos":[508,728],"content":"The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards. The address `addr` is always aligned to a natural boundary on the target machine.","nodes":[{"content":"The <ph id=\"ph1\">`ldarga`</ph> instruction fetches the address (of type <ph id=\"ph2\">`*`</ph>) of the argument indexed by <ph id=\"ph3\">`index`</ph>, where arguments are indexed from 0 onwards.","pos":[0,138],"source":"The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards."},{"content":"The address <ph id=\"ph1\">`addr`</ph> is always aligned to a natural boundary on the target machine.","pos":[139,220],"source":" The address `addr` is always aligned to a natural boundary on the target machine."}]},{"pos":[735,916],"content":"For procedures that take a variable-length argument list, the <ph id=\"ph1\">`ldarga`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.","source":"For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature."},{"pos":[923,1094],"content":"`ldarga` is used for by-ref parameter passing. For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.","nodes":[{"content":"<ph id=\"ph1\">`ldarga`</ph> is used for by-ref parameter passing.","pos":[0,46],"source":"`ldarga` is used for by-ref parameter passing."},{"content":"For other cases, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> should be used.","pos":[47,171],"source":" For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used."}]},{"pos":[1101,1209],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarga`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:"},{"pos":[1219,1250],"content":"ILGenerator.Emit(OpCode, short)","nodes":[{"content":"ILGenerator.Emit(OpCode, short)","pos":[0,31]}]}],"pos":[335628,336899],"yaml":true,"extradata":"MT"},{"content":"Load an argument address, in short form, onto the evaluation stack.","nodes":[{"pos":[0,67],"content":"Load an argument address, in short form, onto the evaluation stack.","nodes":[{"content":"Load an argument address, in short form, onto the evaluation stack.","pos":[0,67]}]}],"pos":[338501,338569],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|0F < `unsigned int8` >|ldarga.s `index`|Fetch the address of argument indexed by `index`, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The address `addr` of the argument indexed by `index` is pushed onto the stack.  \n  \n `ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.  \n  \n The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards. The address `addr` is always aligned to a natural boundary on the target machine.  \n  \n For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \n  \n `ldarga.s` is used for by-ref parameter passing. For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,278],"content":"0F &lt; <ph id=\"ph1\">`unsigned int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"0F < `unsigned int8` >"},{"pos":[279,295],"content":"ldarga.s <ph id=\"ph1\">`index`</ph>","source":"ldarga.s `index`"},{"pos":[296,357],"content":"Fetch the address of argument indexed by <ph id=\"ph1\">`index`</ph>, short form.","source":"Fetch the address of argument indexed by `index`, short form."},{"pos":[365,422],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[432,511],"content":"The address <ph id=\"ph1\">`addr`</ph> of the argument indexed by <ph id=\"ph2\">`index`</ph> is pushed onto the stack.","source":"The address `addr` of the argument indexed by `index` is pushed onto the stack."},{"pos":[518,642],"content":"<ph id=\"ph1\">`ldarga.s`</ph> (the short form of <ph id=\"ph2\">`ldarga`</ph>) should be used for argument numbers 0 through 255, and is a more efficient encoding.","source":"`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding."},{"pos":[649,870],"content":"The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards. The address `addr` is always aligned to a natural boundary on the target machine.","nodes":[{"content":"The <ph id=\"ph1\">`ldarga.s`</ph> instruction fetches the address (of type<ph id=\"ph2\">`*`</ph>) of the argument indexed by <ph id=\"ph3\">`index`</ph>, where arguments are indexed from 0 onwards.","pos":[0,139],"source":"The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards."},{"content":"The address <ph id=\"ph1\">`addr`</ph> is always aligned to a natural boundary on the target machine.","pos":[140,221],"source":" The address `addr` is always aligned to a natural boundary on the target machine."}]},{"pos":[877,1060],"content":"For procedures that take a variable-length argument list, the <ph id=\"ph1\">`ldarga.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.","source":"For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature."},{"pos":[1067,1244],"content":"`ldarga.s` is used for by-ref parameter passing. For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.","nodes":[{"content":"<ph id=\"ph1\">`ldarga.s`</ph> is used for by-ref parameter passing.","pos":[0,48],"source":"`ldarga.s` is used for by-ref parameter passing."},{"content":"For other cases, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> should be used.","pos":[49,177],"source":" For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used."}]},{"pos":[1251,1361],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldarga.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:"},{"pos":[1371,1401],"content":"ILGenerator.Emit(OpCode, byte)","nodes":[{"content":"ILGenerator.Emit(OpCode, byte)","pos":[0,30]}]}],"pos":[338580,340004],"yaml":true,"extradata":"MT"},{"content":"Pushes a supplied value of type `int32` onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,80],"content":"Pushes a supplied value of type <ph id=\"ph1\">`int32`</ph> onto the evaluation stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Pushes a supplied value of type `int32` onto the evaluation stack as an `int32`."}],"pos":[341596,341677],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|20 < `int32` >|ldc.i4 `num`|Pushes the value `num` onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value `num` is pushed onto the stack.  \n  \n Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8. All short encodings push 4 byte integers on the stack. Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms. There are three ways to push an 8 byte integer constant onto the stack  \n  \n 1. Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.  \n  \n 2. Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.  \n  \n 3. Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:  \n  \n-   ILGenerator.Emit(OpCode, int)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"20 &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"20 < `int32` >"},{"pos":[271,283],"content":"ldc.i4 <ph id=\"ph1\">`num`</ph>","source":"ldc.i4 `num`"},{"pos":[284,322],"content":"Pushes the value <ph id=\"ph1\">`num`</ph> onto the stack.","source":"Pushes the value `num` onto the stack."},{"pos":[330,387],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[397,438],"content":"The value <ph id=\"ph1\">`num`</ph> is pushed onto the stack.","source":"The value `num` is pushed onto the stack."},{"pos":[445,873],"content":"Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8. All short encodings push 4 byte integers on the stack. Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms. There are three ways to push an 8 byte integer constant onto the stack","nodes":[{"content":"Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8. All short encodings push 4 byte integers on the stack. Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms. There are three ways to push an 8 byte integer constant onto the stack","pos":[0,428],"nodes":[{"content":"Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.","pos":[0,154]},{"content":"All short encodings push 4 byte integers on the stack.","pos":[155,209]},{"content":"Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.","pos":[210,357]},{"content":"There are three ways to push an 8 byte integer constant onto the stack","pos":[358,428]}]}]},{"pos":[883,1006],"content":"Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> instruction for constants that must be expressed in more than 32 bits.","pos":[0,123],"source":"Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits."}]},{"pos":[1016,1181],"content":"Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> instruction followed by a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that require 9 to 32 bits.","pos":[0,165],"source":"Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits."}]},{"pos":[1191,1335],"content":"Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.","nodes":[{"content":"Use a short form instruction followed by a <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that can be expressed in 8 or fewer bits.","pos":[0,144],"source":"Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits."}]},{"pos":[1342,1450],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:"},{"pos":[1460,1489],"content":"ILGenerator.Emit(OpCode, int)","nodes":[{"content":"ILGenerator.Emit(OpCode, int)","pos":[0,29]}]}],"pos":[341688,343200],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 0 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 0 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 0 onto the evaluation stack as an `int32`."}],"pos":[344802,344873],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|16|ldc.i4.0|Pushes 0 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 0 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"16","nodes":[{"content":"16","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.0","nodes":[{"content":"ldc.i4.0","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 0 onto the stack.","nodes":[{"content":"Pushes 0 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 0 is pushed onto the stack.","nodes":[{"content":"The value 0 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.0`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[344884,345595],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 1 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 1 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 1 onto the evaluation stack as an `int32`."}],"pos":[347199,347270],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|17|ldc.i4.1|Pushes 1 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 1 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"17","nodes":[{"content":"17","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.1","nodes":[{"content":"ldc.i4.1","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 1 onto the stack.","nodes":[{"content":"Pushes 1 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 1 is pushed onto the stack.","nodes":[{"content":"The value 1 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[347281,347992],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 2 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 2 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 2 onto the evaluation stack as an `int32`."}],"pos":[349596,349667],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|18|ldc.i4.2|Pushes 2 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 2 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"18","nodes":[{"content":"18","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.2","nodes":[{"content":"ldc.i4.2","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 2 onto the stack.","nodes":[{"content":"Pushes 2 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 2 is pushed onto the stack.","nodes":[{"content":"The value 2 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[349678,350389],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 3 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 3 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 3 onto the evaluation stack as an `int32`."}],"pos":[351993,352064],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|19|ldc.i4.3|Pushes 3 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 3 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"19","nodes":[{"content":"19","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.3","nodes":[{"content":"ldc.i4.3","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 3 onto the stack.","nodes":[{"content":"Pushes 3 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 3 is pushed onto the stack.","nodes":[{"content":"The value 3 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.3`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[352075,352786],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 4 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 4 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 4 onto the evaluation stack as an `int32`."}],"pos":[354390,354461],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|1A|ldc.i4.4|Pushes 4 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 4 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"1A","nodes":[{"content":"1A","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.4","nodes":[{"content":"ldc.i4.4","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 4 onto the stack.","nodes":[{"content":"Pushes 4 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 4 is pushed onto the stack.","nodes":[{"content":"The value 4 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[354472,355183],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 5 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 5 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 5 onto the evaluation stack as an `int32`."}],"pos":[356787,356858],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|1B|ldc.i4.5|Pushes 5 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 5 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"1B","nodes":[{"content":"1B","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.5","nodes":[{"content":"ldc.i4.5","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 5 onto the stack.","nodes":[{"content":"Pushes 5 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 5 is pushed onto the stack.","nodes":[{"content":"The value 5 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.5`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[356869,357580],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 6 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 6 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 6 onto the evaluation stack as an `int32`."}],"pos":[359184,359255],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|1C|ldc.i4.6|Pushes 6 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 6 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"1C","nodes":[{"content":"1C","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.6","nodes":[{"content":"ldc.i4.6","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 6 onto the stack.","nodes":[{"content":"Pushes 6 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 6 is pushed onto the stack.","nodes":[{"content":"The value 6 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.6`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[359266,359977],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 7 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 7 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 7 onto the evaluation stack as an `int32`."}],"pos":[361581,361652],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|1D|ldc.i4.7|Pushes 7 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 7 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"1D","nodes":[{"content":"1D","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.7","nodes":[{"content":"ldc.i4.7","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 7 onto the stack.","nodes":[{"content":"Pushes 7 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 7 is pushed onto the stack.","nodes":[{"content":"The value 7 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.7`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[361663,362374],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of 8 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,70],"content":"Pushes the integer value of 8 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of 8 onto the evaluation stack as an `int32`."}],"pos":[363978,364049],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|1E|ldc.i4.8|Pushes 8 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value 8 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"1E","nodes":[{"content":"1E","pos":[0,2]}]},{"pos":[259,267],"content":"ldc.i4.8","nodes":[{"content":"ldc.i4.8","pos":[0,8]}]},{"pos":[268,292],"content":"Pushes 8 onto the stack.","nodes":[{"content":"Pushes 8 onto the stack.","pos":[0,24]}]},{"pos":[300,357],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[367,404],"content":"The value 8 is pushed onto the stack.","nodes":[{"content":"The value 8 is pushed onto the stack.","pos":[0,37]}]},{"pos":[411,543],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[550,660],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:"},{"pos":[670,694],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[364060,364771],"yaml":true,"extradata":"MT"},{"content":"Pushes the integer value of -1 onto the evaluation stack as an `int32`.","nodes":[{"pos":[0,71],"content":"Pushes the integer value of -1 onto the evaluation stack as an <ph id=\"ph1\">`int32`</ph>.","source":"Pushes the integer value of -1 onto the evaluation stack as an `int32`."}],"pos":[366381,366453],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|15|ldc.i4.m1|Pushes -1 onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value -1 is pushed onto the stack.  \n  \n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"15","nodes":[{"content":"15","pos":[0,2]}]},{"pos":[259,268],"content":"ldc.i4.m1","nodes":[{"content":"ldc.i4.m1","pos":[0,9]}]},{"pos":[269,294],"content":"Pushes -1 onto the stack.","nodes":[{"content":"Pushes -1 onto the stack.","pos":[0,25]}]},{"pos":[302,359],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[369,407],"content":"The value -1 is pushed onto the stack.","nodes":[{"content":"The value -1 is pushed onto the stack.","pos":[0,38]}]},{"pos":[414,546],"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","nodes":[{"content":"This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.","pos":[0,132],"nodes":[{"content":"This is a special short encoding for the push of the integer value 0.","pos":[0,69]},{"content":"All special short encodings push 4 byte integers on the stack.","pos":[70,132]}]}]},{"pos":[553,664],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.m1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:"},{"pos":[674,698],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[366464,367179],"yaml":true,"extradata":"MT"},{"content":"Pushes the supplied `int8` value onto the evaluation stack as an `int32`, short form.","nodes":[{"pos":[0,85],"content":"Pushes the supplied <ph id=\"ph1\">`int8`</ph> value onto the evaluation stack as an <ph id=\"ph2\">`int32`</ph>, short form.","source":"Pushes the supplied `int8` value onto the evaluation stack as an `int32`, short form."}],"pos":[368784,368870],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|1F < `int8` >|ldc.i4.s `num`|Pushes `num` onto the stack as `int32`, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value `num` is pushed onto the stack.  \n  \n `ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"1F &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"1F < `int8` >"},{"pos":[270,284],"content":"ldc.i4.s <ph id=\"ph1\">`num`</ph>","source":"ldc.i4.s `num`"},{"pos":[285,336],"content":"Pushes <ph id=\"ph1\">`num`</ph> onto the stack as <ph id=\"ph2\">`int32`</ph>, short form.","source":"Pushes `num` onto the stack as `int32`, short form."},{"pos":[344,401],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[411,452],"content":"The value <ph id=\"ph1\">`num`</ph> is pushed onto the stack.","source":"The value `num` is pushed onto the stack."},{"pos":[459,567],"content":"<ph id=\"ph1\">`ldc.i4.s`</ph> is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.","source":"`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack."},{"pos":[574,684],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i4.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:"},{"pos":[694,724],"content":"ILGenerator.Emit(OpCode, byte)","nodes":[{"content":"ILGenerator.Emit(OpCode, byte)","pos":[0,30]}]}],"pos":[368881,369622],"yaml":true,"extradata":"MT"},{"content":"Pushes a supplied value of type `int64` onto the evaluation stack as an `int64`.","nodes":[{"pos":[0,80],"content":"Pushes a supplied value of type <ph id=\"ph1\">`int64`</ph> onto the evaluation stack as an <ph id=\"ph2\">`int64`</ph>.","source":"Pushes a supplied value of type `int64` onto the evaluation stack as an `int64`."}],"pos":[371214,371295],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|21 < `int64` >|ldc.i8 `num`|Pushes `num` onto the stack as `int64`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value `num` is pushed onto the stack.  \n  \n This encoding pushes an `int64` value onto the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:  \n  \n-   ILGenerator.Emit(OpCode, long)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"21 &lt; <ph id=\"ph1\">`int64`</ph><ph id=\"ph2\"> &gt;</ph>","source":"21 < `int64` >"},{"pos":[271,283],"content":"ldc.i8 <ph id=\"ph1\">`num`</ph>","source":"ldc.i8 `num`"},{"pos":[284,323],"content":"Pushes <ph id=\"ph1\">`num`</ph> onto the stack as <ph id=\"ph2\">`int64`</ph>.","source":"Pushes `num` onto the stack as `int64`."},{"pos":[331,388],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[398,439],"content":"The value <ph id=\"ph1\">`num`</ph> is pushed onto the stack.","source":"The value `num` is pushed onto the stack."},{"pos":[446,499],"content":"This encoding pushes an <ph id=\"ph1\">`int64`</ph> value onto the stack.","source":"This encoding pushes an `int64` value onto the stack."},{"pos":[506,614],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.i8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:"},{"pos":[624,654],"content":"ILGenerator.Emit(OpCode, long)","nodes":[{"content":"ILGenerator.Emit(OpCode, long)","pos":[0,30]}]}],"pos":[371306,371977],"yaml":true,"extradata":"MT"},{"content":"Pushes a supplied value of type `float32` onto the evaluation stack as type `F` (float).","nodes":[{"pos":[0,88],"content":"Pushes a supplied value of type <ph id=\"ph1\">`float32`</ph> onto the evaluation stack as type <ph id=\"ph2\">`F`</ph> (float).","source":"Pushes a supplied value of type `float32` onto the evaluation stack as type `F` (float)."}],"pos":[373567,373656],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|22 < `float32` >|ldc.r4 `num`|Pushes `num` onto the stack as `F`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value `num` is pushed onto the stack.  \n  \n This encoding pushes a `float32` value onto the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:  \n  \n-   ILGenerator.Emit(OpCode, single)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,272],"content":"22 &lt; <ph id=\"ph1\">`float32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"22 < `float32` >"},{"pos":[273,285],"content":"ldc.r4 <ph id=\"ph1\">`num`</ph>","source":"ldc.r4 `num`"},{"pos":[286,321],"content":"Pushes <ph id=\"ph1\">`num`</ph> onto the stack as <ph id=\"ph2\">`F`</ph>.","source":"Pushes `num` onto the stack as `F`."},{"pos":[329,386],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[396,437],"content":"The value <ph id=\"ph1\">`num`</ph> is pushed onto the stack.","source":"The value `num` is pushed onto the stack."},{"pos":[444,498],"content":"This encoding pushes a <ph id=\"ph1\">`float32`</ph> value onto the stack.","source":"This encoding pushes a `float32` value onto the stack."},{"pos":[505,613],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.r4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:"},{"pos":[623,655],"content":"ILGenerator.Emit(OpCode, single)","nodes":[{"content":"ILGenerator.Emit(OpCode, single)","pos":[0,32]}]}],"pos":[373667,374339],"yaml":true,"extradata":"MT"},{"content":"Pushes a supplied value of type `float64` onto the evaluation stack as type `F` (float).","nodes":[{"pos":[0,88],"content":"Pushes a supplied value of type <ph id=\"ph1\">`float64`</ph> onto the evaluation stack as type <ph id=\"ph2\">`F`</ph> (float).","source":"Pushes a supplied value of type `float64` onto the evaluation stack as type `F` (float)."}],"pos":[375929,376018],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|23 < `float64` >|ldc.r8 `num`|Pushes `num` onto the stack as `F`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value `num` is pushed onto the stack.  \n  \n This encoding pushes a `float64` value onto the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:  \n  \n-   ILGenerator.Emit(OpCode, double)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,272],"content":"23 &lt; <ph id=\"ph1\">`float64`</ph><ph id=\"ph2\"> &gt;</ph>","source":"23 < `float64` >"},{"pos":[273,285],"content":"ldc.r8 <ph id=\"ph1\">`num`</ph>","source":"ldc.r8 `num`"},{"pos":[286,321],"content":"Pushes <ph id=\"ph1\">`num`</ph> onto the stack as <ph id=\"ph2\">`F`</ph>.","source":"Pushes `num` onto the stack as `F`."},{"pos":[329,386],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[396,437],"content":"The value <ph id=\"ph1\">`num`</ph> is pushed onto the stack.","source":"The value `num` is pushed onto the stack."},{"pos":[444,498],"content":"This encoding pushes a <ph id=\"ph1\">`float64`</ph> value onto the stack.","source":"This encoding pushes a `float64` value onto the stack."},{"pos":[505,613],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldc.r8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:"},{"pos":[623,655],"content":"ILGenerator.Emit(OpCode, double)","nodes":[{"content":"ILGenerator.Emit(OpCode, double)","pos":[0,32]}]}],"pos":[376029,376701],"yaml":true,"extradata":"MT"},{"content":"Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.","nodes":[{"pos":[0,123],"content":"Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.","nodes":[{"content":"Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.","pos":[0,123]}]}],"pos":[378291,378415],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|A3 < `T` >|ldelem `typeTok`|Loads the element at `index` onto the top of the stack as type `typeTok`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects, and hence represented by a value of type `O`.  \n  \n The type of the return value is specified by the token `typeTok` in the instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"A3 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"A3 < `T` >"},{"pos":[267,283],"content":"ldelem <ph id=\"ph1\">`typeTok`</ph>","source":"ldelem `typeTok`"},{"pos":[284,357],"content":"Loads the element at <ph id=\"ph1\">`index`</ph> onto the top of the stack as type <ph id=\"ph2\">`typeTok`</ph>.","source":"Loads the element at `index` onto the top of the stack as type `typeTok`."},{"pos":[365,422],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[432,485],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[495,543],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[553,661],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[671,706],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[713,960],"content":"The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects, and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,181],"source":"The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects, and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[182,247],"source":" Arrays are objects, and hence represented by a value of type `O`."}]},{"pos":[967,1051],"content":"The type of the return value is specified by the token <ph id=\"ph1\">`typeTok`</ph> in the instruction.","source":"The type of the return value is specified by the token `typeTok` in the instruction."},{"pos":[1058,1136],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1143,1258],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the upper bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`."},{"pos":[1265,1373],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:"},{"pos":[1383,1413],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[378426,379868],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `native int` at a specified array index onto the top of the evaluation stack as a `native int`.","nodes":[{"pos":[0,123],"content":"Loads the element with type <ph id=\"ph1\">`native int`</ph> at a specified array index onto the top of the evaluation stack as a <ph id=\"ph2\">`native int`</ph>.","source":"Loads the element with type `native int` at a specified array index onto the top of the evaluation stack as a `native int`."}],"pos":[381470,381594],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|97|ldelem.i|Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.i` is `native int`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"97","nodes":[{"content":"97","pos":[0,2]}]},{"pos":[259,267],"content":"ldelem.i","nodes":[{"content":"ldelem.i","pos":[0,8]}]},{"pos":[268,364],"content":"Loads the element with type <ph id=\"ph1\">`native int`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as a <ph id=\"ph3\">`native int`</ph>.","source":"Loads the element with type `native int` at `index` onto the top of the stack as a `native int`."},{"pos":[372,429],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[439,492],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[502,550],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[560,668],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[678,713],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[720,968],"content":"The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.i`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,183],"source":"The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[184,248],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[975,1023],"content":"The return value for <ph id=\"ph1\">`ldelem.i`</ph> is <ph id=\"ph2\">`native int`</ph>.","source":"The return value for `ldelem.i` is `native int`."},{"pos":[1030,1166],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1173,1251],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1258,1364],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1371,1480],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1487,1597],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.i`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:"},{"pos":[1607,1631],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[381605,383269],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `int8` at a specified array index onto the top of the evaluation stack as an `int32`.","nodes":[{"pos":[0,113],"content":"Loads the element with type <ph id=\"ph1\">`int8`</ph> at a specified array index onto the top of the evaluation stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `int8` at a specified array index onto the top of the evaluation stack as an `int32`."}],"pos":[384879,384993],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|90|ldelem.i1|Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.i1` is `int8`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"90","nodes":[{"content":"90","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.i1","nodes":[{"content":"ldelem.i1","pos":[0,9]}]},{"pos":[269,355],"content":"Loads the element with type <ph id=\"ph1\">`int8`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the element with type `int8` at `index` onto the top of the stack as an `int32`."},{"pos":[363,420],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[430,483],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[493,541],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[551,659],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[669,704],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[711,960],"content":"The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.i1`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[967,1010],"content":"The return value for <ph id=\"ph1\">`ldelem.i1`</ph> is <ph id=\"ph2\">`int8`</ph>.","source":"The return value for `ldelem.i1` is `int8`."},{"pos":[1017,1153],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1160,1238],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1245,1351],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1358,1467],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1474,1585],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.i1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:"},{"pos":[1595,1619],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[385004,386656],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `int16` at a specified array index onto the top of the evaluation stack as an `int32`.","nodes":[{"pos":[0,114],"content":"Loads the element with type <ph id=\"ph1\">`int16`</ph> at a specified array index onto the top of the evaluation stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `int16` at a specified array index onto the top of the evaluation stack as an `int32`."}],"pos":[388267,388382],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|92|ldelem.i2|Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.i2` is `int16`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"92","nodes":[{"content":"92","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.i2","nodes":[{"content":"ldelem.i2","pos":[0,9]}]},{"pos":[269,356],"content":"Loads the element with type <ph id=\"ph1\">`int16`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the element with type `int16` at `index` onto the top of the stack as an `int32`."},{"pos":[364,421],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[431,484],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[494,542],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[552,660],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[670,705],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[712,961],"content":"The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.i2`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[968,1012],"content":"The return value for <ph id=\"ph1\">`ldelem.i2`</ph> is <ph id=\"ph2\">`int16`</ph>.","source":"The return value for `ldelem.i2` is `int16`."},{"pos":[1019,1155],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1162,1240],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1247,1353],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1360,1469],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1476,1587],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.i2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:"},{"pos":[1597,1621],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[388393,390047],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `int32` at a specified array index onto the top of the evaluation stack as an `int32`.","nodes":[{"pos":[0,114],"content":"Loads the element with type <ph id=\"ph1\">`int32`</ph> at a specified array index onto the top of the evaluation stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `int32` at a specified array index onto the top of the evaluation stack as an `int32`."}],"pos":[391658,391773],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|94|ldelem.i4|Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.i4` is `int32`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"94","nodes":[{"content":"94","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.i4","nodes":[{"content":"ldelem.i4","pos":[0,9]}]},{"pos":[269,356],"content":"Loads the element with type <ph id=\"ph1\">`int32`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the element with type `int32` at `index` onto the top of the stack as an `int32`."},{"pos":[364,421],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[431,484],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[494,542],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[552,660],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[670,705],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[712,961],"content":"The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.i4`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[968,1012],"content":"The return value for <ph id=\"ph1\">`ldelem.i4`</ph> is <ph id=\"ph2\">`int32`</ph>.","source":"The return value for `ldelem.i4` is `int32`."},{"pos":[1019,1155],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1162,1240],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1247,1353],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1360,1469],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1476,1587],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.i4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:"},{"pos":[1597,1621],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[391784,393438],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `int64` at a specified array index onto the top of the evaluation stack as an `int64`.","nodes":[{"pos":[0,114],"content":"Loads the element with type <ph id=\"ph1\">`int64`</ph> at a specified array index onto the top of the evaluation stack as an <ph id=\"ph2\">`int64`</ph>.","source":"Loads the element with type `int64` at a specified array index onto the top of the evaluation stack as an `int64`."}],"pos":[395049,395164],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|96|ldelem.i8|Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.i8` is `int64`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"96","nodes":[{"content":"96","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.i8","nodes":[{"content":"ldelem.i8","pos":[0,9]}]},{"pos":[269,356],"content":"Loads the element with type <ph id=\"ph1\">`int64`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as an <ph id=\"ph3\">`int64`</ph>.","source":"Loads the element with type `int64` at `index` onto the top of the stack as an `int64`."},{"pos":[364,421],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[431,484],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[494,542],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[552,660],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[670,705],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[712,961],"content":"The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.i8`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[968,1012],"content":"The return value for <ph id=\"ph1\">`ldelem.i8`</ph> is <ph id=\"ph2\">`int64`</ph>.","source":"The return value for `ldelem.i8` is `int64`."},{"pos":[1019,1155],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1162,1240],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1247,1353],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1360,1469],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1476,1587],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.i8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:"},{"pos":[1597,1621],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[395175,396829],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `float32` at a specified array index onto the top of the evaluation stack as type `F` (float).","nodes":[{"pos":[0,122],"content":"Loads the element with type <ph id=\"ph1\">`float32`</ph> at a specified array index onto the top of the evaluation stack as type <ph id=\"ph2\">`F`</ph> (float).","source":"Loads the element with type `float32` at a specified array index onto the top of the evaluation stack as type `F` (float)."}],"pos":[398440,398563],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|98|ldelem.r4|Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.r4` is `float32`.  \n  \n Floating-point values are converted to type `F` when loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"98","nodes":[{"content":"98","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.r4","nodes":[{"content":"ldelem.r4","pos":[0,9]}]},{"pos":[269,358],"content":"Loads the element with type <ph id=\"ph1\">`float32`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as a type <ph id=\"ph3\">`F`</ph>.","source":"Loads the element with type `float32` at `index` onto the top of the stack as a type `F`."},{"pos":[366,423],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[433,486],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[496,544],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[554,662],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[672,707],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[714,963],"content":"The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.r4`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[970,1016],"content":"The return value for <ph id=\"ph1\">`ldelem.r4`</ph> is <ph id=\"ph2\">`float32`</ph>.","source":"The return value for `ldelem.r4` is `float32`."},{"pos":[1023,1109],"content":"Floating-point values are converted to type <ph id=\"ph1\">`F`</ph> when loaded onto the evaluation stack.","source":"Floating-point values are converted to type `F` when loaded onto the evaluation stack."},{"pos":[1116,1194],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1201,1307],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1314,1423],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1430,1541],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.r4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:"},{"pos":[1551,1575],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[398574,400182],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `float64` at a specified array index onto the top of the evaluation stack as type `F` (float).","nodes":[{"pos":[0,122],"content":"Loads the element with type <ph id=\"ph1\">`float64`</ph> at a specified array index onto the top of the evaluation stack as type <ph id=\"ph2\">`F`</ph> (float).","source":"Loads the element with type `float64` at a specified array index onto the top of the evaluation stack as type `F` (float)."}],"pos":[401793,401916],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|99|ldelem.r8|Loads the element with type `float64` at `index` onto the top of the stack as type `F`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.r8` is `float64`.  \n  \n Floating-point values are converted to type `F` when loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"99","nodes":[{"content":"99","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.r8","nodes":[{"content":"ldelem.r8","pos":[0,9]}]},{"pos":[269,356],"content":"Loads the element with type <ph id=\"ph1\">`float64`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as type <ph id=\"ph3\">`F`</ph>.","source":"Loads the element with type `float64` at `index` onto the top of the stack as type `F`."},{"pos":[364,421],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[431,484],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[494,542],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[552,660],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[670,705],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[712,961],"content":"The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.r8`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[968,1014],"content":"The return value for <ph id=\"ph1\">`ldelem.r8`</ph> is <ph id=\"ph2\">`float64`</ph>.","source":"The return value for `ldelem.r8` is `float64`."},{"pos":[1021,1107],"content":"Floating-point values are converted to type <ph id=\"ph1\">`F`</ph> when loaded onto the evaluation stack.","source":"Floating-point values are converted to type `F` when loaded onto the evaluation stack."},{"pos":[1114,1192],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1199,1305],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1312,1421],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1428,1539],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.r8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:"},{"pos":[1549,1573],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[401927,403533],"yaml":true,"extradata":"MT"},{"content":"Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type `O` (object reference).","nodes":[{"pos":[0,144],"content":"Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <ph id=\"ph1\">`O`</ph> (object reference).","source":"Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type `O` (object reference)."}],"pos":[405150,405295],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|9A|ldelem.ref|Loads the element with an object reference at `index` onto the top of the stack as type `O`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.ref` is type `O` (object reference).  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"9A","nodes":[{"content":"9A","pos":[0,2]}]},{"pos":[259,269],"content":"ldelem.ref","nodes":[{"content":"ldelem.ref","pos":[0,10]}]},{"pos":[270,362],"content":"Loads the element with an object reference at <ph id=\"ph1\">`index`</ph> onto the top of the stack as type <ph id=\"ph2\">`O`</ph>.","source":"Loads the element with an object reference at `index` onto the top of the stack as type `O`."},{"pos":[370,427],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[437,490],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[500,548],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[558,666],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[676,711],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[718,968],"content":"The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.ref`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,185],"source":"The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[186,250],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[975,1040],"content":"The return value for <ph id=\"ph1\">`ldelem.ref`</ph> is type <ph id=\"ph2\">`O`</ph> (object reference).","source":"The return value for `ldelem.ref` is type `O` (object reference)."},{"pos":[1047,1125],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1132,1238],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1245,1354],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1361,1473],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.ref`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:"},{"pos":[1483,1507],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[405306,406844],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `unsigned int8` at a specified array index onto the top of the evaluation stack as an `int32`.","nodes":[{"pos":[0,122],"content":"Loads the element with type <ph id=\"ph1\">`unsigned int8`</ph> at a specified array index onto the top of the evaluation stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `unsigned int8` at a specified array index onto the top of the evaluation stack as an `int32`."}],"pos":[408456,408579],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|91|ldelem.u1|Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.u1` is `int8`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"91","nodes":[{"content":"91","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.u1","nodes":[{"content":"ldelem.u1","pos":[0,9]}]},{"pos":[269,364],"content":"Loads the element with type <ph id=\"ph1\">`unsigned int8`</ph> at <ph id=\"ph2\">`index`</ph> onto the top of the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`."},{"pos":[372,429],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[439,492],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[502,550],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[560,668],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[678,713],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[720,969],"content":"The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.u1`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[976,1019],"content":"The return value for <ph id=\"ph1\">`ldelem.u1`</ph> is <ph id=\"ph2\">`int8`</ph>.","source":"The return value for `ldelem.u1` is `int8`."},{"pos":[1026,1162],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1169,1247],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1254,1360],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1367,1476],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1483,1594],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.u1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:"},{"pos":[1604,1628],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[408590,410251],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `unsigned int16` at a specified array index onto the top of the evaluation stack as an `int32`.","nodes":[{"pos":[0,123],"content":"Loads the element with type <ph id=\"ph1\">`unsigned int16`</ph> at a specified array index onto the top of the evaluation stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `unsigned int16` at a specified array index onto the top of the evaluation stack as an `int32`."}],"pos":[411862,411986],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|93|ldelem.u2|Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.u2` is `int16`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"93","nodes":[{"content":"93","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.u2","nodes":[{"content":"ldelem.u2","pos":[0,9]}]},{"pos":[269,363],"content":"Loads the element with type <ph id=\"ph1\">`unsigned int16`</ph> at index onto the top of the stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`."},{"pos":[371,428],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[438,491],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[501,549],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[559,667],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[677,712],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[719,968],"content":"The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.u2`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[975,1019],"content":"The return value for <ph id=\"ph1\">`ldelem.u2`</ph> is <ph id=\"ph2\">`int16`</ph>.","source":"The return value for `ldelem.u2` is `int16`."},{"pos":[1026,1162],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1169,1247],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1254,1360],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1367,1476],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1483,1594],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.u2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:"},{"pos":[1604,1628],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[411997,413658],"yaml":true,"extradata":"MT"},{"content":"Loads the element with type `unsigned int32` at a specified array index onto the top of the evaluation stack as an `int32`.","nodes":[{"pos":[0,123],"content":"Loads the element with type <ph id=\"ph1\">`unsigned int32`</ph> at a specified array index onto the top of the evaluation stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `unsigned int32` at a specified array index onto the top of the evaluation stack as an `int32`."}],"pos":[415269,415393],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|95|ldelem.u4|Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \n  \n4.  The value is pushed onto the stack.  \n  \n The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \n  \n The return value for `ldelem.u4` is `int32`.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"95","nodes":[{"content":"95","pos":[0,2]}]},{"pos":[259,268],"content":"ldelem.u4","nodes":[{"content":"ldelem.u4","pos":[0,9]}]},{"pos":[269,363],"content":"Loads the element with type <ph id=\"ph1\">`unsigned int32`</ph> at index onto the top of the stack as an <ph id=\"ph2\">`int32`</ph>.","source":"Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`."},{"pos":[371,428],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[438,491],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[501,549],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[559,667],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the value stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up."},{"pos":[677,712],"content":"The value is pushed onto the stack.","nodes":[{"content":"The value is pushed onto the stack.","pos":[0,35]}]},{"pos":[719,968],"content":"The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.","nodes":[{"content":"The <ph id=\"ph1\">`ldelem.u4`</ph> instruction loads the value of the element with index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[0,184],"source":"The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[185,249],"source":" Arrays are objects and hence represented by a value of type `O`."}]},{"pos":[975,1019],"content":"The return value for <ph id=\"ph1\">`ldelem.u4`</ph> is <ph id=\"ph2\">`int32`</ph>.","source":"The return value for `ldelem.u4` is `int32`."},{"pos":[1026,1162],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1169,1247],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1254,1358],"content":"<xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if array does not hold elements of the required type.","pos":[0,104],"source":"<xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type."}]},{"pos":[1365,1474],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1481,1592],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelem.u4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:"},{"pos":[1602,1626],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[415404,417063],"yaml":true,"extradata":"MT"},{"content":"Loads the address of the array element at a specified array index onto the top of the evaluation stack as type `&` (managed pointer).","nodes":[{"pos":[0,133],"content":"Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <ph id=\"ph1\">`&amp;`</ph> (managed pointer).","source":"Loads the address of the array element at a specified array index onto the top of the evaluation stack as type `&` (managed pointer)."}],"pos":[418662,418796],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|8F < `T` >|ldelema `class`|Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `array` is pushed onto the stack.  \n  \n2.  An index value `index` is pushed onto the stack.  \n  \n3.  `index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.  \n  \n4.  The address is pushed onto the stack.  \n  \n The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`). The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`. The value must be of type `class` passed with the instruction.  \n  \n The return value for `ldelema` is a managed pointer (type `&`).  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"8F &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"8F < `T` >"},{"pos":[267,282],"content":"ldelema <ph id=\"ph1\">`class`</ph>","source":"ldelema `class`"},{"pos":[283,400],"content":"Loads the address of the array element at <ph id=\"ph1\">`index`</ph> onto the top of the evaluation stack as type <ph id=\"ph2\">`&amp;`</ph> (managed pointer).","source":"Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer)."},{"pos":[408,465],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[475,528],"content":"An object reference <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"An object reference `array` is pushed onto the stack."},{"pos":[538,586],"content":"An index value <ph id=\"ph1\">`index`</ph> is pushed onto the stack.","source":"An index value `index` is pushed onto the stack."},{"pos":[596,706],"content":"<ph id=\"ph1\">`index`</ph> and <ph id=\"ph2\">`array`</ph> are popped from the stack; the address stored at position <ph id=\"ph3\">`index`</ph> in <ph id=\"ph4\">`array`</ph> is looked up.","source":"`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up."},{"pos":[716,753],"content":"The address is pushed onto the stack.","nodes":[{"content":"The address is pushed onto the stack.","pos":[0,37]}]},{"pos":[760,1191],"content":"The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`). The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`. The value must be of type `class` passed with the instruction.","nodes":[{"content":"The <ph id=\"ph1\">`ldelema`</ph> is used to retrieve the address of an object at a particular index in an array of objects (of type <ph id=\"ph2\">`class`</ph>).","pos":[0,122],"source":"The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`)."},{"content":"The <ph id=\"ph1\">`ldelema`</ph> instruction loads the address of the value at index <ph id=\"ph2\">`index`</ph> (type <ph id=\"ph3\">`native int`</ph>) in the zero-based one-dimensional array <ph id=\"ph4\">`array`</ph> and places it on the top of the stack.","pos":[123,303],"source":" The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack."},{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[304,368],"source":" Arrays are objects and hence represented by a value of type `O`."},{"content":"The value must be of type <ph id=\"ph1\">`class`</ph> passed with the instruction.","pos":[369,431],"source":" The value must be of type `class` passed with the instruction."}]},{"pos":[1198,1261],"content":"The return value for <ph id=\"ph1\">`ldelema`</ph> is a managed pointer (type <ph id=\"ph2\">`&amp;`</ph>).","source":"The return value for `ldelema` is a managed pointer (type `&`)."},{"pos":[1268,1404],"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"pos":[1411,1489],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1496,1602],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1609,1718],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1725,1834],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldelema`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:"},{"pos":[1844,1874],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[418807,420714],"yaml":true,"extradata":"MT"},{"content":"Finds the value of a field in the object whose reference is currently on the evaluation stack.","nodes":[{"pos":[0,94],"content":"Finds the value of a field in the object whose reference is currently on the evaluation stack.","nodes":[{"content":"Finds the value of a field in the object whose reference is currently on the evaluation stack.","pos":[0,94]}]}],"pos":[422299,422394],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|7B < `T` >|ldfld `field`|Pushes the value of a field in a specified object onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference (or pointer) is pushed onto the stack.  \n  \n2.  The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.  \n  \n3.  The value stored in the field is pushed onto the stack.  \n  \n The `ldfld` instruction pushes the value of a field located in an object onto the stack. The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member. The return type is the same as the one associated with the field. The field may be either an instance field (in which case the object must not be a null reference) or a static field.  \n  \n The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.  \n  \n <xref:System.NullReferenceException> is thrown if the object is null and the field is not static.  \n  \n <xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:  \n  \n-   ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"7B &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"7B < `T` >"},{"pos":[267,280],"content":"ldfld <ph id=\"ph1\">`field`</ph>","source":"ldfld `field`"},{"pos":[281,346],"content":"Pushes the value of a field in a specified object onto the stack.","nodes":[{"content":"Pushes the value of a field in a specified object onto the stack.","pos":[0,65]}]},{"pos":[354,411],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[421,479],"content":"An object reference (or pointer) is pushed onto the stack.","nodes":[{"content":"An object reference (or pointer) is pushed onto the stack.","pos":[0,58]}]},{"pos":[489,605],"content":"The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.","nodes":[{"content":"The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.","pos":[0,116]}]},{"pos":[615,670],"content":"The value stored in the field is pushed onto the stack.","nodes":[{"content":"The value stored in the field is pushed onto the stack.","pos":[0,55]}]},{"pos":[677,1307],"content":"The `ldfld` instruction pushes the value of a field located in an object onto the stack. The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member. The return type is the same as the one associated with the field. The field may be either an instance field (in which case the object must not be a null reference) or a static field.","nodes":[{"content":"The <ph id=\"ph1\">`ldfld`</ph> instruction pushes the value of a field located in an object onto the stack.","pos":[0,88],"source":"The `ldfld` instruction pushes the value of a field located in an object onto the stack."},{"content":"The object must be on the stack as an object reference (type <ph id=\"ph1\">`O`</ph>), a managed pointer (type <ph id=\"ph2\">`&amp;`</ph>), an unmanaged pointer (type <ph id=\"ph3\">`native int`</ph>), a transient pointer (type <ph id=\"ph4\">`*`</ph>), or an instance of a value type.","pos":[89,291],"source":" The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type."},{"content":"The use of an unmanaged pointer is not permitted in verifiable code.","pos":[292,360]},{"content":"The object's field is specified by a metadata token that must refer to a field member.","pos":[361,447]},{"content":"The return type is the same as the one associated with the field.","pos":[448,513]},{"content":"The field may be either an instance field (in which case the object must not be a null reference) or a static field.","pos":[514,630]}]},{"pos":[1314,1487],"content":"The <ph id=\"ph1\">`ldfld`</ph> instruction can be preceded by either or both of the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.","source":"The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes."},{"pos":[1494,1591],"content":"<xref:System.NullReferenceException> is thrown if the object is null and the field is not static.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.","pos":[0,97],"source":"<xref:System.NullReferenceException> is thrown if the object is null and the field is not static."}]},{"pos":[1598,1826],"content":"<xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","nodes":[{"content":"<xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","pos":[0,228],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.","pos":[0,98],"source":"<xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata."},{"content":"This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","pos":[99,228]}]}]},{"pos":[1833,1940],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldfld`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:"},{"pos":[1950,1985],"content":"ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, FieldInfo)","pos":[0,35]}]}],"pos":[422405,424417],"yaml":true,"extradata":"MT"},{"content":"Finds the address of a field in the object whose reference is currently on the evaluation stack.","nodes":[{"pos":[0,96],"content":"Finds the address of a field in the object whose reference is currently on the evaluation stack.","nodes":[{"content":"Finds the address of a field in the object whose reference is currently on the evaluation stack.","pos":[0,96]}]}],"pos":[426006,426103],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|7C < `T` >|ldflda `field`|Pushes the address of `field` in a specified object onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference (or pointer) is pushed onto the stack.  \n  \n2.  The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.  \n  \n3.  The address of the specified field is pushed onto the stack.  \n  \n The `ldflda` instruction pushes the address of a field located in an object onto the stack. The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member.  \n  \n The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).  \n  \n The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.  \n  \n <xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed. The address of a field that is not inside the accessing application domain cannot be loaded.  \n  \n <xref:System.NullReferenceException> is thrown if the object is null and the field is not static.  \n  \n <xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:  \n  \n-   ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"7C &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"7C < `T` >"},{"pos":[267,281],"content":"ldflda <ph id=\"ph1\">`field`</ph>","source":"ldflda `field`"},{"pos":[282,349],"content":"Pushes the address of <ph id=\"ph1\">`field`</ph> in a specified object onto the stack.","source":"Pushes the address of `field` in a specified object onto the stack."},{"pos":[357,414],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[424,482],"content":"An object reference (or pointer) is pushed onto the stack.","nodes":[{"content":"An object reference (or pointer) is pushed onto the stack.","pos":[0,58]}]},{"pos":[492,610],"content":"The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.","nodes":[{"content":"The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.","pos":[0,118]}]},{"pos":[620,680],"content":"The address of the specified field is pushed onto the stack.","nodes":[{"content":"The address of the specified field is pushed onto the stack.","pos":[0,60]}]},{"pos":[687,1137],"content":"The `ldflda` instruction pushes the address of a field located in an object onto the stack. The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member.","nodes":[{"content":"The <ph id=\"ph1\">`ldflda`</ph> instruction pushes the address of a field located in an object onto the stack.","pos":[0,91],"source":"The `ldflda` instruction pushes the address of a field located in an object onto the stack."},{"content":"The object must be on the stack as an object reference (type <ph id=\"ph1\">`O`</ph>), a managed pointer (type <ph id=\"ph2\">`&amp;`</ph>), an unmanaged pointer (type <ph id=\"ph3\">`native int`</ph>), a transient pointer (type <ph id=\"ph4\">`*`</ph>), or an instance of a value type.","pos":[92,294],"source":" The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type."},{"content":"The use of an unmanaged pointer is not permitted in verifiable code.","pos":[295,363]},{"content":"The object's field is specified by a metadata token that must refer to a field member.","pos":[364,450]}]},{"pos":[1144,1357],"content":"The value returned by <ph id=\"ph1\">`ldflda`</ph> is a managed pointer (type <ph id=\"ph2\">`&amp;`</ph>) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type <ph id=\"ph3\">`native int`</ph>).","source":"The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`)."},{"pos":[1364,1538],"content":"The <ph id=\"ph1\">`ldflda`</ph> instruction can be preceded by either or both of the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.","source":"The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes."},{"pos":[1545,1771],"content":"<xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed. The address of a field that is not inside the accessing application domain cannot be loaded.","nodes":[{"content":"<xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed. The address of a field that is not inside the accessing application domain cannot be loaded.","pos":[0,226],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown if the object is not within the application domain from which it is being accessed.","pos":[0,133],"source":"<xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed."},{"content":"The address of a field that is not inside the accessing application domain cannot be loaded.","pos":[134,226]}]}]},{"pos":[1778,1875],"content":"<xref:System.NullReferenceException> is thrown if the object is null and the field is not static.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.","pos":[0,97],"source":"<xref:System.NullReferenceException> is thrown if the object is null and the field is not static."}]},{"pos":[1882,2110],"content":"<xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","nodes":[{"content":"<xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","pos":[0,228],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.","pos":[0,98],"source":"<xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata."},{"content":"This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","pos":[99,228]}]}]},{"pos":[2117,2225],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldflda`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:"},{"pos":[2235,2270],"content":"ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, FieldInfo)","pos":[0,35]}]}],"pos":[426114,428415],"yaml":true,"extradata":"MT"},{"content":"Pushes an unmanaged pointer (type `native int`) to the native code implementing a specific method onto the evaluation stack.","nodes":[{"pos":[0,124],"content":"Pushes an unmanaged pointer (type <ph id=\"ph1\">`native int`</ph>) to the native code implementing a specific method onto the evaluation stack.","source":"Pushes an unmanaged pointer (type `native int`) to the native code implementing a specific method onto the evaluation stack."}],"pos":[429999,430124],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 06 < `T` >|ldftn `method`|Pushes a pointer to a method referenced by `method` on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The unmanaged pointer to a specific method is pushed onto the stack.  \n  \n The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).  \n  \n The value returned points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:  \n  \n-   ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"FE 06 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 06 < `T` >"},{"pos":[270,284],"content":"ldftn <ph id=\"ph1\">`method`</ph>","source":"ldftn `method`"},{"pos":[285,350],"content":"Pushes a pointer to a method referenced by <ph id=\"ph1\">`method`</ph> on the stack.","source":"Pushes a pointer to a method referenced by `method` on the stack."},{"pos":[358,415],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[425,493],"content":"The unmanaged pointer to a specific method is pushed onto the stack.","nodes":[{"content":"The unmanaged pointer to a specific method is pushed onto the stack.","pos":[0,68]}]},{"pos":[500,705],"content":"The specific method (<ph id=\"ph1\">`method`</ph>) can be called using the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).","source":"The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code)."},{"pos":[712,875],"content":"The value returned points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.","nodes":[{"content":"The value returned points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.","pos":[0,163],"nodes":[{"content":"The value returned points to native code using the CLR calling convention.","pos":[0,74]},{"content":"This method pointer should not be passed to unmanaged native code as a callback routine.","pos":[75,163]}]}]},{"pos":[882,989],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldftn`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:"},{"pos":[999,1035],"content":"ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, MethodInfo)","pos":[0,36]}]}],"pos":[430135,431189],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `native int` as a `native int` onto the evaluation stack indirectly.","nodes":[{"pos":[0,90],"content":"Loads a value of type <ph id=\"ph1\">`native int`</ph> as a <ph id=\"ph2\">`native int`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `native int` as a `native int` onto the evaluation stack indirectly."}],"pos":[432784,432875],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|4D|ldind.i|Loads the `native int` value at address `addr` onto the stack as a `native int`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or *) onto the stack as a `native int`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"4D","nodes":[{"content":"4D","pos":[0,2]}]},{"pos":[259,266],"content":"ldind.i","nodes":[{"content":"ldind.i","pos":[0,7]}]},{"pos":[267,347],"content":"Loads the <ph id=\"ph1\">`native int`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as a <ph id=\"ph3\">`native int`</ph>.","source":"Loads the `native int` value at address `addr` onto the stack as a `native int`."},{"pos":[355,412],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[422,458],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[468,550],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[560,603],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[610,768],"content":"The <ph id=\"ph1\">`ldind.i`</ph> instruction indirectly loads a <ph id=\"ph2\">`native int`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as a <ph id=\"ph5\">`native int`</ph>.","source":"The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or *) onto the stack as a `native int`."},{"pos":[775,937],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[944,1167],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1174,1329],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1336,1936],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1943,2028],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2035,2144],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.i`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:"},{"pos":[2154,2178],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[432886,435095],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `int8` as an `int32` onto the evaluation stack indirectly.","nodes":[{"pos":[0,80],"content":"Loads a value of type <ph id=\"ph1\">`int8`</ph> as an <ph id=\"ph2\">`int32`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `int8` as an `int32` onto the evaluation stack indirectly."}],"pos":[436698,436779],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|46|ldind.i1|Loads the `int8` value at address `addr` onto the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack..  \n  \n The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"46","nodes":[{"content":"46","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.i1","nodes":[{"content":"ldind.i1","pos":[0,8]}]},{"pos":[268,338],"content":"Loads the <ph id=\"ph1\">`int8`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the `int8` value at address `addr` onto the stack as an `int32`."},{"pos":[346,403],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[413,449],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[459,541],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[551,595],"content":"The fetched value is pushed onto the stack..","nodes":[{"content":"The fetched value is pushed onto the stack..","pos":[0,44]}]},{"pos":[602,752],"content":"The <ph id=\"ph1\">`ldind.i1`</ph> instruction indirectly loads an <ph id=\"ph2\">`int8`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as an <ph id=\"ph5\">`int32`</ph>.","source":"The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`."},{"pos":[759,921],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[928,1151],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1158,1313],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1320,1920],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1927,2012],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2019,2129],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.i1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:"},{"pos":[2139,2163],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[436790,438984],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `int16` as an `int32` onto the evaluation stack indirectly.","nodes":[{"pos":[0,81],"content":"Loads a value of type <ph id=\"ph1\">`int16`</ph> as an <ph id=\"ph2\">`int32`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `int16` as an `int32` onto the evaluation stack indirectly."}],"pos":[440588,440670],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|48|ldind.i2|Loads the `int16` value at address `addr` onto the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca>and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"48","nodes":[{"content":"48","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.i2","nodes":[{"content":"ldind.i2","pos":[0,8]}]},{"pos":[268,339],"content":"Loads the <ph id=\"ph1\">`int16`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the `int16` value at address `addr` onto the stack as an `int32`."},{"pos":[347,404],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[414,450],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[460,542],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[552,595],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[602,753],"content":"The <ph id=\"ph1\">`ldind.i2`</ph> instruction indirectly loads an <ph id=\"ph2\">`int16`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as an <ph id=\"ph5\">`int32`</ph>.","source":"The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`."},{"pos":[760,922],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[929,1152],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1159,1314],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1321,1920],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca>and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca>and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,599],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,448],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca>and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[449,532]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[533,599]}]}]},{"pos":[1927,2012],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2019,2129],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.i2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:"},{"pos":[2139,2163],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[440681,442875],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `int32` as an `int32` onto the evaluation stack indirectly.","nodes":[{"pos":[0,81],"content":"Loads a value of type <ph id=\"ph1\">`int32`</ph> as an <ph id=\"ph2\">`int32`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `int32` as an `int32` onto the evaluation stack indirectly."}],"pos":[444479,444561],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|4A|ldind.i4|Loads the `int32` value at address `addr` onto the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"4A","nodes":[{"content":"4A","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.i4","nodes":[{"content":"ldind.i4","pos":[0,8]}]},{"pos":[268,339],"content":"Loads the <ph id=\"ph1\">`int32`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the `int32` value at address `addr` onto the stack as an `int32`."},{"pos":[347,404],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[414,450],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[460,542],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[552,595],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[602,753],"content":"The <ph id=\"ph1\">`ldind.i4`</ph> instruction indirectly loads an <ph id=\"ph2\">`int32`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as an <ph id=\"ph5\">`int32`</ph>.","source":"The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`."},{"pos":[760,922],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[929,1152],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1159,1314],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1321,1921],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1928,2013],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2020,2130],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.i4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:"},{"pos":[2140,2164],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[444572,446767],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `int64` as an `int64` onto the evaluation stack indirectly.","nodes":[{"pos":[0,81],"content":"Loads a value of type <ph id=\"ph1\">`int64`</ph> as an <ph id=\"ph2\">`int64`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `int64` as an `int64` onto the evaluation stack indirectly."}],"pos":[448371,448453],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|4C|ldind.i8|Loads the `int64` value at address `addr` onto the stack as an `int64`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int64`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"4C","nodes":[{"content":"4C","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.i8","nodes":[{"content":"ldind.i8","pos":[0,8]}]},{"pos":[268,339],"content":"Loads the <ph id=\"ph1\">`int64`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as an <ph id=\"ph3\">`int64`</ph>.","source":"Loads the `int64` value at address `addr` onto the stack as an `int64`."},{"pos":[347,404],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[414,450],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[460,542],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[552,595],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[602,753],"content":"The <ph id=\"ph1\">`ldind.i8`</ph> instruction indirectly loads an <ph id=\"ph2\">`int64`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as an <ph id=\"ph5\">`int64`</ph>.","source":"The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int64`."},{"pos":[760,922],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[929,1152],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1159,1314],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1321,1921],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1928,2013],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2020,2130],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.i8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:"},{"pos":[2140,2164],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[448464,450659],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `float32` as a type `F` (float) onto the evaluation stack indirectly.","nodes":[{"pos":[0,91],"content":"Loads a value of type <ph id=\"ph1\">`float32`</ph> as a type <ph id=\"ph2\">`F`</ph> (float) onto the evaluation stack indirectly.","source":"Loads a value of type `float32` as a type `F` (float) onto the evaluation stack indirectly."}],"pos":[452263,452355],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|4E|ldind.r4|Loads the `float32` value at address `addr` onto the stack as a type `F`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or *) onto the stack as a type `F`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"4E","nodes":[{"content":"4E","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.r4","nodes":[{"content":"ldind.r4","pos":[0,8]}]},{"pos":[268,341],"content":"Loads the <ph id=\"ph1\">`float32`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as a type <ph id=\"ph3\">`F`</ph>.","source":"Loads the `float32` value at address `addr` onto the stack as a type `F`."},{"pos":[349,406],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[416,452],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[462,544],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[554,597],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[604,756],"content":"The <ph id=\"ph1\">`ldind.r4`</ph> instruction indirectly loads a <ph id=\"ph2\">`float32`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as a type <ph id=\"ph5\">`F`</ph>.","source":"The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or *) onto the stack as a type `F`."},{"pos":[763,925],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[932,1155],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1162,1317],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1324,1924],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1931,2016],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2023,2133],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.r4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:"},{"pos":[2143,2167],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[452366,454564],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `float64` as a type `F` (float) onto the evaluation stack indirectly.","nodes":[{"pos":[0,91],"content":"Loads a value of type <ph id=\"ph1\">`float64`</ph> as a type <ph id=\"ph2\">`F`</ph> (float) onto the evaluation stack indirectly.","source":"Loads a value of type `float64` as a type `F` (float) onto the evaluation stack indirectly."}],"pos":[456168,456260],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|4F|ldind.r8|Loads the `float64` value at address `addr` onto the stack as a type `F`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or *) onto the stack as a `float64`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"4F","nodes":[{"content":"4F","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.r8","nodes":[{"content":"ldind.r8","pos":[0,8]}]},{"pos":[268,341],"content":"Loads the <ph id=\"ph1\">`float64`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as a type <ph id=\"ph3\">`F`</ph>.","source":"Loads the `float64` value at address `addr` onto the stack as a type `F`."},{"pos":[349,406],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[416,452],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[462,544],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[554,597],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[604,757],"content":"The <ph id=\"ph1\">`ldind.r8`</ph> instruction indirectly loads a <ph id=\"ph2\">`float64`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as a <ph id=\"ph5\">`float64`</ph>.","source":"The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or *) onto the stack as a `float64`."},{"pos":[764,926],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[933,1156],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1163,1318],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1325,1925],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1932,2017],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2024,2134],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.r8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:"},{"pos":[2144,2168],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[456271,458470],"yaml":true,"extradata":"MT"},{"content":"Loads an object reference as a type `O` (object reference) onto the evaluation stack indirectly.","nodes":[{"pos":[0,96],"content":"Loads an object reference as a type <ph id=\"ph1\">`O`</ph> (object reference) onto the evaluation stack indirectly.","source":"Loads an object reference as a type `O` (object reference) onto the evaluation stack indirectly."}],"pos":[460080,460177],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|50|ldind.ref|Loads the object reference at address `addr` onto the stack as a type `O`|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the object reference located at the address is fetched.  \n  \n3.  The fetched reference is pushed onto the stack.  \n  \n The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or *) onto the stack as type `O`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"50","nodes":[{"content":"50","pos":[0,2]}]},{"pos":[259,268],"content":"ldind.ref","nodes":[{"content":"ldind.ref","pos":[0,9]}]},{"pos":[269,342],"content":"Loads the object reference at address <ph id=\"ph1\">`addr`</ph> onto the stack as a type <ph id=\"ph2\">`O`</ph>","source":"Loads the object reference at address `addr` onto the stack as a type `O`"},{"pos":[350,407],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[417,453],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[463,556],"content":"The address is popped from the stack; the object reference located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the object reference located at the address is fetched.","pos":[0,93]}]},{"pos":[566,613],"content":"The fetched reference is pushed onto the stack.","nodes":[{"content":"The fetched reference is pushed onto the stack.","pos":[0,47]}]},{"pos":[620,769],"content":"The <ph id=\"ph1\">`ldind.ref`</ph> instruction indirectly loads the object reference the specified address (of type <ph id=\"ph2\">`native int`</ph>, <ph id=\"ph3\">`&amp;`</ph>, or *) onto the stack as type <ph id=\"ph4\">`O`</ph>.","source":"The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or *) onto the stack as type `O`."},{"pos":[776,938],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[945,1168],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1175,1330],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1337,1937],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1944,2029],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2036,2147],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.ref`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:"},{"pos":[2157,2181],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[460188,462400],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `unsigned int8` as an `int32` onto the evaluation stack indirectly.","nodes":[{"pos":[0,89],"content":"Loads a value of type <ph id=\"ph1\">`unsigned int8`</ph> as an <ph id=\"ph2\">`int32`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `unsigned int8` as an `int32` onto the evaluation stack indirectly."}],"pos":[464005,464095],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|47|ldind.u1|Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or *) onto the stack as an `int32`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"47","nodes":[{"content":"47","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.u1","nodes":[{"content":"ldind.u1","pos":[0,8]}]},{"pos":[268,347],"content":"Loads the <ph id=\"ph1\">`unsigned int8`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`."},{"pos":[355,412],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[422,458],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[468,550],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[560,603],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[610,768],"content":"The <ph id=\"ph1\">`ldind.u1`</ph> instruction indirectly loads an <ph id=\"ph2\">`unsigned int8`</ph> value from the specified address (of type<ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as an <ph id=\"ph5\">`int32`</ph>.","source":"The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or *) onto the stack as an `int32`."},{"pos":[775,937],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[944,1167],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1174,1329],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1336,1936],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1943,2028],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2035,2145],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.u1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:"},{"pos":[2155,2179],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[464106,466316],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `unsigned int16` as an `int32` onto the evaluation stack indirectly.","nodes":[{"pos":[0,90],"content":"Loads a value of type <ph id=\"ph1\">`unsigned int16`</ph> as an <ph id=\"ph2\">`int32`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `unsigned int16` as an `int32` onto the evaluation stack indirectly."}],"pos":[467920,468011],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|49|ldind.u2|Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"49","nodes":[{"content":"49","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.u2","nodes":[{"content":"ldind.u2","pos":[0,8]}]},{"pos":[268,348],"content":"Loads the <ph id=\"ph1\">`unsigned int16`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`."},{"pos":[356,413],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[423,459],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[469,551],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[561,604],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[611,771],"content":"The <ph id=\"ph1\">`ldind.u2`</ph> instruction indirectly loads an <ph id=\"ph2\">`unsigned int16`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as an <ph id=\"ph5\">`int32`</ph>.","source":"The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`."},{"pos":[778,940],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[947,1170],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1177,1332],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1339,1939],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1946,2031],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2038,2148],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.u2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:"},{"pos":[2158,2182],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[468022,470235],"yaml":true,"extradata":"MT"},{"content":"Loads a value of type `unsigned int32` as an `int32` onto the evaluation stack indirectly.","nodes":[{"pos":[0,90],"content":"Loads a value of type <ph id=\"ph1\">`unsigned int32`</ph> as an <ph id=\"ph2\">`int32`</ph> onto the evaluation stack indirectly.","source":"Loads a value of type `unsigned int32` as an `int32` onto the evaluation stack indirectly."}],"pos":[471839,471930],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|4B|ldind.u4|Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  The address is popped from the stack; the value located at the address is fetched.  \n  \n3.  The fetched value is pushed onto the stack.  \n  \n The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \n  \n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \n  \n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \n  \n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \n  \n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \n  \n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"4B","nodes":[{"content":"4B","pos":[0,2]}]},{"pos":[259,267],"content":"ldind.u4","nodes":[{"content":"ldind.u4","pos":[0,8]}]},{"pos":[268,348],"content":"Loads the <ph id=\"ph1\">`unsigned int32`</ph> value at address <ph id=\"ph2\">`addr`</ph> onto the stack as an <ph id=\"ph3\">`int32`</ph>.","source":"Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`."},{"pos":[356,413],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[423,459],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[469,551],"content":"The address is popped from the stack; the value located at the address is fetched.","nodes":[{"content":"The address is popped from the stack; the value located at the address is fetched.","pos":[0,82]}]},{"pos":[561,604],"content":"The fetched value is pushed onto the stack.","nodes":[{"content":"The fetched value is pushed onto the stack.","pos":[0,43]}]},{"pos":[611,771],"content":"The <ph id=\"ph1\">`ldind.u4`</ph> instruction indirectly loads an <ph id=\"ph2\">`unsigned int32`</ph> value from the specified address (of type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or *) onto the stack as an <ph id=\"ph5\">`int32`</ph>.","source":"The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`."},{"pos":[778,940],"content":"All of the <ph id=\"ph1\">`ldind`</ph> instructions are shortcuts for a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.","source":"All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class."},{"pos":[947,1170],"content":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.","nodes":[{"content":"Note that integer values of less than 4 bytes are extended to <ph id=\"ph1\">`int32`</ph> (not <ph id=\"ph2\">`native int`</ph>) when they are loaded onto the evaluation stack.","pos":[0,136],"source":"Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack."},{"content":"Floating-point values are converted to <ph id=\"ph1\">`F`</ph> type when loaded onto the evaluation stack.","pos":[137,223],"source":" Floating-point values are converted to `F` type when loaded onto the evaluation stack."}]},{"pos":[1177,1332],"content":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id=\"ph1\">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.","source":"Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer."},{"pos":[1339,1939],"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.","pos":[0,600],"nodes":[{"content":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).","pos":[0,261],"source":"The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures)."},{"content":"The results of all MSIL instructions that return addresses (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.","pos":[262,449],"source":" The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned."},{"content":"For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.","pos":[450,533]},{"content":"Code that depends on byte ordering might not run on all platforms.","pos":[534,600]}]}]},{"pos":[1946,2031],"content":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.","pos":[0,85],"source":"<xref:System.NullReferenceException> can be thrown if an invalid address is detected."}]},{"pos":[2038,2148],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldind.u4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:"},{"pos":[2158,2182],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[471941,474154],"yaml":true,"extradata":"MT"},{"content":"Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.","nodes":[{"pos":[0,95],"content":"Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.","nodes":[{"content":"Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.","pos":[0,95]}]}],"pos":[475740,475836],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|8E|ldlen|Pushes the length (of type `natural unsigned int`) of an array on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array is pushed onto the stack.  \n  \n2.  The array reference is popped from the stack and the length is computed.  \n  \n3.  The length is pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The length is returned as a `natural unsigned int`.  \n  \n <xref:System.NullReferenceException> is thrown if the array reference is a null reference.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"8E","nodes":[{"content":"8E","pos":[0,2]}]},{"pos":[259,264],"content":"ldlen","nodes":[{"content":"ldlen","pos":[0,5]}]},{"pos":[265,341],"content":"Pushes the length (of type <ph id=\"ph1\">`natural unsigned int`</ph>) of an array on the stack.","source":"Pushes the length (of type `natural unsigned int`) of an array on the stack."},{"pos":[349,406],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[416,473],"content":"An object reference to an array is pushed onto the stack.","nodes":[{"content":"An object reference to an array is pushed onto the stack.","pos":[0,57]}]},{"pos":[483,555],"content":"The array reference is popped from the stack and the length is computed.","nodes":[{"content":"The array reference is popped from the stack and the length is computed.","pos":[0,72]}]},{"pos":[565,601],"content":"The length is pushed onto the stack.","nodes":[{"content":"The length is pushed onto the stack.","pos":[0,36]}]},{"pos":[608,724],"content":"Arrays are objects and hence represented by a value of type `O`. The length is returned as a `natural unsigned int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The length is returned as a <ph id=\"ph1\">`natural unsigned int`</ph>.","pos":[65,116],"source":" The length is returned as a `natural unsigned int`."}]},{"pos":[731,821],"content":"<xref:System.NullReferenceException> is thrown if the array reference is a null reference.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the array reference is a null reference.","pos":[0,90],"source":"<xref:System.NullReferenceException> is thrown if the array reference is a null reference."}]},{"pos":[828,935],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldlen`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:"},{"pos":[945,969],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[475847,476839],"yaml":true,"extradata":"MT"},{"content":"Loads the local variable at a specific index onto the evaluation stack.","nodes":[{"pos":[0,71],"content":"Loads the local variable at a specific index onto the evaluation stack.","nodes":[{"content":"Loads the local variable at a specific index onto the evaluation stack.","pos":[0,71]}]}],"pos":[478422,478494],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 0C < `unsigned int16` >|ldloc `index`|Loads the local variable at index `index` onto stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The local variable value at the specified index is pushed onto the stack.  \n  \n The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true. There are 65,535 (2^16-1) local variables possible (0-65,534). Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.  \n  \n The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.  \n  \n The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:  \n  \n-   ILGenerator.Emit(OpCode, LocalBuilder)  \n  \n-   ILGenerator.Emit(OpCode, short)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,282],"content":"FE 0C &lt; <ph id=\"ph1\">`unsigned int16`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 0C < `unsigned int16` >"},{"pos":[283,296],"content":"ldloc <ph id=\"ph1\">`index`</ph>","source":"ldloc `index`"},{"pos":[297,350],"content":"Loads the local variable at index <ph id=\"ph1\">`index`</ph> onto stack.","source":"Loads the local variable at index `index` onto stack."},{"pos":[358,415],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[425,498],"content":"The local variable value at the specified index is pushed onto the stack.","nodes":[{"content":"The local variable value at the specified index is pushed onto the stack.","pos":[0,73]}]},{"pos":[505,1145],"content":"The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true. There are 65,535 (2^16-1) local variables possible (0-65,534). Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.","nodes":[{"content":"The <ph id=\"ph1\">`ldloc`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.","pos":[0,169],"source":"The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards."},{"content":"Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.","pos":[170,284]},{"content":"There are 65,535 (2^16-1) local variables possible (0-65,534).","pos":[285,347]},{"content":"Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.","pos":[348,517]},{"content":"If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.","pos":[518,640]}]},{"pos":[1152,1291],"content":"The <ph id=\"ph1\">`ldloc.0`</ph>, <ph id=\"ph2\">`ldloc.1`</ph>, <ph id=\"ph3\">`ldloc.2`</ph>, and <ph id=\"ph4\">`ldloc.3`</ph> instructions provide an efficient encoding for accessing the first four local variables.","source":"The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables."},{"pos":[1298,1609],"content":"The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"The type of the value is the same as the type of the local variable, which is specified in the method header.","pos":[0,109]},{"content":"See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[110,243],"source":" See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[244,311],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1616,1724],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`ldloc`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:"},{"pos":[1734,1772],"content":"ILGenerator.Emit(OpCode, LocalBuilder)","nodes":[{"content":"ILGenerator.Emit(OpCode, LocalBuilder)","pos":[0,38]}]},{"pos":[1782,1813],"content":"ILGenerator.Emit(OpCode, short)","nodes":[{"content":"ILGenerator.Emit(OpCode, short)","pos":[0,31]}]}],"pos":[478505,480341],"yaml":true,"extradata":"MT"},{"content":"Loads the local variable at index 0 onto the evaluation stack.","nodes":[{"pos":[0,62],"content":"Loads the local variable at index 0 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 0 onto the evaluation stack.","pos":[0,62]}]}],"pos":[481936,481999],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|06|ldloc.0|Loads the local variable at index 0 onto the evaluation stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The local variable value at the index 0 is pushed onto the stack.  \n  \n `ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.  \n  \n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"06","nodes":[{"content":"06","pos":[0,2]}]},{"pos":[259,266],"content":"ldloc.0","nodes":[{"content":"ldloc.0","pos":[0,7]}]},{"pos":[267,329],"content":"Loads the local variable at index 0 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 0 onto the evaluation stack.","pos":[0,62]}]},{"pos":[337,394],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[404,469],"content":"The local variable value at the index 0 is pushed onto the stack.","nodes":[{"content":"The local variable value at the index 0 is pushed onto the stack.","pos":[0,65]}]},{"pos":[476,620],"content":"<ph id=\"ph1\">`ldloc.0`</ph> is an especially efficient encoding for <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 0.","source":"`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0."},{"pos":[627,921],"content":"The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"The type of the value is the same as the type of the local variable, which is specified in the method header.","pos":[0,109]},{"content":"Local variables that are smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[110,226],"source":" Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[227,294],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[928,1037],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldloc.0`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:"},{"pos":[1047,1071],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[482010,483100],"yaml":true,"extradata":"MT"},{"content":"Loads the local variable at index 1 onto the evaluation stack.","nodes":[{"pos":[0,62],"content":"Loads the local variable at index 1 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 1 onto the evaluation stack.","pos":[0,62]}]}],"pos":[484697,484760],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|07|ldloc.1|Loads the local variable at index 1 onto the evaluation stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The local variable value at the index 1 is pushed onto the stack.  \n  \n `ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.  \n  \n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"07","nodes":[{"content":"07","pos":[0,2]}]},{"pos":[259,266],"content":"ldloc.1","nodes":[{"content":"ldloc.1","pos":[0,7]}]},{"pos":[267,329],"content":"Loads the local variable at index 1 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 1 onto the evaluation stack.","pos":[0,62]}]},{"pos":[337,394],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[404,469],"content":"The local variable value at the index 1 is pushed onto the stack.","nodes":[{"content":"The local variable value at the index 1 is pushed onto the stack.","pos":[0,65]}]},{"pos":[476,620],"content":"<ph id=\"ph1\">`ldloc.1`</ph> is an especially efficient encoding for <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 1.","source":"`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1."},{"pos":[627,921],"content":"The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"The type of the value is the same as the type of the local variable, which is specified in the method header.","pos":[0,109]},{"content":"Local variables that are smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[110,226],"source":" Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[227,294],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[928,1037],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldloc.1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:"},{"pos":[1047,1071],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[484771,485861],"yaml":true,"extradata":"MT"},{"content":"Loads the local variable at index 2 onto the evaluation stack.","nodes":[{"pos":[0,62],"content":"Loads the local variable at index 2 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 2 onto the evaluation stack.","pos":[0,62]}]}],"pos":[487458,487521],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|08|ldloc.2|Loads the local variable at index 2 onto the evaluation stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The local variable value at the index 2 is pushed onto the stack.  \n  \n `ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.  \n  \n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"08","nodes":[{"content":"08","pos":[0,2]}]},{"pos":[259,266],"content":"ldloc.2","nodes":[{"content":"ldloc.2","pos":[0,7]}]},{"pos":[267,329],"content":"Loads the local variable at index 2 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 2 onto the evaluation stack.","pos":[0,62]}]},{"pos":[337,394],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[404,469],"content":"The local variable value at the index 2 is pushed onto the stack.","nodes":[{"content":"The local variable value at the index 2 is pushed onto the stack.","pos":[0,65]}]},{"pos":[476,620],"content":"<ph id=\"ph1\">`ldloc.2`</ph> is an especially efficient encoding for <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 2.","source":"`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2."},{"pos":[627,921],"content":"The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"The type of the value is the same as the type of the local variable, which is specified in the method header.","pos":[0,109]},{"content":"Local variables that are smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[110,226],"source":" Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[227,294],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[928,1037],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldloc.2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:"},{"pos":[1047,1071],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[487532,488622],"yaml":true,"extradata":"MT"},{"content":"Loads the local variable at index 3 onto the evaluation stack.","nodes":[{"pos":[0,62],"content":"Loads the local variable at index 3 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 3 onto the evaluation stack.","pos":[0,62]}]}],"pos":[490219,490282],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|09|ldloc.3|Loads the local variable at index 3 onto the evaluation stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The local variable value at the index 3 is pushed onto the stack.  \n  \n `ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.  \n  \n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"09","nodes":[{"content":"09","pos":[0,2]}]},{"pos":[259,266],"content":"ldloc.3","nodes":[{"content":"ldloc.3","pos":[0,7]}]},{"pos":[267,329],"content":"Loads the local variable at index 3 onto the evaluation stack.","nodes":[{"content":"Loads the local variable at index 3 onto the evaluation stack.","pos":[0,62]}]},{"pos":[337,394],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[404,469],"content":"The local variable value at the index 3 is pushed onto the stack.","nodes":[{"content":"The local variable value at the index 3 is pushed onto the stack.","pos":[0,65]}]},{"pos":[476,620],"content":"<ph id=\"ph1\">`ldloc.3`</ph> is an especially efficient encoding for <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 3.","source":"`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3."},{"pos":[627,921],"content":"The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"The type of the value is the same as the type of the local variable, which is specified in the method header.","pos":[0,109]},{"content":"Local variables that are smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[110,226],"source":" Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[227,294],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[928,1037],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldloc.3`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:"},{"pos":[1047,1071],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[490293,491383],"yaml":true,"extradata":"MT"},{"content":"Loads the local variable at a specific index onto the evaluation stack, short form.","nodes":[{"pos":[0,83],"content":"Loads the local variable at a specific index onto the evaluation stack, short form.","nodes":[{"content":"Loads the local variable at a specific index onto the evaluation stack, short form.","pos":[0,83]}]}],"pos":[492980,493064],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|11 < `unsigned int8` >|ldloc.s `index`|Loads the local variable at index `index` onto stack, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The local variable value at the specified index is pushed onto the stack.  \n  \n The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method if the initialize flag on the method is true. There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.  \n  \n The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, LocalBuilder)  \n  \n-   ILGenerator.Emit(OpCode, byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,278],"content":"11 &lt; <ph id=\"ph1\">`unsigned int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"11 < `unsigned int8` >"},{"pos":[279,294],"content":"ldloc.s <ph id=\"ph1\">`index`</ph>","source":"ldloc.s `index`"},{"pos":[295,360],"content":"Loads the local variable at index <ph id=\"ph1\">`index`</ph> onto stack, short form.","source":"Loads the local variable at index `index` onto stack, short form."},{"pos":[368,425],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[435,508],"content":"The local variable value at the specified index is pushed onto the stack.","nodes":[{"content":"The local variable value at the specified index is pushed onto the stack.","pos":[0,73]}]},{"pos":[515,917],"content":"The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method if the initialize flag on the method is true. There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.","nodes":[{"content":"The <ph id=\"ph1\">`ldloc.s`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.","pos":[0,171],"source":"The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards."},{"content":"Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.","pos":[172,281]},{"content":"There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than <ph id=\"ph1\">`ldloc`</ph>.","pos":[282,402],"source":" There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`."}]},{"pos":[924,1235],"content":"The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).","nodes":[{"content":"The type of the value is the same as the type of the local variable, which is specified in the method header.","pos":[0,109]},{"content":"See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id=\"ph1\">`int32`</ph> when they are loaded onto the stack.","pos":[110,243],"source":" See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack."},{"content":"Floating-point values are expanded to their native size (type <ph id=\"ph1\">`F`</ph>).","pos":[244,311],"source":" Floating-point values are expanded to their native size (type `F`)."}]},{"pos":[1242,1352],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`ldloc.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:"},{"pos":[1362,1400],"content":"ILGenerator.Emit(OpCode, LocalBuilder)","nodes":[{"content":"ILGenerator.Emit(OpCode, LocalBuilder)","pos":[0,38]}]},{"pos":[1410,1440],"content":"ILGenerator.Emit(OpCode, byte)","nodes":[{"content":"ILGenerator.Emit(OpCode, byte)","pos":[0,30]}]}],"pos":[493075,494536],"yaml":true,"extradata":"MT"},{"content":"Loads the address of the local variable at a specific index onto the evaluation stack.","nodes":[{"pos":[0,86],"content":"Loads the address of the local variable at a specific index onto the evaluation stack.","nodes":[{"content":"Loads the address of the local variable at a specific index onto the evaluation stack.","pos":[0,86]}]}],"pos":[496127,496214],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE OD < `unsigned int16` >|ldloca `index`|Loads the address of the local variable at `index` onto the evaluation stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The address stored in the local variable at the specified index is pushed onto the stack.  \n  \n The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>. The result is a transient pointer (type `*`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:  \n  \n-   ILGenerator.Emit(OpCode, short)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,282],"content":"FE OD &lt; <ph id=\"ph1\">`unsigned int16`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE OD < `unsigned int16` >"},{"pos":[283,297],"content":"ldloca <ph id=\"ph1\">`index`</ph>","source":"ldloca `index`"},{"pos":[298,375],"content":"Loads the address of the local variable at <ph id=\"ph1\">`index`</ph> onto the evaluation stack.","source":"Loads the address of the local variable at `index` onto the evaluation stack."},{"pos":[383,440],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[450,539],"content":"The address stored in the local variable at the specified index is pushed onto the stack.","nodes":[{"content":"The address stored in the local variable at the specified index is pushed onto the stack.","pos":[0,89]}]},{"pos":[546,933],"content":"The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>. The result is a transient pointer (type `*`).","nodes":[{"content":"The <ph id=\"ph1\">`ldloca`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.","pos":[0,154],"source":"The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards."},{"content":"The value pushed on the stack is already aligned correctly for use with instructions like <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.","pos":[155,341],"source":" The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>."},{"content":"The result is a transient pointer (type <ph id=\"ph1\">`*`</ph>).","pos":[342,387],"source":" The result is a transient pointer (type `*`)."}]},{"pos":[940,1048],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldloca`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:"},{"pos":[1058,1089],"content":"ILGenerator.Emit(OpCode, short)","nodes":[{"content":"ILGenerator.Emit(OpCode, short)","pos":[0,31]}]}],"pos":[496225,497331],"yaml":true,"extradata":"MT"},{"content":"Loads the address of the local variable at a specific index onto the evaluation stack, short form.","nodes":[{"pos":[0,98],"content":"Loads the address of the local variable at a specific index onto the evaluation stack, short form.","nodes":[{"content":"Loads the address of the local variable at a specific index onto the evaluation stack, short form.","pos":[0,98]}]}],"pos":[498933,499032],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|12 < `unsigned int8` >|ldloca.s `index`|Loads the address of the local variable at `index` onto the evaluation stack, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The address stored in the local variable at the specified index is pushed onto the stack.  \n  \n The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>. The result is a transient pointer (type `*`).  \n  \n The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,278],"content":"12 &lt; <ph id=\"ph1\">`unsigned int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"12 < `unsigned int8` >"},{"pos":[279,295],"content":"ldloca.s <ph id=\"ph1\">`index`</ph>","source":"ldloca.s `index`"},{"pos":[296,385],"content":"Loads the address of the local variable at <ph id=\"ph1\">`index`</ph> onto the evaluation stack, short form.","source":"Loads the address of the local variable at `index` onto the evaluation stack, short form."},{"pos":[393,450],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[460,549],"content":"The address stored in the local variable at the specified index is pushed onto the stack.","nodes":[{"content":"The address stored in the local variable at the specified index is pushed onto the stack.","pos":[0,89]}]},{"pos":[556,945],"content":"The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>. The result is a transient pointer (type `*`).","nodes":[{"content":"The <ph id=\"ph1\">`ldloca.s`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.","pos":[0,156],"source":"The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards."},{"content":"The value pushed on the stack is already aligned correctly for use with instructions like <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.","pos":[157,343],"source":" The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>."},{"content":"The result is a transient pointer (type <ph id=\"ph1\">`*`</ph>).","pos":[344,389],"source":" The result is a transient pointer (type `*`)."}]},{"pos":[952,1057],"content":"The <ph id=\"ph1\">`ldloca.s`</ph> instruction provides an efficient encoding for use with the local variables 0 through 255.","source":"The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255."},{"pos":[1064,1174],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldloca.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:"},{"pos":[1184,1214],"content":"ILGenerator.Emit(OpCode, byte)","nodes":[{"content":"ILGenerator.Emit(OpCode, byte)","pos":[0,30]}]}],"pos":[499043,500276],"yaml":true,"extradata":"MT"},{"content":"Pushes a null reference (type `O`) onto the evaluation stack.","nodes":[{"pos":[0,61],"content":"Pushes a null reference (type <ph id=\"ph1\">`O`</ph>) onto the evaluation stack.","source":"Pushes a null reference (type `O`) onto the evaluation stack."}],"pos":[501868,501930],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|14|ldnull|push a null reference onto the stack|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A null object reference is pushed onto the stack.  \n  \n `ldnull` pushes a null reference (type `O`) on the stack. This is used to initialize locations before they are populated with data, or when they become deprecated.  \n  \n `ldnull` provides a null reference that is size-independent.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"14","nodes":[{"content":"14","pos":[0,2]}]},{"pos":[259,265],"content":"ldnull","nodes":[{"content":"ldnull","pos":[0,6]}]},{"pos":[266,302],"content":"push a null reference onto the stack","nodes":[{"content":"push a null reference onto the stack","pos":[0,36]}]},{"pos":[310,367],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[377,426],"content":"A null object reference is pushed onto the stack.","nodes":[{"content":"A null object reference is pushed onto the stack.","pos":[0,49]}]},{"pos":[433,596],"content":"`ldnull` pushes a null reference (type `O`) on the stack. This is used to initialize locations before they are populated with data, or when they become deprecated.","nodes":[{"content":"<ph id=\"ph1\">`ldnull`</ph> pushes a null reference (type <ph id=\"ph2\">`O`</ph>) on the stack.","pos":[0,57],"source":"`ldnull` pushes a null reference (type `O`) on the stack."},{"content":"This is used to initialize locations before they are populated with data, or when they become deprecated.","pos":[58,163]}]},{"pos":[603,663],"content":"<ph id=\"ph1\">`ldnull`</ph> provides a null reference that is size-independent.","source":"`ldnull` provides a null reference that is size-independent."},{"pos":[670,778],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldnull`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:"},{"pos":[788,812],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[501941,502772],"yaml":true,"extradata":"MT"},{"content":"Copies the value type object pointed to by an address to the top of the evaluation stack.","nodes":[{"pos":[0,89],"content":"Copies the value type object pointed to by an address to the top of the evaluation stack.","nodes":[{"content":"Copies the value type object pointed to by an address to the top of the evaluation stack.","pos":[0,89]}]}],"pos":[504356,504446],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|71 < `T` >|ldobj `class`|Copy instance of value type `class` to the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The address of a value type object is pushed onto the stack.  \n  \n2.  The address is popped from the stack and the instance at that particular address is looked up.  \n  \n3.  The value of the object stored at that address is pushed onto the stack.  \n  \n The `ldobj` instruction is used to pass a value type as a parameter.  \n  \n The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack. The number of bytes copied depends on the size of the class (as specified by the `class` parameter). The `class` parameter is a metadata token representing the value type.  \n  \n The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"71 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"71 < `T` >"},{"pos":[267,280],"content":"ldobj <ph id=\"ph1\">`class`</ph>","source":"ldobj `class`"},{"pos":[281,330],"content":"Copy instance of value type <ph id=\"ph1\">`class`</ph> to the stack.","source":"Copy instance of value type `class` to the stack."},{"pos":[338,395],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[405,465],"content":"The address of a value type object is pushed onto the stack.","nodes":[{"content":"The address of a value type object is pushed onto the stack.","pos":[0,60]}]},{"pos":[475,569],"content":"The address is popped from the stack and the instance at that particular address is looked up.","nodes":[{"content":"The address is popped from the stack and the instance at that particular address is looked up.","pos":[0,94]}]},{"pos":[579,651],"content":"The value of the object stored at that address is pushed onto the stack.","nodes":[{"content":"The value of the object stored at that address is pushed onto the stack.","pos":[0,72]}]},{"pos":[658,726],"content":"The <ph id=\"ph1\">`ldobj`</ph> instruction is used to pass a value type as a parameter.","source":"The `ldobj` instruction is used to pass a value type as a parameter."},{"pos":[733,1035],"content":"The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack. The number of bytes copied depends on the size of the class (as specified by the `class` parameter). The `class` parameter is a metadata token representing the value type.","nodes":[{"content":"The <ph id=\"ph1\">`ldobj`</ph> instruction copies the value pointed to by <ph id=\"ph2\">`addrOfValObj`</ph> (of type <ph id=\"ph3\">`&amp;`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`native int`</ph>) to the top of the stack.","pos":[0,130],"source":"The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack."},{"content":"The number of bytes copied depends on the size of the class (as specified by the <ph id=\"ph1\">`class`</ph> parameter).","pos":[131,231],"source":" The number of bytes copied depends on the size of the class (as specified by the `class` parameter)."},{"content":"The <ph id=\"ph1\">`class`</ph> parameter is a metadata token representing the value type.","pos":[232,302],"source":" The `class` parameter is a metadata token representing the value type."}]},{"pos":[1042,1243],"content":"The operation of the <ph id=\"ph1\">`ldobj`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","source":"The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."},{"pos":[1250,1456],"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.","nodes":[{"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.","pos":[0,206],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.","pos":[0,67],"source":"<xref:System.TypeLoadException> is thrown if class cannot be found."},{"content":"This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.","pos":[68,206]}]}]},{"pos":[1463,1570],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldobj`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:"},{"pos":[1580,1610],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[504457,506094],"yaml":true,"extradata":"MT"},{"content":"Pushes the value of a static field onto the evaluation stack.","nodes":[{"pos":[0,61],"content":"Pushes the value of a static field onto the evaluation stack.","nodes":[{"content":"Pushes the value of a static field onto the evaluation stack.","pos":[0,61]}]}],"pos":[507683,507745],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|7E < `T` >|ldsfld `field`|Push the value of `field` on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value of the specific field is pushed onto the stack.  \n  \n The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack. The return type is that associated with the passed metadata token `field`.  \n  \n The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:  \n  \n-   ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"7E &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"7E < `T` >"},{"pos":[267,281],"content":"ldsfld <ph id=\"ph1\">`field`</ph>","source":"ldsfld `field`"},{"pos":[282,321],"content":"Push the value of <ph id=\"ph1\">`field`</ph> on the stack.","source":"Push the value of `field` on the stack."},{"pos":[329,386],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[396,453],"content":"The value of the specific field is pushed onto the stack.","nodes":[{"content":"The value of the specific field is pushed onto the stack.","pos":[0,57]}]},{"pos":[460,648],"content":"The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack. The return type is that associated with the passed metadata token `field`.","nodes":[{"content":"The <ph id=\"ph1\">`ldsfld`</ph> instruction pushes the value of a static (shared among all instances of a class) field on the stack.","pos":[0,113],"source":"The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack."},{"content":"The return type is that associated with the passed metadata token <ph id=\"ph1\">`field`</ph>.","pos":[114,188],"source":" The return type is that associated with the passed metadata token `field`."}]},{"pos":[655,745],"content":"The <ph id=\"ph1\">`ldsfld`</ph> instruction can have a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.","source":"The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix."},{"pos":[752,860],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldsfld`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:"},{"pos":[870,905],"content":"ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, FieldInfo)","pos":[0,35]}]}],"pos":[507756,508680],"yaml":true,"extradata":"MT"},{"content":"Pushes the address of a static field onto the evaluation stack.","nodes":[{"pos":[0,63],"content":"Pushes the address of a static field onto the evaluation stack.","nodes":[{"content":"Pushes the address of a static field onto the evaluation stack.","pos":[0,63]}]}],"pos":[510276,510340],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|7F < `T` >|ldsflda `field`|Push the address of `field` on the stack|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The address of a specific field is pushed onto the stack.  \n  \n The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack. The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed. Otherwise, it corresponds to an unmanaged pointer (type `native int`). Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.  \n  \n The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.  \n  \n <xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:  \n  \n-   ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"7F &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"7F < `T` >"},{"pos":[267,282],"content":"ldsflda <ph id=\"ph1\">`field`</ph>","source":"ldsflda `field`"},{"pos":[283,323],"content":"Push the address of <ph id=\"ph1\">`field`</ph> on the stack","source":"Push the address of `field` on the stack"},{"pos":[331,388],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[398,455],"content":"The address of a specific field is pushed onto the stack.","nodes":[{"content":"The address of a specific field is pushed onto the stack.","pos":[0,57]}]},{"pos":[462,1002],"content":"The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack. The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed. Otherwise, it corresponds to an unmanaged pointer (type `native int`). Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.","nodes":[{"content":"The <ph id=\"ph1\">`ldsflda`</ph> instruction pushes the address of a static (shared among all instances of a class) field on the stack.","pos":[0,116],"source":"The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack."},{"content":"The address may be represented as a transient pointer (type <ph id=\"ph1\">`*`</ph>) if the metadata token <ph id=\"ph2\">`field`</ph> refers to a type whose memory is managed.","pos":[117,253],"source":" The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed."},{"content":"Otherwise, it corresponds to an unmanaged pointer (type <ph id=\"ph1\">`native int`</ph>).","pos":[254,324],"source":" Otherwise, it corresponds to an unmanaged pointer (type `native int`)."},{"content":"Note that <ph id=\"ph1\">`field`</ph> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.","pos":[325,540],"source":" Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged."}]},{"pos":[1009,1100],"content":"The <ph id=\"ph1\">`ldsflda`</ph> instruction can have a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.","source":"The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix."},{"pos":[1107,1320],"content":"<xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.","nodes":[{"content":"<xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.","pos":[0,213],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.","pos":[0,84],"source":"<xref:System.MissingFieldException> is thrown if field is not found in the metadata."},{"content":"This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.","pos":[85,213]}]}]},{"pos":[1327,1436],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldsflda`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:"},{"pos":[1446,1481],"content":"ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, FieldInfo)","pos":[0,35]}]}],"pos":[510351,511853],"yaml":true,"extradata":"MT"},{"content":"Pushes a new object reference to a string literal stored in the metadata.","nodes":[{"pos":[0,73],"content":"Pushes a new object reference to a string literal stored in the metadata.","nodes":[{"content":"Pushes a new object reference to a string literal stored in the metadata.","pos":[0,73]}]}],"pos":[513438,513512],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|72 < `T` >|ldstr `mdToken`|Pushes a string object for the metadata string token `mdToken`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to a string is pushed onto the stack.  \n  \n The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata. The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.  \n  \n The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as \"string interning\").  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:  \n  \n-   ILGenerator.Emit(OpCode, string)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"72 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"72 < `T` >"},{"pos":[267,282],"content":"ldstr <ph id=\"ph1\">`mdToken`</ph>","source":"ldstr `mdToken`"},{"pos":[283,346],"content":"Pushes a string object for the metadata string token <ph id=\"ph1\">`mdToken`</ph>.","source":"Pushes a string object for the metadata string token `mdToken`."},{"pos":[354,411],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[421,478],"content":"An object reference to a string is pushed onto the stack.","nodes":[{"content":"An object reference to a string is pushed onto the stack.","pos":[0,57]}]},{"pos":[485,846],"content":"The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata. The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.","nodes":[{"content":"The <ph id=\"ph1\">`ldstr`</ph> instruction pushes an object reference (type <ph id=\"ph2\">`O`</ph>) to a new string object representing the specific string literal stored in the metadata.","pos":[0,149],"source":"The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata."},{"content":"The <ph id=\"ph1\">`ldstr`</ph> instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.","pos":[150,361],"source":" The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime."}]},{"pos":[853,1104],"content":"The Common Language Infrastructure (CLI) guarantees that the result of two <ph id=\"ph1\">`ldstr`</ph> instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as \"string interning\").","source":"The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as \"string interning\")."},{"pos":[1111,1218],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldstr`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:"},{"pos":[1228,1260],"content":"ILGenerator.Emit(OpCode, string)","nodes":[{"content":"ILGenerator.Emit(OpCode, string)","pos":[0,32]}]}],"pos":[513523,514804],"yaml":true,"extradata":"MT"},{"content":"Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.","nodes":[{"pos":[0,94],"content":"Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.","nodes":[{"content":"Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.","pos":[0,94]}]}],"pos":[516399,516494],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D0 < `T` >|ldtoken `token`|Converts a metadata token to its runtime representation.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The passed token is converted to a `RuntimeHandle` and pushed onto the stack.  \n  \n The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token. A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.  \n  \n The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.  \n  \n For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:  \n  \n-   ILGenerator.Emit(OpCode, MethodInfo)  \n  \n-   ILGenerator.Emit(OpCode, FieldInfo)  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"D0 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"D0 < `T` >"},{"pos":[267,282],"content":"ldtoken <ph id=\"ph1\">`token`</ph>","source":"ldtoken `token`"},{"pos":[283,339],"content":"Converts a metadata token to its runtime representation.","nodes":[{"content":"Converts a metadata token to its runtime representation.","pos":[0,56]}]},{"pos":[347,404],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[414,491],"content":"The passed token is converted to a <ph id=\"ph1\">`RuntimeHandle`</ph> and pushed onto the stack.","source":"The passed token is converted to a `RuntimeHandle` and pushed onto the stack."},{"pos":[498,679],"content":"The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token. A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.","nodes":[{"content":"The <ph id=\"ph1\">`ldtoken`</ph> instruction pushes a <ph id=\"ph2\">`RuntimeHandle`</ph> for the specified metadata token.","pos":[0,84],"source":"The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token."},{"content":"A <ph id=\"ph1\">`RuntimeHandle`</ph> can be a <ph id=\"ph2\">`fieldref/fielddef`</ph>, a <ph id=\"ph3\">`methodref/methoddef`</ph>, or a <ph id=\"ph4\">`typeref/typedef`</ph>.","pos":[85,181],"source":" A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`."}]},{"pos":[686,789],"content":"The value pushed on the stack can be used in calls to <ph id=\"ph1\">`Reflection`</ph> methods in the system class library.","source":"The value pushed on the stack can be used in calls to `Reflection` methods in the system class library."},{"pos":[796,964],"content":"For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.","nodes":[{"content":"For information on runtime handles, see the following classes: <ph id=\"ph1\">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.","pos":[0,168],"source":"For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>."}]},{"pos":[971,1081],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`ldtoken`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:"},{"pos":[1091,1127],"content":"ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, MethodInfo)","pos":[0,36]}]},{"pos":[1137,1172],"content":"ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, FieldInfo)","pos":[0,35]}]},{"pos":[1182,1212],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[516505,517742],"yaml":true,"extradata":"MT"},{"content":"Pushes an unmanaged pointer (type `native int`) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.","nodes":[{"pos":[0,169],"content":"Pushes an unmanaged pointer (type <ph id=\"ph1\">`native int`</ph>) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.","source":"Pushes an unmanaged pointer (type `native int`) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack."}],"pos":[519351,519521],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 07 < `T` >|ldvirtftn `method`|Pushes the pointer to an object's virtual method `method` on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference is pushed onto the stack.  \n  \n2.  The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.  \n  \n3.  The pointer to `method` is pushed onto the stack.  \n  \n The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).  \n  \n The unmanaged pointer points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:  \n  \n-   ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"FE 07 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 07 < `T` >"},{"pos":[270,288],"content":"ldvirtftn <ph id=\"ph1\">`method`</ph>","source":"ldvirtftn `method`"},{"pos":[289,360],"content":"Pushes the pointer to an object's virtual method <ph id=\"ph1\">`method`</ph> on the stack.","source":"Pushes the pointer to an object's virtual method `method` on the stack."},{"pos":[368,425],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[435,480],"content":"An object reference is pushed onto the stack.","nodes":[{"content":"An object reference is pushed onto the stack.","pos":[0,45]}]},{"pos":[490,644],"content":"The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <ph id=\"ph1\">`method`</ph>) is looked up.","source":"The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up."},{"pos":[654,703],"content":"The pointer to <ph id=\"ph1\">`method`</ph> is pushed onto the stack.","source":"The pointer to `method` is pushed onto the stack."},{"pos":[710,969],"content":"The resulting unmanaged pointer pushed onto the stack by the <ph id=\"ph1\">`ldvirtftn`</ph> instruction can be called using the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).","source":"The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code)."},{"pos":[976,1142],"content":"The unmanaged pointer points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.","nodes":[{"content":"The unmanaged pointer points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.","pos":[0,166],"nodes":[{"content":"The unmanaged pointer points to native code using the CLR calling convention.","pos":[0,77]},{"content":"This method pointer should not be passed to unmanaged native code as a callback routine.","pos":[78,166]}]}]},{"pos":[1149,1260],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ldvirtftn`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:"},{"pos":[1270,1306],"content":"ILGenerator.Emit(OpCode, MethodInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, MethodInfo)","pos":[0,36]}]}],"pos":[519532,520861],"yaml":true,"extradata":"MT"},{"content":"Exits a protected region of code, unconditionally transferring control to a specific target instruction.","nodes":[{"pos":[0,104],"content":"Exits a protected region of code, unconditionally transferring control to a specific target instruction.","nodes":[{"content":"Exits a protected region of code, unconditionally transferring control to a specific target instruction.","pos":[0,104]}]}],"pos":[522448,522553],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|DD < `int32` >|leave `target`|Exits a protected region of code.|  \n  \n There is no stack transition behavior specified for this instruction.  \n  \n The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.  \n  \n You cannot use a `leave` instruction to exit a `finally` block. To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.  \n  \n If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,270],"content":"DD &lt; <ph id=\"ph1\">`int32`</ph><ph id=\"ph2\"> &gt;</ph>","source":"DD < `int32` >"},{"pos":[271,285],"content":"leave <ph id=\"ph1\">`target`</ph>","source":"leave `target`"},{"pos":[286,319],"content":"Exits a protected region of code.","nodes":[{"content":"Exits a protected region of code.","pos":[0,33]}]},{"pos":[327,396],"content":"There is no stack transition behavior specified for this instruction.","nodes":[{"content":"There is no stack transition behavior specified for this instruction.","pos":[0,69]}]},{"pos":[403,607],"content":"The <ph id=\"ph1\">`leave`</ph> instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.","source":"The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction."},{"pos":[614,970],"content":"The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.","nodes":[{"content":"The <ph id=\"ph1\">`leave`</ph> instruction is similar to the <ph id=\"ph2\">`br`</ph> instruction, but it can be used to exit a <ph id=\"ph3\">`try`</ph>, <ph id=\"ph4\">`filter`</ph>, or <ph id=\"ph5\">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.","pos":[0,227],"source":"The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it."},{"content":"The <ph id=\"ph1\">`leave`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id=\"ph2\">`finally`</ph> blocks are executed.","pos":[228,356],"source":" The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed."}]},{"pos":[977,1228],"content":"You cannot use a `leave` instruction to exit a `finally` block. To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.","nodes":[{"content":"You cannot use a <ph id=\"ph1\">`leave`</ph> instruction to exit a <ph id=\"ph2\">`finally`</ph> block.","pos":[0,63],"source":"You cannot use a `leave` instruction to exit a `finally` block."},{"content":"To ease code generation for exception handlers it is valid from within a catch block to use a <ph id=\"ph1\">`leave`</ph> instruction to transfer control to any instruction within the associated <ph id=\"ph2\">`try`</ph> block.","pos":[64,251],"source":" To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block."}]},{"pos":[1235,1346],"content":"If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","nodes":[{"content":"If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,111]}]},{"pos":[1353,1461],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`leave`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:"},{"pos":[1471,1502],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[522564,524087],"yaml":true,"extradata":"MT"},{"content":"Exits a protected region of code, unconditionally transferring control to a target instruction (short form).","nodes":[{"pos":[0,108],"content":"Exits a protected region of code, unconditionally transferring control to a target instruction (short form).","nodes":[{"content":"Exits a protected region of code, unconditionally transferring control to a target instruction (short form).","pos":[0,108]}]}],"pos":[525682,525791],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|DE < `int8` >|leave.s `target`|Exit a protected region of code, short form.|  \n  \n There is no stack transition behavior specified for this instruction.  \n  \n The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \n  \n The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.  \n  \n You cannot use a `leave.s` instruction to exit a `finally` block. To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.  \n  \n If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"DE &lt; <ph id=\"ph1\">`int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"DE < `int8` >"},{"pos":[270,286],"content":"leave.s <ph id=\"ph1\">`target`</ph>","source":"leave.s `target`"},{"pos":[287,331],"content":"Exit a protected region of code, short form.","nodes":[{"content":"Exit a protected region of code, short form.","pos":[0,44]}]},{"pos":[339,408],"content":"There is no stack transition behavior specified for this instruction.","nodes":[{"content":"There is no stack transition behavior specified for this instruction.","pos":[0,69]}]},{"pos":[415,619],"content":"The <ph id=\"ph1\">`leave.s`</ph> instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.","source":"The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction."},{"pos":[626,986],"content":"The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.","nodes":[{"content":"The <ph id=\"ph1\">`leave.s`</ph> instruction is similar to the <ph id=\"ph2\">`br`</ph> instruction, but it can be used to exit a <ph id=\"ph3\">`try`</ph>, <ph id=\"ph4\">`filter`</ph>, or <ph id=\"ph5\">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.","pos":[0,229],"source":"The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it."},{"content":"The <ph id=\"ph1\">`leave.s`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id=\"ph2\">`finally`</ph> blocks are executed.","pos":[230,360],"source":" The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed."}]},{"pos":[993,1248],"content":"You cannot use a `leave.s` instruction to exit a `finally` block. To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.","nodes":[{"content":"You cannot use a <ph id=\"ph1\">`leave.s`</ph> instruction to exit a <ph id=\"ph2\">`finally`</ph> block.","pos":[0,65],"source":"You cannot use a `leave.s` instruction to exit a `finally` block."},{"content":"To ease code generation for exception handlers it is valid from within a catch block to use a <ph id=\"ph1\">`leave.s`</ph> instruction to transfer control to any instruction within the associated <ph id=\"ph2\">`try`</ph> block.","pos":[66,255],"source":" To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block."}]},{"pos":[1255,1366],"content":"If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","nodes":[{"content":"If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,111]}]},{"pos":[1373,1482],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`leave.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:"},{"pos":[1492,1523],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]}],"pos":[525802,527346],"yaml":true,"extradata":"MT"},{"content":"Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type `*`) of the first allocated byte onto the evaluation stack.","nodes":[{"pos":[0,180],"content":"Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <ph id=\"ph1\">`*`</ph>) of the first allocated byte onto the evaluation stack.","source":"Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type `*`) of the first allocated byte onto the evaluation stack."}],"pos":[528949,529130],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 0F|localloc|Allocate space from the local heap.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The number of bytes to be allocated is pushed onto the stack.  \n  \n2.  The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.  \n  \n3.  A pointer to the first byte of the allocated memory is pushed onto the stack.  \n  \n The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte. The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`. When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.  \n  \n The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  \n  \n The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.  \n  \n <xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 0F","nodes":[{"content":"FE 0F","pos":[0,5]}]},{"pos":[262,270],"content":"localloc","nodes":[{"content":"localloc","pos":[0,8]}]},{"pos":[271,306],"content":"Allocate space from the local heap.","nodes":[{"content":"Allocate space from the local heap.","pos":[0,35]}]},{"pos":[314,371],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[381,442],"content":"The number of bytes to be allocated is pushed onto the stack.","nodes":[{"content":"The number of bytes to be allocated is pushed onto the stack.","pos":[0,61]}]},{"pos":[452,577],"content":"The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.","nodes":[{"content":"The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.","pos":[0,125]}]},{"pos":[587,664],"content":"A pointer to the first byte of the allocated memory is pushed onto the stack.","nodes":[{"content":"A pointer to the first byte of the allocated memory is pushed onto the stack.","pos":[0,77]}]},{"pos":[671,1101],"content":"The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte. The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`. When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.","nodes":[{"content":"The <ph id=\"ph1\">`localloc`</ph> instruction allocates <ph id=\"ph2\">`size`</ph> (type <ph id=\"ph3\">`natural unsigned int`</ph>) bytes from the local dynamic memory pool and returns the address (a transient pointer, type <ph id=\"ph4\">`*`</ph>) of the first allocated byte.","pos":[0,199],"source":"The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte."},{"content":"The block of memory returned is initialized to 0 only if the initialize flag on the method is <ph id=\"ph1\">`true`</ph>.","pos":[200,301],"source":" The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`."},{"content":"When the current method executes a <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, the local memory pool is made available for reuse.","pos":[302,430],"source":" When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse."}]},{"pos":[1108,1380],"content":"The resulting address is aligned so that any primitive data type can be stored there using the <ph id=\"ph1\">`stind`</ph> instructions (such as <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) and loaded using the <ph id=\"ph3\">`ldind`</ph> instructions (such as <ph id=\"ph4\">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).","source":"The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>)."},{"pos":[1387,1483],"content":"The <ph id=\"ph1\">`localloc`</ph> instruction cannot occur within a <ph id=\"ph2\">`filter`</ph>, <ph id=\"ph3\">`catch`</ph>, <ph id=\"ph4\">`finally`</ph>, or <ph id=\"ph5\">`fault`</ph> block.","source":"The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block."},{"pos":[1490,1592],"content":"<xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.StackOverflowException&gt;</ph> is thrown if there is insufficient memory to service the request.","pos":[0,102],"source":"<xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request."}]},{"pos":[1599,1709],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`localloc`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:"},{"pos":[1719,1743],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[529141,530911],"yaml":true,"extradata":"MT"},{"content":"Pushes a typed reference to an instance of a specific type onto the evaluation stack.","nodes":[{"pos":[0,85],"content":"Pushes a typed reference to an instance of a specific type onto the evaluation stack.","nodes":[{"content":"Pushes a typed reference to an instance of a specific type onto the evaluation stack.","pos":[0,85]}]}],"pos":[532515,532601],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|C6 < `T` >|mkrefany `class`|Pushes a typed reference of type `class` onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A pointer to piece of data is pushed onto the stack.  \n  \n2.  The pointer is popped and converted to a typed reference of type `class`.  \n  \n3.  The typed reference is pushed onto the stack.  \n  \n The `mkrefany` instruction supports the passing of dynamically typed references. The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data. `Class` is the class token describing the type of the data referenced by the pointer. `Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.  \n  \n The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter. The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.  \n  \n <xref:System.TypeLoadException> is thrown if `class` cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"C6 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"C6 < `T` >"},{"pos":[267,283],"content":"mkrefany <ph id=\"ph1\">`class`</ph>","source":"mkrefany `class`"},{"pos":[284,340],"content":"Pushes a typed reference of type <ph id=\"ph1\">`class`</ph> onto the stack.","source":"Pushes a typed reference of type `class` onto the stack."},{"pos":[348,405],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[415,467],"content":"A pointer to piece of data is pushed onto the stack.","nodes":[{"content":"A pointer to piece of data is pushed onto the stack.","pos":[0,52]}]},{"pos":[477,550],"content":"The pointer is popped and converted to a typed reference of type <ph id=\"ph1\">`class`</ph>.","source":"The pointer is popped and converted to a typed reference of type `class`."},{"pos":[560,605],"content":"The typed reference is pushed onto the stack.","nodes":[{"content":"The typed reference is pushed onto the stack.","pos":[0,45]}]},{"pos":[612,998],"content":"The `mkrefany` instruction supports the passing of dynamically typed references. The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data. `Class` is the class token describing the type of the data referenced by the pointer. `Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.","nodes":[{"content":"The <ph id=\"ph1\">`mkrefany`</ph> instruction supports the passing of dynamically typed references.","pos":[0,80],"source":"The `mkrefany` instruction supports the passing of dynamically typed references."},{"content":"The pointer must be of type <ph id=\"ph1\">`&amp;`</ph>, <ph id=\"ph2\">`*`</ph>, or <ph id=\"ph3\">`native int`</ph>, and hold the valid address of a piece of data.","pos":[81,182],"source":" The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data."},{"content":"<ph id=\"ph1\">`Class`</ph> is the class token describing the type of the data referenced by the pointer.","pos":[183,268],"source":"`Class` is the class token describing the type of the data referenced by the pointer."},{"content":"<ph id=\"ph1\">`Mkrefany`</ph> pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <ph id=\"ph2\">`class`</ph>.","pos":[269,386],"source":"`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`."}]},{"pos":[1005,1337],"content":"The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter. The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.","nodes":[{"content":"The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter. The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.","pos":[0,332],"nodes":[{"content":"The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.","pos":[0,131]},{"content":"The callee can then use the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> instructions to retrieve the type (class) and the address respectively.","pos":[132,332],"source":" The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively."}]}]},{"pos":[1344,1550],"content":"<xref:System.TypeLoadException> is thrown if `class` cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id=\"ph2\">`class`</ph> cannot be found.","pos":[0,69],"source":"<xref:System.TypeLoadException> is thrown if `class` cannot be found."},{"content":"This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.","pos":[70,206]}]},{"pos":[1557,1667],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`mkrefany`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:"},{"pos":[1677,1707],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[532612,534344],"yaml":true,"extradata":"MT"},{"content":"Multiplies two values and pushes the result on the evaluation stack.","nodes":[{"pos":[0,68],"content":"Multiplies two values and pushes the result on the evaluation stack.","nodes":[{"content":"Multiplies two values and pushes the result on the evaluation stack.","pos":[0,68]}]}],"pos":[535918,535987],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|5A|mul|Multiplies two values on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack. Integer operations silently truncate the upper bits on overflow.  \n  \n See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.  \n  \n For floating-point types, 0 * infinity = NaN.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"5A","nodes":[{"content":"5A","pos":[0,2]}]},{"pos":[259,262],"content":"mul","nodes":[{"content":"mul","pos":[0,3]}]},{"pos":[263,298],"content":"Multiplies two values on the stack.","nodes":[{"content":"Multiplies two values on the stack.","pos":[0,35]}]},{"pos":[306,363],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[373,407],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[417,451],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[461,545],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is multiplied by <ph id=\"ph4\">`value2`</ph>.","source":"`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`."},{"pos":[555,591],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[598,752],"content":"The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack. Integer operations silently truncate the upper bits on overflow.","nodes":[{"content":"The <ph id=\"ph1\">`mul`</ph> instruction multiplies <ph id=\"ph2\">`value1`</ph> by <ph id=\"ph3\">`value2`</ph> and pushes the result on the stack.","pos":[0,89],"source":"The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack."},{"content":"Integer operations silently truncate the upper bits on overflow.","pos":[90,154]}]},{"pos":[759,875],"content":"See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> for an integer-specific multiply operation with overflow handling.","pos":[0,116],"source":"See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling."}]},{"pos":[882,927],"content":"For floating-point types, 0 * infinity = NaN.","nodes":[{"content":"For floating-point types, 0 * infinity = NaN.","pos":[0,45]}]},{"pos":[934,1039],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`mul`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:"},{"pos":[1049,1073],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[535998,537098],"yaml":true,"extradata":"MT"},{"content":"Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,107],"content":"Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"content":"Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.","pos":[0,107]}]}],"pos":[538691,538799],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D8|mul.ovf|Multiplies two integer values on the stack with an overflow check.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D8","nodes":[{"content":"D8","pos":[0,2]}]},{"pos":[259,266],"content":"mul.ovf","nodes":[{"content":"mul.ovf","pos":[0,7]}]},{"pos":[267,333],"content":"Multiplies two integer values on the stack with an overflow check.","nodes":[{"content":"Multiplies two integer values on the stack with an overflow check.","pos":[0,66]}]},{"pos":[341,398],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[408,442],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[452,486],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[496,604],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is multiplied by <ph id=\"ph4\">`value2`</ph>, with an overflow check.","source":"`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check."},{"pos":[614,650],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[657,836],"content":"The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.","nodes":[{"content":"The <ph id=\"ph1\">`mul.ovf`</ph> instruction multiplies integer <ph id=\"ph2\">`value1`</ph> by integer <ph id=\"ph3\">`value2`</ph> and pushes the result on the stack.","pos":[0,109],"source":"The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack."},{"content":"An exception is thrown if the result will not fit in the result type.","pos":[110,179]}]},{"pos":[843,941],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[948,1057],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`mul.ovf`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:"},{"pos":[1067,1091],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[538810,539926],"yaml":true,"extradata":"MT"},{"content":"Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,116],"content":"Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"content":"Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.","pos":[0,116]}]}],"pos":[541541,541658],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|D9|mul.ovf.un|Multiplies two unsigned values on the stack with an overflow check.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"D9","nodes":[{"content":"D9","pos":[0,2]}]},{"pos":[259,269],"content":"mul.ovf.un","nodes":[{"content":"mul.ovf.un","pos":[0,10]}]},{"pos":[270,337],"content":"Multiplies two unsigned values on the stack with an overflow check.","nodes":[{"content":"Multiplies two unsigned values on the stack with an overflow check.","pos":[0,67]}]},{"pos":[345,402],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[412,446],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[456,490],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[500,608],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value1`</ph> is multiplied by <ph id=\"ph4\">`value2`</ph>, with an overflow check.","source":"`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check."},{"pos":[618,654],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[661,861],"content":"The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.","nodes":[{"content":"The <ph id=\"ph1\">`mul.ovf.un`</ph> instruction multiplies unsigned integer <ph id=\"ph2\">`value1`</ph> by unsigned integer <ph id=\"ph3\">`value2`</ph> and pushes the result on the stack.","pos":[0,130],"source":"The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack."},{"content":"An exception is thrown if the result will not fit in the result type.","pos":[131,200]}]},{"pos":[868,966],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[973,1085],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`mul.ovf.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:"},{"pos":[1095,1119],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[541669,542813],"yaml":true,"extradata":"MT"},{"content":"Negates a value and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,64],"content":"Negates a value and pushes the result onto the evaluation stack.","nodes":[{"content":"Negates a value and pushes the result onto the evaluation stack.","pos":[0,64]}]}],"pos":[544389,544454],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|65|neg|Negates the value currently on top of the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is pushed onto the stack.  \n  \n2.  A value is popped from the stack and negated.  \n  \n3.  The result is pushed onto the stack.  \n  \n The `neg` instruction negates value and pushes the result on top of the stack. The return type is the same as the operand type.  \n  \n Negation of integral values is standard two's complement negation. In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number. To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).  \n  \n Negating a floating-point number cannot overflow, and negating NaN returns NaN.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"65","nodes":[{"content":"65","pos":[0,2]}]},{"pos":[259,262],"content":"neg","nodes":[{"content":"neg","pos":[0,3]}]},{"pos":[263,311],"content":"Negates the value currently on top of the stack.","nodes":[{"content":"Negates the value currently on top of the stack.","pos":[0,48]}]},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,419],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[429,474],"content":"A value is popped from the stack and negated.","nodes":[{"content":"A value is popped from the stack and negated.","pos":[0,45]}]},{"pos":[484,520],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[527,654],"content":"The `neg` instruction negates value and pushes the result on top of the stack. The return type is the same as the operand type.","nodes":[{"content":"The <ph id=\"ph1\">`neg`</ph> instruction negates value and pushes the result on top of the stack.","pos":[0,78],"source":"The `neg` instruction negates value and pushes the result on top of the stack."},{"content":"The return type is the same as the operand type.","pos":[79,127]}]},{"pos":[661,980],"content":"Negation of integral values is standard two's complement negation. In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number. To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).","nodes":[{"content":"Negation of integral values is standard two's complement negation. In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number. To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).","pos":[0,319],"nodes":[{"content":"Negation of integral values is standard two's complement negation.","pos":[0,66]},{"content":"In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.","pos":[67,193]},{"content":"To detect this overflow use the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> instruction instead (that is, subtract from 0).","pos":[194,319],"source":" To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0)."}]}]},{"pos":[987,1066],"content":"Negating a floating-point number cannot overflow, and negating NaN returns NaN.","nodes":[{"content":"Negating a floating-point number cannot overflow, and negating NaN returns NaN.","pos":[0,79]}]},{"pos":[1073,1178],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`neg`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:"},{"pos":[1188,1212],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[544465,545702],"yaml":true,"extradata":"MT"},{"content":"Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.","nodes":[{"pos":[0,134],"content":"Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.","nodes":[{"content":"Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.","pos":[0,134]}]}],"pos":[547289,547424],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|8D < `T` >|newarr `etype`|Creates a new array with elements of type `etype`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The number of elements in the array is pushed onto the stack.  \n  \n2.  The number of elements is popped from the stack and the array is created.  \n  \n3.  An object reference to the new array is pushed onto the stack.  \n  \n The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type). The number of elements in the new array should be specified as a `native int`. Valid array indexes range from zero to the maximum number of elements minus one.  \n  \n The elements of an array can be any type, including value types.  \n  \n Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on). Elements of the array are initialized to 0 of the appropriate type.  \n  \n Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`. More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.  \n  \n <xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.  \n  \n <xref:System.OverflowException> is thrown if `numElems` is less than 0.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"8D &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"8D < `T` >"},{"pos":[267,281],"content":"newarr <ph id=\"ph1\">`etype`</ph>","source":"newarr `etype`"},{"pos":[282,332],"content":"Creates a new array with elements of type <ph id=\"ph1\">`etype`</ph>.","source":"Creates a new array with elements of type `etype`."},{"pos":[340,397],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[407,468],"content":"The number of elements in the array is pushed onto the stack.","nodes":[{"content":"The number of elements in the array is pushed onto the stack.","pos":[0,61]}]},{"pos":[478,551],"content":"The number of elements is popped from the stack and the array is created.","nodes":[{"content":"The number of elements is popped from the stack and the array is created.","pos":[0,73]}]},{"pos":[561,623],"content":"An object reference to the new array is pushed onto the stack.","nodes":[{"content":"An object reference to the new array is pushed onto the stack.","pos":[0,62]}]},{"pos":[630,970],"content":"The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type). The number of elements in the new array should be specified as a `native int`. Valid array indexes range from zero to the maximum number of elements minus one.","nodes":[{"content":"The <ph id=\"ph1\">`newarr`</ph> instruction pushes an object reference (type <ph id=\"ph2\">`O`</ph>) to a new zero-based, one-dimensional array whose elements are of type <ph id=\"ph3\">`etype`</ph> (a metadata token describing the type).","pos":[0,180],"source":"The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type)."},{"content":"The number of elements in the new array should be specified as a <ph id=\"ph1\">`native int`</ph>.","pos":[181,259],"source":" The number of elements in the new array should be specified as a `native int`."},{"content":"Valid array indexes range from zero to the maximum number of elements minus one.","pos":[260,340]}]},{"pos":[977,1041],"content":"The elements of an array can be any type, including value types.","nodes":[{"content":"The elements of an array can be any type, including value types.","pos":[0,64]}]},{"pos":[1048,1269],"content":"Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on). Elements of the array are initialized to 0 of the appropriate type.","nodes":[{"content":"Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on). Elements of the array are initialized to 0 of the appropriate type.","pos":[0,221],"nodes":[{"content":"Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>, and so on).","pos":[0,153],"source":"Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on)."},{"content":"Elements of the array are initialized to 0 of the appropriate type.","pos":[154,221]}]}]},{"pos":[1276,1531],"content":"Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`. More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.","nodes":[{"content":"Nonzero-based one-dimensional arrays and multidimensional arrays are created using <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> rather than <ph id=\"ph2\">`newarr`</ph>.","pos":[0,149],"source":"Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`."},{"content":"More commonly, they are created using the methods of the <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> class in the .NET Framework.","pos":[150,255],"source":" More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework."}]},{"pos":[1538,1638],"content":"<xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.","pos":[0,100],"source":"<xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request."}]},{"pos":[1645,1716],"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if <ph id=\"ph2\">`numElems`</ph> is less than 0.","source":"<xref:System.OverflowException> is thrown if `numElems` is less than 0."},{"pos":[1723,1831],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`newarr`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:"},{"pos":[1841,1871],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[547435,549337],"yaml":true,"extradata":"MT"},{"content":"Creates a new object or a new instance of a value type, pushing an object reference (type `O`) onto the evaluation stack.","nodes":[{"pos":[0,121],"content":"Creates a new object or a new instance of a value type, pushing an object reference (type <ph id=\"ph1\">`O`</ph>) onto the evaluation stack.","source":"Creates a new object or a new instance of a value type, pushing an object reference (type `O`) onto the evaluation stack."}],"pos":[550927,551049],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|73 < `T` >|newobj `ctor`|Allocates an uninitialized object or value type and calls the constructor method `ctor`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  Arguments `arg1` through `argn` are pushed on the stack in sequence.  \n  \n2.  Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.  \n  \n3.  A reference to the new object is pushed onto the stack.  \n  \n The `newobj` instruction creates a new object or a new instance of a value type. `Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.  \n  \n The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate. It then calls the constructor `ctor` with the given arguments along with the newly created instance. After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.  \n  \n From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.  \n  \n All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`. On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.  \n  \n Value types are not usually created using `newobj`. They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects. Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>. However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.  \n  \n <xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.  \n  \n <xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:  \n  \n-   ILGenerator.Emit(OpCode, ConstructorInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"73 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"73 < `T` >"},{"pos":[267,280],"content":"newobj <ph id=\"ph1\">`ctor`</ph>","source":"newobj `ctor`"},{"pos":[281,369],"content":"Allocates an uninitialized object or value type and calls the constructor method <ph id=\"ph1\">`ctor`</ph>.","source":"Allocates an uninitialized object or value type and calls the constructor method `ctor`."},{"pos":[377,434],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[444,512],"content":"Arguments <ph id=\"ph1\">`arg1`</ph> through <ph id=\"ph2\">`argn`</ph> are pushed on the stack in sequence.","source":"Arguments `arg1` through `argn` are pushed on the stack in sequence."},{"pos":[522,621],"content":"Arguments <ph id=\"ph1\">`argn`</ph> through <ph id=\"ph2\">`arg1`</ph> are popped from the stack and passed to <ph id=\"ph3\">`ctor`</ph> for object creation.","source":"Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation."},{"pos":[631,686],"content":"A reference to the new object is pushed onto the stack.","nodes":[{"content":"A reference to the new object is pushed onto the stack.","pos":[0,55]}]},{"pos":[693,941],"content":"The `newobj` instruction creates a new object or a new instance of a value type. `Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.","nodes":[{"content":"The <ph id=\"ph1\">`newobj`</ph> instruction creates a new object or a new instance of a value type.","pos":[0,80],"source":"The `newobj` instruction creates a new object or a new instance of a value type."},{"content":"<ph id=\"ph1\">`Ctor`</ph> is a metadata token (a <ph id=\"ph2\">`methodref`</ph> or <ph id=\"ph3\">`methoddef`</ph> that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.","pos":[81,248],"source":"`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call."}]},{"pos":[948,1357],"content":"The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate. It then calls the constructor `ctor` with the given arguments along with the newly created instance. After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.","nodes":[{"content":"The <ph id=\"ph1\">`newobj`</ph> instruction allocates a new instance of the class associated with <ph id=\"ph2\">`ctor`</ph> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.","pos":[0,197],"source":"The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate."},{"content":"It then calls the constructor <ph id=\"ph1\">`ctor`</ph> with the given arguments along with the newly created instance.","pos":[198,298],"source":" It then calls the constructor `ctor` with the given arguments along with the newly created instance."},{"content":"After the constructor has been called, the now initialized object reference (type <ph id=\"ph1\">`O`</ph>) is pushed on the stack.","pos":[299,409],"source":" After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack."}]},{"pos":[1364,1498],"content":"From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.","nodes":[{"content":"From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.","pos":[0,134]}]},{"pos":[1505,1750],"content":"All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`. On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.","nodes":[{"content":"All zero-based, one-dimensional arrays are created using <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, not <ph id=\"ph2\">`newobj`</ph>.","pos":[0,116],"source":"All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`."},{"content":"On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using <ph id=\"ph1\">`newobj`</ph>.","pos":[117,245],"source":" On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`."}]},{"pos":[1757,2218],"content":"Value types are not usually created using `newobj`. They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects. Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>. However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.","nodes":[{"content":"Value types are not usually created using <ph id=\"ph1\">`newobj`</ph>.","pos":[0,51],"source":"Value types are not usually created using `newobj`."},{"content":"They are usually allocated either as arguments or local variables, using <ph id=\"ph1\">`newarr`</ph> (for zero-based, one-dimensional arrays), or as fields of objects.","pos":[52,200],"source":" They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects."},{"content":"Once allocated, they are initialized using <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.","pos":[201,290],"source":" Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>."},{"content":"However, the <ph id=\"ph1\">`newobj`</ph> instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.","pos":[291,461],"source":" However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on."}]},{"pos":[2225,2325],"content":"<xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.","pos":[0,100],"source":"<xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request."}]},{"pos":[2332,2612],"content":"<xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a constructor method <ph id=\"ph2\">`ctor`</ph> with the indicated name, class and signature could not be found.","pos":[0,142],"source":"<xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found."},{"content":"This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.","pos":[143,280]}]},{"pos":[2619,2727],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`newobj`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:"},{"pos":[2737,2778],"content":"ILGenerator.Emit(OpCode, ConstructorInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, ConstructorInfo)","pos":[0,41]}]}],"pos":[551060,553871],"yaml":true,"extradata":"MT"},{"content":"Fills space if opcodes are patched. No meaningful operation is performed although a processing cycle can be consumed.","nodes":[{"pos":[0,117],"content":"Fills space if opcodes are patched. No meaningful operation is performed although a processing cycle can be consumed.","nodes":[{"content":"Fills space if opcodes are patched. No meaningful operation is performed although a processing cycle can be consumed.","pos":[0,117],"nodes":[{"content":"Fills space if opcodes are patched.","pos":[0,35]},{"content":"No meaningful operation is performed although a processing cycle can be consumed.","pos":[36,117]}]}]}],"pos":[555443,555561],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|00|nop|Performs an operation without behavior.|  \n  \n There is no stack transitional behavior defined for this instruction.  \n  \n The `nop` operation does nothing. It is intended to fill in space if opcodes are patched.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"00","nodes":[{"content":"00","pos":[0,2]}]},{"pos":[259,262],"content":"nop","nodes":[{"content":"nop","pos":[0,3]}]},{"pos":[263,302],"content":"Performs an operation without behavior.","nodes":[{"content":"Performs an operation without behavior.","pos":[0,39]}]},{"pos":[310,379],"content":"There is no stack transitional behavior defined for this instruction.","nodes":[{"content":"There is no stack transitional behavior defined for this instruction.","pos":[0,69]}]},{"pos":[386,475],"content":"The `nop` operation does nothing. It is intended to fill in space if opcodes are patched.","nodes":[{"content":"The <ph id=\"ph1\">`nop`</ph> operation does nothing.","pos":[0,33],"source":"The `nop` operation does nothing."},{"content":"It is intended to fill in space if opcodes are patched.","pos":[34,89]}]},{"pos":[482,587],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`nop`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:"},{"pos":[597,621],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[555572,556208],"yaml":true,"extradata":"MT"},{"content":"Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.","nodes":[{"pos":[0,138],"content":"Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.","nodes":[{"content":"Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.","pos":[0,138]}]}],"pos":[557777,557916],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|66|not|Computes the bitwise complement of a value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value` is pushed onto the stack.  \n  \n2.  `value` is popped from the stack and its bitwise complement computed.  \n  \n3.  The result is pushed onto the stack.  \n  \n The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack. The return type is the same as the operand type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"66","nodes":[{"content":"66","pos":[0,2]}]},{"pos":[259,262],"content":"not","nodes":[{"content":"not","pos":[0,3]}]},{"pos":[263,306],"content":"Computes the bitwise complement of a value.","nodes":[{"content":"Computes the bitwise complement of a value.","pos":[0,43]}]},{"pos":[314,371],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[381,414],"content":"<ph id=\"ph1\">`value`</ph> is pushed onto the stack.","source":"`value` is pushed onto the stack."},{"pos":[424,493],"content":"<ph id=\"ph1\">`value`</ph> is popped from the stack and its bitwise complement computed.","source":"`value` is popped from the stack and its bitwise complement computed."},{"pos":[503,539],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[546,706],"content":"The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack. The return type is the same as the operand type.","nodes":[{"content":"The <ph id=\"ph1\">`not`</ph> instruction computes the bitwise complement of an integer value and pushes the result onto the stack.","pos":[0,111],"source":"The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack."},{"content":"The return type is the same as the operand type.","pos":[112,160]}]},{"pos":[713,818],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`not`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:"},{"pos":[828,852],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[557927,558800],"yaml":true,"extradata":"MT"},{"content":"Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,125],"content":"Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.","nodes":[{"content":"Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.","pos":[0,125]}]}],"pos":[560363,560489],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|60|or|Computes the bitwise OR of two integer values, returns an integer.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack and their bitwise OR computed.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.  \n  \n `Or` is an integer-specific operation.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"60","nodes":[{"content":"60","pos":[0,2]}]},{"pos":[259,261],"content":"or","nodes":[{"content":"or","pos":[0,2]}]},{"pos":[262,328],"content":"Computes the bitwise OR of two integer values, returns an integer.","nodes":[{"content":"Computes the bitwise OR of two integer values, returns an integer.","pos":[0,66]}]},{"pos":[336,393],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[403,437],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[447,481],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[491,569],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack and their bitwise OR computed.","source":"`value2` and `value1` are popped from the stack and their bitwise OR computed."},{"pos":[579,615],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[622,731],"content":"The <ph id=\"ph1\">`or`</ph> instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.","source":"The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack."},{"pos":[738,776],"content":"<ph id=\"ph1\">`Or`</ph> is an integer-specific operation.","source":"`Or` is an integer-specific operation."},{"pos":[783,887],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`or`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:"},{"pos":[897,921],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[560500,561446],"yaml":true,"extradata":"MT"},{"content":"Removes the value currently on top of the evaluation stack.","nodes":[{"pos":[0,59],"content":"Removes the value currently on top of the evaluation stack.","nodes":[{"content":"Removes the value currently on top of the evaluation stack.","pos":[0,59]}]}],"pos":[563014,563074],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|26|pop|Pops the top value from the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The top value is popped from the stack.  \n  \n The `pop` instruction removes the top element from the stack.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"26","nodes":[{"content":"26","pos":[0,2]}]},{"pos":[259,262],"content":"pop","nodes":[{"content":"pop","pos":[0,3]}]},{"pos":[263,297],"content":"Pops the top value from the stack.","nodes":[{"content":"Pops the top value from the stack.","pos":[0,34]}]},{"pos":[305,362],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[372,411],"content":"The top value is popped from the stack.","nodes":[{"content":"The top value is popped from the stack.","pos":[0,39]}]},{"pos":[418,479],"content":"The <ph id=\"ph1\">`pop`</ph> instruction removes the top element from the stack.","source":"The `pop` instruction removes the top element from the stack."},{"pos":[486,591],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`pop`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:"},{"pos":[601,625],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[563085,563727],"yaml":true,"extradata":"MT"},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[565320,565352],"yaml":true},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[566949,566981],"yaml":true},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[568578,568610],"yaml":true},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[570207,570239],"yaml":true},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[571836,571868],"yaml":true},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[573465,573497],"yaml":true},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[575094,575126],"yaml":true},{"content":"This is a reserved instruction.","nodes":[{"pos":[0,31],"content":"This is a reserved instruction.","nodes":[{"content":"This is a reserved instruction.","pos":[0,31]}]}],"pos":[576735,576767],"yaml":true},{"content":"Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.","nodes":[{"pos":[0,159],"content":"Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.","nodes":[{"content":"Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.","pos":[0,159]}]}],"pos":[578372,578532],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 1E|readonly.|Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.|  \n  \n This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays. Its effect on the subsequent operation is twofold:  \n  \n1.  At run time, no type check operation is performed. Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays. There is never a run-time type check for value classes, so `readonly` is a no-op in that case.  \n  \n2.  The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.  \n  \n The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated. For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix). In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.  \n  \n A managed pointer restricted in this fashion can be used only in the following ways:  \n  \n-   As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.  \n  \n-   As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.  \n  \n-   As the `source` parameter to the `cpobj` instruction.  \n  \n All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.  \n  \n The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code. For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.  \n  \n```  \nldloc arr  \nldloc i  \nreadonly.  \nldelema !0    // Loads the pointer to the object.  \n…             // Load the arguments to the call.  \nconstrained. !0  \ncallvirt m  \n```  \n  \n Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type. Not only is this type check inefficient, but it is semantically incorrect. The type check for `ldelema` is an exact match, which is too strong. If the array held subclasses of type !0, the code above would fail the type check.  \n  \n The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.  \n  \n In general it would be unsafe to skip the run-time check if the array held elements of a reference type. To be safe, it is necessary to ensure that no modifications to the array are made through this pointer. The verifier rules ensure this. The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 1E","nodes":[{"content":"FE 1E","pos":[0,5]}]},{"pos":[262,271],"content":"readonly.","nodes":[{"content":"readonly.","pos":[0,9]}]},{"pos":[272,425],"content":"Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.","nodes":[{"content":"Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.","pos":[0,153]}]},{"pos":[433,612],"content":"This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays. Its effect on the subsequent operation is twofold:","nodes":[{"content":"This prefix can only appear immediately preceding the <ph id=\"ph1\">`ldelema`</ph> instruction and calls to the special <ph id=\"ph2\">`Address`</ph> method on arrays.","pos":[0,128],"source":"This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays."},{"content":"Its effect on the subsequent operation is twofold:","pos":[129,179]}]},{"pos":[622,898],"content":"At run time, no type check operation is performed. Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays. There is never a run-time type check for value classes, so `readonly` is a no-op in that case.","nodes":[{"content":"At run time, no type check operation is performed.","pos":[0,50]},{"content":"Note that there is normally an implicit type check for the <ph id=\"ph1\">`ldelema`</ph> and <ph id=\"ph2\">`stelem`</ph> instructions when used on reference type arrays.","pos":[51,181],"source":" Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays."},{"content":"There is never a run-time type check for value classes, so <ph id=\"ph1\">`readonly`</ph> is a no-op in that case.","pos":[182,276],"source":" There is never a run-time type check for value classes, so `readonly` is a no-op in that case."}]},{"pos":[908,1015],"content":"The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.","nodes":[{"content":"The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.","pos":[0,107]}]},{"pos":[1022,1418],"content":"The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated. For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix). In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.","nodes":[{"content":"The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated. For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix). In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.","pos":[0,396],"nodes":[{"content":"The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.","pos":[0,118]},{"content":"For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).","pos":[119,265]},{"content":"In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.","pos":[266,396]}]}]},{"pos":[1425,1509],"content":"A managed pointer restricted in this fashion can be used only in the following ways:","nodes":[{"content":"A managed pointer restricted in this fashion can be used only in the following ways:","pos":[0,84]}]},{"pos":[1519,1627],"content":"As the <ph id=\"ph1\">`object`</ph> parameter for the <ph id=\"ph2\">`ldfld`</ph>, <ph id=\"ph3\">`ldflda`</ph>, <ph id=\"ph4\">`stfld`</ph>, <ph id=\"ph5\">`call`</ph>, or<ph id=\"ph6\">`constrained callvirt`</ph> instructions.","source":"As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions."},{"pos":[1637,1729],"content":"As the <ph id=\"ph1\">`pointer`</ph> parameter to the <ph id=\"ph2\">`ldobj`</ph> instruction or to one of the <ph id=\"ph3\">`ldind`</ph> instructions.","source":"As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions."},{"pos":[1739,1792],"content":"As the <ph id=\"ph1\">`source`</ph> parameter to the <ph id=\"ph2\">`cpobj`</ph> instruction.","source":"As the `source` parameter to the `cpobj` instruction."},{"pos":[1799,1927],"content":"All other operations disallowed, including the <ph id=\"ph1\">`stobj`</ph>, <ph id=\"ph2\">`initobj`</ph>, or <ph id=\"ph3\">`mkrefany`</ph> operations, or any of the <ph id=\"ph4\">`stind`</ph> instructions.","source":"All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions."},{"pos":[1934,2254],"content":"The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code. For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.","nodes":[{"content":"The purpose of the <ph id=\"ph1\">`readonly`</ph> prefix is to avoid a type check when fetching an element from an array in generic code.","pos":[0,117],"source":"The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code."},{"content":"For example, the expression <ph id=\"ph1\">`arr[i].m()`</ph>, where the element type of the array <ph id=\"ph2\">`arr`</ph> is a generic type that has been constrained to have an interface with method <ph id=\"ph3\">`m`</ph>, might compile to the following MSIL.","pos":[118,320],"source":" For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL."}]},{"pos":[2444,2797],"content":"Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type. Not only is this type check inefficient, but it is semantically incorrect. The type check for `ldelema` is an exact match, which is too strong. If the array held subclasses of type !0, the code above would fail the type check.","nodes":[{"content":"Without the <ph id=\"ph1\">`readonly`</ph> prefix, the <ph id=\"ph2\">`ldelema`</ph> instruction would perform a type check in the case where !0 was a reference type.","pos":[0,126],"source":"Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type."},{"content":"Not only is this type check inefficient, but it is semantically incorrect.","pos":[127,201]},{"content":"The type check for <ph id=\"ph1\">`ldelema`</ph> is an exact match, which is too strong.","pos":[202,270],"source":" The type check for `ldelema` is an exact match, which is too strong."},{"content":"If the array held subclasses of type !0, the code above would fail the type check.","pos":[271,353]}]},{"pos":[2804,3037],"content":"The address of the array element is fetched, instead of the element itself, in order to have a handle for <ph id=\"ph1\">`arr[i]`</ph> that works for both value types and reference types, and thus can be passed to the <ph id=\"ph2\">`constrained callvirt`</ph> instruction.","source":"The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction."},{"pos":[3044,3480],"content":"In general it would be unsafe to skip the run-time check if the array held elements of a reference type. To be safe, it is necessary to ensure that no modifications to the array are made through this pointer. The verifier rules ensure this. The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.","nodes":[{"content":"In general it would be unsafe to skip the run-time check if the array held elements of a reference type. To be safe, it is necessary to ensure that no modifications to the array are made through this pointer. The verifier rules ensure this. The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.","pos":[0,436],"nodes":[{"content":"In general it would be unsafe to skip the run-time check if the array held elements of a reference type.","pos":[0,104]},{"content":"To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.","pos":[105,208]},{"content":"The verifier rules ensure this.","pos":[209,240]},{"content":"The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.","pos":[241,436]}]}]},{"pos":[3487,3597],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`readonly`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:"},{"pos":[3607,3631],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[578543,582221],"yaml":true,"extradata":"MT"},{"content":"Retrieves the type token embedded in a typed reference.","nodes":[{"pos":[0,55],"content":"Retrieves the type token embedded in a typed reference.","nodes":[{"content":"Retrieves the type token embedded in a typed reference.","pos":[0,55]}]}],"pos":[583837,583893],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 1D|refanytype|Pushes the type token stored in a typed reference.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value type reference is pushed onto the stack.  \n  \n2.  The typed reference is popped from the stack and its corresponding type token retrieved.  \n  \n3.  The type token is pushed onto the stack.  \n  \n A typed reference contains a type token and an address to an object instance.  \n  \n The `refanytype` instruction retrieves the type token embedded in the typed reference. See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 1D","nodes":[{"content":"FE 1D","pos":[0,5]}]},{"pos":[262,272],"content":"refanytype","nodes":[{"content":"refanytype","pos":[0,10]}]},{"pos":[273,323],"content":"Pushes the type token stored in a typed reference.","nodes":[{"content":"Pushes the type token stored in a typed reference.","pos":[0,50]}]},{"pos":[331,388],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[398,446],"content":"A value type reference is pushed onto the stack.","nodes":[{"content":"A value type reference is pushed onto the stack.","pos":[0,48]}]},{"pos":[456,544],"content":"The typed reference is popped from the stack and its corresponding type token retrieved.","nodes":[{"content":"The typed reference is popped from the stack and its corresponding type token retrieved.","pos":[0,88]}]},{"pos":[554,594],"content":"The type token is pushed onto the stack.","nodes":[{"content":"The type token is pushed onto the stack.","pos":[0,40]}]},{"pos":[601,678],"content":"A typed reference contains a type token and an address to an object instance.","nodes":[{"content":"A typed reference contains a type token and an address to an object instance.","pos":[0,77]}]},{"pos":[685,884],"content":"The `refanytype` instruction retrieves the type token embedded in the typed reference. See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.","nodes":[{"content":"The <ph id=\"ph1\">`refanytype`</ph> instruction retrieves the type token embedded in the typed reference.","pos":[0,86],"source":"The `refanytype` instruction retrieves the type token embedded in the typed reference."},{"content":"See the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for information on creating typed references.","pos":[87,199],"source":" See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references."}]},{"pos":[891,1003],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`refanytype`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:"},{"pos":[1013,1037],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[583904,584964],"yaml":true,"extradata":"MT"},{"content":"Retrieves the address (type `&`) embedded in a typed reference.","nodes":[{"pos":[0,63],"content":"Retrieves the address (type <ph id=\"ph1\">`&amp;`</ph>) embedded in a typed reference.","source":"Retrieves the address (type `&`) embedded in a typed reference."}],"pos":[586576,586640],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|C2 < `T` >|refanyval `type`|Pushes the address stored in a typed reference.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value type reference is pushed onto the stack.  \n  \n2.  The typed reference is popped from the stack and the corresponding address retrieved.  \n  \n3.  The address is pushed onto the stack.  \n  \n A typed reference contains a type token and an address to an object instance.  \n  \n The `refanyval` instruction retrieves the address embedded in the a typed reference. The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`). See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.  \n  \n <xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).  \n  \n <xref:System.TypeLoadException> is thrown if `type` cannot be found.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"C2 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"C2 < `T` >"},{"pos":[267,283],"content":"refanyval <ph id=\"ph1\">`type`</ph>","source":"refanyval `type`"},{"pos":[284,331],"content":"Pushes the address stored in a typed reference.","nodes":[{"content":"Pushes the address stored in a typed reference.","pos":[0,47]}]},{"pos":[339,396],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[406,454],"content":"A value type reference is pushed onto the stack.","nodes":[{"content":"A value type reference is pushed onto the stack.","pos":[0,48]}]},{"pos":[464,549],"content":"The typed reference is popped from the stack and the corresponding address retrieved.","nodes":[{"content":"The typed reference is popped from the stack and the corresponding address retrieved.","pos":[0,85]}]},{"pos":[559,596],"content":"The address is pushed onto the stack.","nodes":[{"content":"The address is pushed onto the stack.","pos":[0,37]}]},{"pos":[603,680],"content":"A typed reference contains a type token and an address to an object instance.","nodes":[{"content":"A typed reference contains a type token and an address to an object instance.","pos":[0,77]}]},{"pos":[687,1017],"content":"The `refanyval` instruction retrieves the address embedded in the a typed reference. The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`). See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.","nodes":[{"content":"The <ph id=\"ph1\">`refanyval`</ph> instruction retrieves the address embedded in the a typed reference.","pos":[0,84],"source":"The `refanyval` instruction retrieves the address embedded in the a typed reference."},{"content":"The type embedded in the typed reference supplied on the stack must match the type specified by <ph id=\"ph1\">`type`</ph> (a metadata token, either a <ph id=\"ph2\">`typedef`</ph> or a <ph id=\"ph3\">`typeref`</ph>).","pos":[85,242],"source":" The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`)."},{"content":"See the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for related content.","pos":[243,330],"source":" See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content."}]},{"pos":[1024,1286],"content":"<ph id=\"ph1\">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id=\"ph2\">`type`</ph> is not identical to the type stored in the type reference (in this case, <ph id=\"ph3\">`type`</ph> is the class supplied to the <ph id=\"ph4\">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction that constructed said typed reference).","source":"<xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference)."},{"pos":[1293,1361],"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id=\"ph2\">`type`</ph> cannot be found.","source":"<xref:System.TypeLoadException> is thrown if `type` cannot be found."},{"pos":[1368,1479],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`refanyval`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:"},{"pos":[1489,1519],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[586651,588197],"yaml":true,"extradata":"MT"},{"content":"Divides two values and pushes the remainder onto the evaluation stack.","nodes":[{"pos":[0,70],"content":"Divides two values and pushes the remainder onto the evaluation stack.","nodes":[{"content":"Divides two values and pushes the remainder onto the evaluation stack.","pos":[0,70]}]}],"pos":[589772,589843],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|5D|rem|Pushes the remainder of dividing `value1` by `value2` onto the stack.|  \n  \n> [!NOTE]\n>  ReplaceThisText  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.  \n  \n4.  The result is pushed onto the stack.  \n  \n `result` = `value1` `rem` `value2` satisfies the following conditions:  \n  \n `result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:  \n  \n 0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.  \n  \n If `value2` is zero or `value1` is infinity the result is NaN. If `value2` is infinity, the result is `value1` (negated for `-infinity`).  \n  \n Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.  \n  \n Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"5D","nodes":[{"content":"5D","pos":[0,2]}]},{"pos":[259,262],"content":"rem","nodes":[{"content":"rem","pos":[0,3]}]},{"pos":[263,332],"content":"Pushes the remainder of dividing <ph id=\"ph1\">`value1`</ph> by <ph id=\"ph2\">`value2`</ph> onto the stack.","source":"Pushes the remainder of dividing `value1` by `value2` onto the stack."},{"pos":[341,367],"content":"[!NOTE]\n ReplaceThisText","leadings":["","> "],"nodes":[{"content":"ReplaceThisText","pos":[9,24]}]},{"pos":[374,431],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[441,477],"content":"A <ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"A `value1` is pushed onto the stack."},{"pos":[487,521],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[531,633],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack and the remainder of <ph id=\"ph3\">`value1`</ph> <ph id=\"ph4\">`div`</ph> <ph id=\"ph5\">`value2`</ph> computed.","source":"`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed."},{"pos":[643,679],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[686,756],"content":"<ph id=\"ph1\">`result`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`value1`</ph> <ph id=\"ph4\">`rem`</ph> <ph id=\"ph5\">`value2`</ph> satisfies the following conditions:","source":"`result` = `value1` `rem` `value2` satisfies the following conditions:"},{"pos":[763,829],"content":"<ph id=\"ph1\">`result`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`value1`</ph><ph id=\"ph4\"> - </ph><ph id=\"ph5\">`value2`</ph> <ph id=\"ph6\">`×`</ph> (<ph id=\"ph7\">`value1`</ph> <ph id=\"ph8\">`div`</ph> <ph id=\"ph9\">`value2`</ph>), and:","source":"`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:"},{"pos":[836,990],"content":"0 = &amp;#124; <ph id=\"ph1\">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id=\"ph2\">`value2`</ph> &amp;#124;, sign(<ph id=\"ph3\">`result`</ph>) = sign(<ph id=\"ph4\">`value1`</ph>), where <ph id=\"ph5\">`div`</ph> is the division instruction that truncates towards zero.","source":"0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero."},{"pos":[997,1134],"content":"If `value2` is zero or `value1` is infinity the result is NaN. If `value2` is infinity, the result is `value1` (negated for `-infinity`).","nodes":[{"content":"If <ph id=\"ph1\">`value2`</ph> is zero or <ph id=\"ph2\">`value1`</ph> is infinity the result is NaN.","pos":[0,62],"source":"If `value2` is zero or `value1` is infinity the result is NaN."},{"content":"If <ph id=\"ph1\">`value2`</ph> is infinity, the result is <ph id=\"ph2\">`value1`</ph> (negated for <ph id=\"ph3\">`-infinity`</ph>).","pos":[63,137],"source":" If `value2` is infinity, the result is `value1` (negated for `-infinity`)."}]},{"pos":[1141,1223],"content":"Integral operations throw <ph id=\"ph1\">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id=\"ph2\">`value2`</ph> is zero.","source":"Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero."},{"pos":[1230,1347],"content":"Note that on the Intel-based platforms an <ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint <ph id=\"ph2\">`rem`</ph> -1).","source":"Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1)."},{"pos":[1354,1459],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`rem`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:"},{"pos":[1469,1493],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[589854,591383],"yaml":true,"extradata":"MT"},{"content":"Divides two unsigned values and pushes the remainder onto the evaluation stack.","nodes":[{"pos":[0,79],"content":"Divides two unsigned values and pushes the remainder onto the evaluation stack.","nodes":[{"content":"Divides two unsigned values and pushes the remainder onto the evaluation stack.","pos":[0,79]}]}],"pos":[592970,593050],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|5E|rem.un|Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.  \n  \n4.  The result is pushed onto the stack.  \n  \n `result` = `value1` `rem.un` `value2` satisfies the following conditions:  \n  \n `result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:  \n  \n 0 = `result` < `value2`, where `div.un` is the unsigned division instruction.  \n  \n The `rem.un` instruction computes `result` and pushes it on the stack. `Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.  \n  \n `Rem.un` is unspecified for floating-point numbers.  \n  \n Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"5E","nodes":[{"content":"5E","pos":[0,2]}]},{"pos":[259,265],"content":"rem.un","nodes":[{"content":"rem.un","pos":[0,6]}]},{"pos":[266,353],"content":"Pushes the remainder of dividing unsigned <ph id=\"ph1\">`value1`</ph> by unsigned <ph id=\"ph2\">`value2`</ph> onto the stack.","source":"Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack."},{"pos":[361,418],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[428,462],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[472,506],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[516,618],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack and the remainder of <ph id=\"ph3\">`value1`</ph> <ph id=\"ph4\">`div`</ph> <ph id=\"ph5\">`value2`</ph> computed.","source":"`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed."},{"pos":[628,664],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[671,744],"content":"<ph id=\"ph1\">`result`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`value1`</ph> <ph id=\"ph4\">`rem.un`</ph> <ph id=\"ph5\">`value2`</ph> satisfies the following conditions:","source":"`result` = `value1` `rem.un` `value2` satisfies the following conditions:"},{"pos":[751,817],"content":"<ph id=\"ph1\">`result`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`value1`</ph><ph id=\"ph4\"> - </ph><ph id=\"ph5\">`value2`</ph> x(<ph id=\"ph6\">`value1`</ph> <ph id=\"ph7\">`div.un`</ph> <ph id=\"ph8\">`value2`</ph>), and:","source":"`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:"},{"pos":[824,901],"content":"0 = <ph id=\"ph1\">`result`</ph><ph id=\"ph2\"> &lt; </ph><ph id=\"ph3\">`value2`</ph>, where <ph id=\"ph4\">`div.un`</ph> is the unsigned division instruction.","source":"0 = `result` < `value2`, where `div.un` is the unsigned division instruction."},{"pos":[908,1110],"content":"The `rem.un` instruction computes `result` and pushes it on the stack. `Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.","nodes":[{"content":"The <ph id=\"ph1\">`rem.un`</ph> instruction computes <ph id=\"ph2\">`result`</ph> and pushes it on the stack.","pos":[0,70],"source":"The `rem.un` instruction computes `result` and pushes it on the stack."},{"content":"<ph id=\"ph1\">`Rem.un`</ph> treats its arguments as unsigned integers, while <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> treats them as signed integers.","pos":[71,202],"source":"`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers."}]},{"pos":[1117,1168],"content":"<ph id=\"ph1\">`Rem.un`</ph> is unspecified for floating-point numbers.","source":"`Rem.un` is unspecified for floating-point numbers."},{"pos":[1175,1257],"content":"Integral operations throw <ph id=\"ph1\">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id=\"ph2\">`value2`</ph> is zero.","source":"Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero."},{"pos":[1264,1372],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`rem.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:"},{"pos":[1382,1406],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[593061,594500],"yaml":true,"extradata":"MT"},{"content":"Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.","nodes":[{"pos":[0,139],"content":"Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.","nodes":[{"content":"Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.","pos":[0,139]}]}],"pos":[596072,596212],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|2A|ret|Returns from method, possibly returning a value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The return value is popped from the callee evaluation stack.  \n  \n2.  The return value obtained in step 1 is pushed onto the caller evaluation stack.  \n  \n If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).  \n  \n The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method. The evaluation stack for the current method must be empty except for the value to be returned.  \n  \n The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block. From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks. Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"2A","nodes":[{"content":"2A","pos":[0,2]}]},{"pos":[259,262],"content":"ret","nodes":[{"content":"ret","pos":[0,3]}]},{"pos":[263,311],"content":"Returns from method, possibly returning a value.","nodes":[{"content":"Returns from method, possibly returning a value.","pos":[0,48]}]},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,446],"content":"The return value is popped from the callee evaluation stack.","nodes":[{"content":"The return value is popped from the callee evaluation stack.","pos":[0,60]}]},{"pos":[456,535],"content":"The return value obtained in step 1 is pushed onto the caller evaluation stack.","nodes":[{"content":"The return value obtained in step 1 is pushed onto the caller evaluation stack.","pos":[0,79]}]},{"pos":[542,701],"content":"If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).","nodes":[{"content":"If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).","pos":[0,159]}]},{"pos":[708,1003],"content":"The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method. The evaluation stack for the current method must be empty except for the value to be returned.","nodes":[{"content":"The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method. The evaluation stack for the current method must be empty except for the value to be returned.","pos":[0,295],"nodes":[{"content":"The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.","pos":[0,200]},{"content":"The evaluation stack for the current method must be empty except for the value to be returned.","pos":[201,295]}]}]},{"pos":[1010,1581],"content":"The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block. From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks. Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.","nodes":[{"content":"The <ph id=\"ph1\">`ret`</ph> instruction cannot be used to transfer control out of a<ph id=\"ph2\">`try`</ph>, <ph id=\"ph3\">`filter`</ph>, <ph id=\"ph4\">`catch`</ph>, or <ph id=\"ph5\">`finally`</ph> block.","pos":[0,110],"source":"The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block."},{"content":"From within a <ph id=\"ph1\">`try`</ph> or <ph id=\"ph2\">`catch`</ph>, use the <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction with a destination of a <ph id=\"ph4\">`ret`</ph> instruction that is outside all enclosing exception blocks.","pos":[111,296],"source":" From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks."},{"content":"Because the <ph id=\"ph1\">`filter`</ph> and <ph id=\"ph2\">`finally`</ph> blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a <ph id=\"ph3\">`filter`</ph> or <ph id=\"ph4\">`finally`</ph>.","pos":[297,571],"source":" Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`."}]},{"pos":[1588,1693],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`ret`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:"},{"pos":[1703,1727],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[596223,597973],"yaml":true,"extradata":"MT"},{"content":"Rethrows the current exception.","nodes":[{"pos":[0,31],"content":"Rethrows the current exception.","nodes":[{"content":"Rethrows the current exception.","pos":[0,31]}]}],"pos":[599566,599598],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 1A|rethrow|Rethrows the current exception|  \n  \n No stack transition behavior is defined for this instruction.  \n  \n The `rethrow` instruction is only permitted within the body of a `catch` handler. It throws the same exception that was caught by this handler.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 1A","nodes":[{"content":"FE 1A","pos":[0,5]}]},{"pos":[262,269],"content":"rethrow","nodes":[{"content":"rethrow","pos":[0,7]}]},{"pos":[270,300],"content":"Rethrows the current exception","nodes":[{"content":"Rethrows the current exception","pos":[0,30]}]},{"pos":[308,369],"content":"No stack transition behavior is defined for this instruction.","nodes":[{"content":"No stack transition behavior is defined for this instruction.","pos":[0,61]}]},{"pos":[376,519],"content":"The `rethrow` instruction is only permitted within the body of a `catch` handler. It throws the same exception that was caught by this handler.","nodes":[{"content":"The <ph id=\"ph1\">`rethrow`</ph> instruction is only permitted within the body of a <ph id=\"ph2\">`catch`</ph> handler.","pos":[0,81],"source":"The `rethrow` instruction is only permitted within the body of a `catch` handler."},{"content":"It throws the same exception that was caught by this handler.","pos":[82,143]}]},{"pos":[526,635],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`rethrow`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:"},{"pos":[645,669],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[599609,600293],"yaml":true,"extradata":"MT"},{"content":"Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.","nodes":[{"pos":[0,124],"content":"Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.","nodes":[{"content":"Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.","pos":[0,124]}]}],"pos":[601866,601991],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|62|shl|Shifts an integer to the left (shifting in zeros).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is pushed onto the stack.  \n  \n2.  The amount of bits to be shifted is pushed onto the stack.  \n  \n3.  The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits. The number of bits is a value of type `int32` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.  \n  \n `Shl` inserts a zero bit in the lowest position on each shift.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"62","nodes":[{"content":"62","pos":[0,2]}]},{"pos":[259,262],"content":"shl","nodes":[{"content":"shl","pos":[0,3]}]},{"pos":[263,313],"content":"Shifts an integer to the left (shifting in zeros).","nodes":[{"content":"Shifts an integer to the left (shifting in zeros).","pos":[0,50]}]},{"pos":[321,378],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[388,421],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[431,489],"content":"The amount of bits to be shifted is pushed onto the stack.","nodes":[{"content":"The amount of bits to be shifted is pushed onto the stack.","pos":[0,58]}]},{"pos":[499,631],"content":"The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.","nodes":[{"content":"The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.","pos":[0,132]}]},{"pos":[641,677],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[684,1002],"content":"The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits. The number of bits is a value of type `int32` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.","nodes":[{"content":"The <ph id=\"ph1\">`shl`</ph> instruction shifts the value (type <ph id=\"ph2\">`int32`</ph>, <ph id=\"ph3\">`int64`</ph> or <ph id=\"ph4\">`native int`</ph>) left by the specified number of bits.","pos":[0,116],"source":"The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits."},{"content":"The number of bits is a value of type <ph id=\"ph1\">`int32`</ph> or <ph id=\"ph2\">`native int`</ph>.","pos":[117,179],"source":" The number of bits is a value of type `int32` or `native int`."},{"content":"The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.","pos":[180,318]}]},{"pos":[1009,1071],"content":"<ph id=\"ph1\">`Shl`</ph> inserts a zero bit in the lowest position on each shift.","source":"`Shl` inserts a zero bit in the lowest position on each shift."},{"pos":[1078,1183],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`shl`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:"},{"pos":[1193,1217],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[602002,603244],"yaml":true,"extradata":"MT"},{"content":"Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.","nodes":[{"pos":[0,123],"content":"Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.","nodes":[{"content":"Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.","pos":[0,123]}]}],"pos":[604813,604937],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|63|shr|Shifts an integer to the right (shifting in sign).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is pushed onto the stack.  \n  \n2.  The amount of bits to be shifted is pushed onto the stack.  \n  \n3.  The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits. The number of bits is a value of type `int32` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.  \n  \n `Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"63","nodes":[{"content":"63","pos":[0,2]}]},{"pos":[259,262],"content":"shr","nodes":[{"content":"shr","pos":[0,3]}]},{"pos":[263,313],"content":"Shifts an integer to the right (shifting in sign).","nodes":[{"content":"Shifts an integer to the right (shifting in sign).","pos":[0,50]}]},{"pos":[321,378],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[388,421],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[431,489],"content":"The amount of bits to be shifted is pushed onto the stack.","nodes":[{"content":"The amount of bits to be shifted is pushed onto the stack.","pos":[0,58]}]},{"pos":[499,632],"content":"The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.","nodes":[{"content":"The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.","pos":[0,133]}]},{"pos":[642,678],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[685,1007],"content":"The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits. The number of bits is a value of type `int32` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.","nodes":[{"content":"The <ph id=\"ph1\">`shr.un`</ph> instruction shifts the value (type <ph id=\"ph2\">`int32`</ph>, <ph id=\"ph3\">`int64`</ph> or <ph id=\"ph4\">`native int`</ph>) right by the specified number of bits.","pos":[0,120],"source":"The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits."},{"content":"The number of bits is a value of type <ph id=\"ph1\">`int32`</ph> or <ph id=\"ph2\">`native int`</ph>.","pos":[121,183],"source":" The number of bits is a value of type `int32` or `native int`."},{"content":"The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.","pos":[184,322]}]},{"pos":[1014,1123],"content":"<ph id=\"ph1\">`Shr`</ph> replicates the high order bit on each shift, preserving the sign of the original value in the <ph id=\"ph2\">`result`</ph>.","source":"`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`."},{"pos":[1130,1235],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`shr`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:"},{"pos":[1245,1269],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[604948,606242],"yaml":true,"extradata":"MT"},{"content":"Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.","nodes":[{"pos":[0,134],"content":"Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.","nodes":[{"content":"Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.","pos":[0,134]}]}],"pos":[607829,607964],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|64|shr.un|Shifts an integer to the right (shifting in zeroes).|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is pushed onto the stack.  \n  \n2.  The amount of bits to be shifted is pushed onto the stack.  \n  \n3.  The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.  \n  \n4.  The result is pushed onto the stack.  \n  \n The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits. The number of bits is a value of type `int32`, `int64` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.  \n  \n `Shr.un` inserts a zero bit in the highest position on each shift.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"64","nodes":[{"content":"64","pos":[0,2]}]},{"pos":[259,265],"content":"shr.un","nodes":[{"content":"shr.un","pos":[0,6]}]},{"pos":[266,318],"content":"Shifts an integer to the right (shifting in zeroes).","nodes":[{"content":"Shifts an integer to the right (shifting in zeroes).","pos":[0,52]}]},{"pos":[326,383],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[393,426],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[436,494],"content":"The amount of bits to be shifted is pushed onto the stack.","nodes":[{"content":"The amount of bits to be shifted is pushed onto the stack.","pos":[0,58]}]},{"pos":[504,637],"content":"The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.","nodes":[{"content":"The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.","pos":[0,133]}]},{"pos":[647,683],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[690,1021],"content":"The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits. The number of bits is a value of type `int32`, `int64` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.","nodes":[{"content":"The <ph id=\"ph1\">`shr.un`</ph> instruction shifts the value (type <ph id=\"ph2\">`int32`</ph>, <ph id=\"ph3\">`int64`</ph> or <ph id=\"ph4\">`native int`</ph>) right by the specified number of bits.","pos":[0,120],"source":"The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits."},{"content":"The number of bits is a value of type <ph id=\"ph1\">`int32`</ph>, <ph id=\"ph2\">`int64`</ph> or <ph id=\"ph3\">`native int`</ph>.","pos":[121,192],"source":" The number of bits is a value of type `int32`, `int64` or `native int`."},{"content":"The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.","pos":[193,331]}]},{"pos":[1028,1094],"content":"<ph id=\"ph1\">`Shr.un`</ph> inserts a zero bit in the highest position on each shift.","source":"`Shr.un` inserts a zero bit in the highest position on each shift."},{"pos":[1101,1209],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`shr.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:"},{"pos":[1219,1243],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[607975,609243],"yaml":true,"extradata":"MT"},{"content":"Pushes the size, in bytes, of a supplied value type onto the evaluation stack.","nodes":[{"pos":[0,78],"content":"Pushes the size, in bytes, of a supplied value type onto the evaluation stack.","nodes":[{"content":"Pushes the size, in bytes, of a supplied value type onto the evaluation stack.","pos":[0,78]}]}],"pos":[610833,610912],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 1C < `T` >|sizeof `valType`|Push the size, in bytes, of a value type as an `unsigned int32`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.  \n  \n `valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.  \n  \n For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value. A generic type parameter can be used only in the body of the type or method that defines it. When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,269],"content":"FE 1C &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 1C < `T` >"},{"pos":[270,286],"content":"sizeof <ph id=\"ph1\">`valType`</ph>","source":"sizeof `valType`"},{"pos":[287,351],"content":"Push the size, in bytes, of a value type as an <ph id=\"ph1\">`unsigned int32`</ph>.","source":"Push the size, in bytes, of a value type as an `unsigned int32`."},{"pos":[359,416],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[426,510],"content":"The size (in bytes) of the supplied value type (<ph id=\"ph1\">`valType`</ph>) is pushed onto the stack.","source":"The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack."},{"pos":[517,650],"content":"<ph id=\"ph1\">`valType`</ph> must be a metadata token (a <ph id=\"ph2\">`typeref`</ph> or <ph id=\"ph3\">`typedef`</ph>) that specifies a value type, reference type, or generic type parameter.","source":"`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter."},{"pos":[657,1072],"content":"For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value. A generic type parameter can be used only in the body of the type or method that defines it. When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.","nodes":[{"content":"For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value. A generic type parameter can be used only in the body of the type or method that defines it. When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.","pos":[0,415],"nodes":[{"content":"For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.","pos":[0,206]},{"content":"A generic type parameter can be used only in the body of the type or method that defines it.","pos":[207,299]},{"content":"When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.","pos":[300,415]}]}]},{"pos":[1079,1187],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`sizeof`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:"},{"pos":[1197,1227],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[610923,612169],"yaml":true,"extradata":"MT"},{"content":"Stores the value on top of the evaluation stack in the argument slot at a specified index.","nodes":[{"pos":[0,90],"content":"Stores the value on top of the evaluation stack in the argument slot at a specified index.","nodes":[{"content":"Stores the value on top of the evaluation stack in the argument slot at a specified index.","pos":[0,90]}]}],"pos":[613753,613844],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 0B < `unsigned int16` >|starg `num`|Pops the top value from the stack and stores it in argument slot `num`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value currently on top of the stack is popped and placed in argument slot `num`.  \n  \n The `starg` instruction pops a value from the stack and places it in argument slot `num`. The type of the value must match the type of the argument, as specified in the current method's signature.  \n  \n For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \n  \n Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:  \n  \n-   ILGenerator.Emit(OpCode, short)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,282],"content":"FE 0B &lt; <ph id=\"ph1\">`unsigned int16`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 0B < `unsigned int16` >"},{"pos":[283,294],"content":"starg <ph id=\"ph1\">`num`</ph>","source":"starg `num`"},{"pos":[295,366],"content":"Pops the top value from the stack and stores it in argument slot <ph id=\"ph1\">`num`</ph>.","source":"Pops the top value from the stack and stores it in argument slot `num`."},{"pos":[374,431],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[441,525],"content":"The value currently on top of the stack is popped and placed in argument slot <ph id=\"ph1\">`num`</ph>.","source":"The value currently on top of the stack is popped and placed in argument slot `num`."},{"pos":[532,728],"content":"The `starg` instruction pops a value from the stack and places it in argument slot `num`. The type of the value must match the type of the argument, as specified in the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`starg`</ph> instruction pops a value from the stack and places it in argument slot <ph id=\"ph2\">`num`</ph>.","pos":[0,89],"source":"The `starg` instruction pops a value from the stack and places it in argument slot `num`."},{"content":"The type of the value must match the type of the argument, as specified in the current method's signature.","pos":[90,196]}]},{"pos":[735,908],"content":"For procedures that take a variable argument list, the <ph id=\"ph1\">`starg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.","source":"For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature."},{"pos":[915,1175],"content":"Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.","pos":[0,150]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[151,260],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1182,1289],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`starg`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:"},{"pos":[1299,1330],"content":"ILGenerator.Emit(OpCode, short)","nodes":[{"content":"ILGenerator.Emit(OpCode, short)","pos":[0,31]}]}],"pos":[613855,615206],"yaml":true,"extradata":"MT"},{"content":"Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.","nodes":[{"pos":[0,102],"content":"Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.","nodes":[{"content":"Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.","pos":[0,102]}]}],"pos":[616801,616904],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|10 < `unsigned int8` >|starg.s `num`|Pops the top value from the stack and stores it in argument slot `num`, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  The value currently on top of the stack is popped and placed in argument slot `num`.  \n  \n The `starg.s` instruction pops a value from the stack and places it in argument slot `num`. The type of the value must match the type of the argument, as specified in the current method's signature.  \n  \n The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.  \n  \n For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \n  \n Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A>method overload can use the `starg.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,278],"content":"10 &lt; <ph id=\"ph1\">`unsigned int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"10 < `unsigned int8` >"},{"pos":[279,292],"content":"starg.s <ph id=\"ph1\">`num`</ph>","source":"starg.s `num`"},{"pos":[293,376],"content":"Pops the top value from the stack and stores it in argument slot <ph id=\"ph1\">`num`</ph>, short form.","source":"Pops the top value from the stack and stores it in argument slot `num`, short form."},{"pos":[384,441],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[451,535],"content":"The value currently on top of the stack is popped and placed in argument slot <ph id=\"ph1\">`num`</ph>.","source":"The value currently on top of the stack is popped and placed in argument slot `num`."},{"pos":[542,740],"content":"The `starg.s` instruction pops a value from the stack and places it in argument slot `num`. The type of the value must match the type of the argument, as specified in the current method's signature.","nodes":[{"content":"The <ph id=\"ph1\">`starg.s`</ph> instruction pops a value from the stack and places it in argument slot <ph id=\"ph2\">`num`</ph>.","pos":[0,91],"source":"The `starg.s` instruction pops a value from the stack and places it in argument slot `num`."},{"content":"The type of the value must match the type of the argument, as specified in the current method's signature.","pos":[92,198]}]},{"pos":[747,841],"content":"The <ph id=\"ph1\">`starg.s`</ph> instruction provides an efficient encoding for use with the first 256 arguments.","source":"The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments."},{"pos":[848,1023],"content":"For procedures that take a variable argument list, the <ph id=\"ph1\">`starg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.","source":"For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature."},{"pos":[1030,1290],"content":"Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.","pos":[0,150]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[151,260],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1297,1405],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>method overload can use the <ph id=\"ph2\">`starg.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A>method overload can use the `starg.s` opcode:"},{"pos":[1415,1445],"content":"ILGenerator.Emit(OpCode, byte)","nodes":[{"content":"ILGenerator.Emit(OpCode, byte)","pos":[0,30]}]}],"pos":[616915,618383],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.","nodes":[{"pos":[0,127],"content":"Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.","nodes":[{"content":"Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.","pos":[0,127]}]}],"pos":[619974,620102],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|A4 < `T` >|stelem `typeTok`|Replaces the array element at the supplied index with a value of type `typeTok` on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  An index value, `index`, to an element in `array` is pushed onto the stack.  \n  \n3.  A value of the type specified in the instruction is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value. The value has the type specified by the token `typeTok` in the instruction.  \n  \n Arrays are objects, and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"A4 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"A4 < `T` >"},{"pos":[267,283],"content":"stelem <ph id=\"ph1\">`typeTok`</ph>","source":"stelem `typeTok`"},{"pos":[284,377],"content":"Replaces the array element at the supplied index with a value of type <ph id=\"ph1\">`typeTok`</ph> on the stack.","source":"Replaces the array element at the supplied index with a value of type `typeTok` on the stack."},{"pos":[385,442],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[452,519],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[529,604],"content":"An index value, <ph id=\"ph1\">`index`</ph>, to an element in <ph id=\"ph2\">`array`</ph> is pushed onto the stack.","source":"An index value, `index`, to an element in `array` is pushed onto the stack."},{"pos":[614,688],"content":"A value of the type specified in the instruction is pushed onto the stack.","nodes":[{"content":"A value of the type specified in the instruction is pushed onto the stack.","pos":[0,74]}]},{"pos":[698,830],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[837,1057],"content":"The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value. The value has the type specified by the token `typeTok` in the instruction.","nodes":[{"content":"The <ph id=\"ph1\">`stelem`</ph> instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <ph id=\"ph2\">`array`</ph> with the value.","pos":[0,144],"source":"The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value."},{"content":"The value has the type specified by the token <ph id=\"ph1\">`typeTok`</ph> in the instruction.","pos":[145,220],"source":" The value has the type specified by the token `typeTok` in the instruction."}]},{"pos":[1064,1161],"content":"Arrays are objects, and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects, and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,65],"source":"Arrays are objects, and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[66,97],"source":" The index is type `native int`."}]},{"pos":[1168,1246],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1253,1362],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1369,1475],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1482,1590],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:"},{"pos":[1600,1630],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[620113,621774],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the `native int` value on the evaluation stack.","nodes":[{"pos":[0,96],"content":"Replaces the array element at a given index with the <ph id=\"ph1\">`native int`</ph> value on the evaluation stack.","source":"Replaces the array element at a given index with the `native int` value on the evaluation stack."}],"pos":[623376,623473],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|9B|stelem.i|Replaces an array element at the supplied index with the `native int` value on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"9B","nodes":[{"content":"9B","pos":[0,2]}]},{"pos":[259,267],"content":"stelem.i","nodes":[{"content":"stelem.i","pos":[0,8]}]},{"pos":[268,357],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`native int`</ph> value on the stack.","source":"Replaces an array element at the supplied index with the `native int` value on the stack."},{"pos":[365,422],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[432,499],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[509,573],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[583,616],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[626,758],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[765,921],"content":"The <ph id=\"ph1\">`stelem.i`</ph> instruction replaces the value of the element <ph id=\"ph2\">`index`</ph> in the one-dimensional array <ph id=\"ph3\">`array`</ph> with the <ph id=\"ph4\">`native int`</ph> value pushed onto the stack.","source":"The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack."},{"pos":[928,1024],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1031,1109],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1116,1225],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1232,1338],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1345,1455],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.i`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:"},{"pos":[1465,1489],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[623484,625004],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the `int8` value on the evaluation stack.","nodes":[{"pos":[0,90],"content":"Replaces the array element at a given index with the <ph id=\"ph1\">`int8`</ph> value on the evaluation stack.","source":"Replaces the array element at a given index with the `int8` value on the evaluation stack."}],"pos":[626614,626705],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|9C|stelem.i1|Replaces an array element at the supplied index with the `int8` value on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"9C","nodes":[{"content":"9C","pos":[0,2]}]},{"pos":[259,268],"content":"stelem.i1","nodes":[{"content":"stelem.i1","pos":[0,9]}]},{"pos":[269,352],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`int8`</ph> value on the stack.","source":"Replaces an array element at the supplied index with the `int8` value on the stack."},{"pos":[360,417],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[427,494],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[504,568],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[578,611],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[621,753],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[760,911],"content":"The <ph id=\"ph1\">`stelem.i1`</ph> instruction replaces the value of the element <ph id=\"ph2\">`index`</ph> in the one-dimensional array <ph id=\"ph3\">`array`</ph> with the <ph id=\"ph4\">`int8`</ph> value pushed onto the stack.","source":"The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack."},{"pos":[918,1014],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1021,1099],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1106,1215],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1222,1328],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1335,1446],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.i1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:"},{"pos":[1456,1480],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[626716,628227],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the `int16` value on the evaluation stack.","nodes":[{"pos":[0,91],"content":"Replaces the array element at a given index with the <ph id=\"ph1\">`int16`</ph> value on the evaluation stack.","source":"Replaces the array element at a given index with the `int16` value on the evaluation stack."}],"pos":[629838,629930],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|9D|stelem.i2|Replaces an array element at the supplied index with the `int16` value on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"9D","nodes":[{"content":"9D","pos":[0,2]}]},{"pos":[259,268],"content":"stelem.i2","nodes":[{"content":"stelem.i2","pos":[0,9]}]},{"pos":[269,353],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`int16`</ph> value on the stack.","source":"Replaces an array element at the supplied index with the `int16` value on the stack."},{"pos":[361,418],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[428,495],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[505,569],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[579,612],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[622,754],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[761,913],"content":"The <ph id=\"ph1\">`stelem.i2`</ph> instruction replaces the value of the element <ph id=\"ph2\">`index`</ph> in the one-dimensional array <ph id=\"ph3\">`array`</ph> with the <ph id=\"ph4\">`int16`</ph> value pushed onto the stack.","source":"The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack."},{"pos":[920,1016],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1023,1101],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1108,1217],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1224,1330],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1337,1448],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.i2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:"},{"pos":[1458,1482],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[629941,631454],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the `int32` value on the evaluation stack.","nodes":[{"pos":[0,91],"content":"Replaces the array element at a given index with the <ph id=\"ph1\">`int32`</ph> value on the evaluation stack.","source":"Replaces the array element at a given index with the `int32` value on the evaluation stack."}],"pos":[633065,633157],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|9E|stelem.i4|Replaces an array element at the supplied index with the `int32` value on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"9E","nodes":[{"content":"9E","pos":[0,2]}]},{"pos":[259,268],"content":"stelem.i4","nodes":[{"content":"stelem.i4","pos":[0,9]}]},{"pos":[269,353],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`int32`</ph> value on the stack.","source":"Replaces an array element at the supplied index with the `int32` value on the stack."},{"pos":[361,418],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[428,495],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[505,569],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[579,612],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[622,754],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[761,913],"content":"The <ph id=\"ph1\">`stelem.i4`</ph> instruction replaces the value of the element <ph id=\"ph2\">`index`</ph> in the one-dimensional array <ph id=\"ph3\">`array`</ph> with the <ph id=\"ph4\">`int32`</ph> value pushed onto the stack.","source":"The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack."},{"pos":[920,1016],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1023,1101],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1108,1217],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1224,1330],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1337,1448],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.i4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:"},{"pos":[1458,1482],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[633168,634681],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the `int64` value on the evaluation stack.","nodes":[{"pos":[0,91],"content":"Replaces the array element at a given index with the <ph id=\"ph1\">`int64`</ph> value on the evaluation stack.","source":"Replaces the array element at a given index with the `int64` value on the evaluation stack."}],"pos":[636292,636384],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|9F|stelem.i8|Replaces an array element at the supplied index with the `int64` value on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"9F","nodes":[{"content":"9F","pos":[0,2]}]},{"pos":[259,268],"content":"stelem.i8","nodes":[{"content":"stelem.i8","pos":[0,9]}]},{"pos":[269,353],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`int64`</ph> value on the stack.","source":"Replaces an array element at the supplied index with the `int64` value on the stack."},{"pos":[361,418],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[428,495],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[505,569],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[579,612],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[622,754],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[761,913],"content":"The <ph id=\"ph1\">`stelem.i8`</ph> instruction replaces the value of the element <ph id=\"ph2\">`index`</ph> in the one-dimensional array <ph id=\"ph3\">`array`</ph> with the <ph id=\"ph4\">`int64`</ph> value pushed onto the stack.","source":"The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack."},{"pos":[920,1016],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1023,1101],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1108,1217],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1224,1330],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1337,1448],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.i8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:"},{"pos":[1458,1482],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[636395,637908],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the `float32` value on the evaluation stack.","nodes":[{"pos":[0,93],"content":"Replaces the array element at a given index with the <ph id=\"ph1\">`float32`</ph> value on the evaluation stack.","source":"Replaces the array element at a given index with the `float32` value on the evaluation stack."}],"pos":[639519,639613],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|A0|stelem.r4|Replaces an array element at the supplied index with the `float32` value on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"A0","nodes":[{"content":"A0","pos":[0,2]}]},{"pos":[259,268],"content":"stelem.r4","nodes":[{"content":"stelem.r4","pos":[0,9]}]},{"pos":[269,355],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`float32`</ph> value on the stack.","source":"Replaces an array element at the supplied index with the `float32` value on the stack."},{"pos":[363,420],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[430,497],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[507,571],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[581,614],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[624,756],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[763,917],"content":"The <ph id=\"ph1\">`stelem.r4`</ph> instruction replaces the value of the element <ph id=\"ph2\">`index`</ph> in the one-dimensional array <ph id=\"ph3\">`array`</ph> with the <ph id=\"ph4\">`float32`</ph> value pushed onto the stack.","source":"The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack."},{"pos":[924,1020],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1027,1105],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1112,1221],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1228,1334],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1341,1452],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.r4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:"},{"pos":[1462,1486],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[639624,641141],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the `float64` value on the evaluation stack.","nodes":[{"pos":[0,93],"content":"Replaces the array element at a given index with the <ph id=\"ph1\">`float64`</ph> value on the evaluation stack.","source":"Replaces the array element at a given index with the `float64` value on the evaluation stack."}],"pos":[642752,642846],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|A1|stelem.r8|Replaces an array element at the supplied index with the `float64` value on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"A1","nodes":[{"content":"A1","pos":[0,2]}]},{"pos":[259,268],"content":"stelem.r8","nodes":[{"content":"stelem.r8","pos":[0,9]}]},{"pos":[269,355],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`float64`</ph> value on the stack.","source":"Replaces an array element at the supplied index with the `float64` value on the stack."},{"pos":[363,420],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[430,497],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[507,571],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[581,614],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[624,756],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[763,917],"content":"The <ph id=\"ph1\">`stelem.r8`</ph> instruction replaces the value of the element <ph id=\"ph2\">`index`</ph> in the one-dimensional array <ph id=\"ph3\">`array`</ph> with the <ph id=\"ph4\">`float64`</ph> value pushed onto the stack.","source":"The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack."},{"pos":[924,1020],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1027,1105],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1112,1221],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1228,1334],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1341,1452],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.r8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:"},{"pos":[1462,1486],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[642857,644374],"yaml":true,"extradata":"MT"},{"content":"Replaces the array element at a given index with the object ref value (type `O`) on the evaluation stack.","nodes":[{"pos":[0,105],"content":"Replaces the array element at a given index with the object ref value (type <ph id=\"ph1\">`O`</ph>) on the evaluation stack.","source":"Replaces the array element at a given index with the object ref value (type `O`) on the evaluation stack."}],"pos":[645991,646097],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|A2|stelem.ref|Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference to an array, `array`, is pushed onto the stack.  \n  \n2.  A valid index to an element in `array` is pushed onto the stack.  \n  \n3.  A value is pushed onto the stack.  \n  \n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \n  \n The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.  \n  \n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \n  \n Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element. This cast can fail, even for verified code. Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>. For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.  \n  \n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \n  \n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \n  \n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"A2","nodes":[{"content":"A2","pos":[0,2]}]},{"pos":[259,269],"content":"stelem.ref","nodes":[{"content":"stelem.ref","pos":[0,10]}]},{"pos":[270,363],"content":"Replaces an array element at the supplied index with the <ph id=\"ph1\">`ref`</ph> value (type <ph id=\"ph2\">`O`</ph>) on the stack.","source":"Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack."},{"pos":[371,428],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[438,505],"content":"An object reference to an array, <ph id=\"ph1\">`array`</ph>, is pushed onto the stack.","source":"An object reference to an array, `array`, is pushed onto the stack."},{"pos":[515,579],"content":"A valid index to an element in <ph id=\"ph1\">`array`</ph> is pushed onto the stack.","source":"A valid index to an element in `array` is pushed onto the stack."},{"pos":[589,622],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[632,764],"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","nodes":[{"content":"The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.","pos":[0,132]}]},{"pos":[771,947],"content":"The <ph id=\"ph1\">`stelem.ref`</ph> instruction replaces the value of the element at the supplied index in the one-dimensional array <ph id=\"ph2\">`array`</ph> with the <ph id=\"ph3\">`ref`</ph> (type <ph id=\"ph4\">`O`</ph>) value pushed onto the stack.","source":"The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack."},{"pos":[954,1050],"content":"Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.","nodes":[{"content":"Arrays are objects and hence represented by a value of type <ph id=\"ph1\">`O`</ph>.","pos":[0,64],"source":"Arrays are objects and hence represented by a value of type `O`."},{"content":"The index is type <ph id=\"ph1\">`native int`</ph>.","pos":[65,96],"source":" The index is type `native int`."}]},{"pos":[1057,1483],"content":"Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element. This cast can fail, even for verified code. Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>. For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.","nodes":[{"content":"Note that <ph id=\"ph1\">`stelem.ref`</ph> implicitly casts the supplied value to the element type of <ph id=\"ph2\">`array`</ph> before assigning the value to the array element.","pos":[0,138],"source":"Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element."},{"content":"This cast can fail, even for verified code.","pos":[139,182]},{"content":"Thus the <ph id=\"ph1\">`stelem.ref`</ph> instruction can throw <ph id=\"ph2\">&lt;xref:System.InvalidCastException&gt;</ph>.","pos":[183,262],"source":" Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>."},{"content":"For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> class provides a <ph id=\"ph2\">&lt;xref:System.Array.SetValue%2A&gt;</ph> method.","pos":[263,426],"source":" For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method."}]},{"pos":[1490,1568],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `array` is a null reference."},{"pos":[1575,1684],"content":"<ph id=\"ph1\">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id=\"ph2\">`index`</ph> is negative, or larger than the bound of <ph id=\"ph3\">`array`</ph>.","source":"<xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`."},{"pos":[1691,1797],"content":"<ph id=\"ph1\">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id=\"ph2\">`array`</ph> does not hold elements of the required type.","source":"<xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type."},{"pos":[1804,1916],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stelem.ref`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:"},{"pos":[1926,1950],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[646108,648091],"yaml":true,"extradata":"MT"},{"content":"Replaces the value stored in the field of an object reference or pointer with a new value.","nodes":[{"pos":[0,90],"content":"Replaces the value stored in the field of an object reference or pointer with a new value.","nodes":[{"content":"Replaces the value stored in the field of an object reference or pointer with a new value.","pos":[0,90]}]}],"pos":[649679,649770],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|7D < `T` >|stfld `field`|Replaces the value of `field` of the object with a new value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference or pointer is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.  \n  \n The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value. `Field` is a metadata token that refers to a field member reference. The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.  \n  \n <xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.  \n  \n <xref:System.MissingFieldException> is thrown if `field` is not found in the metadata. This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:  \n  \n-   ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"7D &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"7D < `T` >"},{"pos":[267,280],"content":"stfld <ph id=\"ph1\">`field`</ph>","source":"stfld `field`"},{"pos":[281,342],"content":"Replaces the value of <ph id=\"ph1\">`field`</ph> of the object with a new value.","source":"Replaces the value of `field` of the object with a new value."},{"pos":[350,407],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[417,473],"content":"An object reference or pointer is pushed onto the stack.","nodes":[{"content":"An object reference or pointer is pushed onto the stack.","pos":[0,56]}]},{"pos":[483,516],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[526,667],"content":"The value and the object reference/pointer are popped from the stack; the value of <ph id=\"ph1\">`field`</ph> in the object is replaced with the supplied value.","source":"The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value."},{"pos":[674,1053],"content":"The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value. `Field` is a metadata token that refers to a field member reference. The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.","nodes":[{"content":"The <ph id=\"ph1\">`stfld`</ph> instruction replaces the value of a field of an object (type <ph id=\"ph2\">`O`</ph>) or via a pointer (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`&amp;`</ph>, or <ph id=\"ph5\">`*`</ph>) with a given value.","pos":[0,147],"source":"The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value."},{"content":"<ph id=\"ph1\">`Field`</ph> is a metadata token that refers to a field member reference.","pos":[148,216],"source":"`Field` is a metadata token that refers to a field member reference."},{"content":"The <ph id=\"ph1\">`stfld`</ph> instruction can have a prefix of either or both of <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.","pos":[217,379],"source":" The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>."}]},{"pos":[1060,1189],"content":"<xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference or pointer is a null reference and the field isn't static.","pos":[0,129],"source":"<xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static."}]},{"pos":[1196,1413],"content":"<xref:System.MissingFieldException> is thrown if `field` is not found in the metadata. This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if <ph id=\"ph2\">`field`</ph> is not found in the metadata.","pos":[0,86],"source":"<xref:System.MissingFieldException> is thrown if `field` is not found in the metadata."},{"content":"This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.","pos":[87,217]}]},{"pos":[1420,1527],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stfld`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:"},{"pos":[1537,1572],"content":"ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, FieldInfo)","pos":[0,35]}]}],"pos":[649781,651378],"yaml":true,"extradata":"MT"},{"content":"Stores a value of type `native int` at a supplied address.","nodes":[{"pos":[0,58],"content":"Stores a value of type <ph id=\"ph1\">`native int`</ph> at a supplied address.","source":"Stores a value of type `native int` at a supplied address."}],"pos":[652973,653032],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|DF|stind.i|Stores a `native int` value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"DF","nodes":[{"content":"DF","pos":[0,2]}]},{"pos":[259,266],"content":"stind.i","nodes":[{"content":"stind.i","pos":[0,7]}]},{"pos":[267,314],"content":"Stores a <ph id=\"ph1\">`native int`</ph> value at a given address.","source":"Stores a `native int` value at a given address."},{"pos":[322,379],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[389,425],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[435,468],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[478,566],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[573,684],"content":"The <ph id=\"ph1\">`stind.i`</ph> instruction stores a <ph id=\"ph2\">`native int`</ph> value at the supplied address (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`&amp;`</ph>).","source":"The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[691,1015],"content":"Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.i`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,120],"source":"Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","pos":[121,324],"source":" The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."}]},{"pos":[1022,1160],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1167,1276],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.i`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:"},{"pos":[1286,1310],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[653043,654378],"yaml":true,"extradata":"MT"},{"content":"Stores a value of type `int8` at a supplied address.","nodes":[{"pos":[0,52],"content":"Stores a value of type <ph id=\"ph1\">`int8`</ph> at a supplied address.","source":"Stores a value of type `int8` at a supplied address."}],"pos":[655981,656034],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|52|stind.i1|Stores an `int8` value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"52","nodes":[{"content":"52","pos":[0,2]}]},{"pos":[259,267],"content":"stind.i1","nodes":[{"content":"stind.i1","pos":[0,8]}]},{"pos":[268,310],"content":"Stores an <ph id=\"ph1\">`int8`</ph> value at a given address.","source":"Stores an `int8` value at a given address."},{"pos":[318,375],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[385,421],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[431,464],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[474,562],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[569,676],"content":"The <ph id=\"ph1\">`stind.i1`</ph> instruction stores an <ph id=\"ph2\">`int8`</ph> value at the supplied address (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`&amp;`</ph>).","source":"The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[683,1009],"content":"Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.i1`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,121],"source":"Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.i1`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","pos":[122,326],"source":" The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."}]},{"pos":[1016,1154],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1161,1271],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.i1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:"},{"pos":[1281,1305],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[656045,657375],"yaml":true,"extradata":"MT"},{"content":"Stores a value of type `int16` at a supplied address.","nodes":[{"pos":[0,53],"content":"Stores a value of type <ph id=\"ph1\">`int16`</ph> at a supplied address.","source":"Stores a value of type `int16` at a supplied address."}],"pos":[658979,659033],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|53|stind.i2|Stores an `int16` value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned>prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"53","nodes":[{"content":"53","pos":[0,2]}]},{"pos":[259,267],"content":"stind.i2","nodes":[{"content":"stind.i2","pos":[0,8]}]},{"pos":[268,311],"content":"Stores an <ph id=\"ph1\">`int16`</ph> value at a given address.","source":"Stores an `int16` value at a given address."},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,422],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[432,465],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[475,563],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[570,678],"content":"The <ph id=\"ph1\">`stind.i2`</ph> instruction stores an <ph id=\"ph2\">`int16`</ph> value at the supplied address (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`&amp;`</ph>).","source":"The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[685,1010],"content":"Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned>prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.2i`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,121],"source":"Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.i2`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>prefix instruction.","pos":[122,325],"source":" The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned>prefix instruction."}]},{"pos":[1017,1155],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1162,1272],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.i2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:"},{"pos":[1282,1306],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[659044,660375],"yaml":true,"extradata":"MT"},{"content":"Stores a value of type `int32` at a supplied address.","nodes":[{"pos":[0,53],"content":"Stores a value of type <ph id=\"ph1\">`int32`</ph> at a supplied address.","source":"Stores a value of type `int32` at a supplied address."}],"pos":[661979,662033],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|54|stind.i4|Stores an `int32` value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"54","nodes":[{"content":"54","pos":[0,2]}]},{"pos":[259,267],"content":"stind.i4","nodes":[{"content":"stind.i4","pos":[0,8]}]},{"pos":[268,311],"content":"Stores an <ph id=\"ph1\">`int32`</ph> value at a given address.","source":"Stores an `int32` value at a given address."},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,422],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[432,465],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[475,563],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[570,678],"content":"The <ph id=\"ph1\">`stind.i4`</ph> instruction stores an <ph id=\"ph2\">`int32`</ph> value at the supplied address (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`&amp;`</ph>).","source":"The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[685,1011],"content":"Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.i4`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,121],"source":"Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.i4`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","pos":[122,326],"source":" The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."}]},{"pos":[1018,1156],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1163,1273],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.i4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:"},{"pos":[1283,1307],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[662044,663376],"yaml":true,"extradata":"MT"},{"content":"Stores a value of type `int64` at a supplied address.","nodes":[{"pos":[0,53],"content":"Stores a value of type <ph id=\"ph1\">`int64`</ph> at a supplied address.","source":"Stores a value of type `int64` at a supplied address."}],"pos":[664980,665034],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|55|stind.i8|Stores an `int64` value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"55","nodes":[{"content":"55","pos":[0,2]}]},{"pos":[259,267],"content":"stind.i8","nodes":[{"content":"stind.i8","pos":[0,8]}]},{"pos":[268,311],"content":"Stores an <ph id=\"ph1\">`int64`</ph> value at a given address.","source":"Stores an `int64` value at a given address."},{"pos":[319,376],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[386,422],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[432,465],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[475,563],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[570,678],"content":"The <ph id=\"ph1\">`stind.i8`</ph> instruction stores an <ph id=\"ph2\">`int64`</ph> value at the supplied address (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`&amp;`</ph>).","source":"The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[685,1010],"content":"Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.i8`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,121],"source":"Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","pos":[122,325],"source":" The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."}]},{"pos":[1017,1155],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1162,1272],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.i8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:"},{"pos":[1282,1306],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[665045,666376],"yaml":true,"extradata":"MT"},{"content":"Stores a value of type `float32` at a supplied address.","nodes":[{"pos":[0,55],"content":"Stores a value of type <ph id=\"ph1\">`float32`</ph> at a supplied address.","source":"Stores a value of type `float32` at a supplied address."}],"pos":[667980,668036],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|56|stind.r4|Stores a `float32` value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"56","nodes":[{"content":"56","pos":[0,2]}]},{"pos":[259,267],"content":"stind.r4","nodes":[{"content":"stind.r4","pos":[0,8]}]},{"pos":[268,312],"content":"Stores a <ph id=\"ph1\">`float32`</ph> value at a given address.","source":"Stores a `float32` value at a given address."},{"pos":[320,377],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[387,423],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[433,466],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[476,564],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[571,680],"content":"The <ph id=\"ph1\">`stind.r4`</ph> instruction stores a <ph id=\"ph2\">`float32`</ph> value at the supplied address (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`&amp;`</ph>).","source":"The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[687,1013],"content":"Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.r4`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,121],"source":"Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.r4`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","pos":[122,326],"source":" The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."}]},{"pos":[1020,1158],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1165,1275],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.r4`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:"},{"pos":[1285,1309],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[668047,669381],"yaml":true,"extradata":"MT"},{"content":"Stores a value of type `float64` at a supplied address.","nodes":[{"pos":[0,55],"content":"Stores a value of type <ph id=\"ph1\">`float64`</ph> at a supplied address.","source":"Stores a value of type `float64` at a supplied address."}],"pos":[670985,671041],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|57|stind.r8|Stores a `float64` value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"57","nodes":[{"content":"57","pos":[0,2]}]},{"pos":[259,267],"content":"stind.r8","nodes":[{"content":"stind.r8","pos":[0,8]}]},{"pos":[268,312],"content":"Stores a <ph id=\"ph1\">`float64`</ph> value at a given address.","source":"Stores a `float64` value at a given address."},{"pos":[320,377],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[387,423],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[433,466],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[476,564],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[571,680],"content":"The <ph id=\"ph1\">`stind.r8`</ph> instruction stores a <ph id=\"ph2\">`float64`</ph> value at the supplied address (type <ph id=\"ph3\">`native int`</ph>, <ph id=\"ph4\">`*`</ph>, or <ph id=\"ph5\">`&amp;`</ph>).","source":"The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[687,1013],"content":"Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.r8`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,121],"source":"Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.r8`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","pos":[122,326],"source":" The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."}]},{"pos":[1020,1158],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1165,1275],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.r8`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:"},{"pos":[1285,1309],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[671052,672386],"yaml":true,"extradata":"MT"},{"content":"Stores a object reference value at a supplied address.","nodes":[{"pos":[0,54],"content":"Stores a object reference value at a supplied address.","nodes":[{"content":"Stores a object reference value at a supplied address.","pos":[0,54]}]}],"pos":[673996,674051],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|51|stind.ref|Stores an object reference (type `O`) value at a given address.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value is pushed onto the stack.  \n  \n3.  The value and the address are popped from the stack; the value is stored at the address.  \n  \n The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).  \n  \n Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"51","nodes":[{"content":"51","pos":[0,2]}]},{"pos":[259,268],"content":"stind.ref","nodes":[{"content":"stind.ref","pos":[0,9]}]},{"pos":[269,332],"content":"Stores an object reference (type <ph id=\"ph1\">`O`</ph>) value at a given address.","source":"Stores an object reference (type `O`) value at a given address."},{"pos":[340,397],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[407,443],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[453,486],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[496,584],"content":"The value and the address are popped from the stack; the value is stored at the address.","nodes":[{"content":"The value and the address are popped from the stack; the value is stored at the address.","pos":[0,88]}]},{"pos":[591,709],"content":"The <ph id=\"ph1\">`stind.ref`</ph> instruction stores an object reference value at the supplied address (type <ph id=\"ph2\">`native int`</ph>, <ph id=\"ph3\">`*`</ph>, or <ph id=\"ph4\">`&amp;`</ph>).","source":"The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`)."},{"pos":[716,1044],"content":"Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.","nodes":[{"content":"Type safe operation requires that the <ph id=\"ph1\">`stind.ref`</ph> instruction be used in a manner consistent with the type of the pointer.","pos":[0,122],"source":"Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer."},{"content":"The operation of the <ph id=\"ph1\">`stind.ref`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","pos":[123,328],"source":" The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."}]},{"pos":[1051,1189],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.","source":"<xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix."},{"pos":[1196,1307],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stind.ref`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:"},{"pos":[1317,1341],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[674062,675428],"yaml":true,"extradata":"MT"},{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.","nodes":[{"pos":[0,124],"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.","nodes":[{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.","pos":[0,124]}]}],"pos":[677015,677140],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 0E < `unsigned int16` >|stloc `index`|Pops a value from the stack and stores it in local variable `index`.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is popped off of the stack and placed in local variable `index`.  \n  \n The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.  \n  \n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index. For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid). The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:  \n  \n-   ILGenerator.Emit(OpCode, LocalBuilder)  \n  \n-   ILGenerator.Emit(OpCode, short)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,282],"content":"FE 0E &lt; <ph id=\"ph1\">`unsigned int16`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 0E < `unsigned int16` >"},{"pos":[283,296],"content":"stloc <ph id=\"ph1\">`index`</ph>","source":"stloc `index`"},{"pos":[297,365],"content":"Pops a value from the stack and stores it in local variable <ph id=\"ph1\">`index`</ph>.","source":"Pops a value from the stack and stores it in local variable `index`."},{"pos":[373,430],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[440,512],"content":"A value is popped off of the stack and placed in local variable <ph id=\"ph1\">`index`</ph>.","source":"A value is popped off of the stack and placed in local variable `index`."},{"pos":[519,799],"content":"The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.","nodes":[{"content":"The <ph id=\"ph1\">`stloc`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id=\"ph2\">`index`</ph>, where local variables are numbered 0 onwards.","pos":[0,162],"source":"The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards."},{"content":"The type of the value must match the type of the local variable as specified in the current method's local signature.","pos":[163,280]}]},{"pos":[806,1058],"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.","pos":[0,142]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[143,252],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1065,1591],"content":"Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index. For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid). The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.","nodes":[{"content":"Correct Microsoft Intermediate Language (MSIL) instructions require that <ph id=\"ph1\">`index`</ph> be a valid local index.","pos":[0,104],"source":"Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index."},{"content":"For the <ph id=\"ph1\">`stloc`</ph> instruction, <ph id=\"ph2\">`index`</ph> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).","pos":[105,220],"source":" For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid)."},{"content":"The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.","pos":[221,403]},{"content":"If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.","pos":[404,526]}]},{"pos":[1598,1706],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`stloc`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:"},{"pos":[1716,1754],"content":"ILGenerator.Emit(OpCode, LocalBuilder)","nodes":[{"content":"ILGenerator.Emit(OpCode, LocalBuilder)","pos":[0,38]}]},{"pos":[1764,1795],"content":"ILGenerator.Emit(OpCode, short)","nodes":[{"content":"ILGenerator.Emit(OpCode, short)","pos":[0,31]}]}],"pos":[677151,678969],"yaml":true,"extradata":"MT"},{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.","nodes":[{"pos":[0,114],"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.","nodes":[{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.","pos":[0,114]}]}],"pos":[680564,680679],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|0A|stloc.0|Pops a value from the stack into local variable 0.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is popped off of the stack and placed in the local variable indexed by 0.  \n  \n The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0. The type of the value must match the type of the local variable as specified in the current method's local signature.  \n  \n `stloc.0` is an especially efficient encoding for storing values in local variable 0.  \n  \n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"0A","nodes":[{"content":"0A","pos":[0,2]}]},{"pos":[259,266],"content":"stloc.0","nodes":[{"content":"stloc.0","pos":[0,7]}]},{"pos":[267,317],"content":"Pops a value from the stack into local variable 0.","nodes":[{"content":"Pops a value from the stack into local variable 0.","pos":[0,50]}]},{"pos":[325,382],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[392,473],"content":"A value is popped off of the stack and placed in the local variable indexed by 0.","nodes":[{"content":"A value is popped off of the stack and placed in the local variable indexed by 0.","pos":[0,81]}]},{"pos":[480,718],"content":"The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0. The type of the value must match the type of the local variable as specified in the current method's local signature.","nodes":[{"content":"The <ph id=\"ph1\">`stloc.0`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.","pos":[0,120],"source":"The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0."},{"content":"The type of the value must match the type of the local variable as specified in the current method's local signature.","pos":[121,238]}]},{"pos":[725,810],"content":"<ph id=\"ph1\">`stloc.0`</ph> is an especially efficient encoding for storing values in local variable 0.","source":"`stloc.0` is an especially efficient encoding for storing values in local variable 0."},{"pos":[817,1069],"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.","pos":[0,142]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[143,252],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1076,1185],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stloc.0`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:"},{"pos":[1195,1219],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[680690,681930],"yaml":true,"extradata":"MT"},{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.","nodes":[{"pos":[0,114],"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.","nodes":[{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.","pos":[0,114]}]}],"pos":[683527,683642],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|0B|stloc.1|Pops a value from the stack into local variable 1.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is popped off of the stack and placed in the local variable indexed by 1.  \n  \n The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1. The type of the value must match the type of the local variable as specified in the current method's local signature.  \n  \n `stloc.1` is an especially efficient encoding for storing values in local variable 1.  \n  \n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"0B","nodes":[{"content":"0B","pos":[0,2]}]},{"pos":[259,266],"content":"stloc.1","nodes":[{"content":"stloc.1","pos":[0,7]}]},{"pos":[267,317],"content":"Pops a value from the stack into local variable 1.","nodes":[{"content":"Pops a value from the stack into local variable 1.","pos":[0,50]}]},{"pos":[325,382],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[392,473],"content":"A value is popped off of the stack and placed in the local variable indexed by 1.","nodes":[{"content":"A value is popped off of the stack and placed in the local variable indexed by 1.","pos":[0,81]}]},{"pos":[480,718],"content":"The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1. The type of the value must match the type of the local variable as specified in the current method's local signature.","nodes":[{"content":"The <ph id=\"ph1\">`stloc.1`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.","pos":[0,120],"source":"The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1."},{"content":"The type of the value must match the type of the local variable as specified in the current method's local signature.","pos":[121,238]}]},{"pos":[725,810],"content":"<ph id=\"ph1\">`stloc.1`</ph> is an especially efficient encoding for storing values in local variable 1.","source":"`stloc.1` is an especially efficient encoding for storing values in local variable 1."},{"pos":[817,1069],"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.","pos":[0,142]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[143,252],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1076,1185],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stloc.1`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:"},{"pos":[1195,1219],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[683653,684893],"yaml":true,"extradata":"MT"},{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.","nodes":[{"pos":[0,114],"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.","nodes":[{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.","pos":[0,114]}]}],"pos":[686490,686605],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|0C|stloc.2|Pops a value from the stack into local variable 2|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is popped off of the stack and placed in the local variable indexed by 2.  \n  \n The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2. The type of the value must match the type of the local variable as specified in the current method's local signature.  \n  \n `stloc.2` is an especially efficient encoding for storing values in local variable 2.  \n  \n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"0C","nodes":[{"content":"0C","pos":[0,2]}]},{"pos":[259,266],"content":"stloc.2","nodes":[{"content":"stloc.2","pos":[0,7]}]},{"pos":[267,316],"content":"Pops a value from the stack into local variable 2","nodes":[{"content":"Pops a value from the stack into local variable 2","pos":[0,49]}]},{"pos":[324,381],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[391,472],"content":"A value is popped off of the stack and placed in the local variable indexed by 2.","nodes":[{"content":"A value is popped off of the stack and placed in the local variable indexed by 2.","pos":[0,81]}]},{"pos":[479,717],"content":"The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2. The type of the value must match the type of the local variable as specified in the current method's local signature.","nodes":[{"content":"The <ph id=\"ph1\">`stloc.2`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.","pos":[0,120],"source":"The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2."},{"content":"The type of the value must match the type of the local variable as specified in the current method's local signature.","pos":[121,238]}]},{"pos":[724,809],"content":"<ph id=\"ph1\">`stloc.2`</ph> is an especially efficient encoding for storing values in local variable 2.","source":"`stloc.2` is an especially efficient encoding for storing values in local variable 2."},{"pos":[816,1068],"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.","pos":[0,142]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[143,252],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1075,1184],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stloc.2`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:"},{"pos":[1194,1218],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[686616,687855],"yaml":true,"extradata":"MT"},{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.","nodes":[{"pos":[0,114],"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.","nodes":[{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.","pos":[0,114]}]}],"pos":[689452,689567],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|0D|stloc.3|Pops a value from the stack into local variable 3|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is popped off of the stack and placed in the local variable indexed by 3.  \n  \n The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3. The type of the value must match the type of the local variable as specified in the current method's local signature.  \n  \n `stloc.3` is an especially efficient encoding for storing values in local variable 3.  \n  \n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"0D","nodes":[{"content":"0D","pos":[0,2]}]},{"pos":[259,266],"content":"stloc.3","nodes":[{"content":"stloc.3","pos":[0,7]}]},{"pos":[267,316],"content":"Pops a value from the stack into local variable 3","nodes":[{"content":"Pops a value from the stack into local variable 3","pos":[0,49]}]},{"pos":[324,381],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[391,472],"content":"A value is popped off of the stack and placed in the local variable indexed by 3.","nodes":[{"content":"A value is popped off of the stack and placed in the local variable indexed by 3.","pos":[0,81]}]},{"pos":[479,717],"content":"The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3. The type of the value must match the type of the local variable as specified in the current method's local signature.","nodes":[{"content":"The <ph id=\"ph1\">`stloc.3`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.","pos":[0,120],"source":"The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3."},{"content":"The type of the value must match the type of the local variable as specified in the current method's local signature.","pos":[121,238]}]},{"pos":[724,809],"content":"<ph id=\"ph1\">`stloc.3`</ph> is an especially efficient encoding for storing values in local variable 3.","source":"`stloc.3` is an especially efficient encoding for storing values in local variable 3."},{"pos":[816,1068],"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.","pos":[0,142]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[143,252],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1075,1184],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stloc.3`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:"},{"pos":[1194,1218],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[689578,690817],"yaml":true,"extradata":"MT"},{"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <code>index</code> (short form).","nodes":[{"pos":[0,138],"content":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">index</ph><ept id=\"p1\">&lt;/code&gt;</ept> (short form).","source":"Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <code>index</code> (short form)."}],"pos":[692414,692553],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|13 < `unsigned int8` >|stloc.s `index`|Pops a value from the stack and stores it in local variable `index`, short form.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is popped off of the stack and placed in local variable `index`.  \n  \n The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.  \n  \n The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.  \n  \n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:  \n  \n-   ILGenerator.Emit(OpCode, LocalBuilder)  \n  \n-   ILGenerator.Emit(OpCode, byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,278],"content":"13 &lt; <ph id=\"ph1\">`unsigned int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"13 < `unsigned int8` >"},{"pos":[279,294],"content":"stloc.s <ph id=\"ph1\">`index`</ph>","source":"stloc.s `index`"},{"pos":[295,375],"content":"Pops a value from the stack and stores it in local variable <ph id=\"ph1\">`index`</ph>, short form.","source":"Pops a value from the stack and stores it in local variable `index`, short form."},{"pos":[383,440],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[450,522],"content":"A value is popped off of the stack and placed in local variable <ph id=\"ph1\">`index`</ph>.","source":"A value is popped off of the stack and placed in local variable `index`."},{"pos":[529,811],"content":"The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.","nodes":[{"content":"The <ph id=\"ph1\">`stloc.s`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id=\"ph2\">`index`</ph>, where local variables are numbered 0 onwards.","pos":[0,164],"source":"The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards."},{"content":"The type of the value must match the type of the local variable as specified in the current method's local signature.","pos":[165,282]}]},{"pos":[818,909],"content":"The <ph id=\"ph1\">`stloc.s`</ph> instruction provides an efficient encoding for local variables 0 through 255.","source":"The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255."},{"pos":[916,1168],"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.","nodes":[{"content":"Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.","pos":[0,142]},{"content":"Floating-point values are rounded from their native size (type <ph id=\"ph1\">`F`</ph>) to the size associated with the argument.","pos":[143,252],"source":" Floating-point values are rounded from their native size (type `F`) to the size associated with the argument."}]},{"pos":[1175,1285],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`stloc.s`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:"},{"pos":[1295,1333],"content":"ILGenerator.Emit(OpCode, LocalBuilder)","nodes":[{"content":"ILGenerator.Emit(OpCode, LocalBuilder)","pos":[0,38]}]},{"pos":[1343,1373],"content":"ILGenerator.Emit(OpCode, byte)","nodes":[{"content":"ILGenerator.Emit(OpCode, byte)","pos":[0,30]}]}],"pos":[692564,693960],"yaml":true,"extradata":"MT"},{"content":"Copies a value of a specified type from the evaluation stack into a supplied memory address.","nodes":[{"pos":[0,92],"content":"Copies a value of a specified type from the evaluation stack into a supplied memory address.","nodes":[{"content":"Copies a value of a specified type from the evaluation stack into a supplied memory address.","pos":[0,92]}]}],"pos":[695545,695638],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|81 < `T` >|stobj `class`|Stores a value of type `class` from the stack into memory.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n2.  A value type object of type `class` is pushed onto the stack.  \n  \n3.  The object and the address are popped from the stack; the value type object is stored at the address.  \n  \n The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`). The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.  \n  \n The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \n  \n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"81 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"81 < `T` >"},{"pos":[267,280],"content":"stobj <ph id=\"ph1\">`class`</ph>","source":"stobj `class`"},{"pos":[281,339],"content":"Stores a value of type <ph id=\"ph1\">`class`</ph> from the stack into memory.","source":"Stores a value of type `class` from the stack into memory."},{"pos":[347,404],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[414,450],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[460,521],"content":"A value type object of type <ph id=\"ph1\">`class`</ph> is pushed onto the stack.","source":"A value type object of type `class` is pushed onto the stack."},{"pos":[531,632],"content":"The object and the address are popped from the stack; the value type object is stored at the address.","nodes":[{"content":"The object and the address are popped from the stack; the value type object is stored at the address.","pos":[0,101]}]},{"pos":[639,908],"content":"The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`). The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.","nodes":[{"content":"The <ph id=\"ph1\">`stobj`</ph> instruction copies the value type object into the address specified by the address (a pointer of type <ph id=\"ph2\">`native int`</ph>, <ph id=\"ph3\">`*`</ph>, or <ph id=\"ph4\">`&amp;`</ph>).","pos":[0,141],"source":"The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`)."},{"content":"The number of bytes copied depends on the size of the class represented by <ph id=\"ph1\">`class`</ph>, a metadata token representing a value type.","pos":[142,269],"source":" The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type."}]},{"pos":[915,1116],"content":"The operation of the <ph id=\"ph1\">`stobj`</ph> instruction can be altered by an immediately preceding <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.","source":"The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction."},{"pos":[1123,1328],"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.","nodes":[{"content":"<xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.","pos":[0,205],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.","pos":[0,67],"source":"<xref:System.TypeLoadException> is thrown if class cannot be found."},{"content":"This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.","pos":[68,205]}]}]},{"pos":[1335,1442],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stobj`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:"},{"pos":[1452,1482],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[695649,697156],"yaml":true,"extradata":"MT"},{"content":"Replaces the value of a static field with a value from the evaluation stack.","nodes":[{"pos":[0,76],"content":"Replaces the value of a static field with a value from the evaluation stack.","nodes":[{"content":"Replaces the value of a static field with a value from the evaluation stack.","pos":[0,76]}]}],"pos":[698745,698822],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|80 < `T` >|stsfld `field`|Replaces the value in `field` with a supplied value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is pushed onto the stack.  \n  \n2.  A value is popped from the stack and stored in `field`.  \n  \n The `stsfld` instruction replaces the value of a static field with a value from the stack. `field` is a metadata token that must refer to a static field member.  \n  \n The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.  \n  \n <xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:  \n  \n-   ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"80 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"80 < `T` >"},{"pos":[267,281],"content":"stsfld <ph id=\"ph1\">`field`</ph>","source":"stsfld `field`"},{"pos":[282,334],"content":"Replaces the value in <ph id=\"ph1\">`field`</ph> with a supplied value.","source":"Replaces the value in `field` with a supplied value."},{"pos":[342,399],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[409,442],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[452,507],"content":"A value is popped from the stack and stored in <ph id=\"ph1\">`field`</ph>.","source":"A value is popped from the stack and stored in `field`."},{"pos":[514,674],"content":"The `stsfld` instruction replaces the value of a static field with a value from the stack. `field` is a metadata token that must refer to a static field member.","nodes":[{"content":"The <ph id=\"ph1\">`stsfld`</ph> instruction replaces the value of a static field with a value from the stack.","pos":[0,90],"source":"The `stsfld` instruction replaces the value of a static field with a value from the stack."},{"content":"<ph id=\"ph1\">`field`</ph> is a metadata token that must refer to a static field member.","pos":[91,160],"source":"`field` is a metadata token that must refer to a static field member."}]},{"pos":[681,772],"content":"The <ph id=\"ph1\">`stsfld`</ph> instruction may be prefixed by <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.","source":"The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>."},{"pos":[779,993],"content":"<xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","nodes":[{"content":"<xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","pos":[0,214],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.","pos":[0,84],"source":"<xref:System.MissingFieldException> is thrown if field is not found in the metadata."},{"content":"This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.","pos":[85,214]}]}]},{"pos":[1000,1108],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`stsfld`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:"},{"pos":[1118,1153],"content":"ILGenerator.Emit(OpCode, FieldInfo)","nodes":[{"content":"ILGenerator.Emit(OpCode, FieldInfo)","pos":[0,35]}]}],"pos":[698833,700009],"yaml":true,"extradata":"MT"},{"content":"Subtracts one value from another and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,81],"content":"Subtracts one value from another and pushes the result onto the evaluation stack.","nodes":[{"content":"Subtracts one value from another and pushes the result onto the evaluation stack.","pos":[0,81]}]}],"pos":[701581,701663],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|59|sub|Subtracts one value from another, returning a new numeric value.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.  \n  \n4.  The result is pushed onto the stack.  \n  \n Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  \n  \n Integer subtraction wraps, rather than saturates. For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the \"wrapped\" result will be 255.  \n  \n Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"59","nodes":[{"content":"59","pos":[0,2]}]},{"pos":[259,262],"content":"sub","nodes":[{"content":"sub","pos":[0,3]}]},{"pos":[263,327],"content":"Subtracts one value from another, returning a new numeric value.","nodes":[{"content":"Subtracts one value from another, returning a new numeric value.","pos":[0,64]}]},{"pos":[335,392],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[402,436],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[446,480],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[490,576],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value2`</ph> is subtracted from <ph id=\"ph4\">`value1`</ph>.","source":"`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`."},{"pos":[586,622],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[629,759],"content":"Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).","nodes":[{"content":"Overflow is not detected for integer operations (for proper overflow handling, see <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).","pos":[0,130],"source":"Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)."}]},{"pos":[766,940],"content":"Integer subtraction wraps, rather than saturates. For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the \"wrapped\" result will be 255.","nodes":[{"content":"Integer subtraction wraps, rather than saturates.","pos":[0,49]},{"content":"For example: assuming 8-bit integers, where <ph id=\"ph1\">`value1`</ph> is set to 0 and <ph id=\"ph2\">`value2`</ph> is set to 1, the \"wrapped\" result will be 255.","pos":[50,174],"source":" For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the \"wrapped\" result will be 255."}]},{"pos":[947,1038],"content":"Floating-point overflow returns <ph id=\"ph1\">`+inf`</ph> (<ph id=\"ph2\">`PositiveInfinity`</ph>) or <ph id=\"ph3\">`-inf`</ph> (<ph id=\"ph4\">`NegativeInfinity`</ph>).","source":"Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`)."},{"pos":[1045,1150],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`sub`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:"},{"pos":[1160,1184],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[701674,702887],"yaml":true,"extradata":"MT"},{"content":"Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,118],"content":"Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"content":"Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.","pos":[0,118]}]}],"pos":[704480,704599],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|DA|sub.ovf|Subtracts one integer value from another with an overflow check.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.  \n  \n4.  The result is pushed onto the stack.  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"DA","nodes":[{"content":"DA","pos":[0,2]}]},{"pos":[259,266],"content":"sub.ovf","nodes":[{"content":"sub.ovf","pos":[0,7]}]},{"pos":[267,331],"content":"Subtracts one integer value from another with an overflow check.","nodes":[{"content":"Subtracts one integer value from another with an overflow check.","pos":[0,64]}]},{"pos":[339,396],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[406,440],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[450,484],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[494,606],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value2`</ph> is subtracted from <ph id=\"ph4\">`value1`</ph> with a check for overflow.","source":"`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow."},{"pos":[616,652],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[659,757],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[764,885],"content":"This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.","nodes":[{"content":"This operation is performed on signed integers; for floating-point values, use <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.","pos":[0,121],"source":"This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>."}]},{"pos":[892,1001],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`sub.ovf`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:"},{"pos":[1011,1035],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[704610,705670],"yaml":true,"extradata":"MT"},{"content":"Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"pos":[0,127],"content":"Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.","nodes":[{"content":"Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.","pos":[0,127]}]}],"pos":[707285,707413],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|DB|sub.ovf.un|Subtracts one unsigned integer value from another with an overflow check.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.  \n  \n4.  The result is pushed onto the stack.  \n  \n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \n  \n This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"DB","nodes":[{"content":"DB","pos":[0,2]}]},{"pos":[259,269],"content":"sub.ovf.un","nodes":[{"content":"sub.ovf.un","pos":[0,10]}]},{"pos":[270,343],"content":"Subtracts one unsigned integer value from another with an overflow check.","nodes":[{"content":"Subtracts one unsigned integer value from another with an overflow check.","pos":[0,73]}]},{"pos":[351,408],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[418,452],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[462,496],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[506,618],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack; <ph id=\"ph3\">`value2`</ph> is subtracted from <ph id=\"ph4\">`value1`</ph> with a check for overflow.","source":"`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow."},{"pos":[628,664],"content":"The result is pushed onto the stack.","nodes":[{"content":"The result is pushed onto the stack.","pos":[0,36]}]},{"pos":[671,769],"content":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.","pos":[0,98],"source":"<xref:System.OverflowException> is thrown if the result can not be represented in the result type."}]},{"pos":[776,897],"content":"This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.","nodes":[{"content":"This operation is performed on signed integers; for floating-point values, use <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.","pos":[0,121],"source":"This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>."}]},{"pos":[904,1016],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`sub.ovf.un`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:"},{"pos":[1026,1050],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[707424,708499],"yaml":true,"extradata":"MT"},{"content":"Implements a jump table.","nodes":[{"pos":[0,24],"content":"Implements a jump table.","nodes":[{"content":"Implements a jump table.","pos":[0,24]}]}],"pos":[710093,710118],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|45 < `unsigned int32` > < `int32` >... < `int32` >|switch (`N`, `t1`, `t2`... `tN`)|Jumps to one of `N` values.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  A value is pushed onto the stack.  \n  \n2.  The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.  \n  \n The `switch` instruction implements a jump table. The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets. These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.  \n  \n The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`. If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on). If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).  \n  \n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \n  \n Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction. (Such transfers are severely restricted and must use the leave instruction instead).  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode. The `Label[]` argument is an array of Labels representing 32-bit offsets.  \n  \n-   ILGenerator.Emit(OpCode, Label[])","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,306],"content":"45 &lt; <ph id=\"ph1\">`unsigned int32`</ph> &gt; &lt; <ph id=\"ph2\">`int32`</ph> &gt;... &lt; <ph id=\"ph3\">`int32`</ph><ph id=\"ph4\"> &gt;</ph>","source":"45 < `unsigned int32` > < `int32` >... < `int32` >"},{"pos":[307,339],"content":"switch (<ph id=\"ph1\">`N`</ph>, <ph id=\"ph2\">`t1`</ph>, <ph id=\"ph3\">`t2`</ph>... <ph id=\"ph4\">`tN`</ph>)","source":"switch (`N`, `t1`, `t2`... `tN`)"},{"pos":[340,367],"content":"Jumps to one of <ph id=\"ph1\">`N`</ph> values.","source":"Jumps to one of `N` values."},{"pos":[375,432],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[442,475],"content":"A value is pushed onto the stack.","nodes":[{"content":"A value is pushed onto the stack.","pos":[0,33]}]},{"pos":[485,636],"content":"The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <ph id=\"ph1\">`N`</ph>.","source":"The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`."},{"pos":[643,978],"content":"The `switch` instruction implements a jump table. The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets. These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.","nodes":[{"content":"The <ph id=\"ph1\">`switch`</ph> instruction implements a jump table.","pos":[0,49],"source":"The `switch` instruction implements a jump table."},{"content":"The format of the instruction is an <ph id=\"ph1\">`unsigned int32`</ph> representing the number of targets <ph id=\"ph2\">`N`</ph>, followed by <ph id=\"ph3\">`N`</ph> int32 values specifying jump targets.","pos":[50,196],"source":" The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets."},{"content":"These targets are represented as offsets (positive or negative) from the beginning of the instruction following this <ph id=\"ph1\">`switch`</ph> instruction.","pos":[197,335],"source":" These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction."}]},{"pos":[985,1410],"content":"The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`. If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on). If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).","nodes":[{"content":"The <ph id=\"ph1\">`switch`</ph> instruction pops a value off the stack and compares it, as an unsigned integer, to <ph id=\"ph2\">`N`</ph>.","pos":[0,100],"source":"The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`."},{"content":"If value is less than <ph id=\"ph1\">`N`</ph>, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).","pos":[101,319],"source":" If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on)."},{"content":"If the value is greater than or equal to <ph id=\"ph1\">`N`</ph>, execution continues at the next instruction (fall through).","pos":[320,425],"source":" If the value is greater than or equal to `N`, execution continues at the next instruction (fall through)."}]},{"pos":[1417,1536],"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","nodes":[{"content":"If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.","pos":[0,119]}]},{"pos":[1543,1749],"content":"Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction. (Such transfers are severely restricted and must use the leave instruction instead).","nodes":[{"content":"Control transfers into and out of <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`catch`</ph>, <ph id=\"ph3\">`filter`</ph>, and <ph id=\"ph4\">`finally`</ph> blocks cannot be performed by this instruction.","pos":[0,121],"source":"Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction."},{"content":"(Such transfers are severely restricted and must use the leave instruction instead).","pos":[122,206]}]},{"pos":[1756,1938],"content":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode. The `Label[]` argument is an array of Labels representing 32-bit offsets.","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`switch`</ph> opcode.","pos":[0,108],"source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode."},{"content":"The <ph id=\"ph1\">`Label[]`</ph> argument is an array of Labels representing 32-bit offsets.","pos":[109,182],"source":" The `Label[]` argument is an array of Labels representing 32-bit offsets."}]},{"pos":[1948,1981],"content":"ILGenerator.Emit(OpCode, Label[])","nodes":[{"content":"ILGenerator.Emit(OpCode, Label[])","pos":[0,33]}]}],"pos":[710129,712135],"yaml":true,"extradata":"MT"},{"content":"Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.","nodes":[{"pos":[0,146],"content":"Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.","nodes":[{"content":"Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.","pos":[0,146]}]}],"pos":[714461,714608],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 14|tail.|Subsequent call terminates current methods|  \n  \n There is no stack transition behavior defined for this instruction.  \n  \n The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction. It indicates that the current method's stack frame should be removed before the call instruction is executed. It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.  \n  \n The stack must be empty except for the arguments being transferred by the following call. The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`). Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.  \n  \n The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security. The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction. Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 14","nodes":[{"content":"FE 14","pos":[0,5]}]},{"pos":[262,267],"content":"tail.","nodes":[{"content":"tail.","pos":[0,5]}]},{"pos":[268,310],"content":"Subsequent call terminates current methods","nodes":[{"content":"Subsequent call terminates current methods","pos":[0,42]}]},{"pos":[318,385],"content":"There is no stack transition behavior defined for this instruction.","nodes":[{"content":"There is no stack transition behavior defined for this instruction.","pos":[0,67]}]},{"pos":[392,890],"content":"The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction. It indicates that the current method's stack frame should be removed before the call instruction is executed. It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.","nodes":[{"content":"The <ph id=\"ph1\">`tail`</ph> prefix instruction must immediately precede a <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction.","pos":[0,208],"source":"The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction."},{"content":"It indicates that the current method's stack frame should be removed before the call instruction is executed.","pos":[209,318]},{"content":"It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.","pos":[319,498]}]},{"pos":[897,1310],"content":"The stack must be empty except for the arguments being transferred by the following call. The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`). Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.","nodes":[{"content":"The stack must be empty except for the arguments being transferred by the following call.","pos":[0,89]},{"content":"The instruction following the call instruction must be a ret.","pos":[90,151]},{"content":"Thus the only valid code sequence is <ph id=\"ph1\">`tail. call`</ph> (or <ph id=\"ph2\">`calli`</ph> or <ph id=\"ph3\">`callvirt`</ph>).","pos":[152,229],"source":" Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`)."},{"content":"Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the <ph id=\"ph1\">`call`</ph> instruction, but they may branch to the subsequent <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.","pos":[230,413],"source":" Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>."}]},{"pos":[1317,1808],"content":"The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security. The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction. Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.","nodes":[{"content":"The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.","pos":[0,154]},{"content":"The .NET Framework security checks can therefore cause the <ph id=\"ph1\">`tail`</ph> to be ignored, leaving a standard <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.","pos":[155,310],"source":" The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction."},{"content":"Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the <ph id=\"ph1\">`tail`</ph> prefix is ignored when used to exit a method that is marked synchronized.","pos":[311,491],"source":" Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized."}]},{"pos":[1815,1921],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`tail`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:"},{"pos":[1931,1955],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[714619,716593],"yaml":true,"extradata":"MT"},{"content":"Returns true or false if the supplied opcode takes a single byte argument.","nodes":[{"pos":[0,74],"content":"Returns true or false if the supplied opcode takes a single byte argument.","nodes":[{"content":"Returns true or false if the supplied opcode takes a single byte argument.","pos":[0,74]}]}],"pos":[718405,718480],"yaml":true},{"content":"This method can be used to find which MSIL opcodes are \"short form\", for use in optimized code.  \n  \n `TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:  \n  \n-   The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  \n  \n-   The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  \n  \n-   The opcode references a variable or argument via the byte-sized \"short form\" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  \n  \n Otherwise, it returns `false`.  \n  \n The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.  \n  \n [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]\n [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]\n [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]","nodes":[{"pos":[0,95],"content":"This method can be used to find which MSIL opcodes are \"short form\", for use in optimized code.","nodes":[{"content":"This method can be used to find which MSIL opcodes are \"short form\", for use in optimized code.","pos":[0,95]}]},{"pos":[102,248],"content":"<ph id=\"ph1\">`TakesSingleByteArgument`</ph> returns <ph id=\"ph2\">`true`</ph> if the <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> instance takes a single byte argument in the following cases:","source":"`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:"},{"pos":[258,429],"content":"The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).","nodes":[{"content":"The opcode performs a branch instruction to a byte-sized address (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).","pos":[0,171],"source":"The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>)."}]},{"pos":[439,547],"content":"The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).","nodes":[{"content":"The opcode pushes a byte value onto the stack (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).","pos":[0,108],"source":"The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)."}]},{"pos":[557,745],"content":"The opcode references a variable or argument via the byte-sized \"short form\" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).","nodes":[{"content":"The opcode references a variable or argument via the byte-sized \"short form\" (for example, <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).","pos":[0,188],"source":"The opcode references a variable or argument via the byte-sized \"short form\" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>)."}]},{"pos":[752,782],"content":"Otherwise, it returns <ph id=\"ph1\">`false`</ph>.","source":"Otherwise, it returns `false`."},{"pos":[789,973],"content":"The example below demonstrates the use of <ph id=\"ph1\">`TakesSingleByteArgument`</ph> by reflecting on to the <ph id=\"ph2\">`OpCodes`</ph> class and testing to see whether each <ph id=\"ph3\">`OpCode`</ph> field takes a single-byte argument.","source":"The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument."},{"pos":[980,1605],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)</ept><ept id=\"p5\">]</ept>","leadings":[""," "," "],"source":"[!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]\n[!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]\n[!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]"}],"pos":[718491,720119],"yaml":true,"extradata":"MT"},{"content":"An instance of an Opcode object.","nodes":[{"pos":[0,32],"content":"An instance of an Opcode object.","nodes":[{"content":"An instance of an Opcode object.","pos":[0,32]}]}],"pos":[720315,720348],"yaml":true},{"content":"`True` or `false`.","nodes":[{"pos":[0,18],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`false`</ph>.","source":"`True` or `false`."}],"pos":[720406,720427],"yaml":true},{"content":"Throws the exception object currently on the evaluation stack.","nodes":[{"pos":[0,62],"content":"Throws the exception object currently on the evaluation stack.","nodes":[{"content":"Throws the exception object currently on the evaluation stack.","pos":[0,62]}]}],"pos":[721919,721982],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|7A|throw|Throws an exception.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference (to an exception) is pushed onto the stack.  \n  \n2.  The object reference is popped from the stack and the exception thrown.  \n  \n The `throw` instruction throws the exception object (type `O`) currently on the stack.  \n  \n <xref:System.NullReferenceException> is thrown if the object reference is a null reference.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"7A","nodes":[{"content":"7A","pos":[0,2]}]},{"pos":[259,264],"content":"throw","nodes":[{"content":"throw","pos":[0,5]}]},{"pos":[265,285],"content":"Throws an exception.","nodes":[{"content":"Throws an exception.","pos":[0,20]}]},{"pos":[293,350],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[360,423],"content":"An object reference (to an exception) is pushed onto the stack.","nodes":[{"content":"An object reference (to an exception) is pushed onto the stack.","pos":[0,63]}]},{"pos":[433,504],"content":"The object reference is popped from the stack and the exception thrown.","nodes":[{"content":"The object reference is popped from the stack and the exception thrown.","pos":[0,71]}]},{"pos":[511,597],"content":"The <ph id=\"ph1\">`throw`</ph> instruction throws the exception object (type <ph id=\"ph2\">`O`</ph>) currently on the stack.","source":"The `throw` instruction throws the exception object (type `O`) currently on the stack."},{"pos":[604,695],"content":"<xref:System.NullReferenceException> is thrown if the object reference is a null reference.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.","pos":[0,91],"source":"<xref:System.NullReferenceException> is thrown if the object reference is a null reference."}]},{"pos":[702,809],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`throw`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:"},{"pos":[819,843],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[721993,722857],"yaml":true,"extradata":"MT"},{"content":"Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.","nodes":[{"pos":[0,220],"content":"Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <ph id=\"ph1\">`ldind`</ph>, <ph id=\"ph2\">`stind`</ph>, <ph id=\"ph3\">`ldfld`</ph>, <ph id=\"ph4\">`stfld`</ph>, <ph id=\"ph5\">`ldobj`</ph>, <ph id=\"ph6\">`stobj`</ph>, <ph id=\"ph7\">`initblk`</ph>, or <ph id=\"ph8\">`cpblk`</ph> instruction.","source":"Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction."}],"pos":[724464,724685],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 12 < `unsigned int8` >|unaligned. `alignment`|Indicates that the subsequent pointer instruction may be unaligned.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n `Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary. For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs). Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.  \n  \n The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively. Note that transient pointers (type `*`) are always aligned.  \n  \n While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.  \n  \n The `unaligned` and `volatile` prefixes can be combined in either order. They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Label)  \n  \n-   ILGenerator.Emit(Opcode, Byte)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,281],"content":"FE 12 &lt; <ph id=\"ph1\">`unsigned int8`</ph><ph id=\"ph2\"> &gt;</ph>","source":"FE 12 < `unsigned int8` >"},{"pos":[282,304],"content":"unaligned. `alignment`","nodes":[{"content":"unaligned.","pos":[0,10]}]},{"pos":[305,372],"content":"Indicates that the subsequent pointer instruction may be unaligned.","nodes":[{"content":"Indicates that the subsequent pointer instruction may be unaligned.","pos":[0,67]}]},{"pos":[380,437],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[447,483],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[490,1148],"content":"`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary. For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs). Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.","nodes":[{"content":"<ph id=\"ph1\">`Unaligned`</ph> specifies that the address (an unmanaged pointer, <ph id=\"ph2\">`native int`</ph>) on the stack might not be aligned to the natural size of the immediately following <ph id=\"ph3\">`ldind`</ph>, <ph id=\"ph4\">`stind`</ph>, <ph id=\"ph5\">`ldfld`</ph>, <ph id=\"ph6\">`stfld`</ph>, <ph id=\"ph7\">`ldobj`</ph>, <ph id=\"ph8\">`stobj`</ph>, <ph id=\"ph9\">`initblk`</ph>, or <ph id=\"ph10\">`cpblk`</ph> instruction.","pos":[0,247],"source":"`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction."},{"content":"That is, for a <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> instruction the alignment of the address may not be to a 4-byte boundary.","pos":[248,383],"source":" That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary."},{"content":"For <ph id=\"ph1\">`initblk`</ph> and <ph id=\"ph2\">`cpblk`</ph> the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).","pos":[384,505],"source":" For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs)."},{"content":"Code generators that do not restrict their output to a 32-bit word size must use <ph id=\"ph1\">`unaligned`</ph> if the alignment is not known at compile time to be 8-byte.","pos":[506,658],"source":" Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte."}]},{"pos":[1155,1379],"content":"The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively. Note that transient pointers (type `*`) are always aligned.","nodes":[{"content":"The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.","pos":[0,164]},{"content":"Note that transient pointers (type <ph id=\"ph1\">`*`</ph>) are always aligned.","pos":[165,224],"source":" Note that transient pointers (type `*`) are always aligned."}]},{"pos":[1386,1601],"content":"While the alignment for a <ph id=\"ph1\">`cpblk`</ph> instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.","source":"While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified."},{"pos":[1608,1991],"content":"The `unaligned` and `volatile` prefixes can be combined in either order. They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.","nodes":[{"content":"The <ph id=\"ph1\">`unaligned`</ph> and <ph id=\"ph2\">`volatile`</ph> prefixes can be combined in either order.","pos":[0,72],"source":"The `unaligned` and `volatile` prefixes can be combined in either order."},{"content":"They must immediately precede a <ph id=\"ph1\">`ldind`</ph>, <ph id=\"ph2\">`stind`</ph>, <ph id=\"ph3\">`ldfld`</ph>, <ph id=\"ph4\">`stfld`</ph>, <ph id=\"ph5\">`ldobj`</ph>, <ph id=\"ph6\">`stobj`</ph>, <ph id=\"ph7\">`initblk`</ph>, or <ph id=\"ph8\">`cpblk`</ph> instruction.","pos":[73,193],"source":" They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction."},{"content":"Only the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix is allowed for the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.","pos":[194,383],"source":" Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions."}]},{"pos":[1998,2110],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id=\"ph2\">`unaligned`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:"},{"pos":[2120,2151],"content":"ILGenerator.Emit(OpCode, Label)","nodes":[{"content":"ILGenerator.Emit(OpCode, Label)","pos":[0,31]}]},{"pos":[2161,2191],"content":"ILGenerator.Emit(Opcode, Byte)","nodes":[{"content":"ILGenerator.Emit(Opcode, Byte)","pos":[0,30]}]}],"pos":[724696,726912],"yaml":true,"extradata":"MT"},{"content":"Converts the boxed representation of a value type to its unboxed form.","nodes":[{"pos":[0,70],"content":"Converts the boxed representation of a value type to its unboxed form.","nodes":[{"content":"Converts the boxed representation of a value type to its unboxed form.","pos":[0,70]}]}],"pos":[728499,728570],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|79 < `T` >|unbox `valType`|Extracts the value type data from `obj`, its boxed representation.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference is pushed onto the stack.  \n  \n2.  The object reference is popped from the stack and unboxed to a value type pointer.  \n  \n3.  The value type pointer is pushed onto the stack.  \n  \n A value type has two separate representations within the Common Language Infrastructure (CLI):  \n  \n-   A 'raw' form used when a value type is embedded within another object.  \n  \n-   A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.  \n  \n The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form. The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.  \n  \n Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object. Typically it simply computes the address of the value type that is already present inside of the boxed object.  \n  \n <xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.  \n  \n <xref:System.NullReferenceException> is thrown if the object reference is a null reference.  \n  \n <xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"79 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"79 < `T` >"},{"pos":[267,282],"content":"unbox <ph id=\"ph1\">`valType`</ph>","source":"unbox `valType`"},{"pos":[283,349],"content":"Extracts the value type data from <ph id=\"ph1\">`obj`</ph>, its boxed representation.","source":"Extracts the value type data from `obj`, its boxed representation."},{"pos":[357,414],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[424,469],"content":"An object reference is pushed onto the stack.","nodes":[{"content":"An object reference is pushed onto the stack.","pos":[0,45]}]},{"pos":[479,561],"content":"The object reference is popped from the stack and unboxed to a value type pointer.","nodes":[{"content":"The object reference is popped from the stack and unboxed to a value type pointer.","pos":[0,82]}]},{"pos":[571,619],"content":"The value type pointer is pushed onto the stack.","nodes":[{"content":"The value type pointer is pushed onto the stack.","pos":[0,48]}]},{"pos":[626,720],"content":"A value type has two separate representations within the Common Language Infrastructure (CLI):","nodes":[{"content":"A value type has two separate representations within the Common Language Infrastructure (CLI):","pos":[0,94]}]},{"pos":[730,800],"content":"A 'raw' form used when a value type is embedded within another object.","nodes":[{"content":"A 'raw' form used when a value type is embedded within another object.","pos":[0,70]}]},{"pos":[810,934],"content":"A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.","nodes":[{"content":"A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.","pos":[0,124]}]},{"pos":[941,1246],"content":"The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form. The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.","nodes":[{"content":"The <ph id=\"ph1\">`unbox`</ph> instruction converts the object reference (type <ph id=\"ph2\">`O`</ph>), the boxed representation of a value type, to a value type pointer (a managed pointer, type <ph id=\"ph3\">`&amp;`</ph>), its unboxed form.","pos":[0,180],"source":"The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form."},{"content":"The supplied value type (<ph id=\"ph1\">`valType`</ph>) is a metadata token indicating the type of value type contained within the boxed object.","pos":[181,305],"source":" The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object."}]},{"pos":[1253,1549],"content":"Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object. Typically it simply computes the address of the value type that is already present inside of the boxed object.","nodes":[{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, which is required to make a copy of a value type for use in the object, <ph id=\"ph2\">`unbox`</ph> is not required to copy the value type from the object.","pos":[0,185],"source":"Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object."},{"content":"Typically it simply computes the address of the value type that is already present inside of the boxed object.","pos":[186,296]}]},{"pos":[1556,1641],"content":"<ph id=\"ph1\">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if the object is not boxed as <ph id=\"ph2\">`valType`</ph>.","source":"<xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`."},{"pos":[1648,1739],"content":"<xref:System.NullReferenceException> is thrown if the object reference is a null reference.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.","pos":[0,91],"source":"<xref:System.NullReferenceException> is thrown if the object reference is a null reference."}]},{"pos":[1746,1970],"content":"<xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the value type <ph id=\"ph2\">`valType`</ph> cannot be found.","pos":[0,86],"source":"<xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found."},{"content":"This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.","pos":[87,224]}]},{"pos":[1977,2084],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`unbox`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:"},{"pos":[2094,2124],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[728581,730740],"yaml":true,"extradata":"MT"},{"content":"Converts the boxed representation of a type specified in the instruction to its unboxed form.","nodes":[{"pos":[0,93],"content":"Converts the boxed representation of a type specified in the instruction to its unboxed form.","nodes":[{"content":"Converts the boxed representation of a type specified in the instruction to its unboxed form.","pos":[0,93]}]}],"pos":[732347,732441],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|A5 < `T` >|unbox.any `typeTok`|Extract the data from `obj`, its boxed representation.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An object reference `obj` is pushed onto the stack.  \n  \n2.  The object reference is popped from the stack and unboxed to the type specified in the instruction.  \n  \n3.  The resulting object reference or value type is pushed onto the stack.  \n  \n When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.  \n  \n When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.  \n  \n If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.  \n  \n <xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.  \n  \n <xref:System.NullReferenceException> is thrown if `obj` is a null reference.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:  \n  \n-   ILGenerator.Emit(OpCode, Type)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,266],"content":"A5 &lt; <ph id=\"ph1\">`T`</ph><ph id=\"ph2\"> &gt;</ph>","source":"A5 < `T` >"},{"pos":[267,286],"content":"unbox.any <ph id=\"ph1\">`typeTok`</ph>","source":"unbox.any `typeTok`"},{"pos":[287,341],"content":"Extract the data from <ph id=\"ph1\">`obj`</ph>, its boxed representation.","source":"Extract the data from `obj`, its boxed representation."},{"pos":[349,406],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[416,467],"content":"An object reference <ph id=\"ph1\">`obj`</ph> is pushed onto the stack.","source":"An object reference `obj` is pushed onto the stack."},{"pos":[477,576],"content":"The object reference is popped from the stack and unboxed to the type specified in the instruction.","nodes":[{"content":"The object reference is popped from the stack and unboxed to the type specified in the instruction.","pos":[0,99]}]},{"pos":[586,656],"content":"The resulting object reference or value type is pushed onto the stack.","nodes":[{"content":"The resulting object reference or value type is pushed onto the stack.","pos":[0,70]}]},{"pos":[663,855],"content":"When applied to the boxed form of a value type, the <ph id=\"ph1\">`unbox.any`</ph> instruction extracts the value contained within <ph id=\"ph2\">`obj`</ph> (of type <ph id=\"ph3\">`O`</ph>), and is therefore equivalent to <ph id=\"ph4\">`unbox`</ph> followed by <ph id=\"ph5\">`ldobj`</ph>.","source":"When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`."},{"pos":[862,969],"content":"When applied to a reference type, the <ph id=\"ph1\">`unbox.any`</ph> instruction has the same effect as <ph id=\"ph2\">`castclass`</ph> <ph id=\"ph3\">`typeTok`</ph>.","source":"When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`."},{"pos":[976,1132],"content":"If the operand <ph id=\"ph1\">`typeTok`</ph> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.","source":"If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter."},{"pos":[1139,1213],"content":"<ph id=\"ph1\">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id=\"ph2\">`obj`</ph> is not a boxed type.","source":"<xref:System.InvalidCastException> is thrown if `obj` is not a boxed type."},{"pos":[1220,1296],"content":"<ph id=\"ph1\">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id=\"ph2\">`obj`</ph> is a null reference.","source":"<xref:System.NullReferenceException> is thrown if `obj` is a null reference."},{"pos":[1303,1414],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`unbox.any`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:"},{"pos":[1424,1454],"content":"ILGenerator.Emit(OpCode, Type)","nodes":[{"content":"ILGenerator.Emit(OpCode, Type)","pos":[0,30]}]}],"pos":[732452,733935],"yaml":true,"extradata":"MT"},{"content":"Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.","nodes":[{"pos":[0,201],"content":"Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.","nodes":[{"content":"Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.","pos":[0,201]}]}],"pos":[735540,735742],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|FE 13|volatile.|Indicates that the subsequent pointer reference is volatile.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  An address is pushed onto the stack.  \n  \n `volatile`. specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed. Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately. Access to volatile locations need not be performed atomically.  \n  \n The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order. They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,261],"content":"FE 13","nodes":[{"content":"FE 13","pos":[0,5]}]},{"pos":[262,271],"content":"volatile.","nodes":[{"content":"volatile.","pos":[0,9]}]},{"pos":[272,332],"content":"Indicates that the subsequent pointer reference is volatile.","nodes":[{"content":"Indicates that the subsequent pointer reference is volatile.","pos":[0,60]}]},{"pos":[340,397],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[407,443],"content":"An address is pushed onto the stack.","nodes":[{"content":"An address is pushed onto the stack.","pos":[0,36]}]},{"pos":[450,900],"content":"`volatile`. specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed. Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately. Access to volatile locations need not be performed atomically.","nodes":[{"content":"<ph id=\"ph1\">`volatile`</ph>.","pos":[0,11],"source":"`volatile`."},{"content":"specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.","pos":[12,259]},{"content":"Marking an access as <ph id=\"ph1\">`volatile`</ph> affects only that single access; other accesses to the same location must be marked separately.","pos":[260,387],"source":" Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately."},{"content":"Access to volatile locations need not be performed atomically.","pos":[388,450]}]},{"pos":[907,1290],"content":"The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order. They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id=\"ph2\">`volatile`</ph> prefixes can be combined in either order.","pos":[0,108],"source":"The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order."},{"content":"They must immediately precede a <ph id=\"ph1\">`ldind`</ph>, <ph id=\"ph2\">`stind`</ph>, <ph id=\"ph3\">`ldfld`</ph>, <ph id=\"ph4\">`stfld`</ph>, <ph id=\"ph5\">`ldobj`</ph>, <ph id=\"ph6\">`stobj`</ph>, <ph id=\"ph7\">`initblk`</ph>, or <ph id=\"ph8\">`cpblk`</ph> instruction.","pos":[109,229],"source":" They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction."},{"content":"Only the <ph id=\"ph1\">`volatile`</ph> prefix is allowed for the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.","pos":[230,383],"source":" Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions."}]},{"pos":[1297,1407],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`volatile`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:"},{"pos":[1417,1441],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[735753,737213],"yaml":true,"extradata":"MT"},{"content":"Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.","nodes":[{"pos":[0,117],"content":"Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.","nodes":[{"content":"Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.","pos":[0,117]}]}],"pos":[738787,738905],"yaml":true},{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \n  \n|Format|Assembly Format|Description|  \n|------------|---------------------|-----------------|  \n|61|xor|Computes the bitwise XOR of two integer values and returns an integer.|  \n  \n The stack transitional behavior, in sequential order, is:  \n  \n1.  `value1` is pushed onto the stack.  \n  \n2.  `value2` is pushed onto the stack.  \n  \n3.  `value2` and `value1` are popped from the stack and their bitwise XOR computed.  \n  \n4.  The bitwise XOR of `value2` and `value1` is pushed onto the stack.  \n  \n The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.  \n  \n `Xor` is an integer-specific operation.  \n  \n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:  \n  \n-   ILGenerator.Emit(OpCode)","nodes":[{"pos":[0,153],"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","nodes":[{"content":"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:","pos":[0,153]}]},{"pos":[160,166],"content":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"pos":[167,182],"content":"Assembly Format","nodes":[{"content":"Assembly Format","pos":[0,15]}]},{"pos":[183,194],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[256,258],"content":"61","nodes":[{"content":"61","pos":[0,2]}]},{"pos":[259,262],"content":"xor","nodes":[{"content":"xor","pos":[0,3]}]},{"pos":[263,333],"content":"Computes the bitwise XOR of two integer values and returns an integer.","nodes":[{"content":"Computes the bitwise XOR of two integer values and returns an integer.","pos":[0,70]}]},{"pos":[341,398],"content":"The stack transitional behavior, in sequential order, is:","nodes":[{"content":"The stack transitional behavior, in sequential order, is:","pos":[0,57]}]},{"pos":[408,442],"content":"<ph id=\"ph1\">`value1`</ph> is pushed onto the stack.","source":"`value1` is pushed onto the stack."},{"pos":[452,486],"content":"<ph id=\"ph1\">`value2`</ph> is pushed onto the stack.","source":"`value2` is pushed onto the stack."},{"pos":[496,575],"content":"<ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> are popped from the stack and their bitwise XOR computed.","source":"`value2` and `value1` are popped from the stack and their bitwise XOR computed."},{"pos":[585,651],"content":"The bitwise XOR of <ph id=\"ph1\">`value2`</ph> and <ph id=\"ph2\">`value1`</ph> is pushed onto the stack.","source":"The bitwise XOR of `value2` and `value1` is pushed onto the stack."},{"pos":[658,775],"content":"The <ph id=\"ph1\">`xor`</ph> instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.","source":"The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack."},{"pos":[782,821],"content":"<ph id=\"ph1\">`Xor`</ph> is an integer-specific operation.","source":"`Xor` is an integer-specific operation."},{"pos":[828,933],"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id=\"ph2\">`xor`</ph> opcode:","source":"The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:"},{"pos":[943,967],"content":"ILGenerator.Emit(OpCode)","nodes":[{"content":"ILGenerator.Emit(OpCode)","pos":[0,24]}]}],"pos":[738916,739908],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Reflection.Emit.OpCodes\n  commentId: T:System.Reflection.Emit.OpCodes\n  id: OpCodes\n  children:\n  - System.Reflection.Emit.OpCodes.Add\n  - System.Reflection.Emit.OpCodes.Add_Ovf\n  - System.Reflection.Emit.OpCodes.Add_Ovf_Un\n  - System.Reflection.Emit.OpCodes.And\n  - System.Reflection.Emit.OpCodes.Arglist\n  - System.Reflection.Emit.OpCodes.Beq\n  - System.Reflection.Emit.OpCodes.Beq_S\n  - System.Reflection.Emit.OpCodes.Bge\n  - System.Reflection.Emit.OpCodes.Bge_S\n  - System.Reflection.Emit.OpCodes.Bge_Un\n  - System.Reflection.Emit.OpCodes.Bge_Un_S\n  - System.Reflection.Emit.OpCodes.Bgt\n  - System.Reflection.Emit.OpCodes.Bgt_S\n  - System.Reflection.Emit.OpCodes.Bgt_Un\n  - System.Reflection.Emit.OpCodes.Bgt_Un_S\n  - System.Reflection.Emit.OpCodes.Ble\n  - System.Reflection.Emit.OpCodes.Ble_S\n  - System.Reflection.Emit.OpCodes.Ble_Un\n  - System.Reflection.Emit.OpCodes.Ble_Un_S\n  - System.Reflection.Emit.OpCodes.Blt\n  - System.Reflection.Emit.OpCodes.Blt_S\n  - System.Reflection.Emit.OpCodes.Blt_Un\n  - System.Reflection.Emit.OpCodes.Blt_Un_S\n  - System.Reflection.Emit.OpCodes.Bne_Un\n  - System.Reflection.Emit.OpCodes.Bne_Un_S\n  - System.Reflection.Emit.OpCodes.Box\n  - System.Reflection.Emit.OpCodes.Br\n  - System.Reflection.Emit.OpCodes.Br_S\n  - System.Reflection.Emit.OpCodes.Break\n  - System.Reflection.Emit.OpCodes.Brfalse\n  - System.Reflection.Emit.OpCodes.Brfalse_S\n  - System.Reflection.Emit.OpCodes.Brtrue\n  - System.Reflection.Emit.OpCodes.Brtrue_S\n  - System.Reflection.Emit.OpCodes.Call\n  - System.Reflection.Emit.OpCodes.Calli\n  - System.Reflection.Emit.OpCodes.Callvirt\n  - System.Reflection.Emit.OpCodes.Castclass\n  - System.Reflection.Emit.OpCodes.Ceq\n  - System.Reflection.Emit.OpCodes.Cgt\n  - System.Reflection.Emit.OpCodes.Cgt_Un\n  - System.Reflection.Emit.OpCodes.Ckfinite\n  - System.Reflection.Emit.OpCodes.Clt\n  - System.Reflection.Emit.OpCodes.Clt_Un\n  - System.Reflection.Emit.OpCodes.Constrained\n  - System.Reflection.Emit.OpCodes.Conv_I\n  - System.Reflection.Emit.OpCodes.Conv_I1\n  - System.Reflection.Emit.OpCodes.Conv_I2\n  - System.Reflection.Emit.OpCodes.Conv_I4\n  - System.Reflection.Emit.OpCodes.Conv_I8\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I1\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I2\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I4\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I8\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U1\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U2\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U4\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U8\n  - System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un\n  - System.Reflection.Emit.OpCodes.Conv_R_Un\n  - System.Reflection.Emit.OpCodes.Conv_R4\n  - System.Reflection.Emit.OpCodes.Conv_R8\n  - System.Reflection.Emit.OpCodes.Conv_U\n  - System.Reflection.Emit.OpCodes.Conv_U1\n  - System.Reflection.Emit.OpCodes.Conv_U2\n  - System.Reflection.Emit.OpCodes.Conv_U4\n  - System.Reflection.Emit.OpCodes.Conv_U8\n  - System.Reflection.Emit.OpCodes.Cpblk\n  - System.Reflection.Emit.OpCodes.Cpobj\n  - System.Reflection.Emit.OpCodes.Div\n  - System.Reflection.Emit.OpCodes.Div_Un\n  - System.Reflection.Emit.OpCodes.Dup\n  - System.Reflection.Emit.OpCodes.Endfilter\n  - System.Reflection.Emit.OpCodes.Endfinally\n  - System.Reflection.Emit.OpCodes.Initblk\n  - System.Reflection.Emit.OpCodes.Initobj\n  - System.Reflection.Emit.OpCodes.Isinst\n  - System.Reflection.Emit.OpCodes.Jmp\n  - System.Reflection.Emit.OpCodes.Ldarg\n  - System.Reflection.Emit.OpCodes.Ldarg_0\n  - System.Reflection.Emit.OpCodes.Ldarg_1\n  - System.Reflection.Emit.OpCodes.Ldarg_2\n  - System.Reflection.Emit.OpCodes.Ldarg_3\n  - System.Reflection.Emit.OpCodes.Ldarg_S\n  - System.Reflection.Emit.OpCodes.Ldarga\n  - System.Reflection.Emit.OpCodes.Ldarga_S\n  - System.Reflection.Emit.OpCodes.Ldc_I4\n  - System.Reflection.Emit.OpCodes.Ldc_I4_0\n  - System.Reflection.Emit.OpCodes.Ldc_I4_1\n  - System.Reflection.Emit.OpCodes.Ldc_I4_2\n  - System.Reflection.Emit.OpCodes.Ldc_I4_3\n  - System.Reflection.Emit.OpCodes.Ldc_I4_4\n  - System.Reflection.Emit.OpCodes.Ldc_I4_5\n  - System.Reflection.Emit.OpCodes.Ldc_I4_6\n  - System.Reflection.Emit.OpCodes.Ldc_I4_7\n  - System.Reflection.Emit.OpCodes.Ldc_I4_8\n  - System.Reflection.Emit.OpCodes.Ldc_I4_M1\n  - System.Reflection.Emit.OpCodes.Ldc_I4_S\n  - System.Reflection.Emit.OpCodes.Ldc_I8\n  - System.Reflection.Emit.OpCodes.Ldc_R4\n  - System.Reflection.Emit.OpCodes.Ldc_R8\n  - System.Reflection.Emit.OpCodes.Ldelem\n  - System.Reflection.Emit.OpCodes.Ldelem_I\n  - System.Reflection.Emit.OpCodes.Ldelem_I1\n  - System.Reflection.Emit.OpCodes.Ldelem_I2\n  - System.Reflection.Emit.OpCodes.Ldelem_I4\n  - System.Reflection.Emit.OpCodes.Ldelem_I8\n  - System.Reflection.Emit.OpCodes.Ldelem_R4\n  - System.Reflection.Emit.OpCodes.Ldelem_R8\n  - System.Reflection.Emit.OpCodes.Ldelem_Ref\n  - System.Reflection.Emit.OpCodes.Ldelem_U1\n  - System.Reflection.Emit.OpCodes.Ldelem_U2\n  - System.Reflection.Emit.OpCodes.Ldelem_U4\n  - System.Reflection.Emit.OpCodes.Ldelema\n  - System.Reflection.Emit.OpCodes.Ldfld\n  - System.Reflection.Emit.OpCodes.Ldflda\n  - System.Reflection.Emit.OpCodes.Ldftn\n  - System.Reflection.Emit.OpCodes.Ldind_I\n  - System.Reflection.Emit.OpCodes.Ldind_I1\n  - System.Reflection.Emit.OpCodes.Ldind_I2\n  - System.Reflection.Emit.OpCodes.Ldind_I4\n  - System.Reflection.Emit.OpCodes.Ldind_I8\n  - System.Reflection.Emit.OpCodes.Ldind_R4\n  - System.Reflection.Emit.OpCodes.Ldind_R8\n  - System.Reflection.Emit.OpCodes.Ldind_Ref\n  - System.Reflection.Emit.OpCodes.Ldind_U1\n  - System.Reflection.Emit.OpCodes.Ldind_U2\n  - System.Reflection.Emit.OpCodes.Ldind_U4\n  - System.Reflection.Emit.OpCodes.Ldlen\n  - System.Reflection.Emit.OpCodes.Ldloc\n  - System.Reflection.Emit.OpCodes.Ldloc_0\n  - System.Reflection.Emit.OpCodes.Ldloc_1\n  - System.Reflection.Emit.OpCodes.Ldloc_2\n  - System.Reflection.Emit.OpCodes.Ldloc_3\n  - System.Reflection.Emit.OpCodes.Ldloc_S\n  - System.Reflection.Emit.OpCodes.Ldloca\n  - System.Reflection.Emit.OpCodes.Ldloca_S\n  - System.Reflection.Emit.OpCodes.Ldnull\n  - System.Reflection.Emit.OpCodes.Ldobj\n  - System.Reflection.Emit.OpCodes.Ldsfld\n  - System.Reflection.Emit.OpCodes.Ldsflda\n  - System.Reflection.Emit.OpCodes.Ldstr\n  - System.Reflection.Emit.OpCodes.Ldtoken\n  - System.Reflection.Emit.OpCodes.Ldvirtftn\n  - System.Reflection.Emit.OpCodes.Leave\n  - System.Reflection.Emit.OpCodes.Leave_S\n  - System.Reflection.Emit.OpCodes.Localloc\n  - System.Reflection.Emit.OpCodes.Mkrefany\n  - System.Reflection.Emit.OpCodes.Mul\n  - System.Reflection.Emit.OpCodes.Mul_Ovf\n  - System.Reflection.Emit.OpCodes.Mul_Ovf_Un\n  - System.Reflection.Emit.OpCodes.Neg\n  - System.Reflection.Emit.OpCodes.Newarr\n  - System.Reflection.Emit.OpCodes.Newobj\n  - System.Reflection.Emit.OpCodes.Nop\n  - System.Reflection.Emit.OpCodes.Not\n  - System.Reflection.Emit.OpCodes.Or\n  - System.Reflection.Emit.OpCodes.Pop\n  - System.Reflection.Emit.OpCodes.Prefix1\n  - System.Reflection.Emit.OpCodes.Prefix2\n  - System.Reflection.Emit.OpCodes.Prefix3\n  - System.Reflection.Emit.OpCodes.Prefix4\n  - System.Reflection.Emit.OpCodes.Prefix5\n  - System.Reflection.Emit.OpCodes.Prefix6\n  - System.Reflection.Emit.OpCodes.Prefix7\n  - System.Reflection.Emit.OpCodes.Prefixref\n  - System.Reflection.Emit.OpCodes.Readonly\n  - System.Reflection.Emit.OpCodes.Refanytype\n  - System.Reflection.Emit.OpCodes.Refanyval\n  - System.Reflection.Emit.OpCodes.Rem\n  - System.Reflection.Emit.OpCodes.Rem_Un\n  - System.Reflection.Emit.OpCodes.Ret\n  - System.Reflection.Emit.OpCodes.Rethrow\n  - System.Reflection.Emit.OpCodes.Shl\n  - System.Reflection.Emit.OpCodes.Shr\n  - System.Reflection.Emit.OpCodes.Shr_Un\n  - System.Reflection.Emit.OpCodes.Sizeof\n  - System.Reflection.Emit.OpCodes.Starg\n  - System.Reflection.Emit.OpCodes.Starg_S\n  - System.Reflection.Emit.OpCodes.Stelem\n  - System.Reflection.Emit.OpCodes.Stelem_I\n  - System.Reflection.Emit.OpCodes.Stelem_I1\n  - System.Reflection.Emit.OpCodes.Stelem_I2\n  - System.Reflection.Emit.OpCodes.Stelem_I4\n  - System.Reflection.Emit.OpCodes.Stelem_I8\n  - System.Reflection.Emit.OpCodes.Stelem_R4\n  - System.Reflection.Emit.OpCodes.Stelem_R8\n  - System.Reflection.Emit.OpCodes.Stelem_Ref\n  - System.Reflection.Emit.OpCodes.Stfld\n  - System.Reflection.Emit.OpCodes.Stind_I\n  - System.Reflection.Emit.OpCodes.Stind_I1\n  - System.Reflection.Emit.OpCodes.Stind_I2\n  - System.Reflection.Emit.OpCodes.Stind_I4\n  - System.Reflection.Emit.OpCodes.Stind_I8\n  - System.Reflection.Emit.OpCodes.Stind_R4\n  - System.Reflection.Emit.OpCodes.Stind_R8\n  - System.Reflection.Emit.OpCodes.Stind_Ref\n  - System.Reflection.Emit.OpCodes.Stloc\n  - System.Reflection.Emit.OpCodes.Stloc_0\n  - System.Reflection.Emit.OpCodes.Stloc_1\n  - System.Reflection.Emit.OpCodes.Stloc_2\n  - System.Reflection.Emit.OpCodes.Stloc_3\n  - System.Reflection.Emit.OpCodes.Stloc_S\n  - System.Reflection.Emit.OpCodes.Stobj\n  - System.Reflection.Emit.OpCodes.Stsfld\n  - System.Reflection.Emit.OpCodes.Sub\n  - System.Reflection.Emit.OpCodes.Sub_Ovf\n  - System.Reflection.Emit.OpCodes.Sub_Ovf_Un\n  - System.Reflection.Emit.OpCodes.Switch\n  - System.Reflection.Emit.OpCodes.Tailcall\n  - System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)\n  - System.Reflection.Emit.OpCodes.Throw\n  - System.Reflection.Emit.OpCodes.Unaligned\n  - System.Reflection.Emit.OpCodes.Unbox\n  - System.Reflection.Emit.OpCodes.Unbox_Any\n  - System.Reflection.Emit.OpCodes.Volatile\n  - System.Reflection.Emit.OpCodes.Xor\n  langs:\n  - csharp\n  name: OpCodes\n  nameWithType: OpCodes\n  fullName: System.Reflection.Emit.OpCodes\n  type: Class\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <xref href=\"System.Reflection.Emit.ILGenerator\"></xref> class members (such as <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\"></xref>).\n  remarks: 'For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially \"Partition III: CIL Instruction Set\" and \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.'\n  example:\n  - \"The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.  \\n  \\n [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]\\n [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]\\n [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class OpCodes\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Add\n  commentId: F:System.Reflection.Emit.OpCodes.Add\n  id: Add\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Add\n  nameWithType: OpCodes.Add\n  fullName: OpCodes.Add\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Adds two values and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|58|add|Adds two numeric values, returning a new numeric value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is added to `value2`.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  \\n  \\n Integer addition wraps, rather than saturates. For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.  \\n  \\n Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).  \\n  \\n The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.  \\n  \\n|operand|value1 type|value2 type|result type|  \\n|-------------|-----------------|-----------------|-----------------|  \\n|add|`int32`|`int32`|`int32`|  \\n|add|`int32`|`native int`|`native int`|  \\n|add|`int32`|`&`|`&`|  \\n|add|`int32`|`*`|`*`|  \\n|add|`int64`|`int64`|`int64`|  \\n|add|`native int`|`int32`|`native int`|  \\n|add|`native int`|`native int`|`native int`|  \\n|add|`native int`|`&`|`&`|  \\n|add|`native int`|`*`|`*`|  \\n|add|`F`|`F`|`F`|  \\n|add|`&`|`int32`|`&`|  \\n|add|`&`|`native int`|`&`|  \\n|add|`*`|`int32`|`*`|  \\n|add|`*`|`native int`|`*`|  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Add;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Add_Ovf\n  commentId: F:System.Reflection.Emit.OpCodes.Add_Ovf\n  id: Add_Ovf\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Add_Ovf\n  nameWithType: OpCodes.Add_Ovf\n  fullName: OpCodes.Add_Ovf\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D6|add.ovf|Adds two signed integer values with an overflow check.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n <xref:System.OverflowException> is thrown if the result is not represented in the result type.  \\n  \\n You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.  \\n  \\n The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.  \\n  \\n|operand|value1 type|value2 type|result type|  \\n|-------------|-----------------|-----------------|-----------------|  \\n|add|`int32`|`int32`|`int32`|  \\n|add|`int32`|`native int`|`native int`|  \\n|add|`int32`|`&`|`&`|  \\n|add|`int32`|`*`|`*`|  \\n|add|`int64`|`int64`|`int64`|  \\n|add|`native int`|`int32`|`native int`|  \\n|add|`native int`|`native int`|`native int`|  \\n|add|`native int`|`&`|`&`|  \\n|add|`native int`|`*`|`*`|  \\n|add|`F`|`F`|`F`|  \\n|add|`&`|`int32`|`&`|  \\n|add|`&`|`native int`|`&`|  \\n|add|`*`|`int32`|`*`|  \\n|add|`*`|`native int`|`*`|  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Add_Ovf;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Add_Ovf_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Add_Ovf_Un\n  id: Add_Ovf_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Add_Ovf_Un\n  nameWithType: OpCodes.Add_Ovf_Un\n  fullName: OpCodes.Add_Ovf_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D7|add.ovf.un|Adds two unsigned integer values with an overflow check.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n <xref:System.OverflowException> is thrown if the result is not represented in the result type.  \\n  \\n You can perform this operation on signed integers. For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.  \\n  \\n The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.  \\n  \\n|operand|value1 type|value2 type|result type|  \\n|-------------|-----------------|-----------------|-----------------|  \\n|add|`int32`|`int32`|`int32`|  \\n|add|`int32`|`native int`|`native int`|  \\n|add|`int32`|`&`|`&`|  \\n|add|`int32`|`*`|`*`|  \\n|add|`int64`|`int64`|`int64`|  \\n|add|`native int`|`int32`|`native int`|  \\n|add|`native int`|`native int`|`native int`|  \\n|add|`native int`|`&`|`&`|  \\n|add|`native int`|`*`|`*`|  \\n|add|`F`|`F`|`F`|  \\n|add|`&`|`int32`|`&`|  \\n|add|`&`|`native int`|`&`|  \\n|add|`*`|`int32`|`*`|  \\n|add|`*`|`native int`|`*`|  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.And\n  commentId: F:System.Reflection.Emit.OpCodes.And\n  id: And\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: And\n  nameWithType: OpCodes.And\n  fullName: OpCodes.And\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Computes the bitwise AND of two values and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Instruction|Description|  \\n|------------|-----------------|-----------------|  \\n|5F|and|Determines the bitwise AND of two integer values.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.  \\n  \\n `And` is an integer-specific operation.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode And;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Arglist\n  commentId: F:System.Reflection.Emit.OpCodes.Arglist\n  id: Arglist\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Arglist\n  nameWithType: OpCodes.Arglist\n  fullName: OpCodes.Arglist\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Returns an unmanaged pointer to the argument list of the current method.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 00|arglist|Returns an argument list handle for the current method.|  \\n  \\n No evaluation stack behaviors are performed by this operation.  \\n  \\n The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method. This handle is valid only during the lifetime of the current method. You can, however, pass the handle to other methods as long as the current method is on the thread of control. You can only execute the `arglist` instruction within a method that takes a variable number of arguments.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Arglist;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Beq\n  commentId: F:System.Reflection.Emit.OpCodes.Beq\n  id: Beq\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Beq\n  nameWithType: OpCodes.Beq\n  fullName: OpCodes.Beq\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if two values are equal.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|3B < `int32` >|beq `target`|Branch to the target instruction at offset `target` if the two values are equal.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.  \\n  \\n The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`. The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n The acceptable operand types are encapsulated below:  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \\n  \\n Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Beq;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Beq_S\n  commentId: F:System.Reflection.Emit.OpCodes.Beq_S\n  id: Beq_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Beq_S\n  nameWithType: OpCodes.Beq_S\n  fullName: OpCodes.Beq_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if two values are equal.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|2E < `int8` >|beq.s `target`|Branch to the target instruction at offset `target` if equal, short form|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.  \\n  \\n The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`. The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n The acceptable operand types are encapsulated below:  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \\n  \\n Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Beq_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bge\n  commentId: F:System.Reflection.Emit.OpCodes.Bge\n  id: Bge\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bge\n  nameWithType: OpCodes.Bge\n  fullName: OpCodes.Bge\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is greater than or equal to the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|3C `<int32>`|bge `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \\n  \\n The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`. The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bge;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bge_S\n  commentId: F:System.Reflection.Emit.OpCodes.Bge_S\n  id: Bge_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bge_S\n  nameWithType: OpCodes.Bge_S\n  fullName: OpCodes.Bge_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|2F `<int8>`|bge.s `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \\n  \\n The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`. The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bge_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bge_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Bge_Un\n  id: Bge_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bge_Un\n  nameWithType: OpCodes.Bge_Un\n  fullName: OpCodes.Bge_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|41 `<int32>`|bge.un `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \\n  \\n The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bge_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bge_Un_S\n  commentId: F:System.Reflection.Emit.OpCodes.Bge_Un_S\n  id: Bge_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bge_Un_S\n  nameWithType: OpCodes.Bge_Un_S\n  fullName: OpCodes.Bge_Un_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|34 < `int8` >|bge.un.s `target`|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  \\n  \\n The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bge_Un_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bgt\n  commentId: F:System.Reflection.Emit.OpCodes.Bgt\n  id: Bgt\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bgt\n  nameWithType: OpCodes.Bgt\n  fullName: OpCodes.Bgt\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is greater than the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|3D < `int32` >|bgt `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \\n  \\n The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`. The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bgt;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bgt_S\n  commentId: F:System.Reflection.Emit.OpCodes.Bgt_S\n  id: Bgt_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bgt_S\n  nameWithType: OpCodes.Bgt_S\n  fullName: OpCodes.Bgt_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is greater than the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|30 < `int8` >|bgt.s `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \\n  \\n The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`. The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bgt_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bgt_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Bgt_Un\n  id: Bgt_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bgt_Un\n  nameWithType: OpCodes.Bgt_Un\n  fullName: OpCodes.Bgt_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|42 < `int32` >|bgt.un `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \\n  \\n The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bgt_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bgt_Un_S\n  commentId: F:System.Reflection.Emit.OpCodes.Bgt_Un_S\n  id: Bgt_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bgt_Un_S\n  nameWithType: OpCodes.Bgt_Un_S\n  fullName: OpCodes.Bgt_Un_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|35 < `int8` >|bgt.un.s `target`|Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.  \\n  \\n The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ble\n  commentId: F:System.Reflection.Emit.OpCodes.Ble\n  id: Ble\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ble\n  nameWithType: OpCodes.Ble\n  fullName: OpCodes.Ble\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is less than or equal to the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|3E `<int32>`|ble `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \\n  \\n The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ble;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ble_S\n  commentId: F:System.Reflection.Emit.OpCodes.Ble_S\n  id: Ble_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ble_S\n  nameWithType: OpCodes.Ble_S\n  fullName: OpCodes.Ble_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|31 `<int8>`|ble.s `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \\n  \\n The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ble_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ble_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Ble_Un\n  id: Ble_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ble_Un\n  nameWithType: OpCodes.Ble_Un\n  fullName: OpCodes.Ble_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|43 `<int32>`|ble.un `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \\n  \\n The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ble_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ble_Un_S\n  commentId: F:System.Reflection.Emit.OpCodes.Ble_Un_S\n  id: Ble_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ble_Un_S\n  nameWithType: OpCodes.Ble_Un_S\n  fullName: OpCodes.Ble_Un_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|36 `<int8>`|ble.un.s `target`|Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.  \\n  \\n The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ble_Un_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Blt\n  commentId: F:System.Reflection.Emit.OpCodes.Blt\n  id: Blt\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Blt\n  nameWithType: OpCodes.Blt\n  fullName: OpCodes.Blt\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is less than the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|3F < `int32` >|blt `target`|Branch to the target instruction at the specified offset if the first value is less than the second value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \\n  \\n The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`. The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Blt;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Blt_S\n  commentId: F:System.Reflection.Emit.OpCodes.Blt_S\n  id: Blt_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Blt_S\n  nameWithType: OpCodes.Blt_S\n  fullName: OpCodes.Blt_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is less than the second value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|32 < `int8` >|blt.s `target`|Branch to the target instruction at the specified offset if the first value is less than the second value, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \\n  \\n The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`. The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Blt_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Blt_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Blt_Un\n  id: Blt_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Blt_Un\n  nameWithType: OpCodes.Blt_Un\n  fullName: OpCodes.Blt_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|44 < `int32` >|blt.un `target`|Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \\n  \\n The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Blt_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Blt_Un_S\n  commentId: F:System.Reflection.Emit.OpCodes.Blt_Un_S\n  id: Blt_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Blt_Un_S\n  nameWithType: OpCodes.Blt_Un_S\n  fullName: OpCodes.Blt_Un_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|37 < `int8` >|blt.un.s `target`|Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  \\n  \\n The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Blt_Un_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bne_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Bne_Un\n  id: Bne_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bne_Un\n  nameWithType: OpCodes.Bne_Un\n  fullName: OpCodes.Bne_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|40 < `int32` >|bne.un `target`|Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.  \\n  \\n The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bne_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Bne_Un_S\n  commentId: F:System.Reflection.Emit.OpCodes.Bne_Un_S\n  id: Bne_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Bne_Un_S\n  nameWithType: OpCodes.Bne_Un_S\n  fullName: OpCodes.Bne_Un_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|33 < `int8` >|bne.un.s `target`|Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.  \\n  \\n The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values. The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Bne_Un_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Box\n  commentId: F:System.Reflection.Emit.OpCodes.Box\n  id: Box\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Box\n  nameWithType: OpCodes.Box\n  fullName: OpCodes.Box\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts a value type to an object reference (type `O`).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|8C < `T` >|box `valTypeToken`|Convert a value type (of the type specified in `valTypeToken`) to a true object reference.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value type is pushed onto the stack.  \\n  \\n2.  The value type is popped from the stack; the `box` operation is performed.  \\n  \\n3.  An object reference to the resulting \\\"boxed\\\" value type is pushed onto the stack.  \\n  \\n A value type has two separate representations within the Common Language Infrastructure (CLI):  \\n  \\n-   A 'raw' form used when a value type is embedded within another object or on the stack.  \\n  \\n-   A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.  \\n  \\n The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`). This is accomplished by creating a new object and copying the data from the value type into the newly allocated object. `valTypeToken` is a metadata token indicating the type of the value type on the stack.  \\n  \\n <xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.  \\n  \\n <xref:System.TypeLoadException> is thrown if the class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Box;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Br\n  commentId: F:System.Reflection.Emit.OpCodes.Br\n  id: Br\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Br\n  nameWithType: OpCodes.Br\n  fullName: OpCodes.Br\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Unconditionally transfers control to a target instruction.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|38 < `int32` >|br `target`|Branches to a target instruction at the specified offset.|  \\n  \\n No evaluation stack behaviors are performed by this operation.  \\n  \\n The `br` instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Br;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Br_S\n  commentId: F:System.Reflection.Emit.OpCodes.Br_S\n  id: Br_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Br_S\n  nameWithType: OpCodes.Br_S\n  fullName: OpCodes.Br_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Unconditionally transfers control to a target instruction (short form).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|2B < `int8` >|br.s `target`|Branches to a target instruction at the specified offset, short form.|  \\n  \\n No evaluation stack behaviors are performed by this operation.  \\n  \\n The `br.s` instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Br_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Break\n  commentId: F:System.Reflection.Emit.OpCodes.Break\n  id: Break\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Break\n  nameWithType: OpCodes.Break\n  fullName: OpCodes.Break\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|01|break|inform a debugger that a breakpoint has been reached.|  \\n  \\n No evaluation stack behaviors are performed by this operation.  \\n  \\n The `break` instruction is for debugging support. It signals the CLI to inform the debugger that a break point has been tripped. It has no other effect on the interpreter state.  \\n  \\n The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.  \\n  \\n The `break` instruction can trap to a debugger, do nothing, or raise a security exception. The exact behavior is implementation-defined.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Break;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Brfalse\n  commentId: F:System.Reflection.Emit.OpCodes.Brfalse\n  id: Brfalse\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Brfalse\n  nameWithType: OpCodes.Brfalse\n  fullName: OpCodes.Brfalse\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if <code>value</code> is `false`, a null reference (`Nothing` in Visual Basic), or zero.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Branches to a target instruction at the specified offset if `false`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack by a previous operation.  \\n  \\n2.  `value` is popped from the stack; if `value` is `false`, branch to `target`.  \\n  \\n The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`). If `value` is non-zero (`true`) execution continues at the next instruction.  \\n  \\n The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Brfalse;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Brfalse_S\n  commentId: F:System.Reflection.Emit.OpCodes.Brfalse_S\n  id: Brfalse_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Brfalse_S\n  nameWithType: OpCodes.Brfalse_S\n  fullName: OpCodes.Brfalse_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if <code>value</code> is `false`, a null reference, or zero.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Branches to a target instruction at the specified offset if `false`, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack by a previous operation.  \\n  \\n2.  `value` is popped from the stack; if `value` is `false`, branch to `target`.  \\n  \\n The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`). If `value` is non-zero (`true`) execution continues at the next instruction.  \\n  \\n The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Brfalse_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Brtrue\n  commentId: F:System.Reflection.Emit.OpCodes.Brtrue\n  id: Brtrue\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Brtrue\n  nameWithType: OpCodes.Brtrue\n  fullName: OpCodes.Brtrue\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction if <code>value</code> is `true`, not null, or non-zero.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Branch to a target instruction at the specified offset if non-zero (`true`).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack by a previous operation.  \\n  \\n2.  `value` is popped from the stack; if `value` is `true`, branch to `target`.  \\n  \\n The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`). If `value` is zero (`false`) execution continues at the next instruction.  \\n  \\n If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).  \\n  \\n The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Brtrue;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Brtrue_S\n  commentId: F:System.Reflection.Emit.OpCodes.Brtrue_S\n  id: Brtrue_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Brtrue_S\n  nameWithType: OpCodes.Brtrue_S\n  fullName: OpCodes.Brtrue_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control to a target instruction (short form) if <code>value</code> is `true`, not null, or non-zero.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Branch to a target instruction at the specified offset if non-zero (`true`), short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack by a previous operation.  \\n  \\n2.  `value` is popped from the stack; if `value` is `true`, branch to `target`.  \\n  \\n The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`). If `value` is zero (`false`) execution continues at the next instruction.  \\n  \\n If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).  \\n  \\n The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Brtrue_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Call\n  commentId: F:System.Reflection.Emit.OpCodes.Call\n  id: Call\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Call\n  nameWithType: OpCodes.Call\n  fullName: OpCodes.Call\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Calls the method indicated by the passed method descriptor.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|28 < `T` >|call `methodDesc`|Call the method described by `methodDesc`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  Method arguments `arg1` through `argN` are pushed onto the stack.  \\n  \\n2.  Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor. When complete, a return value is generated by the callee method and sent to the caller.  \\n  \\n3.  The return value is pushed onto the stack.  \\n  \\n The `call` instruction calls the method indicated by the method descriptor passed with the instruction. The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used. The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control. If the call transfers control to a method of higher trust than the origin method, the stack frame is not released. Instead, the execution continues silently as if the `tail` had not been supplied. The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function. In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).  \\n  \\n The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. There are three important special cases:  \\n  \\n 1. Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments. The instance reference must not be a null reference. The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.  \\n  \\n 2. It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.  \\n  \\n 3. Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.  \\n  \\n <xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method. The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.  \\n  \\n> [!NOTE]\\n>  When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, MethodInfo)  \\n  \\n-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  \\n  \\n> [!NOTE]\\n>  The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls. Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Call;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Calli\n  commentId: F:System.Reflection.Emit.OpCodes.Calli\n  id: Calli\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Calli\n  nameWithType: OpCodes.Calli\n  fullName: OpCodes.Calli\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|29 < `T` >|calli `callSiteDescr`|Calls the method pointed to with arguments described by the calling convention.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  Method arguments `arg1` through `argN` are pushed onto the stack.  \\n  \\n2.  The method entry pointer is pushed onto the stack.  \\n  \\n3.  Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed. When complete, a return value is generated by the callee method and sent to the caller.  \\n  \\n4.  The return value is pushed onto the stack.  \\n  \\n The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`. The types of these arguments are described by the specific calling convention (`callSiteDesc`). The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control. If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.  \\n  \\n The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature). Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.  \\n  \\n The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.  \\n  \\n The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.  \\n  \\n <xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method. The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack. Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.  \\n  \\n-   ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.  \\n  \\n-   ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Calli;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Callvirt\n  commentId: F:System.Reflection.Emit.OpCodes.Callvirt\n  id: Callvirt\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Callvirt\n  nameWithType: OpCodes.Callvirt\n  fullName: OpCodes.Callvirt\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Calls a late-bound method on an object, pushing the return value onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|6F < `T` >|callvirt `method`|Calls a specific method associated with `obj`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `obj` is pushed onto the stack.  \\n  \\n2.  Method arguments `arg1` through `argN` are pushed onto the stack.  \\n  \\n3.  Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token. When complete, a return value is generated by the callee method and sent to the caller.  \\n  \\n4.  The return value is pushed onto the stack.  \\n  \\n The `callvirt` instruction calls a late-bound method on an object. That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer. `Callvirt` can be used to call both virtual and instance methods. The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control. If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.  \\n  \\n The method metadata token provides the name, class and signature of the method to call. The class associated with `obj` is the class of which it is an instance. If the class defines a non-static method that matches the indicated method name and signature, this method is called. Otherwise all classes in the base class chain of this class are checked in order. It is an error if no method is found.  \\n  \\n `Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method. If the method has a return value, it is pushed on the stack upon method completion. On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.  \\n  \\n The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments. The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.  \\n  \\n Note that a virtual method can also be called using the<xref:System.Reflection.Emit.OpCodes.Call> instruction.  \\n  \\n <xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.  \\n  \\n <xref:System.NullReferenceException> is thrown if obj is null.  \\n  \\n <xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method. The security check may occur when the CIL is converted to native code rather than at run time.  \\n  \\n> [!NOTE]\\n>  When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`. These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, MethodInfo)  \\n  \\n-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Callvirt;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Castclass\n  commentId: F:System.Reflection.Emit.OpCodes.Castclass\n  id: Castclass\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Castclass\n  nameWithType: OpCodes.Castclass\n  fullName: OpCodes.Castclass\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Attempts to cast an object passed by reference to the specified class.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|74 < `T` >|castclass `class`|Casts an object to a new object of type `class`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference is pushed onto the stack.  \\n  \\n2.  The object reference is popped from the stack; the referenced object is cast as the specified `class`.  \\n  \\n3.  If successful, a new object reference is pushed onto the stack.  \\n  \\n The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class. The new class is specified by a metadata token indicating the desired class. If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown. If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.  \\n  \\n <xref:System.InvalidCastException> is thrown if obj cannot be cast to class.  \\n  \\n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public static readonly System.Reflection.Emit.OpCode Castclass;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ceq\n  commentId: F:System.Reflection.Emit.OpCodes.Ceq\n  id: Ceq\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ceq\n  nameWithType: OpCodes.Ceq\n  fullName: OpCodes.Ceq\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Compares two values. If they are equal, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 01|ceq|Pushes 1 if `value1` equals `value2`; else pushes 0.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is compared to `value2`.  \\n  \\n4.  If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \\n  \\n The `ceq` instruction compares `value1` and `value2`. If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack. Otherwise 0 (of type `int32`) is pushed on the stack.  \\n  \\n For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN). The infinite values are equal to themselves.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ceq;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Cgt\n  commentId: F:System.Reflection.Emit.OpCodes.Cgt\n  id: Cgt\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Cgt\n  nameWithType: OpCodes.Cgt\n  fullName: OpCodes.Cgt\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Compares two values. If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 02|cgt|Pushes 1 if `value1` is greater than `value2`; else pushes 0.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.  \\n  \\n4.  If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \\n  \\n The `cgt` instruction compares `value1` and `value2`. If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack. Otherwise, an `int32` value of 0 is pushed on the stack.  \\n  \\n-   For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Cgt;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Cgt_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Cgt_Un\n  id: Cgt_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Cgt_Un\n  nameWithType: OpCodes.Cgt_Un\n  fullName: OpCodes.Cgt_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Compares two unsigned or unordered values. If the first value is greater than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 03|cgt.un|Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.  \\n  \\n4.  If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \\n  \\n An `int32` value of 1 is pushed on the stack if any of the following is `true` :  \\n  \\n For floating-point numbers, `value1` is not ordered with respect to `value2`.  \\n  \\n For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.  \\n  \\n Otherwise an `int32` value of 0 is pushed on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Cgt_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ckfinite\n  commentId: F:System.Reflection.Emit.OpCodes.Ckfinite\n  id: Ckfinite\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ckfinite\n  nameWithType: OpCodes.Ckfinite\n  fullName: OpCodes.Ckfinite\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Throws <xref href=\"System.ArithmeticException\"></xref> if value is not a finite number.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|C3|ckfinite|throw <xref:System.ArithmeticException> if value is not a finite number.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack..  \\n  \\n2.  `value` is popped from the stack and the `ckfinite` instruction is performed on it.  \\n  \\n3.  `value` is pushed back onto the stack if no exception is thrown.  \\n  \\n The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a \\\"not a number\\\" value (NaN) or a `+-` infinity value. `Ckfinite` leaves the value on the stack if no exception is thrown. Execution is unspecified if `value` is not a floating-point number.  \\n  \\n <xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.  \\n  \\n Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ckfinite;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Clt\n  commentId: F:System.Reflection.Emit.OpCodes.Clt\n  id: Clt\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Clt\n  nameWithType: OpCodes.Clt\n  fullName: OpCodes.Clt\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Compares two values. If the first value is less than the second, the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 04|clt|Pushes 1 if `value1` is less than `value2`; else pushes 0.|  \\n  \\n The stack transitional behavior, in sequential order, is: `value1` is pushed onto the stack.  \\n  \\n1.  `value2` is pushed onto the stack.  \\n  \\n2.  `value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.  \\n  \\n3.  If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \\n  \\n The `clt` instruction compares `value1` and `value2`. If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack. Otherwise, an `int32` value of 0 is pushed on the stack.  \\n  \\n-   For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Clt;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Clt_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Clt_Un\n  id: Clt_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Clt_Un\n  nameWithType: OpCodes.Clt_Un\n  fullName: OpCodes.Clt_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Compares the unsigned or unordered values <code>value1</code> and <code>value2</code>. If <code>value1</code> is less than <code>value2</code>, then the integer value 1 `(int32`) is pushed onto the evaluation stack; otherwise 0 (`int32`) is pushed onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 05|clt.un|Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.  \\n  \\n4.  If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.  \\n  \\n The `clt.un` instruction compares `value1` and `value2`. An `int32` value of 1 is pushed on the stack if any of the following is true:  \\n  \\n-   `value1` is strictly less than `value2` (as for `clt`).  \\n  \\n-   For floating-point numbers, `value1` is not ordered with respect to `value2`.  \\n  \\n-   For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.  \\n  \\n Otherwise, an `int32` value of 0 is pushed on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Clt_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Constrained\n  commentId: F:System.Reflection.Emit.OpCodes.Constrained\n  id: Constrained\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Constrained\n  nameWithType: OpCodes.Constrained\n  fullName: OpCodes.Constrained\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Constrains the type on which a virtual method call is made.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 16 < `T` >|constrained. `thisType`|Call a virtual method on a type constrained to be type `T`.|  \\n  \\n The `constrained` prefix is permitted only on a `callvirt` instruction.  \\n  \\n The state of the MSIL stack at this point must be as follows:  \\n  \\n1.  A managed pointer, `ptr`, is pushed onto the stack. The type of `ptr` must be a managed pointer (`&`) to `thisType`. Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.  \\n  \\n2.  Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.  \\n  \\n The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.  \\n  \\n When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:  \\n  \\n-   If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.  \\n  \\n-   If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.  \\n  \\n-   If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.  \\n  \\n This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or<xref:System.Enum> and not overridden by `thisType`. In this case, the boxing causes a copy of the original object to be made. However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.  \\n  \\n The `constrained` prefix supports IL generators that create generic code. Normally the `callvirt` instruction is not valid on value types. Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called. However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.  \\n  \\n The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type. Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.  \\n  \\n Using the `constrained` prefix also avoids potential versioning problems with value types. If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object. For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted. A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.  \\n  \\n The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`. If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time. Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Constrained;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_I\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_I\n  id: Conv_I\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_I\n  nameWithType: OpCodes.Conv_I\n  fullName: OpCodes.Conv_I\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `native int`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D3|conv.i|Convert to `native int`, pushing `native int` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_I;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_I1\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_I1\n  id: Conv_I1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_I1\n  nameWithType: OpCodes.Conv_I1\n  fullName: OpCodes.Conv_I1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `int8`, then extends (pads) it to `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|67|conv.i1|Convert to `int8`, pushing `int32` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_I1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_I2\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_I2\n  id: Conv_I2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_I2\n  nameWithType: OpCodes.Conv_I2\n  fullName: OpCodes.Conv_I2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `int16`, then extends (pads) it to `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|68|conv.i2|Convert to `int16`, pushing `int32` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_I2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_I4\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_I4\n  id: Conv_I4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_I4\n  nameWithType: OpCodes.Conv_I4\n  fullName: OpCodes.Conv_I4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|69|conv.i4|Convert to `int32`, pushing `int32` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_I4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_I8\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_I8\n  id: Conv_I8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_I8\n  nameWithType: OpCodes.Conv_I8\n  fullName: OpCodes.Conv_I8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `int64`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|6A|conv.i8|Convert to `int64`, pushing `int64` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_I8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I\n  id: Conv_Ovf_I\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I\n  nameWithType: OpCodes.Conv_Ovf_I\n  fullName: OpCodes.Conv_Ovf_I\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to signed `native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D4|conv.ovf.i|Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un\n  id: Conv_Ovf_I_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I_Un\n  nameWithType: OpCodes.Conv_Ovf_I_Un\n  fullName: OpCodes.Conv_Ovf_I_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to signed `native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|8A|conv.ovf.i.un|Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I1\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1\n  id: Conv_Ovf_I1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I1\n  nameWithType: OpCodes.Conv_Ovf_I1\n  fullName: OpCodes.Conv_Ovf_I1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to signed `int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|B3|conv.ovf.i1|Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un\n  id: Conv_Ovf_I1_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I1_Un\n  nameWithType: OpCodes.Conv_Ovf_I1_Un\n  fullName: OpCodes.Conv_Ovf_I1_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to signed `int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|82|conv.ovf.i1.un|Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I2\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2\n  id: Conv_Ovf_I2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I2\n  nameWithType: OpCodes.Conv_Ovf_I2\n  fullName: OpCodes.Conv_Ovf_I2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to signed `int16` and extending it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|B5|conv.ovf.i2|Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un\n  id: Conv_Ovf_I2_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I2_Un\n  nameWithType: OpCodes.Conv_Ovf_I2_Un\n  fullName: OpCodes.Conv_Ovf_I2_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to signed `int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|83|conv.ovf.i2.un|Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I4\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4\n  id: Conv_Ovf_I4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I4\n  nameWithType: OpCodes.Conv_Ovf_I4\n  fullName: OpCodes.Conv_Ovf_I4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to signed `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|B7|conv.ovf.i4|Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un\n  id: Conv_Ovf_I4_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I4_Un\n  nameWithType: OpCodes.Conv_Ovf_I4_Un\n  fullName: OpCodes.Conv_Ovf_I4_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to signed `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|84|conv.ovf.i4.un|Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I8\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8\n  id: Conv_Ovf_I8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I8\n  nameWithType: OpCodes.Conv_Ovf_I8\n  fullName: OpCodes.Conv_Ovf_I8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to signed `int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|B9|conv.ovf.i8|Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un\n  id: Conv_Ovf_I8_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_I8_Un\n  nameWithType: OpCodes.Conv_Ovf_I8_Un\n  fullName: OpCodes.Conv_Ovf_I8_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to signed `int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|85|conv.ovf.i8.un|Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U\n  id: Conv_Ovf_U\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U\n  nameWithType: OpCodes.Conv_Ovf_U\n  fullName: OpCodes.Conv_Ovf_U\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to `unsigned native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D5|conv.ovf.u|Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un\n  id: Conv_Ovf_U_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U_Un\n  nameWithType: OpCodes.Conv_Ovf_U_Un\n  fullName: OpCodes.Conv_Ovf_U_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to `unsigned native int`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|8B|conv.ovf.u.un|Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U1\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1\n  id: Conv_Ovf_U1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U1\n  nameWithType: OpCodes.Conv_Ovf_U1\n  fullName: OpCodes.Conv_Ovf_U1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to `unsigned int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|B4|conv.ovf.u1|Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un\n  id: Conv_Ovf_U1_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U1_Un\n  nameWithType: OpCodes.Conv_Ovf_U1_Un\n  fullName: OpCodes.Conv_Ovf_U1_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to `unsigned int8` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|86|conv.ovf.u1.un|Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U2\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2\n  id: Conv_Ovf_U2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U2\n  nameWithType: OpCodes.Conv_Ovf_U2\n  fullName: OpCodes.Conv_Ovf_U2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to `unsigned int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|B6|conv.ovf.u2|Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un\n  id: Conv_Ovf_U2_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U2_Un\n  nameWithType: OpCodes.Conv_Ovf_U2_Un\n  fullName: OpCodes.Conv_Ovf_U2_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to `unsigned int16` and extends it to `int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|87|conv.ovf.u2.un|Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U4\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4\n  id: Conv_Ovf_U4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U4\n  nameWithType: OpCodes.Conv_Ovf_U4\n  fullName: OpCodes.Conv_Ovf_U4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to `unsigned int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|B8|conv.ovf.u4|Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un\n  id: Conv_Ovf_U4_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U4_Un\n  nameWithType: OpCodes.Conv_Ovf_U4_Un\n  fullName: OpCodes.Conv_Ovf_U4_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to `unsigned int32`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|88|conv.ovf.u4.un|Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U8\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8\n  id: Conv_Ovf_U8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U8\n  nameWithType: OpCodes.Conv_Ovf_U8\n  fullName: OpCodes.Conv_Ovf_U8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the signed value on top of the evaluation stack to `unsigned int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|BA|conv.ovf.u8|Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un\n  id: Conv_Ovf_U8_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_Ovf_U8_Un\n  nameWithType: OpCodes.Conv_Ovf_U8_Un\n  fullName: OpCodes.Conv_Ovf_U8_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned value on top of the evaluation stack to `unsigned int64`, throwing <xref href=\"System.OverflowException\"></xref> on overflow.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|89|conv.ovf.u8.un|Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  \\n  \\n Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_R_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_R_Un\n  id: Conv_R_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_R_Un\n  nameWithType: OpCodes.Conv_R_Un\n  fullName: OpCodes.Conv_R_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the unsigned integer value on top of the evaluation stack to `float32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|76|conv.r.un|Convert unsigned integer to floating-point, pushing `F` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a `float64` to a `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified. The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.  \\n  \\n No exceptions are ever thrown when using this field.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_R_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_R4\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_R4\n  id: Conv_R4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_R4\n  nameWithType: OpCodes.Conv_R4\n  fullName: OpCodes.Conv_R4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `float32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|6B|conv.r4|Convert to `float32`, pushing `F` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_R4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_R8\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_R8\n  id: Conv_R8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_R8\n  nameWithType: OpCodes.Conv_R8\n  fullName: OpCodes.Conv_R8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `float64`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|6C|conv.r8|Convert to `float64`, pushing `F` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_R8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_U\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_U\n  id: Conv_U\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_U\n  nameWithType: OpCodes.Conv_U\n  fullName: OpCodes.Conv_U\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `unsigned native int`, and extends it to `native int`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|E0|conv.u|Convert to `unsigned native int`, pushing `native int` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_U;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_U1\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_U1\n  id: Conv_U1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_U1\n  nameWithType: OpCodes.Conv_U1\n  fullName: OpCodes.Conv_U1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `unsigned int8`, and extends it to `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D2|conv.u1|Convert to `int8`, pushing `int32` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_U1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_U2\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_U2\n  id: Conv_U2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_U2\n  nameWithType: OpCodes.Conv_U2\n  fullName: OpCodes.Conv_U2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `unsigned int16`, and extends it to `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D1|conv.u2|Convert to `int16`, pushing `int32` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_U2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_U4\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_U4\n  id: Conv_U4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_U4\n  nameWithType: OpCodes.Conv_U4\n  fullName: OpCodes.Conv_U4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `unsigned int32`, and extends it to `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|6D|conv.u4|Convert to `unsigned int32`, pushing `int32` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_U4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Conv_U8\n  commentId: F:System.Reflection.Emit.OpCodes.Conv_U8\n  id: Conv_U8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Conv_U8\n  nameWithType: OpCodes.Conv_U8\n  fullName: OpCodes.Conv_U8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the value on top of the evaluation stack to `unsigned int64`, and extends it to `int64`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|6E|conv.u8|Convert to `int64`, pushing `int64` on stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and the conversion operation is attempted.  \\n  \\n3.  If the conversion is successful, the resulting value is pushed onto the stack.  \\n  \\n The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`). Floating-point values are converted to the `F` type.  \\n  \\n Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an `float64` to an `float32`, precision can be lost. If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an `int32`, the value is sign-extended to fill the slot.  \\n  \\n If overflow occurs converting a floating-point type to an integer the value returned is unspecified.  \\n  \\n No exceptions are ever thrown when using this field. See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Conv_U8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Cpblk\n  commentId: F:System.Reflection.Emit.OpCodes.Cpblk\n  id: Cpblk\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Cpblk\n  nameWithType: OpCodes.Cpblk\n  fullName: OpCodes.Cpblk\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Copies a specified number bytes from a source address to a destination address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 17|cpblk|Copy data from one memory block to another.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The destination address is pushed onto the stack.  \\n  \\n2.  The source address is pushed onto the stack.  \\n  \\n3.  The number of bytes to copy is pushed onto the stack.  \\n  \\n4.  The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.  \\n  \\n The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`). The behavior of `cpblk` is unspecified if the source and destination areas overlap.  \\n  \\n `cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine. The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.  \\n  \\n The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned>prefix instruction.  \\n  \\n <xref:System.NullReferenceException> may be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Cpblk;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Cpobj\n  commentId: F:System.Reflection.Emit.OpCodes.Cpobj\n  id: Cpobj\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Cpobj\n  nameWithType: OpCodes.Cpobj\n  fullName: OpCodes.Cpobj\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Copies the value type located at the address of an object (type `&`, `*` or `native int`) to the address of the destination object (type `&`, `*` or `native int`).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|70 < `T` >|cpobj `classTok`|Copies a value type from a source object to a destination object.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The destination object reference is pushed onto the stack.  \\n  \\n2.  The source object reference is pushed onto the stack.  \\n  \\n3.  The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.  \\n  \\n The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.  \\n  \\n <xref:System.NullReferenceException> may be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Cpobj;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Div\n  commentId: F:System.Reflection.Emit.OpCodes.Div\n  id: Div\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Div\n  nameWithType: OpCodes.Div\n  fullName: OpCodes.Div\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Divides two values and pushes the result as a floating-point (type `F`) or quotient (type `int32`) onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|5B|div|Divides two values to return a quotient or floating-point result.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is divided by `value2`.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n `result` = `value1` div value2 satisfies the following conditions:  \\n  \\n &#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:  \\n  \\n sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)  \\n  \\n The `div` instruction computes the result and pushes it on the stack.  \\n  \\n Integer division truncates towards zero.  \\n  \\n Division of a finite number by zero produces the correctly signed infinite value.  \\n  \\n Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value. Any number divided by infinity will produce a zero value.  \\n  \\n Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type. This can happen if `value1` is the maximum negative value, and `value2` is -1.  \\n  \\n Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.  \\n  \\n Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1). Floating-point operations never throw an exception (they produce NaNs or infinities instead).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Div;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Div_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Div_Un\n  id: Div_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Div_Un\n  nameWithType: OpCodes.Div_Un\n  fullName: OpCodes.Div_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Divides two unsigned integer values and pushes the result (`int32`) onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|5C|div.un|Divides two values, unsigned, returning a quotient.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is divided by `value2`.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Div_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Dup\n  commentId: F:System.Reflection.Emit.OpCodes.Dup\n  id: Dup\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Dup\n  nameWithType: OpCodes.Dup\n  fullName: OpCodes.Dup\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|25|dup|Duplicates the value on the top of the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped off of the stack for duplication.  \\n  \\n3.  `value` is pushed back onto the stack.  \\n  \\n4.  A duplicate value is pushed onto the stack.  \\n  \\n The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Dup;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Endfilter\n  commentId: F:System.Reflection.Emit.OpCodes.Endfilter\n  id: Endfilter\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Endfilter\n  nameWithType: OpCodes.Endfilter\n  fullName: OpCodes.Endfilter\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control from the `filter` clause of an exception back to the Common Language Infrastructure (CLI) exception handler.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 11|endfilter|End filter clause of SEH exception handling.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.  \\n  \\n `Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause. It should be one of:  \\n  \\n-   `exception_continue_search` (`value` = 0) to continue searching for an exception handler  \\n  \\n-   `exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located. Upon discovery, the handler is executed.  \\n  \\n Other integer values will produce unspecified results.  \\n  \\n The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block. The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block). After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.  \\n  \\n Control cannot be transferred into a filter block except through the exception mechanism. Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction. You cannot embed a `try` block within a `filter` block. If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Endfilter;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Endfinally\n  commentId: F:System.Reflection.Emit.OpCodes.Endfinally\n  id: Endfinally\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Endfinally\n  nameWithType: OpCodes.Endfinally\n  fullName: OpCodes.Endfinally\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Transfers control from the `fault` or `finally` clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|DC|endfinally<br /><br /> endfault|Ends the `finally` or `fault` clause of an exception block.|  \\n  \\n There are no stack transition behaviors for this instruction.  \\n  \\n `Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked. The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism. The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction. If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.  \\n  \\n An `endfinally` instruction might only appear lexically within a `finally` block. Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required. These same restrictions apply to the `endfault` instruction and the `fault` block.  \\n  \\n Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism. Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction. In particular, you cannot \\\"fall out\\\" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.  \\n  \\n Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  \\n  \\n-   ILGenerator.Emit(OpCode)  \\n  \\n-   ILGenerator.EndExceptionBlock()\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Endfinally;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Initblk\n  commentId: F:System.Reflection.Emit.OpCodes.Initblk\n  id: Initblk\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Initblk\n  nameWithType: OpCodes.Initblk\n  fullName: OpCodes.Initblk\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Initializes a specified block of memory at a specific address to a given size and initial value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 18|initblk|Set each location in a block of memory to a given value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A starting address is pushed onto the stack.  \\n  \\n2.  An initialization value is pushed onto the stack.  \\n  \\n3.  The number of bytes to initialize is pushed onto the stack.  \\n  \\n4.  The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.  \\n  \\n The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`). `initblk` assumes that the starting address is aligned to the natural size of the machine.  \\n  \\n The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> may be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Initblk;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Initobj\n  commentId: F:System.Reflection.Emit.OpCodes.Initobj\n  id: Initobj\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Initobj\n  nameWithType: OpCodes.Initobj\n  fullName: OpCodes.Initobj\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 15 < `T` >|`initobj` `typeTok`|Initializes a value type.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The address of the value type to initialize is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.  \\n  \\n The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type. After this method is called, the instance is ready for a constructor method to be called. If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.  \\n  \\n Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method. `Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Initobj;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Isinst\n  commentId: F:System.Reflection.Emit.OpCodes.Isinst\n  id: Isinst\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Isinst\n  nameWithType: OpCodes.Isinst\n  fullName: OpCodes.Isinst\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Tests whether an object reference (type `O`) is an instance of a particular class.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|75 < `T` >|isinst `class`|Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference is pushed onto the stack.  \\n  \\n2.  The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.  \\n  \\n3.  The result (either an object reference or a null reference) is pushed onto the stack.  \\n  \\n `Class` is a metadata token indicating the desired class. If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called. Otherwise, a null reference is pushed on the stack. If the object reference itself is a null reference, then `isinst` likewise returns a null reference.  \\n  \\n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Isinst;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Jmp\n  commentId: F:System.Reflection.Emit.OpCodes.Jmp\n  id: Jmp\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Jmp\n  nameWithType: OpCodes.Jmp\n  fullName: OpCodes.Jmp\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Exits current method and jumps to specified method.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|27 < `T` >|jmp `method`|Exit current method and jump to specified method.|  \\n  \\n There are no stack transition behaviors for this instruction.  \\n  \\n The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference. The current arguments are transferred to the destination method.  \\n  \\n The evaluation stack must be empty when this instruction is executed. The calling convention, number and type of arguments at the destination address must match that of the current method.  \\n  \\n The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, MethodInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Jmp;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarg\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarg\n  id: Ldarg\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarg\n  nameWithType: OpCodes.Ldarg\n  fullName: OpCodes.Ldarg\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads an argument (referenced by a specified index value) onto the stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 09 < `unsigned int16` >|ldarg `index`|Load argument at `index` onto stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The argument value at `index` is pushed onto the stack.  \\n  \\n The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack. The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \\n  \\n For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).  \\n  \\n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, short)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarg;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarg_0\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_0\n  id: Ldarg_0\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarg_0\n  nameWithType: OpCodes.Ldarg_0\n  fullName: OpCodes.Ldarg_0\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the argument at index 0 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|02|ldarg.0|Load argument 0 onto stack|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The argument value at index 0 is pushed onto the stack.  \\n  \\n The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.  \\n  \\n The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack. The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \\n  \\n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarg_0;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarg_1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_1\n  id: Ldarg_1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarg_1\n  nameWithType: OpCodes.Ldarg_1\n  fullName: OpCodes.Ldarg_1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the argument at index 1 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|03|ldarg.1|Load argument 1 onto stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The argument value at index 1 is pushed onto the stack.  \\n  \\n The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.  \\n  \\n The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack. The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \\n  \\n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarg_1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarg_2\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_2\n  id: Ldarg_2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarg_2\n  nameWithType: OpCodes.Ldarg_2\n  fullName: OpCodes.Ldarg_2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the argument at index 2 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|04|ldarg.2|Load argument 2 onto stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The argument value at index 2 is pushed onto the stack.  \\n  \\n The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.  \\n  \\n The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack. The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \\n  \\n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarg_2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarg_3\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_3\n  id: Ldarg_3\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarg_3\n  nameWithType: OpCodes.Ldarg_3\n  fullName: OpCodes.Ldarg_3\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the argument at index 3 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|05|ldarg.3|Load argument 3 onto stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The argument value at index 3 is pushed onto the stack.  \\n  \\n The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.  \\n  \\n The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack. The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \\n  \\n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarg_3;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarg_S\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_S\n  id: Ldarg_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarg_S\n  nameWithType: OpCodes.Ldarg_S\n  fullName: OpCodes.Ldarg_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the argument (referenced by a specified short form index) onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|0E < `unsigned int8` >|ldarg.s `index`|Load argument at `index` onto stack, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The argument value at `index` is pushed onto the stack.  \\n  \\n The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.  \\n  \\n The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack. The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.  \\n  \\n For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).  \\n  \\n Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarg_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarga\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarga\n  id: Ldarga\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarga\n  nameWithType: OpCodes.Ldarga\n  fullName: OpCodes.Ldarga\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Load an argument address onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 0A < `unsigned int16` >|ldarga `index`|Fetch the address of argument indexed by `index`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The address `addr` of the argument indexed by `index` is pushed onto the stack.  \\n  \\n The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards. The address `addr` is always aligned to a natural boundary on the target machine.  \\n  \\n For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \\n  \\n `ldarga` is used for by-ref parameter passing. For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, short)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarga;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldarga_S\n  commentId: F:System.Reflection.Emit.OpCodes.Ldarga_S\n  id: Ldarga_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldarga_S\n  nameWithType: OpCodes.Ldarga_S\n  fullName: OpCodes.Ldarga_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Load an argument address, in short form, onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|0F < `unsigned int8` >|ldarga.s `index`|Fetch the address of argument indexed by `index`, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The address `addr` of the argument indexed by `index` is pushed onto the stack.  \\n  \\n `ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.  \\n  \\n The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards. The address `addr` is always aligned to a natural boundary on the target machine.  \\n  \\n For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \\n  \\n `ldarga.s` is used for by-ref parameter passing. For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldarga_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4\n  id: Ldc_I4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4\n  nameWithType: OpCodes.Ldc_I4\n  fullName: OpCodes.Ldc_I4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes a supplied value of type `int32` onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|20 < `int32` >|ldc.i4 `num`|Pushes the value `num` onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value `num` is pushed onto the stack.  \\n  \\n Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8. All short encodings push 4 byte integers on the stack. Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms. There are three ways to push an 8 byte integer constant onto the stack  \\n  \\n 1. Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.  \\n  \\n 2. Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.  \\n  \\n 3. Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, int)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_0\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_0\n  id: Ldc_I4_0\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_0\n  nameWithType: OpCodes.Ldc_I4_0\n  fullName: OpCodes.Ldc_I4_0\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 0 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|16|ldc.i4.0|Pushes 0 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 0 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_1\n  id: Ldc_I4_1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_1\n  nameWithType: OpCodes.Ldc_I4_1\n  fullName: OpCodes.Ldc_I4_1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 1 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|17|ldc.i4.1|Pushes 1 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 1 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_2\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_2\n  id: Ldc_I4_2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_2\n  nameWithType: OpCodes.Ldc_I4_2\n  fullName: OpCodes.Ldc_I4_2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 2 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|18|ldc.i4.2|Pushes 2 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 2 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_3\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_3\n  id: Ldc_I4_3\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_3\n  nameWithType: OpCodes.Ldc_I4_3\n  fullName: OpCodes.Ldc_I4_3\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 3 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|19|ldc.i4.3|Pushes 3 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 3 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_4\n  id: Ldc_I4_4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_4\n  nameWithType: OpCodes.Ldc_I4_4\n  fullName: OpCodes.Ldc_I4_4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 4 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|1A|ldc.i4.4|Pushes 4 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 4 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_5\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_5\n  id: Ldc_I4_5\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_5\n  nameWithType: OpCodes.Ldc_I4_5\n  fullName: OpCodes.Ldc_I4_5\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 5 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|1B|ldc.i4.5|Pushes 5 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 5 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_6\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_6\n  id: Ldc_I4_6\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_6\n  nameWithType: OpCodes.Ldc_I4_6\n  fullName: OpCodes.Ldc_I4_6\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 6 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|1C|ldc.i4.6|Pushes 6 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 6 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_7\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_7\n  id: Ldc_I4_7\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_7\n  nameWithType: OpCodes.Ldc_I4_7\n  fullName: OpCodes.Ldc_I4_7\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 7 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|1D|ldc.i4.7|Pushes 7 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 7 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_8\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_8\n  id: Ldc_I4_8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_8\n  nameWithType: OpCodes.Ldc_I4_8\n  fullName: OpCodes.Ldc_I4_8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of 8 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|1E|ldc.i4.8|Pushes 8 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value 8 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_M1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_M1\n  id: Ldc_I4_M1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_M1\n  nameWithType: OpCodes.Ldc_I4_M1\n  fullName: OpCodes.Ldc_I4_M1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the integer value of -1 onto the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|15|ldc.i4.m1|Pushes -1 onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value -1 is pushed onto the stack.  \\n  \\n This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_S\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_S\n  id: Ldc_I4_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I4_S\n  nameWithType: OpCodes.Ldc_I4_S\n  fullName: OpCodes.Ldc_I4_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the supplied `int8` value onto the evaluation stack as an `int32`, short form.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|1F < `int8` >|ldc.i4.s `num`|Pushes `num` onto the stack as `int32`, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value `num` is pushed onto the stack.  \\n  \\n `ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_I8\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I8\n  id: Ldc_I8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_I8\n  nameWithType: OpCodes.Ldc_I8\n  fullName: OpCodes.Ldc_I8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes a supplied value of type `int64` onto the evaluation stack as an `int64`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|21 < `int64` >|ldc.i8 `num`|Pushes `num` onto the stack as `int64`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value `num` is pushed onto the stack.  \\n  \\n This encoding pushes an `int64` value onto the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, long)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_I8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_R4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_R4\n  id: Ldc_R4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_R4\n  nameWithType: OpCodes.Ldc_R4\n  fullName: OpCodes.Ldc_R4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes a supplied value of type `float32` onto the evaluation stack as type `F` (float).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|22 < `float32` >|ldc.r4 `num`|Pushes `num` onto the stack as `F`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value `num` is pushed onto the stack.  \\n  \\n This encoding pushes a `float32` value onto the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, single)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_R4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldc_R8\n  commentId: F:System.Reflection.Emit.OpCodes.Ldc_R8\n  id: Ldc_R8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldc_R8\n  nameWithType: OpCodes.Ldc_R8\n  fullName: OpCodes.Ldc_R8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes a supplied value of type `float64` onto the evaluation stack as type `F` (float).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|23 < `float64` >|ldc.r8 `num`|Pushes `num` onto the stack as `F`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value `num` is pushed onto the stack.  \\n  \\n This encoding pushes a `float64` value onto the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, double)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldc_R8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem\n  id: Ldelem\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem\n  nameWithType: OpCodes.Ldelem\n  fullName: OpCodes.Ldelem\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|A3 < `T` >|ldelem `typeTok`|Loads the element at `index` onto the top of the stack as type `typeTok`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects, and hence represented by a value of type `O`.  \\n  \\n The type of the return value is specified by the token `typeTok` in the instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I\n  id: Ldelem_I\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_I\n  nameWithType: OpCodes.Ldelem_I\n  fullName: OpCodes.Ldelem_I\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `native int` at a specified array index onto the top of the evaluation stack as a `native int`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|97|ldelem.i|Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.i` is `native int`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_I;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I1\n  id: Ldelem_I1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_I1\n  nameWithType: OpCodes.Ldelem_I1\n  fullName: OpCodes.Ldelem_I1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `int8` at a specified array index onto the top of the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|90|ldelem.i1|Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.i1` is `int8`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_I1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I2\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I2\n  id: Ldelem_I2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_I2\n  nameWithType: OpCodes.Ldelem_I2\n  fullName: OpCodes.Ldelem_I2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `int16` at a specified array index onto the top of the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|92|ldelem.i2|Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.i2` is `int16`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_I2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I4\n  id: Ldelem_I4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_I4\n  nameWithType: OpCodes.Ldelem_I4\n  fullName: OpCodes.Ldelem_I4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `int32` at a specified array index onto the top of the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|94|ldelem.i4|Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.i4` is `int32`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_I4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I8\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I8\n  id: Ldelem_I8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_I8\n  nameWithType: OpCodes.Ldelem_I8\n  fullName: OpCodes.Ldelem_I8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `int64` at a specified array index onto the top of the evaluation stack as an `int64`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|96|ldelem.i8|Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.i8` is `int64`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_I8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_R4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_R4\n  id: Ldelem_R4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_R4\n  nameWithType: OpCodes.Ldelem_R4\n  fullName: OpCodes.Ldelem_R4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `float32` at a specified array index onto the top of the evaluation stack as type `F` (float).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|98|ldelem.r4|Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.r4` is `float32`.  \\n  \\n Floating-point values are converted to type `F` when loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_R4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_R8\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_R8\n  id: Ldelem_R8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_R8\n  nameWithType: OpCodes.Ldelem_R8\n  fullName: OpCodes.Ldelem_R8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `float64` at a specified array index onto the top of the evaluation stack as type `F` (float).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|99|ldelem.r8|Loads the element with type `float64` at `index` onto the top of the stack as type `F`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.r8` is `float64`.  \\n  \\n Floating-point values are converted to type `F` when loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_R8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_Ref\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_Ref\n  id: Ldelem_Ref\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_Ref\n  nameWithType: OpCodes.Ldelem_Ref\n  fullName: OpCodes.Ldelem_Ref\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type `O` (object reference).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|9A|ldelem.ref|Loads the element with an object reference at `index` onto the top of the stack as type `O`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.ref` is type `O` (object reference).  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_U1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_U1\n  id: Ldelem_U1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_U1\n  nameWithType: OpCodes.Ldelem_U1\n  fullName: OpCodes.Ldelem_U1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `unsigned int8` at a specified array index onto the top of the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|91|ldelem.u1|Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.u1` is `int8`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_U1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_U2\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_U2\n  id: Ldelem_U2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_U2\n  nameWithType: OpCodes.Ldelem_U2\n  fullName: OpCodes.Ldelem_U2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `unsigned int16` at a specified array index onto the top of the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|93|ldelem.u2|Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.u2` is `int16`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_U2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelem_U4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_U4\n  id: Ldelem_U4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelem_U4\n  nameWithType: OpCodes.Ldelem_U4\n  fullName: OpCodes.Ldelem_U4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the element with type `unsigned int32` at a specified array index onto the top of the evaluation stack as an `int32`.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|95|ldelem.u4|Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.  \\n  \\n4.  The value is pushed onto the stack.  \\n  \\n The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`.  \\n  \\n The return value for `ldelem.u4` is `int32`.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelem_U4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldelema\n  commentId: F:System.Reflection.Emit.OpCodes.Ldelema\n  id: Ldelema\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldelema\n  nameWithType: OpCodes.Ldelema\n  fullName: OpCodes.Ldelema\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the address of the array element at a specified array index onto the top of the evaluation stack as type `&` (managed pointer).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|8F < `T` >|ldelema `class`|Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `array` is pushed onto the stack.  \\n  \\n2.  An index value `index` is pushed onto the stack.  \\n  \\n3.  `index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.  \\n  \\n4.  The address is pushed onto the stack.  \\n  \\n The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`). The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack. Arrays are objects and hence represented by a value of type `O`. The value must be of type `class` passed with the instruction.  \\n  \\n The return value for `ldelema` is a managed pointer (type `&`).  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldelema;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldfld\n  commentId: F:System.Reflection.Emit.OpCodes.Ldfld\n  id: Ldfld\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldfld\n  nameWithType: OpCodes.Ldfld\n  fullName: OpCodes.Ldfld\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Finds the value of a field in the object whose reference is currently on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|7B < `T` >|ldfld `field`|Pushes the value of a field in a specified object onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference (or pointer) is pushed onto the stack.  \\n  \\n2.  The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.  \\n  \\n3.  The value stored in the field is pushed onto the stack.  \\n  \\n The `ldfld` instruction pushes the value of a field located in an object onto the stack. The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member. The return type is the same as the one associated with the field. The field may be either an instance field (in which case the object must not be a null reference) or a static field.  \\n  \\n The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.  \\n  \\n <xref:System.NullReferenceException> is thrown if the object is null and the field is not static.  \\n  \\n <xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, FieldInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldfld;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldflda\n  commentId: F:System.Reflection.Emit.OpCodes.Ldflda\n  id: Ldflda\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldflda\n  nameWithType: OpCodes.Ldflda\n  fullName: OpCodes.Ldflda\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Finds the address of a field in the object whose reference is currently on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|7C < `T` >|ldflda `field`|Pushes the address of `field` in a specified object onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference (or pointer) is pushed onto the stack.  \\n  \\n2.  The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.  \\n  \\n3.  The address of the specified field is pushed onto the stack.  \\n  \\n The `ldflda` instruction pushes the address of a field located in an object onto the stack. The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member.  \\n  \\n The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).  \\n  \\n The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.  \\n  \\n <xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed. The address of a field that is not inside the accessing application domain cannot be loaded.  \\n  \\n <xref:System.NullReferenceException> is thrown if the object is null and the field is not static.  \\n  \\n <xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, FieldInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldflda;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldftn\n  commentId: F:System.Reflection.Emit.OpCodes.Ldftn\n  id: Ldftn\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldftn\n  nameWithType: OpCodes.Ldftn\n  fullName: OpCodes.Ldftn\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes an unmanaged pointer (type `native int`) to the native code implementing a specific method onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 06 < `T` >|ldftn `method`|Pushes a pointer to a method referenced by `method` on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The unmanaged pointer to a specific method is pushed onto the stack.  \\n  \\n The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).  \\n  \\n The value returned points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, MethodInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldftn;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_I\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I\n  id: Ldind_I\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_I\n  nameWithType: OpCodes.Ldind_I\n  fullName: OpCodes.Ldind_I\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `native int` as a `native int` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|4D|ldind.i|Loads the `native int` value at address `addr` onto the stack as a `native int`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or *) onto the stack as a `native int`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_I;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_I1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I1\n  id: Ldind_I1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_I1\n  nameWithType: OpCodes.Ldind_I1\n  fullName: OpCodes.Ldind_I1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `int8` as an `int32` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|46|ldind.i1|Loads the `int8` value at address `addr` onto the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack..  \\n  \\n The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_I1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_I2\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I2\n  id: Ldind_I2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_I2\n  nameWithType: OpCodes.Ldind_I2\n  fullName: OpCodes.Ldind_I2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `int16` as an `int32` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|48|ldind.i2|Loads the `int16` value at address `addr` onto the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca>and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_I2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_I4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I4\n  id: Ldind_I4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_I4\n  nameWithType: OpCodes.Ldind_I4\n  fullName: OpCodes.Ldind_I4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `int32` as an `int32` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|4A|ldind.i4|Loads the `int32` value at address `addr` onto the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_I4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_I8\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I8\n  id: Ldind_I8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_I8\n  nameWithType: OpCodes.Ldind_I8\n  fullName: OpCodes.Ldind_I8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `int64` as an `int64` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|4C|ldind.i8|Loads the `int64` value at address `addr` onto the stack as an `int64`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int64`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_I8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_R4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_R4\n  id: Ldind_R4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_R4\n  nameWithType: OpCodes.Ldind_R4\n  fullName: OpCodes.Ldind_R4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `float32` as a type `F` (float) onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|4E|ldind.r4|Loads the `float32` value at address `addr` onto the stack as a type `F`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or *) onto the stack as a type `F`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_R4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_R8\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_R8\n  id: Ldind_R8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_R8\n  nameWithType: OpCodes.Ldind_R8\n  fullName: OpCodes.Ldind_R8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `float64` as a type `F` (float) onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|4F|ldind.r8|Loads the `float64` value at address `addr` onto the stack as a type `F`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or *) onto the stack as a `float64`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_R8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_Ref\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_Ref\n  id: Ldind_Ref\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_Ref\n  nameWithType: OpCodes.Ldind_Ref\n  fullName: OpCodes.Ldind_Ref\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads an object reference as a type `O` (object reference) onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|50|ldind.ref|Loads the object reference at address `addr` onto the stack as a type `O`|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the object reference located at the address is fetched.  \\n  \\n3.  The fetched reference is pushed onto the stack.  \\n  \\n The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or *) onto the stack as type `O`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_Ref;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_U1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_U1\n  id: Ldind_U1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_U1\n  nameWithType: OpCodes.Ldind_U1\n  fullName: OpCodes.Ldind_U1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `unsigned int8` as an `int32` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|47|ldind.u1|Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or *) onto the stack as an `int32`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_U1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_U2\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_U2\n  id: Ldind_U2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_U2\n  nameWithType: OpCodes.Ldind_U2\n  fullName: OpCodes.Ldind_U2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `unsigned int16` as an `int32` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|49|ldind.u2|Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_U2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldind_U4\n  commentId: F:System.Reflection.Emit.OpCodes.Ldind_U4\n  id: Ldind_U4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldind_U4\n  nameWithType: OpCodes.Ldind_U4\n  fullName: OpCodes.Ldind_U4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads a value of type `unsigned int32` as an `int32` onto the evaluation stack indirectly.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|4B|ldind.u4|Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack; the value located at the address is fetched.  \\n  \\n3.  The fetched value is pushed onto the stack.  \\n  \\n The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or *) onto the stack as an `int32`.  \\n  \\n All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.  \\n  \\n Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack. Floating-point values are converted to `F` type when loaded onto the evaluation stack.  \\n  \\n Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.  \\n  \\n The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.  \\n  \\n <xref:System.NullReferenceException> can be thrown if an invalid address is detected.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldind_U4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldlen\n  commentId: F:System.Reflection.Emit.OpCodes.Ldlen\n  id: Ldlen\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldlen\n  nameWithType: OpCodes.Ldlen\n  fullName: OpCodes.Ldlen\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|8E|ldlen|Pushes the length (of type `natural unsigned int`) of an array on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array is pushed onto the stack.  \\n  \\n2.  The array reference is popped from the stack and the length is computed.  \\n  \\n3.  The length is pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The length is returned as a `natural unsigned int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if the array reference is a null reference.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldlen;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloc\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloc\n  id: Ldloc\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloc\n  nameWithType: OpCodes.Ldloc\n  fullName: OpCodes.Ldloc\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the local variable at a specific index onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 0C < `unsigned int16` >|ldloc `index`|Loads the local variable at index `index` onto stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The local variable value at the specified index is pushed onto the stack.  \\n  \\n The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true. There are 65,535 (2^16-1) local variables possible (0-65,534). Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.  \\n  \\n The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.  \\n  \\n The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, LocalBuilder)  \\n  \\n-   ILGenerator.Emit(OpCode, short)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloc;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloc_0\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_0\n  id: Ldloc_0\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloc_0\n  nameWithType: OpCodes.Ldloc_0\n  fullName: OpCodes.Ldloc_0\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the local variable at index 0 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|06|ldloc.0|Loads the local variable at index 0 onto the evaluation stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The local variable value at the index 0 is pushed onto the stack.  \\n  \\n `ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.  \\n  \\n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloc_0;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloc_1\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_1\n  id: Ldloc_1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloc_1\n  nameWithType: OpCodes.Ldloc_1\n  fullName: OpCodes.Ldloc_1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the local variable at index 1 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|07|ldloc.1|Loads the local variable at index 1 onto the evaluation stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The local variable value at the index 1 is pushed onto the stack.  \\n  \\n `ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.  \\n  \\n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloc_1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloc_2\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_2\n  id: Ldloc_2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloc_2\n  nameWithType: OpCodes.Ldloc_2\n  fullName: OpCodes.Ldloc_2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the local variable at index 2 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|08|ldloc.2|Loads the local variable at index 2 onto the evaluation stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The local variable value at the index 2 is pushed onto the stack.  \\n  \\n `ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.  \\n  \\n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloc_2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloc_3\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_3\n  id: Ldloc_3\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloc_3\n  nameWithType: OpCodes.Ldloc_3\n  fullName: OpCodes.Ldloc_3\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the local variable at index 3 onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|09|ldloc.3|Loads the local variable at index 3 onto the evaluation stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The local variable value at the index 3 is pushed onto the stack.  \\n  \\n `ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.  \\n  \\n The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloc_3;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloc_S\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_S\n  id: Ldloc_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloc_S\n  nameWithType: OpCodes.Ldloc_S\n  fullName: OpCodes.Ldloc_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the local variable at a specific index onto the evaluation stack, short form.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|11 < `unsigned int8` >|ldloc.s `index`|Loads the local variable at index `index` onto stack, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The local variable value at the specified index is pushed onto the stack.  \\n  \\n The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method if the initialize flag on the method is true. There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.  \\n  \\n The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack. Floating-point values are expanded to their native size (type `F`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, LocalBuilder)  \\n  \\n-   ILGenerator.Emit(OpCode, byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloc_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloca\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloca\n  id: Ldloca\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloca\n  nameWithType: OpCodes.Ldloca\n  fullName: OpCodes.Ldloca\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the address of the local variable at a specific index onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE OD < `unsigned int16` >|ldloca `index`|Loads the address of the local variable at `index` onto the evaluation stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The address stored in the local variable at the specified index is pushed onto the stack.  \\n  \\n The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>. The result is a transient pointer (type `*`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, short)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloca;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldloca_S\n  commentId: F:System.Reflection.Emit.OpCodes.Ldloca_S\n  id: Ldloca_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldloca_S\n  nameWithType: OpCodes.Ldloca_S\n  fullName: OpCodes.Ldloca_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Loads the address of the local variable at a specific index onto the evaluation stack, short form.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|12 < `unsigned int8` >|ldloca.s `index`|Loads the address of the local variable at `index` onto the evaluation stack, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The address stored in the local variable at the specified index is pushed onto the stack.  \\n  \\n The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>. The result is a transient pointer (type `*`).  \\n  \\n The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldloca_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldnull\n  commentId: F:System.Reflection.Emit.OpCodes.Ldnull\n  id: Ldnull\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldnull\n  nameWithType: OpCodes.Ldnull\n  fullName: OpCodes.Ldnull\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes a null reference (type `O`) onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|14|ldnull|push a null reference onto the stack|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A null object reference is pushed onto the stack.  \\n  \\n `ldnull` pushes a null reference (type `O`) on the stack. This is used to initialize locations before they are populated with data, or when they become deprecated.  \\n  \\n `ldnull` provides a null reference that is size-independent.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldnull;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldobj\n  commentId: F:System.Reflection.Emit.OpCodes.Ldobj\n  id: Ldobj\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldobj\n  nameWithType: OpCodes.Ldobj\n  fullName: OpCodes.Ldobj\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Copies the value type object pointed to by an address to the top of the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|71 < `T` >|ldobj `class`|Copy instance of value type `class` to the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The address of a value type object is pushed onto the stack.  \\n  \\n2.  The address is popped from the stack and the instance at that particular address is looked up.  \\n  \\n3.  The value of the object stored at that address is pushed onto the stack.  \\n  \\n The `ldobj` instruction is used to pass a value type as a parameter.  \\n  \\n The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack. The number of bytes copied depends on the size of the class (as specified by the `class` parameter). The `class` parameter is a metadata token representing the value type.  \\n  \\n The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldobj;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldsfld\n  commentId: F:System.Reflection.Emit.OpCodes.Ldsfld\n  id: Ldsfld\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldsfld\n  nameWithType: OpCodes.Ldsfld\n  fullName: OpCodes.Ldsfld\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the value of a static field onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|7E < `T` >|ldsfld `field`|Push the value of `field` on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value of the specific field is pushed onto the stack.  \\n  \\n The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack. The return type is that associated with the passed metadata token `field`.  \\n  \\n The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, FieldInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldsfld;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldsflda\n  commentId: F:System.Reflection.Emit.OpCodes.Ldsflda\n  id: Ldsflda\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldsflda\n  nameWithType: OpCodes.Ldsflda\n  fullName: OpCodes.Ldsflda\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the address of a static field onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|7F < `T` >|ldsflda `field`|Push the address of `field` on the stack|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The address of a specific field is pushed onto the stack.  \\n  \\n The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack. The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed. Otherwise, it corresponds to an unmanaged pointer (type `native int`). Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.  \\n  \\n The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.  \\n  \\n <xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, FieldInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldsflda;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldstr\n  commentId: F:System.Reflection.Emit.OpCodes.Ldstr\n  id: Ldstr\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldstr\n  nameWithType: OpCodes.Ldstr\n  fullName: OpCodes.Ldstr\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes a new object reference to a string literal stored in the metadata.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|72 < `T` >|ldstr `mdToken`|Pushes a string object for the metadata string token `mdToken`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to a string is pushed onto the stack.  \\n  \\n The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata. The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.  \\n  \\n The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as \\\"string interning\\\").  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, string)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldstr;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldtoken\n  commentId: F:System.Reflection.Emit.OpCodes.Ldtoken\n  id: Ldtoken\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldtoken\n  nameWithType: OpCodes.Ldtoken\n  fullName: OpCodes.Ldtoken\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D0 < `T` >|ldtoken `token`|Converts a metadata token to its runtime representation.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The passed token is converted to a `RuntimeHandle` and pushed onto the stack.  \\n  \\n The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token. A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.  \\n  \\n The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.  \\n  \\n For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, MethodInfo)  \\n  \\n-   ILGenerator.Emit(OpCode, FieldInfo)  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldtoken;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ldvirtftn\n  commentId: F:System.Reflection.Emit.OpCodes.Ldvirtftn\n  id: Ldvirtftn\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ldvirtftn\n  nameWithType: OpCodes.Ldvirtftn\n  fullName: OpCodes.Ldvirtftn\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes an unmanaged pointer (type `native int`) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 07 < `T` >|ldvirtftn `method`|Pushes the pointer to an object's virtual method `method` on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference is pushed onto the stack.  \\n  \\n2.  The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.  \\n  \\n3.  The pointer to `method` is pushed onto the stack.  \\n  \\n The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).  \\n  \\n The unmanaged pointer points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, MethodInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ldvirtftn;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Leave\n  commentId: F:System.Reflection.Emit.OpCodes.Leave\n  id: Leave\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Leave\n  nameWithType: OpCodes.Leave\n  fullName: OpCodes.Leave\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Exits a protected region of code, unconditionally transferring control to a specific target instruction.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|DD < `int32` >|leave `target`|Exits a protected region of code.|  \\n  \\n There is no stack transition behavior specified for this instruction.  \\n  \\n The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.  \\n  \\n You cannot use a `leave` instruction to exit a `finally` block. To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.  \\n  \\n If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Leave;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Leave_S\n  commentId: F:System.Reflection.Emit.OpCodes.Leave_S\n  id: Leave_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Leave_S\n  nameWithType: OpCodes.Leave_S\n  fullName: OpCodes.Leave_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Exits a protected region of code, unconditionally transferring control to a target instruction (short form).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|DE < `int8` >|leave.s `target`|Exit a protected region of code, short form.|  \\n  \\n There is no stack transition behavior specified for this instruction.  \\n  \\n The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.  \\n  \\n The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.  \\n  \\n You cannot use a `leave.s` instruction to exit a `finally` block. To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.  \\n  \\n If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Leave_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Localloc\n  commentId: F:System.Reflection.Emit.OpCodes.Localloc\n  id: Localloc\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Localloc\n  nameWithType: OpCodes.Localloc\n  fullName: OpCodes.Localloc\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type `*`) of the first allocated byte onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 0F|localloc|Allocate space from the local heap.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The number of bytes to be allocated is pushed onto the stack.  \\n  \\n2.  The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.  \\n  \\n3.  A pointer to the first byte of the allocated memory is pushed onto the stack.  \\n  \\n The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte. The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`. When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.  \\n  \\n The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  \\n  \\n The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.  \\n  \\n <xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Localloc;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Mkrefany\n  commentId: F:System.Reflection.Emit.OpCodes.Mkrefany\n  id: Mkrefany\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Mkrefany\n  nameWithType: OpCodes.Mkrefany\n  fullName: OpCodes.Mkrefany\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes a typed reference to an instance of a specific type onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|C6 < `T` >|mkrefany `class`|Pushes a typed reference of type `class` onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A pointer to piece of data is pushed onto the stack.  \\n  \\n2.  The pointer is popped and converted to a typed reference of type `class`.  \\n  \\n3.  The typed reference is pushed onto the stack.  \\n  \\n The `mkrefany` instruction supports the passing of dynamically typed references. The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data. `Class` is the class token describing the type of the data referenced by the pointer. `Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.  \\n  \\n The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter. The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.  \\n  \\n <xref:System.TypeLoadException> is thrown if `class` cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Mkrefany;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Mul\n  commentId: F:System.Reflection.Emit.OpCodes.Mul\n  id: Mul\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Mul\n  nameWithType: OpCodes.Mul\n  fullName: OpCodes.Mul\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Multiplies two values and pushes the result on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|5A|mul|Multiplies two values on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack. Integer operations silently truncate the upper bits on overflow.  \\n  \\n See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.  \\n  \\n For floating-point types, 0 * infinity = NaN.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Mul;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Mul_Ovf\n  commentId: F:System.Reflection.Emit.OpCodes.Mul_Ovf\n  id: Mul_Ovf\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Mul_Ovf\n  nameWithType: OpCodes.Mul_Ovf\n  fullName: OpCodes.Mul_Ovf\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D8|mul.ovf|Multiplies two integer values on the stack with an overflow check.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Mul_Ovf;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Mul_Ovf_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un\n  id: Mul_Ovf_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Mul_Ovf_Un\n  nameWithType: OpCodes.Mul_Ovf_Un\n  fullName: OpCodes.Mul_Ovf_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|D9|mul.ovf.un|Multiplies two unsigned values on the stack with an overflow check.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Neg\n  commentId: F:System.Reflection.Emit.OpCodes.Neg\n  id: Neg\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Neg\n  nameWithType: OpCodes.Neg\n  fullName: OpCodes.Neg\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Negates a value and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|65|neg|Negates the value currently on top of the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is pushed onto the stack.  \\n  \\n2.  A value is popped from the stack and negated.  \\n  \\n3.  The result is pushed onto the stack.  \\n  \\n The `neg` instruction negates value and pushes the result on top of the stack. The return type is the same as the operand type.  \\n  \\n Negation of integral values is standard two's complement negation. In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number. To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).  \\n  \\n Negating a floating-point number cannot overflow, and negating NaN returns NaN.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Neg;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Newarr\n  commentId: F:System.Reflection.Emit.OpCodes.Newarr\n  id: Newarr\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Newarr\n  nameWithType: OpCodes.Newarr\n  fullName: OpCodes.Newarr\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|8D < `T` >|newarr `etype`|Creates a new array with elements of type `etype`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The number of elements in the array is pushed onto the stack.  \\n  \\n2.  The number of elements is popped from the stack and the array is created.  \\n  \\n3.  An object reference to the new array is pushed onto the stack.  \\n  \\n The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type). The number of elements in the new array should be specified as a `native int`. Valid array indexes range from zero to the maximum number of elements minus one.  \\n  \\n The elements of an array can be any type, including value types.  \\n  \\n Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on). Elements of the array are initialized to 0 of the appropriate type.  \\n  \\n Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`. More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.  \\n  \\n <xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.  \\n  \\n <xref:System.OverflowException> is thrown if `numElems` is less than 0.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Newarr;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Newobj\n  commentId: F:System.Reflection.Emit.OpCodes.Newobj\n  id: Newobj\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Newobj\n  nameWithType: OpCodes.Newobj\n  fullName: OpCodes.Newobj\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Creates a new object or a new instance of a value type, pushing an object reference (type `O`) onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|73 < `T` >|newobj `ctor`|Allocates an uninitialized object or value type and calls the constructor method `ctor`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  Arguments `arg1` through `argn` are pushed on the stack in sequence.  \\n  \\n2.  Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.  \\n  \\n3.  A reference to the new object is pushed onto the stack.  \\n  \\n The `newobj` instruction creates a new object or a new instance of a value type. `Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.  \\n  \\n The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate. It then calls the constructor `ctor` with the given arguments along with the newly created instance. After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.  \\n  \\n From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.  \\n  \\n All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`. On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.  \\n  \\n Value types are not usually created using `newobj`. They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects. Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>. However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.  \\n  \\n <xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.  \\n  \\n <xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, ConstructorInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Newobj;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Nop\n  commentId: F:System.Reflection.Emit.OpCodes.Nop\n  id: Nop\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Nop\n  nameWithType: OpCodes.Nop\n  fullName: OpCodes.Nop\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Fills space if opcodes are patched. No meaningful operation is performed although a processing cycle can be consumed.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|00|nop|Performs an operation without behavior.|  \\n  \\n There is no stack transitional behavior defined for this instruction.  \\n  \\n The `nop` operation does nothing. It is intended to fill in space if opcodes are patched.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Nop;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Not\n  commentId: F:System.Reflection.Emit.OpCodes.Not\n  id: Not\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Not\n  nameWithType: OpCodes.Not\n  fullName: OpCodes.Not\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|66|not|Computes the bitwise complement of a value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value` is pushed onto the stack.  \\n  \\n2.  `value` is popped from the stack and its bitwise complement computed.  \\n  \\n3.  The result is pushed onto the stack.  \\n  \\n The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack. The return type is the same as the operand type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Not;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Or\n  commentId: F:System.Reflection.Emit.OpCodes.Or\n  id: Or\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Or\n  nameWithType: OpCodes.Or\n  fullName: OpCodes.Or\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|60|or|Computes the bitwise OR of two integer values, returns an integer.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack and their bitwise OR computed.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.  \\n  \\n `Or` is an integer-specific operation.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Or;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Pop\n  commentId: F:System.Reflection.Emit.OpCodes.Pop\n  id: Pop\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Pop\n  nameWithType: OpCodes.Pop\n  fullName: OpCodes.Pop\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Removes the value currently on top of the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|26|pop|Pops the top value from the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The top value is popped from the stack.  \\n  \\n The `pop` instruction removes the top element from the stack.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Pop;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefix1\n  commentId: F:System.Reflection.Emit.OpCodes.Prefix1\n  id: Prefix1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefix1\n  nameWithType: OpCodes.Prefix1\n  fullName: OpCodes.Prefix1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefix1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefix2\n  commentId: F:System.Reflection.Emit.OpCodes.Prefix2\n  id: Prefix2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefix2\n  nameWithType: OpCodes.Prefix2\n  fullName: OpCodes.Prefix2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefix2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefix3\n  commentId: F:System.Reflection.Emit.OpCodes.Prefix3\n  id: Prefix3\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefix3\n  nameWithType: OpCodes.Prefix3\n  fullName: OpCodes.Prefix3\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefix3;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefix4\n  commentId: F:System.Reflection.Emit.OpCodes.Prefix4\n  id: Prefix4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefix4\n  nameWithType: OpCodes.Prefix4\n  fullName: OpCodes.Prefix4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefix4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefix5\n  commentId: F:System.Reflection.Emit.OpCodes.Prefix5\n  id: Prefix5\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefix5\n  nameWithType: OpCodes.Prefix5\n  fullName: OpCodes.Prefix5\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefix5;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefix6\n  commentId: F:System.Reflection.Emit.OpCodes.Prefix6\n  id: Prefix6\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefix6\n  nameWithType: OpCodes.Prefix6\n  fullName: OpCodes.Prefix6\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefix6;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefix7\n  commentId: F:System.Reflection.Emit.OpCodes.Prefix7\n  id: Prefix7\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefix7\n  nameWithType: OpCodes.Prefix7\n  fullName: OpCodes.Prefix7\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefix7;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Prefixref\n  commentId: F:System.Reflection.Emit.OpCodes.Prefixref\n  id: Prefixref\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Prefixref\n  nameWithType: OpCodes.Prefixref\n  fullName: OpCodes.Prefixref\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: This is a reserved instruction.\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Prefixref;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Readonly\n  commentId: F:System.Reflection.Emit.OpCodes.Readonly\n  id: Readonly\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Readonly\n  nameWithType: OpCodes.Readonly\n  fullName: OpCodes.Readonly\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 1E|readonly.|Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.|  \\n  \\n This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays. Its effect on the subsequent operation is twofold:  \\n  \\n1.  At run time, no type check operation is performed. Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays. There is never a run-time type check for value classes, so `readonly` is a no-op in that case.  \\n  \\n2.  The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.  \\n  \\n The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated. For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix). In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.  \\n  \\n A managed pointer restricted in this fashion can be used only in the following ways:  \\n  \\n-   As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.  \\n  \\n-   As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.  \\n  \\n-   As the `source` parameter to the `cpobj` instruction.  \\n  \\n All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.  \\n  \\n The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code. For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.  \\n  \\n```  \\nldloc arr  \\nldloc i  \\nreadonly.  \\nldelema !0    // Loads the pointer to the object.  \\n…             // Load the arguments to the call.  \\nconstrained. !0  \\ncallvirt m  \\n```  \\n  \\n Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type. Not only is this type check inefficient, but it is semantically incorrect. The type check for `ldelema` is an exact match, which is too strong. If the array held subclasses of type !0, the code above would fail the type check.  \\n  \\n The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.  \\n  \\n In general it would be unsafe to skip the run-time check if the array held elements of a reference type. To be safe, it is necessary to ensure that no modifications to the array are made through this pointer. The verifier rules ensure this. The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Readonly;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Refanytype\n  commentId: F:System.Reflection.Emit.OpCodes.Refanytype\n  id: Refanytype\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Refanytype\n  nameWithType: OpCodes.Refanytype\n  fullName: OpCodes.Refanytype\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Retrieves the type token embedded in a typed reference.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 1D|refanytype|Pushes the type token stored in a typed reference.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value type reference is pushed onto the stack.  \\n  \\n2.  The typed reference is popped from the stack and its corresponding type token retrieved.  \\n  \\n3.  The type token is pushed onto the stack.  \\n  \\n A typed reference contains a type token and an address to an object instance.  \\n  \\n The `refanytype` instruction retrieves the type token embedded in the typed reference. See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Refanytype;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Refanyval\n  commentId: F:System.Reflection.Emit.OpCodes.Refanyval\n  id: Refanyval\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Refanyval\n  nameWithType: OpCodes.Refanyval\n  fullName: OpCodes.Refanyval\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Retrieves the address (type `&`) embedded in a typed reference.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|C2 < `T` >|refanyval `type`|Pushes the address stored in a typed reference.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value type reference is pushed onto the stack.  \\n  \\n2.  The typed reference is popped from the stack and the corresponding address retrieved.  \\n  \\n3.  The address is pushed onto the stack.  \\n  \\n A typed reference contains a type token and an address to an object instance.  \\n  \\n The `refanyval` instruction retrieves the address embedded in the a typed reference. The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`). See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.  \\n  \\n <xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).  \\n  \\n <xref:System.TypeLoadException> is thrown if `type` cannot be found.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Refanyval;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Rem\n  commentId: F:System.Reflection.Emit.OpCodes.Rem\n  id: Rem\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Rem\n  nameWithType: OpCodes.Rem\n  fullName: OpCodes.Rem\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Divides two values and pushes the remainder onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|5D|rem|Pushes the remainder of dividing `value1` by `value2` onto the stack.|  \\n  \\n> [!NOTE]\\n>  ReplaceThisText  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n `result` = `value1` `rem` `value2` satisfies the following conditions:  \\n  \\n `result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:  \\n  \\n 0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.  \\n  \\n If `value2` is zero or `value1` is infinity the result is NaN. If `value2` is infinity, the result is `value1` (negated for `-infinity`).  \\n  \\n Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.  \\n  \\n Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Rem;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Rem_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Rem_Un\n  id: Rem_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Rem_Un\n  nameWithType: OpCodes.Rem_Un\n  fullName: OpCodes.Rem_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Divides two unsigned values and pushes the remainder onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|5E|rem.un|Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n `result` = `value1` `rem.un` `value2` satisfies the following conditions:  \\n  \\n `result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:  \\n  \\n 0 = `result` < `value2`, where `div.un` is the unsigned division instruction.  \\n  \\n The `rem.un` instruction computes `result` and pushes it on the stack. `Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.  \\n  \\n `Rem.un` is unspecified for floating-point numbers.  \\n  \\n Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Rem_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Ret\n  commentId: F:System.Reflection.Emit.OpCodes.Ret\n  id: Ret\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Ret\n  nameWithType: OpCodes.Ret\n  fullName: OpCodes.Ret\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|2A|ret|Returns from method, possibly returning a value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The return value is popped from the callee evaluation stack.  \\n  \\n2.  The return value obtained in step 1 is pushed onto the caller evaluation stack.  \\n  \\n If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).  \\n  \\n The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method. The evaluation stack for the current method must be empty except for the value to be returned.  \\n  \\n The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block. From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks. Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Ret;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Rethrow\n  commentId: F:System.Reflection.Emit.OpCodes.Rethrow\n  id: Rethrow\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Rethrow\n  nameWithType: OpCodes.Rethrow\n  fullName: OpCodes.Rethrow\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Rethrows the current exception.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 1A|rethrow|Rethrows the current exception|  \\n  \\n No stack transition behavior is defined for this instruction.  \\n  \\n The `rethrow` instruction is only permitted within the body of a `catch` handler. It throws the same exception that was caught by this handler.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Rethrow;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Shl\n  commentId: F:System.Reflection.Emit.OpCodes.Shl\n  id: Shl\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Shl\n  nameWithType: OpCodes.Shl\n  fullName: OpCodes.Shl\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|62|shl|Shifts an integer to the left (shifting in zeros).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is pushed onto the stack.  \\n  \\n2.  The amount of bits to be shifted is pushed onto the stack.  \\n  \\n3.  The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits. The number of bits is a value of type `int32` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.  \\n  \\n `Shl` inserts a zero bit in the lowest position on each shift.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Shl;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Shr\n  commentId: F:System.Reflection.Emit.OpCodes.Shr\n  id: Shr\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Shr\n  nameWithType: OpCodes.Shr\n  fullName: OpCodes.Shr\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|63|shr|Shifts an integer to the right (shifting in sign).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is pushed onto the stack.  \\n  \\n2.  The amount of bits to be shifted is pushed onto the stack.  \\n  \\n3.  The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits. The number of bits is a value of type `int32` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.  \\n  \\n `Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Shr;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Shr_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Shr_Un\n  id: Shr_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Shr_Un\n  nameWithType: OpCodes.Shr_Un\n  fullName: OpCodes.Shr_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|64|shr.un|Shifts an integer to the right (shifting in zeroes).|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is pushed onto the stack.  \\n  \\n2.  The amount of bits to be shifted is pushed onto the stack.  \\n  \\n3.  The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits. The number of bits is a value of type `int32`, `int64` or `native int`. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.  \\n  \\n `Shr.un` inserts a zero bit in the highest position on each shift.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Shr_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Sizeof\n  commentId: F:System.Reflection.Emit.OpCodes.Sizeof\n  id: Sizeof\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Sizeof\n  nameWithType: OpCodes.Sizeof\n  fullName: OpCodes.Sizeof\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pushes the size, in bytes, of a supplied value type onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 1C < `T` >|sizeof `valType`|Push the size, in bytes, of a value type as an `unsigned int32`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.  \\n  \\n `valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.  \\n  \\n For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value. A generic type parameter can be used only in the body of the type or method that defines it. When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Sizeof;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Starg\n  commentId: F:System.Reflection.Emit.OpCodes.Starg\n  id: Starg\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Starg\n  nameWithType: OpCodes.Starg\n  fullName: OpCodes.Starg\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores the value on top of the evaluation stack in the argument slot at a specified index.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 0B < `unsigned int16` >|starg `num`|Pops the top value from the stack and stores it in argument slot `num`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value currently on top of the stack is popped and placed in argument slot `num`.  \\n  \\n The `starg` instruction pops a value from the stack and places it in argument slot `num`. The type of the value must match the type of the argument, as specified in the current method's signature.  \\n  \\n For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \\n  \\n Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, short)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Starg;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Starg_S\n  commentId: F:System.Reflection.Emit.OpCodes.Starg_S\n  id: Starg_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Starg_S\n  nameWithType: OpCodes.Starg_S\n  fullName: OpCodes.Starg_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|10 < `unsigned int8` >|starg.s `num`|Pops the top value from the stack and stores it in argument slot `num`, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  The value currently on top of the stack is popped and placed in argument slot `num`.  \\n  \\n The `starg.s` instruction pops a value from the stack and places it in argument slot `num`. The type of the value must match the type of the argument, as specified in the current method's signature.  \\n  \\n The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.  \\n  \\n For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.  \\n  \\n Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A>method overload can use the `starg.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Starg_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem\n  id: Stelem\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem\n  nameWithType: OpCodes.Stelem\n  fullName: OpCodes.Stelem\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|A4 < `T` >|stelem `typeTok`|Replaces the array element at the supplied index with a value of type `typeTok` on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  An index value, `index`, to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value of the type specified in the instruction is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value. The value has the type specified by the token `typeTok` in the instruction.  \\n  \\n Arrays are objects, and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_I\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I\n  id: Stelem_I\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_I\n  nameWithType: OpCodes.Stelem_I\n  fullName: OpCodes.Stelem_I\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the `native int` value on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|9B|stelem.i|Replaces an array element at the supplied index with the `native int` value on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_I;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_I1\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I1\n  id: Stelem_I1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_I1\n  nameWithType: OpCodes.Stelem_I1\n  fullName: OpCodes.Stelem_I1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the `int8` value on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|9C|stelem.i1|Replaces an array element at the supplied index with the `int8` value on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_I1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_I2\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I2\n  id: Stelem_I2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_I2\n  nameWithType: OpCodes.Stelem_I2\n  fullName: OpCodes.Stelem_I2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the `int16` value on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|9D|stelem.i2|Replaces an array element at the supplied index with the `int16` value on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_I2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_I4\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I4\n  id: Stelem_I4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_I4\n  nameWithType: OpCodes.Stelem_I4\n  fullName: OpCodes.Stelem_I4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the `int32` value on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|9E|stelem.i4|Replaces an array element at the supplied index with the `int32` value on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_I4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_I8\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I8\n  id: Stelem_I8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_I8\n  nameWithType: OpCodes.Stelem_I8\n  fullName: OpCodes.Stelem_I8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the `int64` value on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|9F|stelem.i8|Replaces an array element at the supplied index with the `int64` value on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_I8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_R4\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_R4\n  id: Stelem_R4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_R4\n  nameWithType: OpCodes.Stelem_R4\n  fullName: OpCodes.Stelem_R4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the `float32` value on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|A0|stelem.r4|Replaces an array element at the supplied index with the `float32` value on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_R4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_R8\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_R8\n  id: Stelem_R8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_R8\n  nameWithType: OpCodes.Stelem_R8\n  fullName: OpCodes.Stelem_R8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the `float64` value on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|A1|stelem.r8|Replaces an array element at the supplied index with the `float64` value on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_R8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stelem_Ref\n  commentId: F:System.Reflection.Emit.OpCodes.Stelem_Ref\n  id: Stelem_Ref\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stelem_Ref\n  nameWithType: OpCodes.Stelem_Ref\n  fullName: OpCodes.Stelem_Ref\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the array element at a given index with the object ref value (type `O`) on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|A2|stelem.ref|Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference to an array, `array`, is pushed onto the stack.  \\n  \\n2.  A valid index to an element in `array` is pushed onto the stack.  \\n  \\n3.  A value is pushed onto the stack.  \\n  \\n4.  The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.  \\n  \\n The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.  \\n  \\n Arrays are objects and hence represented by a value of type `O`. The index is type `native int`.  \\n  \\n Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element. This cast can fail, even for verified code. Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>. For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.  \\n  \\n <xref:System.NullReferenceException> is thrown if `array` is a null reference.  \\n  \\n <xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.  \\n  \\n <xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stelem_Ref;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stfld\n  commentId: F:System.Reflection.Emit.OpCodes.Stfld\n  id: Stfld\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stfld\n  nameWithType: OpCodes.Stfld\n  fullName: OpCodes.Stfld\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the value stored in the field of an object reference or pointer with a new value.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|7D < `T` >|stfld `field`|Replaces the value of `field` of the object with a new value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference or pointer is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.  \\n  \\n The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value. `Field` is a metadata token that refers to a field member reference. The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.  \\n  \\n <xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.  \\n  \\n <xref:System.MissingFieldException> is thrown if `field` is not found in the metadata. This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, FieldInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stfld;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_I\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_I\n  id: Stind_I\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_I\n  nameWithType: OpCodes.Stind_I\n  fullName: OpCodes.Stind_I\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a value of type `native int` at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|DF|stind.i|Stores a `native int` value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_I;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_I1\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_I1\n  id: Stind_I1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_I1\n  nameWithType: OpCodes.Stind_I1\n  fullName: OpCodes.Stind_I1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a value of type `int8` at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|52|stind.i1|Stores an `int8` value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_I1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_I2\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_I2\n  id: Stind_I2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_I2\n  nameWithType: OpCodes.Stind_I2\n  fullName: OpCodes.Stind_I2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a value of type `int16` at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|53|stind.i2|Stores an `int16` value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned>prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_I2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_I4\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_I4\n  id: Stind_I4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_I4\n  nameWithType: OpCodes.Stind_I4\n  fullName: OpCodes.Stind_I4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a value of type `int32` at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|54|stind.i4|Stores an `int32` value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_I4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_I8\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_I8\n  id: Stind_I8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_I8\n  nameWithType: OpCodes.Stind_I8\n  fullName: OpCodes.Stind_I8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a value of type `int64` at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|55|stind.i8|Stores an `int64` value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_I8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_R4\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_R4\n  id: Stind_R4\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_R4\n  nameWithType: OpCodes.Stind_R4\n  fullName: OpCodes.Stind_R4\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a value of type `float32` at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|56|stind.r4|Stores a `float32` value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_R4;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_R8\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_R8\n  id: Stind_R8\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_R8\n  nameWithType: OpCodes.Stind_R8\n  fullName: OpCodes.Stind_R8\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a value of type `float64` at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|57|stind.r8|Stores a `float64` value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_R8;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stind_Ref\n  commentId: F:System.Reflection.Emit.OpCodes.Stind_Ref\n  id: Stind_Ref\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stind_Ref\n  nameWithType: OpCodes.Stind_Ref\n  fullName: OpCodes.Stind_Ref\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Stores a object reference value at a supplied address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|51|stind.ref|Stores an object reference (type `O`) value at a given address.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value is pushed onto the stack.  \\n  \\n3.  The value and the address are popped from the stack; the value is stored at the address.  \\n  \\n The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).  \\n  \\n Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer. The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stind_Ref;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stloc\n  commentId: F:System.Reflection.Emit.OpCodes.Stloc\n  id: Stloc\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stloc\n  nameWithType: OpCodes.Stloc\n  fullName: OpCodes.Stloc\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 0E < `unsigned int16` >|stloc `index`|Pops a value from the stack and stores it in local variable `index`.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is popped off of the stack and placed in local variable `index`.  \\n  \\n The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.  \\n  \\n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index. For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid). The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, LocalBuilder)  \\n  \\n-   ILGenerator.Emit(OpCode, short)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stloc;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stloc_0\n  commentId: F:System.Reflection.Emit.OpCodes.Stloc_0\n  id: Stloc_0\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stloc_0\n  nameWithType: OpCodes.Stloc_0\n  fullName: OpCodes.Stloc_0\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|0A|stloc.0|Pops a value from the stack into local variable 0.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is popped off of the stack and placed in the local variable indexed by 0.  \\n  \\n The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0. The type of the value must match the type of the local variable as specified in the current method's local signature.  \\n  \\n `stloc.0` is an especially efficient encoding for storing values in local variable 0.  \\n  \\n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stloc_0;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stloc_1\n  commentId: F:System.Reflection.Emit.OpCodes.Stloc_1\n  id: Stloc_1\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stloc_1\n  nameWithType: OpCodes.Stloc_1\n  fullName: OpCodes.Stloc_1\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|0B|stloc.1|Pops a value from the stack into local variable 1.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is popped off of the stack and placed in the local variable indexed by 1.  \\n  \\n The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1. The type of the value must match the type of the local variable as specified in the current method's local signature.  \\n  \\n `stloc.1` is an especially efficient encoding for storing values in local variable 1.  \\n  \\n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stloc_1;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stloc_2\n  commentId: F:System.Reflection.Emit.OpCodes.Stloc_2\n  id: Stloc_2\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stloc_2\n  nameWithType: OpCodes.Stloc_2\n  fullName: OpCodes.Stloc_2\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|0C|stloc.2|Pops a value from the stack into local variable 2|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is popped off of the stack and placed in the local variable indexed by 2.  \\n  \\n The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2. The type of the value must match the type of the local variable as specified in the current method's local signature.  \\n  \\n `stloc.2` is an especially efficient encoding for storing values in local variable 2.  \\n  \\n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stloc_2;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stloc_3\n  commentId: F:System.Reflection.Emit.OpCodes.Stloc_3\n  id: Stloc_3\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stloc_3\n  nameWithType: OpCodes.Stloc_3\n  fullName: OpCodes.Stloc_3\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|0D|stloc.3|Pops a value from the stack into local variable 3|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is popped off of the stack and placed in the local variable indexed by 3.  \\n  \\n The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3. The type of the value must match the type of the local variable as specified in the current method's local signature.  \\n  \\n `stloc.3` is an especially efficient encoding for storing values in local variable 3.  \\n  \\n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stloc_3;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stloc_S\n  commentId: F:System.Reflection.Emit.OpCodes.Stloc_S\n  id: Stloc_S\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stloc_S\n  nameWithType: OpCodes.Stloc_S\n  fullName: OpCodes.Stloc_S\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <code>index</code> (short form).\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|13 < `unsigned int8` >|stloc.s `index`|Pops a value from the stack and stores it in local variable `index`, short form.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is popped off of the stack and placed in local variable `index`.  \\n  \\n The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.  \\n  \\n The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.  \\n  \\n Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, LocalBuilder)  \\n  \\n-   ILGenerator.Emit(OpCode, byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stloc_S;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stobj\n  commentId: F:System.Reflection.Emit.OpCodes.Stobj\n  id: Stobj\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stobj\n  nameWithType: OpCodes.Stobj\n  fullName: OpCodes.Stobj\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Copies a value of a specified type from the evaluation stack into a supplied memory address.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|81 < `T` >|stobj `class`|Stores a value of type `class` from the stack into memory.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n2.  A value type object of type `class` is pushed onto the stack.  \\n  \\n3.  The object and the address are popped from the stack; the value type object is stored at the address.  \\n  \\n The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`). The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.  \\n  \\n The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.  \\n  \\n <xref:System.TypeLoadException> is thrown if class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stobj;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Stsfld\n  commentId: F:System.Reflection.Emit.OpCodes.Stsfld\n  id: Stsfld\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Stsfld\n  nameWithType: OpCodes.Stsfld\n  fullName: OpCodes.Stsfld\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Replaces the value of a static field with a value from the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|80 < `T` >|stsfld `field`|Replaces the value in `field` with a supplied value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is pushed onto the stack.  \\n  \\n2.  A value is popped from the stack and stored in `field`.  \\n  \\n The `stsfld` instruction replaces the value of a static field with a value from the stack. `field` is a metadata token that must refer to a static field member.  \\n  \\n The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.  \\n  \\n <xref:System.MissingFieldException> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, FieldInfo)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Stsfld;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Sub\n  commentId: F:System.Reflection.Emit.OpCodes.Sub\n  id: Sub\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Sub\n  nameWithType: OpCodes.Sub\n  fullName: OpCodes.Sub\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Subtracts one value from another and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|59|sub|Subtracts one value from another, returning a new numeric value.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  \\n  \\n Integer subtraction wraps, rather than saturates. For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the \\\"wrapped\\\" result will be 255.  \\n  \\n Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Sub;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Sub_Ovf\n  commentId: F:System.Reflection.Emit.OpCodes.Sub_Ovf\n  id: Sub_Ovf\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Sub_Ovf\n  nameWithType: OpCodes.Sub_Ovf\n  fullName: OpCodes.Sub_Ovf\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|DA|sub.ovf|Subtracts one integer value from another with an overflow check.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Sub_Ovf;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Sub_Ovf_Un\n  commentId: F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un\n  id: Sub_Ovf_Un\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Sub_Ovf_Un\n  nameWithType: OpCodes.Sub_Ovf_Un\n  fullName: OpCodes.Sub_Ovf_Un\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|DB|sub.ovf.un|Subtracts one unsigned integer value from another with an overflow check.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.  \\n  \\n4.  The result is pushed onto the stack.  \\n  \\n <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  \\n  \\n This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Switch\n  commentId: F:System.Reflection.Emit.OpCodes.Switch\n  id: Switch\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Switch\n  nameWithType: OpCodes.Switch\n  fullName: OpCodes.Switch\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Implements a jump table.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|45 < `unsigned int32` > < `int32` >... < `int32` >|switch (`N`, `t1`, `t2`... `tN`)|Jumps to one of `N` values.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  A value is pushed onto the stack.  \\n  \\n2.  The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.  \\n  \\n The `switch` instruction implements a jump table. The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets. These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.  \\n  \\n The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`. If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on). If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).  \\n  \\n If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.  \\n  \\n Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction. (Such transfers are severely restricted and must use the leave instruction instead).  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode. The `Label[]` argument is an array of Labels representing 32-bit offsets.  \\n  \\n-   ILGenerator.Emit(OpCode, Label[])\"\n  example:\n  - \"The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.  \\n  \\n [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]\\n [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]\\n [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Switch;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Tailcall\n  commentId: F:System.Reflection.Emit.OpCodes.Tailcall\n  id: Tailcall\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Tailcall\n  nameWithType: OpCodes.Tailcall\n  fullName: OpCodes.Tailcall\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 14|tail.|Subsequent call terminates current methods|  \\n  \\n There is no stack transition behavior defined for this instruction.  \\n  \\n The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction. It indicates that the current method's stack frame should be removed before the call instruction is executed. It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.  \\n  \\n The stack must be empty except for the arguments being transferred by the following call. The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`). Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.  \\n  \\n The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security. The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction. Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Tailcall;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)\n  commentId: M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)\n  id: TakesSingleByteArgument(System.Reflection.Emit.OpCode)\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: TakesSingleByteArgument(OpCode)\n  nameWithType: OpCodes.TakesSingleByteArgument(OpCode)\n  fullName: OpCodes.TakesSingleByteArgument(OpCode)\n  type: Method\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Returns true or false if the supplied opcode takes a single byte argument.\n  remarks: \"This method can be used to find which MSIL opcodes are \\\"short form\\\", for use in optimized code.  \\n  \\n `TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:  \\n  \\n-   The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  \\n  \\n-   The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  \\n  \\n-   The opcode references a variable or argument via the byte-sized \\\"short form\\\" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  \\n  \\n Otherwise, it returns `false`.  \\n  \\n The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.  \\n  \\n [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]\\n [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]\\n [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]\"\n  syntax:\n    content: public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);\n    parameters:\n    - id: inst\n      type: System.Reflection.Emit.OpCode\n      description: An instance of an Opcode object.\n    return:\n      type: System.Boolean\n      description: '`True` or `false`.'\n  overload: System.Reflection.Emit.OpCodes.TakesSingleByteArgument*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Throw\n  commentId: F:System.Reflection.Emit.OpCodes.Throw\n  id: Throw\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Throw\n  nameWithType: OpCodes.Throw\n  fullName: OpCodes.Throw\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Throws the exception object currently on the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|7A|throw|Throws an exception.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference (to an exception) is pushed onto the stack.  \\n  \\n2.  The object reference is popped from the stack and the exception thrown.  \\n  \\n The `throw` instruction throws the exception object (type `O`) currently on the stack.  \\n  \\n <xref:System.NullReferenceException> is thrown if the object reference is a null reference.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Throw;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Unaligned\n  commentId: F:System.Reflection.Emit.OpCodes.Unaligned\n  id: Unaligned\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Unaligned\n  nameWithType: OpCodes.Unaligned\n  fullName: OpCodes.Unaligned\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 12 < `unsigned int8` >|unaligned. `alignment`|Indicates that the subsequent pointer instruction may be unaligned.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n `Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary. For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs). Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.  \\n  \\n The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively. Note that transient pointers (type `*`) are always aligned.  \\n  \\n While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.  \\n  \\n The `unaligned` and `volatile` prefixes can be combined in either order. They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Label)  \\n  \\n-   ILGenerator.Emit(Opcode, Byte)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Unaligned;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Unbox\n  commentId: F:System.Reflection.Emit.OpCodes.Unbox\n  id: Unbox\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Unbox\n  nameWithType: OpCodes.Unbox\n  fullName: OpCodes.Unbox\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the boxed representation of a value type to its unboxed form.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|79 < `T` >|unbox `valType`|Extracts the value type data from `obj`, its boxed representation.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference is pushed onto the stack.  \\n  \\n2.  The object reference is popped from the stack and unboxed to a value type pointer.  \\n  \\n3.  The value type pointer is pushed onto the stack.  \\n  \\n A value type has two separate representations within the Common Language Infrastructure (CLI):  \\n  \\n-   A 'raw' form used when a value type is embedded within another object.  \\n  \\n-   A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.  \\n  \\n The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form. The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.  \\n  \\n Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object. Typically it simply computes the address of the value type that is already present inside of the boxed object.  \\n  \\n <xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.  \\n  \\n <xref:System.NullReferenceException> is thrown if the object reference is a null reference.  \\n  \\n <xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Unbox;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Unbox_Any\n  commentId: F:System.Reflection.Emit.OpCodes.Unbox_Any\n  id: Unbox_Any\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Unbox_Any\n  nameWithType: OpCodes.Unbox_Any\n  fullName: OpCodes.Unbox_Any\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Converts the boxed representation of a type specified in the instruction to its unboxed form.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|A5 < `T` >|unbox.any `typeTok`|Extract the data from `obj`, its boxed representation.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An object reference `obj` is pushed onto the stack.  \\n  \\n2.  The object reference is popped from the stack and unboxed to the type specified in the instruction.  \\n  \\n3.  The resulting object reference or value type is pushed onto the stack.  \\n  \\n When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.  \\n  \\n When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.  \\n  \\n If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.  \\n  \\n <xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.  \\n  \\n <xref:System.NullReferenceException> is thrown if `obj` is a null reference.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode, Type)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Unbox_Any;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Volatile\n  commentId: F:System.Reflection.Emit.OpCodes.Volatile\n  id: Volatile\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Volatile\n  nameWithType: OpCodes.Volatile\n  fullName: OpCodes.Volatile\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|FE 13|volatile.|Indicates that the subsequent pointer reference is volatile.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  An address is pushed onto the stack.  \\n  \\n `volatile`. specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed. Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately. Access to volatile locations need not be performed atomically.  \\n  \\n The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order. They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction. Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Volatile;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Reflection.Emit.OpCodes.Xor\n  commentId: F:System.Reflection.Emit.OpCodes.Xor\n  id: Xor\n  parent: System.Reflection.Emit.OpCodes\n  langs:\n  - csharp\n  name: Xor\n  nameWithType: OpCodes.Xor\n  fullName: OpCodes.Xor\n  type: Field\n  assemblies:\n  - System.Reflection.Primitives\n  - mscorlib\n  - netstandard\n  namespace: System.Reflection.Emit\n  summary: Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.\n  remarks: \"The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:  \\n  \\n|Format|Assembly Format|Description|  \\n|------------|---------------------|-----------------|  \\n|61|xor|Computes the bitwise XOR of two integer values and returns an integer.|  \\n  \\n The stack transitional behavior, in sequential order, is:  \\n  \\n1.  `value1` is pushed onto the stack.  \\n  \\n2.  `value2` is pushed onto the stack.  \\n  \\n3.  `value2` and `value1` are popped from the stack and their bitwise XOR computed.  \\n  \\n4.  The bitwise XOR of `value2` and `value1` is pushed onto the stack.  \\n  \\n The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.  \\n  \\n `Xor` is an integer-specific operation.  \\n  \\n The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:  \\n  \\n-   ILGenerator.Emit(OpCode)\"\n  syntax:\n    content: public static readonly System.Reflection.Emit.OpCode Xor;\n    return:\n      type: System.Reflection.Emit.OpCode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.Reflection.Emit.OpCodes.Add\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Add\n  nameWithType: OpCodes.Add\n  fullName: OpCodes.Add\n- uid: System.Reflection.Emit.OpCode\n  parent: System.Reflection.Emit\n  isExternal: false\n  name: OpCode\n  nameWithType: OpCode\n  fullName: System.Reflection.Emit.OpCode\n- uid: System.Reflection.Emit.OpCodes.Add_Ovf\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Add_Ovf\n  nameWithType: OpCodes.Add_Ovf\n  fullName: OpCodes.Add_Ovf\n- uid: System.Reflection.Emit.OpCodes.Add_Ovf_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Add_Ovf_Un\n  nameWithType: OpCodes.Add_Ovf_Un\n  fullName: OpCodes.Add_Ovf_Un\n- uid: System.Reflection.Emit.OpCodes.And\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: And\n  nameWithType: OpCodes.And\n  fullName: OpCodes.And\n- uid: System.Reflection.Emit.OpCodes.Arglist\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Arglist\n  nameWithType: OpCodes.Arglist\n  fullName: OpCodes.Arglist\n- uid: System.Reflection.Emit.OpCodes.Beq\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Beq\n  nameWithType: OpCodes.Beq\n  fullName: OpCodes.Beq\n- uid: System.Reflection.Emit.OpCodes.Beq_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Beq_S\n  nameWithType: OpCodes.Beq_S\n  fullName: OpCodes.Beq_S\n- uid: System.Reflection.Emit.OpCodes.Bge\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bge\n  nameWithType: OpCodes.Bge\n  fullName: OpCodes.Bge\n- uid: System.Reflection.Emit.OpCodes.Bge_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bge_S\n  nameWithType: OpCodes.Bge_S\n  fullName: OpCodes.Bge_S\n- uid: System.Reflection.Emit.OpCodes.Bge_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bge_Un\n  nameWithType: OpCodes.Bge_Un\n  fullName: OpCodes.Bge_Un\n- uid: System.Reflection.Emit.OpCodes.Bge_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bge_Un_S\n  nameWithType: OpCodes.Bge_Un_S\n  fullName: OpCodes.Bge_Un_S\n- uid: System.Reflection.Emit.OpCodes.Bgt\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bgt\n  nameWithType: OpCodes.Bgt\n  fullName: OpCodes.Bgt\n- uid: System.Reflection.Emit.OpCodes.Bgt_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bgt_S\n  nameWithType: OpCodes.Bgt_S\n  fullName: OpCodes.Bgt_S\n- uid: System.Reflection.Emit.OpCodes.Bgt_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bgt_Un\n  nameWithType: OpCodes.Bgt_Un\n  fullName: OpCodes.Bgt_Un\n- uid: System.Reflection.Emit.OpCodes.Bgt_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bgt_Un_S\n  nameWithType: OpCodes.Bgt_Un_S\n  fullName: OpCodes.Bgt_Un_S\n- uid: System.Reflection.Emit.OpCodes.Ble\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ble\n  nameWithType: OpCodes.Ble\n  fullName: OpCodes.Ble\n- uid: System.Reflection.Emit.OpCodes.Ble_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ble_S\n  nameWithType: OpCodes.Ble_S\n  fullName: OpCodes.Ble_S\n- uid: System.Reflection.Emit.OpCodes.Ble_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ble_Un\n  nameWithType: OpCodes.Ble_Un\n  fullName: OpCodes.Ble_Un\n- uid: System.Reflection.Emit.OpCodes.Ble_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ble_Un_S\n  nameWithType: OpCodes.Ble_Un_S\n  fullName: OpCodes.Ble_Un_S\n- uid: System.Reflection.Emit.OpCodes.Blt\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Blt\n  nameWithType: OpCodes.Blt\n  fullName: OpCodes.Blt\n- uid: System.Reflection.Emit.OpCodes.Blt_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Blt_S\n  nameWithType: OpCodes.Blt_S\n  fullName: OpCodes.Blt_S\n- uid: System.Reflection.Emit.OpCodes.Blt_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Blt_Un\n  nameWithType: OpCodes.Blt_Un\n  fullName: OpCodes.Blt_Un\n- uid: System.Reflection.Emit.OpCodes.Blt_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Blt_Un_S\n  nameWithType: OpCodes.Blt_Un_S\n  fullName: OpCodes.Blt_Un_S\n- uid: System.Reflection.Emit.OpCodes.Bne_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bne_Un\n  nameWithType: OpCodes.Bne_Un\n  fullName: OpCodes.Bne_Un\n- uid: System.Reflection.Emit.OpCodes.Bne_Un_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Bne_Un_S\n  nameWithType: OpCodes.Bne_Un_S\n  fullName: OpCodes.Bne_Un_S\n- uid: System.Reflection.Emit.OpCodes.Box\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Box\n  nameWithType: OpCodes.Box\n  fullName: OpCodes.Box\n- uid: System.Reflection.Emit.OpCodes.Br\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Br\n  nameWithType: OpCodes.Br\n  fullName: OpCodes.Br\n- uid: System.Reflection.Emit.OpCodes.Br_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Br_S\n  nameWithType: OpCodes.Br_S\n  fullName: OpCodes.Br_S\n- uid: System.Reflection.Emit.OpCodes.Break\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Break\n  nameWithType: OpCodes.Break\n  fullName: OpCodes.Break\n- uid: System.Reflection.Emit.OpCodes.Brfalse\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Brfalse\n  nameWithType: OpCodes.Brfalse\n  fullName: OpCodes.Brfalse\n- uid: System.Reflection.Emit.OpCodes.Brfalse_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Brfalse_S\n  nameWithType: OpCodes.Brfalse_S\n  fullName: OpCodes.Brfalse_S\n- uid: System.Reflection.Emit.OpCodes.Brtrue\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Brtrue\n  nameWithType: OpCodes.Brtrue\n  fullName: OpCodes.Brtrue\n- uid: System.Reflection.Emit.OpCodes.Brtrue_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Brtrue_S\n  nameWithType: OpCodes.Brtrue_S\n  fullName: OpCodes.Brtrue_S\n- uid: System.Reflection.Emit.OpCodes.Call\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Call\n  nameWithType: OpCodes.Call\n  fullName: OpCodes.Call\n- uid: System.Reflection.Emit.OpCodes.Calli\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Calli\n  nameWithType: OpCodes.Calli\n  fullName: OpCodes.Calli\n- uid: System.Reflection.Emit.OpCodes.Callvirt\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Callvirt\n  nameWithType: OpCodes.Callvirt\n  fullName: OpCodes.Callvirt\n- uid: System.Reflection.Emit.OpCodes.Castclass\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Castclass\n  nameWithType: OpCodes.Castclass\n  fullName: OpCodes.Castclass\n- uid: System.Reflection.Emit.OpCodes.Ceq\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ceq\n  nameWithType: OpCodes.Ceq\n  fullName: OpCodes.Ceq\n- uid: System.Reflection.Emit.OpCodes.Cgt\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Cgt\n  nameWithType: OpCodes.Cgt\n  fullName: OpCodes.Cgt\n- uid: System.Reflection.Emit.OpCodes.Cgt_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Cgt_Un\n  nameWithType: OpCodes.Cgt_Un\n  fullName: OpCodes.Cgt_Un\n- uid: System.Reflection.Emit.OpCodes.Ckfinite\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ckfinite\n  nameWithType: OpCodes.Ckfinite\n  fullName: OpCodes.Ckfinite\n- uid: System.Reflection.Emit.OpCodes.Clt\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Clt\n  nameWithType: OpCodes.Clt\n  fullName: OpCodes.Clt\n- uid: System.Reflection.Emit.OpCodes.Clt_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Clt_Un\n  nameWithType: OpCodes.Clt_Un\n  fullName: OpCodes.Clt_Un\n- uid: System.Reflection.Emit.OpCodes.Constrained\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Constrained\n  nameWithType: OpCodes.Constrained\n  fullName: OpCodes.Constrained\n- uid: System.Reflection.Emit.OpCodes.Conv_I\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_I\n  nameWithType: OpCodes.Conv_I\n  fullName: OpCodes.Conv_I\n- uid: System.Reflection.Emit.OpCodes.Conv_I1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_I1\n  nameWithType: OpCodes.Conv_I1\n  fullName: OpCodes.Conv_I1\n- uid: System.Reflection.Emit.OpCodes.Conv_I2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_I2\n  nameWithType: OpCodes.Conv_I2\n  fullName: OpCodes.Conv_I2\n- uid: System.Reflection.Emit.OpCodes.Conv_I4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_I4\n  nameWithType: OpCodes.Conv_I4\n  fullName: OpCodes.Conv_I4\n- uid: System.Reflection.Emit.OpCodes.Conv_I8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_I8\n  nameWithType: OpCodes.Conv_I8\n  fullName: OpCodes.Conv_I8\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I\n  nameWithType: OpCodes.Conv_Ovf_I\n  fullName: OpCodes.Conv_Ovf_I\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I_Un\n  nameWithType: OpCodes.Conv_Ovf_I_Un\n  fullName: OpCodes.Conv_Ovf_I_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I1\n  nameWithType: OpCodes.Conv_Ovf_I1\n  fullName: OpCodes.Conv_Ovf_I1\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I1_Un\n  nameWithType: OpCodes.Conv_Ovf_I1_Un\n  fullName: OpCodes.Conv_Ovf_I1_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I2\n  nameWithType: OpCodes.Conv_Ovf_I2\n  fullName: OpCodes.Conv_Ovf_I2\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I2_Un\n  nameWithType: OpCodes.Conv_Ovf_I2_Un\n  fullName: OpCodes.Conv_Ovf_I2_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I4\n  nameWithType: OpCodes.Conv_Ovf_I4\n  fullName: OpCodes.Conv_Ovf_I4\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I4_Un\n  nameWithType: OpCodes.Conv_Ovf_I4_Un\n  fullName: OpCodes.Conv_Ovf_I4_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I8\n  nameWithType: OpCodes.Conv_Ovf_I8\n  fullName: OpCodes.Conv_Ovf_I8\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_I8_Un\n  nameWithType: OpCodes.Conv_Ovf_I8_Un\n  fullName: OpCodes.Conv_Ovf_I8_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U\n  nameWithType: OpCodes.Conv_Ovf_U\n  fullName: OpCodes.Conv_Ovf_U\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U_Un\n  nameWithType: OpCodes.Conv_Ovf_U_Un\n  fullName: OpCodes.Conv_Ovf_U_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U1\n  nameWithType: OpCodes.Conv_Ovf_U1\n  fullName: OpCodes.Conv_Ovf_U1\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U1_Un\n  nameWithType: OpCodes.Conv_Ovf_U1_Un\n  fullName: OpCodes.Conv_Ovf_U1_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U2\n  nameWithType: OpCodes.Conv_Ovf_U2\n  fullName: OpCodes.Conv_Ovf_U2\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U2_Un\n  nameWithType: OpCodes.Conv_Ovf_U2_Un\n  fullName: OpCodes.Conv_Ovf_U2_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U4\n  nameWithType: OpCodes.Conv_Ovf_U4\n  fullName: OpCodes.Conv_Ovf_U4\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U4_Un\n  nameWithType: OpCodes.Conv_Ovf_U4_Un\n  fullName: OpCodes.Conv_Ovf_U4_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U8\n  nameWithType: OpCodes.Conv_Ovf_U8\n  fullName: OpCodes.Conv_Ovf_U8\n- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_Ovf_U8_Un\n  nameWithType: OpCodes.Conv_Ovf_U8_Un\n  fullName: OpCodes.Conv_Ovf_U8_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_R_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_R_Un\n  nameWithType: OpCodes.Conv_R_Un\n  fullName: OpCodes.Conv_R_Un\n- uid: System.Reflection.Emit.OpCodes.Conv_R4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_R4\n  nameWithType: OpCodes.Conv_R4\n  fullName: OpCodes.Conv_R4\n- uid: System.Reflection.Emit.OpCodes.Conv_R8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_R8\n  nameWithType: OpCodes.Conv_R8\n  fullName: OpCodes.Conv_R8\n- uid: System.Reflection.Emit.OpCodes.Conv_U\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_U\n  nameWithType: OpCodes.Conv_U\n  fullName: OpCodes.Conv_U\n- uid: System.Reflection.Emit.OpCodes.Conv_U1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_U1\n  nameWithType: OpCodes.Conv_U1\n  fullName: OpCodes.Conv_U1\n- uid: System.Reflection.Emit.OpCodes.Conv_U2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_U2\n  nameWithType: OpCodes.Conv_U2\n  fullName: OpCodes.Conv_U2\n- uid: System.Reflection.Emit.OpCodes.Conv_U4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_U4\n  nameWithType: OpCodes.Conv_U4\n  fullName: OpCodes.Conv_U4\n- uid: System.Reflection.Emit.OpCodes.Conv_U8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Conv_U8\n  nameWithType: OpCodes.Conv_U8\n  fullName: OpCodes.Conv_U8\n- uid: System.Reflection.Emit.OpCodes.Cpblk\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Cpblk\n  nameWithType: OpCodes.Cpblk\n  fullName: OpCodes.Cpblk\n- uid: System.Reflection.Emit.OpCodes.Cpobj\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Cpobj\n  nameWithType: OpCodes.Cpobj\n  fullName: OpCodes.Cpobj\n- uid: System.Reflection.Emit.OpCodes.Div\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Div\n  nameWithType: OpCodes.Div\n  fullName: OpCodes.Div\n- uid: System.Reflection.Emit.OpCodes.Div_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Div_Un\n  nameWithType: OpCodes.Div_Un\n  fullName: OpCodes.Div_Un\n- uid: System.Reflection.Emit.OpCodes.Dup\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Dup\n  nameWithType: OpCodes.Dup\n  fullName: OpCodes.Dup\n- uid: System.Reflection.Emit.OpCodes.Endfilter\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Endfilter\n  nameWithType: OpCodes.Endfilter\n  fullName: OpCodes.Endfilter\n- uid: System.Reflection.Emit.OpCodes.Endfinally\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Endfinally\n  nameWithType: OpCodes.Endfinally\n  fullName: OpCodes.Endfinally\n- uid: System.Reflection.Emit.OpCodes.Initblk\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Initblk\n  nameWithType: OpCodes.Initblk\n  fullName: OpCodes.Initblk\n- uid: System.Reflection.Emit.OpCodes.Initobj\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Initobj\n  nameWithType: OpCodes.Initobj\n  fullName: OpCodes.Initobj\n- uid: System.Reflection.Emit.OpCodes.Isinst\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Isinst\n  nameWithType: OpCodes.Isinst\n  fullName: OpCodes.Isinst\n- uid: System.Reflection.Emit.OpCodes.Jmp\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Jmp\n  nameWithType: OpCodes.Jmp\n  fullName: OpCodes.Jmp\n- uid: System.Reflection.Emit.OpCodes.Ldarg\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarg\n  nameWithType: OpCodes.Ldarg\n  fullName: OpCodes.Ldarg\n- uid: System.Reflection.Emit.OpCodes.Ldarg_0\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarg_0\n  nameWithType: OpCodes.Ldarg_0\n  fullName: OpCodes.Ldarg_0\n- uid: System.Reflection.Emit.OpCodes.Ldarg_1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarg_1\n  nameWithType: OpCodes.Ldarg_1\n  fullName: OpCodes.Ldarg_1\n- uid: System.Reflection.Emit.OpCodes.Ldarg_2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarg_2\n  nameWithType: OpCodes.Ldarg_2\n  fullName: OpCodes.Ldarg_2\n- uid: System.Reflection.Emit.OpCodes.Ldarg_3\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarg_3\n  nameWithType: OpCodes.Ldarg_3\n  fullName: OpCodes.Ldarg_3\n- uid: System.Reflection.Emit.OpCodes.Ldarg_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarg_S\n  nameWithType: OpCodes.Ldarg_S\n  fullName: OpCodes.Ldarg_S\n- uid: System.Reflection.Emit.OpCodes.Ldarga\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarga\n  nameWithType: OpCodes.Ldarga\n  fullName: OpCodes.Ldarga\n- uid: System.Reflection.Emit.OpCodes.Ldarga_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldarga_S\n  nameWithType: OpCodes.Ldarga_S\n  fullName: OpCodes.Ldarga_S\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4\n  nameWithType: OpCodes.Ldc_I4\n  fullName: OpCodes.Ldc_I4\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_0\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_0\n  nameWithType: OpCodes.Ldc_I4_0\n  fullName: OpCodes.Ldc_I4_0\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_1\n  nameWithType: OpCodes.Ldc_I4_1\n  fullName: OpCodes.Ldc_I4_1\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_2\n  nameWithType: OpCodes.Ldc_I4_2\n  fullName: OpCodes.Ldc_I4_2\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_3\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_3\n  nameWithType: OpCodes.Ldc_I4_3\n  fullName: OpCodes.Ldc_I4_3\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_4\n  nameWithType: OpCodes.Ldc_I4_4\n  fullName: OpCodes.Ldc_I4_4\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_5\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_5\n  nameWithType: OpCodes.Ldc_I4_5\n  fullName: OpCodes.Ldc_I4_5\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_6\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_6\n  nameWithType: OpCodes.Ldc_I4_6\n  fullName: OpCodes.Ldc_I4_6\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_7\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_7\n  nameWithType: OpCodes.Ldc_I4_7\n  fullName: OpCodes.Ldc_I4_7\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_8\n  nameWithType: OpCodes.Ldc_I4_8\n  fullName: OpCodes.Ldc_I4_8\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_M1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_M1\n  nameWithType: OpCodes.Ldc_I4_M1\n  fullName: OpCodes.Ldc_I4_M1\n- uid: System.Reflection.Emit.OpCodes.Ldc_I4_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I4_S\n  nameWithType: OpCodes.Ldc_I4_S\n  fullName: OpCodes.Ldc_I4_S\n- uid: System.Reflection.Emit.OpCodes.Ldc_I8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_I8\n  nameWithType: OpCodes.Ldc_I8\n  fullName: OpCodes.Ldc_I8\n- uid: System.Reflection.Emit.OpCodes.Ldc_R4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_R4\n  nameWithType: OpCodes.Ldc_R4\n  fullName: OpCodes.Ldc_R4\n- uid: System.Reflection.Emit.OpCodes.Ldc_R8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldc_R8\n  nameWithType: OpCodes.Ldc_R8\n  fullName: OpCodes.Ldc_R8\n- uid: System.Reflection.Emit.OpCodes.Ldelem\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem\n  nameWithType: OpCodes.Ldelem\n  fullName: OpCodes.Ldelem\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_I\n  nameWithType: OpCodes.Ldelem_I\n  fullName: OpCodes.Ldelem_I\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_I1\n  nameWithType: OpCodes.Ldelem_I1\n  fullName: OpCodes.Ldelem_I1\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_I2\n  nameWithType: OpCodes.Ldelem_I2\n  fullName: OpCodes.Ldelem_I2\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_I4\n  nameWithType: OpCodes.Ldelem_I4\n  fullName: OpCodes.Ldelem_I4\n- uid: System.Reflection.Emit.OpCodes.Ldelem_I8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_I8\n  nameWithType: OpCodes.Ldelem_I8\n  fullName: OpCodes.Ldelem_I8\n- uid: System.Reflection.Emit.OpCodes.Ldelem_R4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_R4\n  nameWithType: OpCodes.Ldelem_R4\n  fullName: OpCodes.Ldelem_R4\n- uid: System.Reflection.Emit.OpCodes.Ldelem_R8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_R8\n  nameWithType: OpCodes.Ldelem_R8\n  fullName: OpCodes.Ldelem_R8\n- uid: System.Reflection.Emit.OpCodes.Ldelem_Ref\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_Ref\n  nameWithType: OpCodes.Ldelem_Ref\n  fullName: OpCodes.Ldelem_Ref\n- uid: System.Reflection.Emit.OpCodes.Ldelem_U1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_U1\n  nameWithType: OpCodes.Ldelem_U1\n  fullName: OpCodes.Ldelem_U1\n- uid: System.Reflection.Emit.OpCodes.Ldelem_U2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_U2\n  nameWithType: OpCodes.Ldelem_U2\n  fullName: OpCodes.Ldelem_U2\n- uid: System.Reflection.Emit.OpCodes.Ldelem_U4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelem_U4\n  nameWithType: OpCodes.Ldelem_U4\n  fullName: OpCodes.Ldelem_U4\n- uid: System.Reflection.Emit.OpCodes.Ldelema\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldelema\n  nameWithType: OpCodes.Ldelema\n  fullName: OpCodes.Ldelema\n- uid: System.Reflection.Emit.OpCodes.Ldfld\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldfld\n  nameWithType: OpCodes.Ldfld\n  fullName: OpCodes.Ldfld\n- uid: System.Reflection.Emit.OpCodes.Ldflda\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldflda\n  nameWithType: OpCodes.Ldflda\n  fullName: OpCodes.Ldflda\n- uid: System.Reflection.Emit.OpCodes.Ldftn\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldftn\n  nameWithType: OpCodes.Ldftn\n  fullName: OpCodes.Ldftn\n- uid: System.Reflection.Emit.OpCodes.Ldind_I\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_I\n  nameWithType: OpCodes.Ldind_I\n  fullName: OpCodes.Ldind_I\n- uid: System.Reflection.Emit.OpCodes.Ldind_I1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_I1\n  nameWithType: OpCodes.Ldind_I1\n  fullName: OpCodes.Ldind_I1\n- uid: System.Reflection.Emit.OpCodes.Ldind_I2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_I2\n  nameWithType: OpCodes.Ldind_I2\n  fullName: OpCodes.Ldind_I2\n- uid: System.Reflection.Emit.OpCodes.Ldind_I4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_I4\n  nameWithType: OpCodes.Ldind_I4\n  fullName: OpCodes.Ldind_I4\n- uid: System.Reflection.Emit.OpCodes.Ldind_I8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_I8\n  nameWithType: OpCodes.Ldind_I8\n  fullName: OpCodes.Ldind_I8\n- uid: System.Reflection.Emit.OpCodes.Ldind_R4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_R4\n  nameWithType: OpCodes.Ldind_R4\n  fullName: OpCodes.Ldind_R4\n- uid: System.Reflection.Emit.OpCodes.Ldind_R8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_R8\n  nameWithType: OpCodes.Ldind_R8\n  fullName: OpCodes.Ldind_R8\n- uid: System.Reflection.Emit.OpCodes.Ldind_Ref\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_Ref\n  nameWithType: OpCodes.Ldind_Ref\n  fullName: OpCodes.Ldind_Ref\n- uid: System.Reflection.Emit.OpCodes.Ldind_U1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_U1\n  nameWithType: OpCodes.Ldind_U1\n  fullName: OpCodes.Ldind_U1\n- uid: System.Reflection.Emit.OpCodes.Ldind_U2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_U2\n  nameWithType: OpCodes.Ldind_U2\n  fullName: OpCodes.Ldind_U2\n- uid: System.Reflection.Emit.OpCodes.Ldind_U4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldind_U4\n  nameWithType: OpCodes.Ldind_U4\n  fullName: OpCodes.Ldind_U4\n- uid: System.Reflection.Emit.OpCodes.Ldlen\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldlen\n  nameWithType: OpCodes.Ldlen\n  fullName: OpCodes.Ldlen\n- uid: System.Reflection.Emit.OpCodes.Ldloc\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloc\n  nameWithType: OpCodes.Ldloc\n  fullName: OpCodes.Ldloc\n- uid: System.Reflection.Emit.OpCodes.Ldloc_0\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloc_0\n  nameWithType: OpCodes.Ldloc_0\n  fullName: OpCodes.Ldloc_0\n- uid: System.Reflection.Emit.OpCodes.Ldloc_1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloc_1\n  nameWithType: OpCodes.Ldloc_1\n  fullName: OpCodes.Ldloc_1\n- uid: System.Reflection.Emit.OpCodes.Ldloc_2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloc_2\n  nameWithType: OpCodes.Ldloc_2\n  fullName: OpCodes.Ldloc_2\n- uid: System.Reflection.Emit.OpCodes.Ldloc_3\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloc_3\n  nameWithType: OpCodes.Ldloc_3\n  fullName: OpCodes.Ldloc_3\n- uid: System.Reflection.Emit.OpCodes.Ldloc_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloc_S\n  nameWithType: OpCodes.Ldloc_S\n  fullName: OpCodes.Ldloc_S\n- uid: System.Reflection.Emit.OpCodes.Ldloca\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloca\n  nameWithType: OpCodes.Ldloca\n  fullName: OpCodes.Ldloca\n- uid: System.Reflection.Emit.OpCodes.Ldloca_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldloca_S\n  nameWithType: OpCodes.Ldloca_S\n  fullName: OpCodes.Ldloca_S\n- uid: System.Reflection.Emit.OpCodes.Ldnull\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldnull\n  nameWithType: OpCodes.Ldnull\n  fullName: OpCodes.Ldnull\n- uid: System.Reflection.Emit.OpCodes.Ldobj\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldobj\n  nameWithType: OpCodes.Ldobj\n  fullName: OpCodes.Ldobj\n- uid: System.Reflection.Emit.OpCodes.Ldsfld\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldsfld\n  nameWithType: OpCodes.Ldsfld\n  fullName: OpCodes.Ldsfld\n- uid: System.Reflection.Emit.OpCodes.Ldsflda\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldsflda\n  nameWithType: OpCodes.Ldsflda\n  fullName: OpCodes.Ldsflda\n- uid: System.Reflection.Emit.OpCodes.Ldstr\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldstr\n  nameWithType: OpCodes.Ldstr\n  fullName: OpCodes.Ldstr\n- uid: System.Reflection.Emit.OpCodes.Ldtoken\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldtoken\n  nameWithType: OpCodes.Ldtoken\n  fullName: OpCodes.Ldtoken\n- uid: System.Reflection.Emit.OpCodes.Ldvirtftn\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ldvirtftn\n  nameWithType: OpCodes.Ldvirtftn\n  fullName: OpCodes.Ldvirtftn\n- uid: System.Reflection.Emit.OpCodes.Leave\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Leave\n  nameWithType: OpCodes.Leave\n  fullName: OpCodes.Leave\n- uid: System.Reflection.Emit.OpCodes.Leave_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Leave_S\n  nameWithType: OpCodes.Leave_S\n  fullName: OpCodes.Leave_S\n- uid: System.Reflection.Emit.OpCodes.Localloc\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Localloc\n  nameWithType: OpCodes.Localloc\n  fullName: OpCodes.Localloc\n- uid: System.Reflection.Emit.OpCodes.Mkrefany\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Mkrefany\n  nameWithType: OpCodes.Mkrefany\n  fullName: OpCodes.Mkrefany\n- uid: System.Reflection.Emit.OpCodes.Mul\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Mul\n  nameWithType: OpCodes.Mul\n  fullName: OpCodes.Mul\n- uid: System.Reflection.Emit.OpCodes.Mul_Ovf\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Mul_Ovf\n  nameWithType: OpCodes.Mul_Ovf\n  fullName: OpCodes.Mul_Ovf\n- uid: System.Reflection.Emit.OpCodes.Mul_Ovf_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Mul_Ovf_Un\n  nameWithType: OpCodes.Mul_Ovf_Un\n  fullName: OpCodes.Mul_Ovf_Un\n- uid: System.Reflection.Emit.OpCodes.Neg\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Neg\n  nameWithType: OpCodes.Neg\n  fullName: OpCodes.Neg\n- uid: System.Reflection.Emit.OpCodes.Newarr\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Newarr\n  nameWithType: OpCodes.Newarr\n  fullName: OpCodes.Newarr\n- uid: System.Reflection.Emit.OpCodes.Newobj\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Newobj\n  nameWithType: OpCodes.Newobj\n  fullName: OpCodes.Newobj\n- uid: System.Reflection.Emit.OpCodes.Nop\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Nop\n  nameWithType: OpCodes.Nop\n  fullName: OpCodes.Nop\n- uid: System.Reflection.Emit.OpCodes.Not\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Not\n  nameWithType: OpCodes.Not\n  fullName: OpCodes.Not\n- uid: System.Reflection.Emit.OpCodes.Or\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Or\n  nameWithType: OpCodes.Or\n  fullName: OpCodes.Or\n- uid: System.Reflection.Emit.OpCodes.Pop\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Pop\n  nameWithType: OpCodes.Pop\n  fullName: OpCodes.Pop\n- uid: System.Reflection.Emit.OpCodes.Prefix1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefix1\n  nameWithType: OpCodes.Prefix1\n  fullName: OpCodes.Prefix1\n- uid: System.Reflection.Emit.OpCodes.Prefix2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefix2\n  nameWithType: OpCodes.Prefix2\n  fullName: OpCodes.Prefix2\n- uid: System.Reflection.Emit.OpCodes.Prefix3\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefix3\n  nameWithType: OpCodes.Prefix3\n  fullName: OpCodes.Prefix3\n- uid: System.Reflection.Emit.OpCodes.Prefix4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefix4\n  nameWithType: OpCodes.Prefix4\n  fullName: OpCodes.Prefix4\n- uid: System.Reflection.Emit.OpCodes.Prefix5\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefix5\n  nameWithType: OpCodes.Prefix5\n  fullName: OpCodes.Prefix5\n- uid: System.Reflection.Emit.OpCodes.Prefix6\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefix6\n  nameWithType: OpCodes.Prefix6\n  fullName: OpCodes.Prefix6\n- uid: System.Reflection.Emit.OpCodes.Prefix7\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefix7\n  nameWithType: OpCodes.Prefix7\n  fullName: OpCodes.Prefix7\n- uid: System.Reflection.Emit.OpCodes.Prefixref\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Prefixref\n  nameWithType: OpCodes.Prefixref\n  fullName: OpCodes.Prefixref\n- uid: System.Reflection.Emit.OpCodes.Readonly\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Readonly\n  nameWithType: OpCodes.Readonly\n  fullName: OpCodes.Readonly\n- uid: System.Reflection.Emit.OpCodes.Refanytype\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Refanytype\n  nameWithType: OpCodes.Refanytype\n  fullName: OpCodes.Refanytype\n- uid: System.Reflection.Emit.OpCodes.Refanyval\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Refanyval\n  nameWithType: OpCodes.Refanyval\n  fullName: OpCodes.Refanyval\n- uid: System.Reflection.Emit.OpCodes.Rem\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Rem\n  nameWithType: OpCodes.Rem\n  fullName: OpCodes.Rem\n- uid: System.Reflection.Emit.OpCodes.Rem_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Rem_Un\n  nameWithType: OpCodes.Rem_Un\n  fullName: OpCodes.Rem_Un\n- uid: System.Reflection.Emit.OpCodes.Ret\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Ret\n  nameWithType: OpCodes.Ret\n  fullName: OpCodes.Ret\n- uid: System.Reflection.Emit.OpCodes.Rethrow\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Rethrow\n  nameWithType: OpCodes.Rethrow\n  fullName: OpCodes.Rethrow\n- uid: System.Reflection.Emit.OpCodes.Shl\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Shl\n  nameWithType: OpCodes.Shl\n  fullName: OpCodes.Shl\n- uid: System.Reflection.Emit.OpCodes.Shr\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Shr\n  nameWithType: OpCodes.Shr\n  fullName: OpCodes.Shr\n- uid: System.Reflection.Emit.OpCodes.Shr_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Shr_Un\n  nameWithType: OpCodes.Shr_Un\n  fullName: OpCodes.Shr_Un\n- uid: System.Reflection.Emit.OpCodes.Sizeof\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Sizeof\n  nameWithType: OpCodes.Sizeof\n  fullName: OpCodes.Sizeof\n- uid: System.Reflection.Emit.OpCodes.Starg\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Starg\n  nameWithType: OpCodes.Starg\n  fullName: OpCodes.Starg\n- uid: System.Reflection.Emit.OpCodes.Starg_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Starg_S\n  nameWithType: OpCodes.Starg_S\n  fullName: OpCodes.Starg_S\n- uid: System.Reflection.Emit.OpCodes.Stelem\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem\n  nameWithType: OpCodes.Stelem\n  fullName: OpCodes.Stelem\n- uid: System.Reflection.Emit.OpCodes.Stelem_I\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_I\n  nameWithType: OpCodes.Stelem_I\n  fullName: OpCodes.Stelem_I\n- uid: System.Reflection.Emit.OpCodes.Stelem_I1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_I1\n  nameWithType: OpCodes.Stelem_I1\n  fullName: OpCodes.Stelem_I1\n- uid: System.Reflection.Emit.OpCodes.Stelem_I2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_I2\n  nameWithType: OpCodes.Stelem_I2\n  fullName: OpCodes.Stelem_I2\n- uid: System.Reflection.Emit.OpCodes.Stelem_I4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_I4\n  nameWithType: OpCodes.Stelem_I4\n  fullName: OpCodes.Stelem_I4\n- uid: System.Reflection.Emit.OpCodes.Stelem_I8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_I8\n  nameWithType: OpCodes.Stelem_I8\n  fullName: OpCodes.Stelem_I8\n- uid: System.Reflection.Emit.OpCodes.Stelem_R4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_R4\n  nameWithType: OpCodes.Stelem_R4\n  fullName: OpCodes.Stelem_R4\n- uid: System.Reflection.Emit.OpCodes.Stelem_R8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_R8\n  nameWithType: OpCodes.Stelem_R8\n  fullName: OpCodes.Stelem_R8\n- uid: System.Reflection.Emit.OpCodes.Stelem_Ref\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stelem_Ref\n  nameWithType: OpCodes.Stelem_Ref\n  fullName: OpCodes.Stelem_Ref\n- uid: System.Reflection.Emit.OpCodes.Stfld\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stfld\n  nameWithType: OpCodes.Stfld\n  fullName: OpCodes.Stfld\n- uid: System.Reflection.Emit.OpCodes.Stind_I\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_I\n  nameWithType: OpCodes.Stind_I\n  fullName: OpCodes.Stind_I\n- uid: System.Reflection.Emit.OpCodes.Stind_I1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_I1\n  nameWithType: OpCodes.Stind_I1\n  fullName: OpCodes.Stind_I1\n- uid: System.Reflection.Emit.OpCodes.Stind_I2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_I2\n  nameWithType: OpCodes.Stind_I2\n  fullName: OpCodes.Stind_I2\n- uid: System.Reflection.Emit.OpCodes.Stind_I4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_I4\n  nameWithType: OpCodes.Stind_I4\n  fullName: OpCodes.Stind_I4\n- uid: System.Reflection.Emit.OpCodes.Stind_I8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_I8\n  nameWithType: OpCodes.Stind_I8\n  fullName: OpCodes.Stind_I8\n- uid: System.Reflection.Emit.OpCodes.Stind_R4\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_R4\n  nameWithType: OpCodes.Stind_R4\n  fullName: OpCodes.Stind_R4\n- uid: System.Reflection.Emit.OpCodes.Stind_R8\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_R8\n  nameWithType: OpCodes.Stind_R8\n  fullName: OpCodes.Stind_R8\n- uid: System.Reflection.Emit.OpCodes.Stind_Ref\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stind_Ref\n  nameWithType: OpCodes.Stind_Ref\n  fullName: OpCodes.Stind_Ref\n- uid: System.Reflection.Emit.OpCodes.Stloc\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stloc\n  nameWithType: OpCodes.Stloc\n  fullName: OpCodes.Stloc\n- uid: System.Reflection.Emit.OpCodes.Stloc_0\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stloc_0\n  nameWithType: OpCodes.Stloc_0\n  fullName: OpCodes.Stloc_0\n- uid: System.Reflection.Emit.OpCodes.Stloc_1\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stloc_1\n  nameWithType: OpCodes.Stloc_1\n  fullName: OpCodes.Stloc_1\n- uid: System.Reflection.Emit.OpCodes.Stloc_2\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stloc_2\n  nameWithType: OpCodes.Stloc_2\n  fullName: OpCodes.Stloc_2\n- uid: System.Reflection.Emit.OpCodes.Stloc_3\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stloc_3\n  nameWithType: OpCodes.Stloc_3\n  fullName: OpCodes.Stloc_3\n- uid: System.Reflection.Emit.OpCodes.Stloc_S\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stloc_S\n  nameWithType: OpCodes.Stloc_S\n  fullName: OpCodes.Stloc_S\n- uid: System.Reflection.Emit.OpCodes.Stobj\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stobj\n  nameWithType: OpCodes.Stobj\n  fullName: OpCodes.Stobj\n- uid: System.Reflection.Emit.OpCodes.Stsfld\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Stsfld\n  nameWithType: OpCodes.Stsfld\n  fullName: OpCodes.Stsfld\n- uid: System.Reflection.Emit.OpCodes.Sub\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Sub\n  nameWithType: OpCodes.Sub\n  fullName: OpCodes.Sub\n- uid: System.Reflection.Emit.OpCodes.Sub_Ovf\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Sub_Ovf\n  nameWithType: OpCodes.Sub_Ovf\n  fullName: OpCodes.Sub_Ovf\n- uid: System.Reflection.Emit.OpCodes.Sub_Ovf_Un\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Sub_Ovf_Un\n  nameWithType: OpCodes.Sub_Ovf_Un\n  fullName: OpCodes.Sub_Ovf_Un\n- uid: System.Reflection.Emit.OpCodes.Switch\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Switch\n  nameWithType: OpCodes.Switch\n  fullName: OpCodes.Switch\n- uid: System.Reflection.Emit.OpCodes.Tailcall\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Tailcall\n  nameWithType: OpCodes.Tailcall\n  fullName: OpCodes.Tailcall\n- uid: System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: TakesSingleByteArgument(OpCode)\n  nameWithType: OpCodes.TakesSingleByteArgument(OpCode)\n  fullName: OpCodes.TakesSingleByteArgument(OpCode)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Reflection.Emit.OpCodes.Throw\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Throw\n  nameWithType: OpCodes.Throw\n  fullName: OpCodes.Throw\n- uid: System.Reflection.Emit.OpCodes.Unaligned\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Unaligned\n  nameWithType: OpCodes.Unaligned\n  fullName: OpCodes.Unaligned\n- uid: System.Reflection.Emit.OpCodes.Unbox\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Unbox\n  nameWithType: OpCodes.Unbox\n  fullName: OpCodes.Unbox\n- uid: System.Reflection.Emit.OpCodes.Unbox_Any\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Unbox_Any\n  nameWithType: OpCodes.Unbox_Any\n  fullName: OpCodes.Unbox_Any\n- uid: System.Reflection.Emit.OpCodes.Volatile\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Volatile\n  nameWithType: OpCodes.Volatile\n  fullName: OpCodes.Volatile\n- uid: System.Reflection.Emit.OpCodes.Xor\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: Xor\n  nameWithType: OpCodes.Xor\n  fullName: OpCodes.Xor\n- uid: System.Reflection.Emit.OpCodes.TakesSingleByteArgument*\n  parent: System.Reflection.Emit.OpCodes\n  isExternal: false\n  name: TakesSingleByteArgument\n  nameWithType: OpCodes.TakesSingleByteArgument\n  fullName: OpCodes.TakesSingleByteArgument\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Reflection.Emit/OpCodes.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}