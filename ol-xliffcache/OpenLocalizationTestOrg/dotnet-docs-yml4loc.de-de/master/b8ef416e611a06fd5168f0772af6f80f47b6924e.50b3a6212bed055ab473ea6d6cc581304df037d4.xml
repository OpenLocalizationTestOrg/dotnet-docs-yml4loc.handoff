{"nodes":[{"content":"Represents a lightweight alternative to <xref href=\"System.Threading.Semaphore\"></xref> that limits the number of threads that can access a resource or pool of resources concurrently.","nodes":[{"pos":[0,183],"content":"Represents a lightweight alternative to <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> that limits the number of threads that can access a resource or pool of resources concurrently.","source":"Represents a lightweight alternative to <xref href=\"System.Threading.Semaphore\"></xref> that limits the number of threads that can access a resource or pool of resources concurrently."}],"pos":[1660,1844],"yaml":true},{"content":"Semaphores are of two types: local semaphores and named system semaphores. The former is local to an app. The latter is visible throughout the operating system and is suitable for inter-process synchronization. The <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to the <xref:System.Threading.Semaphore> class that doesn't use Windows kernel semaphores. Unlike the <xref:System.Threading.Semaphore> class, the <xref:System.Threading.SemaphoreSlim> class doesn't support named system semaphores. You can use it as a local semaphore only. The <xref:System.Threading.SemaphoreSlim> class is the recommended semaphore for synchronization within a single app.  \n  \n A lightweight semaphore controls access to a pool of resources that is local to your application. When you instantiate a semaphore, you can specify the maximum number of threads that can enter the semaphore concurrently. You also specify the initial number of threads that can enter the semaphore concurrently. This defines the semaphore's count.  \n  \n The count is decremented each time a thread enters the semaphore, and incremented each time a thread releases the semaphore. To enter the semaphore, a thread calls one of the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> overloads. To release the semaphore, it calls one of the <xref:System.Threading.SemaphoreSlim.Release%2A> overloads. When the count reaches zero, subsequent calls to one of the `Wait` methods block until other threads release the semaphore. If multiple threads are blocked, there is no guaranteed order, such as FIFO or LIFO, that controls when threads enter the semaphore.  \n  \n The basic structure for code that uses a semaphore to protect resources is:  \n  \n```  \n  \n' Enter semaphore by calling one of the Wait or WaitAsync methods.  \nSemaphoreSlim.Wait()  \n'   \n' Execute code protected by the semaphore.   \n'  \nSemaphoreSlim.Release()  \n  \n```  \n  \n When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created. The semaphore's count is available from the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property.  \n  \n> [!IMPORTANT]\n>  The <xref:System.Threading.SemaphoreSlim> class doesn't enforce thread or task identity on calls to the <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A> methods. In addition, if the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> constructor is used to instantiate the <xref:System.Threading.SemaphoreSlim> object, the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property can increase beyond the value set by the constructor. It is the programmer's responsibility to ensure that calls to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods are appropriately paired with calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods.","nodes":[{"pos":[0,673],"content":"Semaphores are of two types: local semaphores and named system semaphores. The former is local to an app. The latter is visible throughout the operating system and is suitable for inter-process synchronization. The <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to the <xref:System.Threading.Semaphore> class that doesn't use Windows kernel semaphores. Unlike the <xref:System.Threading.Semaphore> class, the <xref:System.Threading.SemaphoreSlim> class doesn't support named system semaphores. You can use it as a local semaphore only. The <xref:System.Threading.SemaphoreSlim> class is the recommended semaphore for synchronization within a single app.","nodes":[{"content":"Semaphores are of two types: local semaphores and named system semaphores. The former is local to an app. The latter is visible throughout the operating system and is suitable for inter-process synchronization. The <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to the <xref:System.Threading.Semaphore> class that doesn't use Windows kernel semaphores. Unlike the <xref:System.Threading.Semaphore> class, the <xref:System.Threading.SemaphoreSlim> class doesn't support named system semaphores. You can use it as a local semaphore only. The <xref:System.Threading.SemaphoreSlim> class is the recommended semaphore for synchronization within a single app.","pos":[0,673],"nodes":[{"content":"Semaphores are of two types: local semaphores and named system semaphores.","pos":[0,74]},{"content":"The former is local to an app.","pos":[75,105]},{"content":"The latter is visible throughout the operating system and is suitable for inter-process synchronization.","pos":[106,210]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> is a lightweight alternative to the <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> class that doesn't use Windows kernel semaphores.","pos":[211,372],"source":" The <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to the <xref:System.Threading.Semaphore> class that doesn't use Windows kernel semaphores."},{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> class, the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> class doesn't support named system semaphores.","pos":[373,513],"source":" Unlike the <xref:System.Threading.Semaphore> class, the <xref:System.Threading.SemaphoreSlim> class doesn't support named system semaphores."},{"content":"You can use it as a local semaphore only.","pos":[514,555]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> class is the recommended semaphore for synchronization within a single app.","pos":[556,673],"source":" The <xref:System.Threading.SemaphoreSlim> class is the recommended semaphore for synchronization within a single app."}]}]},{"pos":[680,1026],"content":"A lightweight semaphore controls access to a pool of resources that is local to your application. When you instantiate a semaphore, you can specify the maximum number of threads that can enter the semaphore concurrently. You also specify the initial number of threads that can enter the semaphore concurrently. This defines the semaphore's count.","nodes":[{"content":"A lightweight semaphore controls access to a pool of resources that is local to your application. When you instantiate a semaphore, you can specify the maximum number of threads that can enter the semaphore concurrently. You also specify the initial number of threads that can enter the semaphore concurrently. This defines the semaphore's count.","pos":[0,346],"nodes":[{"content":"A lightweight semaphore controls access to a pool of resources that is local to your application.","pos":[0,97]},{"content":"When you instantiate a semaphore, you can specify the maximum number of threads that can enter the semaphore concurrently.","pos":[98,220]},{"content":"You also specify the initial number of threads that can enter the semaphore concurrently.","pos":[221,310]},{"content":"This defines the semaphore's count.","pos":[311,346]}]}]},{"pos":[1033,1681],"content":"The count is decremented each time a thread enters the semaphore, and incremented each time a thread releases the semaphore. To enter the semaphore, a thread calls one of the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> overloads. To release the semaphore, it calls one of the <xref:System.Threading.SemaphoreSlim.Release%2A> overloads. When the count reaches zero, subsequent calls to one of the `Wait` methods block until other threads release the semaphore. If multiple threads are blocked, there is no guaranteed order, such as FIFO or LIFO, that controls when threads enter the semaphore.","nodes":[{"content":"The count is decremented each time a thread enters the semaphore, and incremented each time a thread releases the semaphore.","pos":[0,124]},{"content":"To enter the semaphore, a thread calls one of the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Wait%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.WaitAsync%2A&gt;</ph> overloads.","pos":[125,285],"source":" To enter the semaphore, a thread calls one of the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> overloads."},{"content":"To release the semaphore, it calls one of the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Release%2A&gt;</ph> overloads.","pos":[286,391],"source":" To release the semaphore, it calls one of the <xref:System.Threading.SemaphoreSlim.Release%2A> overloads."},{"content":"When the count reaches zero, subsequent calls to one of the <ph id=\"ph1\">`Wait`</ph> methods block until other threads release the semaphore.","pos":[392,515],"source":" When the count reaches zero, subsequent calls to one of the `Wait` methods block until other threads release the semaphore."},{"content":"If multiple threads are blocked, there is no guaranteed order, such as FIFO or LIFO, that controls when threads enter the semaphore.","pos":[516,648]}]},{"pos":[1688,1763],"content":"The basic structure for code that uses a semaphore to protect resources is:","nodes":[{"content":"The basic structure for code that uses a semaphore to protect resources is:","pos":[0,75]}]},{"pos":[1964,2193],"content":"When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created. The semaphore's count is available from the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property.","nodes":[{"content":"When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created. The semaphore's count is available from the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property.","pos":[0,229],"nodes":[{"content":"When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.","pos":[0,121]},{"content":"The semaphore's count is available from the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property.","pos":[122,229],"source":" The semaphore's count is available from the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property."}]}]},{"pos":[2201,3038],"content":"[!IMPORTANT]\n The <xref:System.Threading.SemaphoreSlim> class doesn't enforce thread or task identity on calls to the <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A> methods. In addition, if the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> constructor is used to instantiate the <xref:System.Threading.SemaphoreSlim> object, the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property can increase beyond the value set by the constructor. It is the programmer's responsibility to ensure that calls to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods are appropriately paired with calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods.","leadings":["","> "],"nodes":[{"content":" The <xref:System.Threading.SemaphoreSlim> class doesn't enforce thread or task identity on calls to the <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A> methods. In addition, if the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> constructor is used to instantiate the <xref:System.Threading.SemaphoreSlim> object, the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property can increase beyond the value set by the constructor. It is the programmer's responsibility to ensure that calls to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods are appropriately paired with calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods.","pos":[13,835],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> class doesn't enforce thread or task identity on calls to the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.Wait%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.WaitAsync%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.SemaphoreSlim.Release%2A&gt;</ph> methods.","pos":[1,265],"source":" The <xref:System.Threading.SemaphoreSlim> class doesn't enforce thread or task identity on calls to the <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A> methods."},{"content":"In addition, if the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29&gt;</ph> constructor is used to instantiate the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> object, the <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property can increase beyond the value set by the constructor.","pos":[266,555],"source":" In addition, if the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> constructor is used to instantiate the <xref:System.Threading.SemaphoreSlim> object, the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property can increase beyond the value set by the constructor."},{"content":"It is the programmer's responsibility to ensure that calls to <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Wait%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.WaitAsync%2A&gt;</ph> methods are appropriately paired with calls to <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.Release%2A&gt;</ph> methods.","pos":[556,822],"source":" It is the programmer's responsibility to ensure that calls to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods are appropriately paired with calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods."}]}]}],"pos":[1855,4918],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class, specifying the initial number of requests that can be granted concurrently.","nodes":[{"pos":[0,168],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> class, specifying the initial number of requests that can be granted concurrently.","source":"Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class, specifying the initial number of requests that can be granted concurrently."}],"pos":[7914,8083],"yaml":true},{"content":"The `initialCount` parameter defines the number of concurrent requests to enter the semaphore that can be granted. However, it doesn't define the maximum number of requests that can be granted concurrently. A   <xref:System.Threading.SemaphoreSlim> object instantiated by calling this constructor doesn't throw a <xref:System.Threading.SemaphoreFullException> exception if a call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method increases the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property beyond `initialCount`. This occurs if there are more calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods than there are to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods. To set the maximum number of concurrent requests to enter the semaphore that can be granted, call the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> constructor.","nodes":[{"pos":[0,972],"content":"The `initialCount` parameter defines the number of concurrent requests to enter the semaphore that can be granted. However, it doesn't define the maximum number of requests that can be granted concurrently. A   <xref:System.Threading.SemaphoreSlim> object instantiated by calling this constructor doesn't throw a <xref:System.Threading.SemaphoreFullException> exception if a call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method increases the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property beyond `initialCount`. This occurs if there are more calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods than there are to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods. To set the maximum number of concurrent requests to enter the semaphore that can be granted, call the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> constructor.","nodes":[{"content":"The <ph id=\"ph1\">`initialCount`</ph> parameter defines the number of concurrent requests to enter the semaphore that can be granted.","pos":[0,114],"source":"The `initialCount` parameter defines the number of concurrent requests to enter the semaphore that can be granted."},{"content":"However, it doesn't define the maximum number of requests that can be granted concurrently.","pos":[115,206]},{"content":"A   <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> object instantiated by calling this constructor doesn't throw a <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> exception if a call to the <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.Release%2A&gt;</ph> method increases the value of the <ph id=\"ph4\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property beyond <ph id=\"ph5\">`initialCount`</ph>.","pos":[207,555],"source":" A   <xref:System.Threading.SemaphoreSlim> object instantiated by calling this constructor doesn't throw a <xref:System.Threading.SemaphoreFullException> exception if a call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method increases the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property beyond `initialCount`."},{"content":"This occurs if there are more calls to <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Release%2A&gt;</ph> methods than there are to <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.Wait%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.WaitAsync%2A&gt;</ph> methods.","pos":[556,778],"source":" This occurs if there are more calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods than there are to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods."},{"content":"To set the maximum number of concurrent requests to enter the semaphore that can be granted, call the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor.","pos":[779,972],"source":" To set the maximum number of concurrent requests to enter the semaphore that can be granted, call the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> constructor."}]}],"pos":[8094,9067],"yaml":true,"extradata":"MT"},{"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"pos":[0,82],"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"content":"The initial number of requests for the semaphore that can be granted concurrently.","pos":[0,82]}]}],"pos":[9214,9297],"yaml":true},{"content":"<code>initialCount</code> is less than 0.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is less than 0.","source":"<code>initialCount</code> is less than 0."}],"pos":[9475,9517],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class, specifying the initial and maximum number of requests that can be granted concurrently.","nodes":[{"pos":[0,180],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> class, specifying the initial and maximum number of requests that can be granted concurrently.","source":"Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class, specifying the initial and maximum number of requests that can be granted concurrently."}],"pos":[11073,11254],"yaml":true},{"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"pos":[0,82],"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"content":"The initial number of requests for the semaphore that can be granted concurrently.","pos":[0,82]}]}],"pos":[11415,11498],"yaml":true},{"content":"The maximum number of requests for the semaphore that can be granted concurrently.","nodes":[{"pos":[0,82],"content":"The maximum number of requests for the semaphore that can be granted concurrently.","nodes":[{"content":"The maximum number of requests for the semaphore that can be granted concurrently.","pos":[0,82]}]}],"pos":[11561,11644],"yaml":true},{"content":"<code>initialCount</code> is less than 0, or <code>initialCount</code> is greater than <code>maxCount</code>, or <code>maxCount</code> is equal to or less than 0.","nodes":[{"pos":[0,162],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is less than 0, or <ph id=\"ph2\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is greater than <ph id=\"ph3\">&lt;code&gt;maxCount&lt;/code&gt;</ph>, or <ph id=\"ph4\">&lt;code&gt;maxCount&lt;/code&gt;</ph> is equal to or less than 0.","source":"<code>initialCount</code> is less than 0, or <code>initialCount</code> is greater than <code>maxCount</code>, or <code>maxCount</code> is equal to or less than 0."}],"pos":[11822,11985],"yaml":true},{"content":"Returns a <xref href=\"System.Threading.WaitHandle\"></xref> that can be used to wait on the semaphore.","nodes":[{"pos":[0,101],"content":"Returns a <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> that can be used to wait on the semaphore.","source":"Returns a <xref href=\"System.Threading.WaitHandle\"></xref> that can be used to wait on the semaphore."}],"pos":[13473,13575],"yaml":true},{"content":"Use this property only when you must wait on a SemaphoreSlim together with other kernel-based synchronization objects with the same wait handle. A successful wait on the <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> does not imply a successful wait on the <xref:System.Threading.SemaphoreSlim> itself, nor does it decrement the semaphore's count. After the available wait handle is signaled, you should wait on the <xref:System.Threading.SemaphoreSlim> specifically.","nodes":[{"pos":[0,481],"content":"Use this property only when you must wait on a SemaphoreSlim together with other kernel-based synchronization objects with the same wait handle. A successful wait on the <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> does not imply a successful wait on the <xref:System.Threading.SemaphoreSlim> itself, nor does it decrement the semaphore's count. After the available wait handle is signaled, you should wait on the <xref:System.Threading.SemaphoreSlim> specifically.","nodes":[{"content":"Use this property only when you must wait on a SemaphoreSlim together with other kernel-based synchronization objects with the same wait handle. A successful wait on the <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> does not imply a successful wait on the <xref:System.Threading.SemaphoreSlim> itself, nor does it decrement the semaphore's count. After the available wait handle is signaled, you should wait on the <xref:System.Threading.SemaphoreSlim> specifically.","pos":[0,481],"nodes":[{"content":"Use this property only when you must wait on a SemaphoreSlim together with other kernel-based synchronization objects with the same wait handle.","pos":[0,144]},{"content":"A successful wait on the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A&gt;</ph> does not imply a successful wait on the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> itself, nor does it decrement the semaphore's count.","pos":[145,361],"source":" A successful wait on the <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> does not imply a successful wait on the <xref:System.Threading.SemaphoreSlim> itself, nor does it decrement the semaphore's count."},{"content":"After the available wait handle is signaled, you should wait on the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> specifically.","pos":[362,481],"source":" After the available wait handle is signaled, you should wait on the <xref:System.Threading.SemaphoreSlim> specifically."}]}]}],"pos":[13586,14068],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Threading.WaitHandle\"></xref> that can be used to wait on the semaphore.","nodes":[{"pos":[0,93],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> that can be used to wait on the semaphore.","source":"A <xref href=\"System.Threading.WaitHandle\"></xref> that can be used to wait on the semaphore."}],"pos":[14226,14320],"yaml":true},{"content":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has been disposed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> has been disposed.","source":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has been disposed."}],"pos":[14504,14579],"yaml":true},{"content":"Gets the number of remaining threads that can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object.","nodes":[{"pos":[0,115],"content":"Gets the number of remaining threads that can enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> object.","source":"Gets the number of remaining threads that can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object."}],"pos":[16025,16141],"yaml":true},{"content":"The initial value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is set by the call to the <xref:System.Threading.SemaphoreSlim.%23ctor%2A> class constructor. It is decremented by each call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method, and incremented by each call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method.","nodes":[{"pos":[0,420],"content":"The initial value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is set by the call to the <xref:System.Threading.SemaphoreSlim.%23ctor%2A> class constructor. It is decremented by each call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method, and incremented by each call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method.","nodes":[{"content":"The initial value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is set by the call to the <xref:System.Threading.SemaphoreSlim.%23ctor%2A> class constructor. It is decremented by each call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method, and incremented by each call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method.","pos":[0,420],"nodes":[{"content":"The initial value of the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property is set by the call to the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.%23ctor%2A&gt;</ph> class constructor.","pos":[0,181],"source":"The initial value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is set by the call to the <xref:System.Threading.SemaphoreSlim.%23ctor%2A> class constructor."},{"content":"It is decremented by each call to the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Wait%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.WaitAsync%2A&gt;</ph> method, and incremented by each call to the <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.Release%2A&gt;</ph> method.","pos":[182,420],"source":" It is decremented by each call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method, and incremented by each call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method."}]}]}],"pos":[16152,16573],"yaml":true,"extradata":"MT"},{"content":"The number of remaining threads that can enter the semaphore.","nodes":[{"pos":[0,61],"content":"The number of remaining threads that can enter the semaphore.","nodes":[{"content":"The number of remaining threads that can enter the semaphore.","pos":[0,61]}]}],"pos":[16685,16747],"yaml":true},{"content":"Releases all resources used by the current instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class.","nodes":[{"pos":[0,117],"content":"Releases all resources used by the current instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> class.","source":"Releases all resources used by the current instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class."}],"pos":[18241,18359],"yaml":true},{"content":"Call `Dispose` when you are finished using the <xref:System.Threading.SemaphoreSlim>. The `Dispose` method leaves the <xref:System.Threading.SemaphoreSlim> in an unusable state. After calling `Dispose`, you must release all references to the <xref:System.Threading.SemaphoreSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.SemaphoreSlim> was occupying.  \n  \n For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \n  \n> [!NOTE]\n>  Always call `Dispose` before you release your last reference to the <xref:System.Threading.SemaphoreSlim>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Threading.SemaphoreSlim> object's `Finalize` method.","nodes":[{"pos":[0,389],"content":"Call `Dispose` when you are finished using the <xref:System.Threading.SemaphoreSlim>. The `Dispose` method leaves the <xref:System.Threading.SemaphoreSlim> in an unusable state. After calling `Dispose`, you must release all references to the <xref:System.Threading.SemaphoreSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.SemaphoreSlim> was occupying.","nodes":[{"content":"Call <ph id=\"ph1\">`Dispose`</ph> when you are finished using the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph>.","pos":[0,85],"source":"Call `Dispose` when you are finished using the <xref:System.Threading.SemaphoreSlim>."},{"content":"The <ph id=\"ph1\">`Dispose`</ph> method leaves the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> in an unusable state.","pos":[86,177],"source":" The `Dispose` method leaves the <xref:System.Threading.SemaphoreSlim> in an unusable state."},{"content":"After calling <ph id=\"ph1\">`Dispose`</ph>, you must release all references to the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> so the garbage collector can reclaim the memory that the <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> was occupying.","pos":[178,389],"source":" After calling `Dispose`, you must release all references to the <xref:System.Threading.SemaphoreSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.SemaphoreSlim> was occupying."}]},{"pos":[396,601],"content":"For more information, see <bpt id=\"p1\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id=\"p2\">[</bpt>Implementing a Dispose Method<ept id=\"p2\">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.","source":"For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)."},{"pos":[609,885],"content":"[!NOTE]\n Always call `Dispose` before you release your last reference to the <xref:System.Threading.SemaphoreSlim>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Threading.SemaphoreSlim> object's `Finalize` method.","leadings":["","> "],"nodes":[{"content":" Always call `Dispose` before you release your last reference to the <xref:System.Threading.SemaphoreSlim>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Threading.SemaphoreSlim> object's `Finalize` method.","pos":[8,274],"nodes":[{"content":"Always call <ph id=\"ph1\">`Dispose`</ph> before you release your last reference to the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph>.","pos":[1,107],"source":" Always call `Dispose` before you release your last reference to the <xref:System.Threading.SemaphoreSlim>."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> object's <ph id=\"ph2\">`Finalize`</ph> method.","pos":[108,266],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Threading.SemaphoreSlim> object's `Finalize` method."}]}]}],"pos":[18370,19263],"yaml":true,"extradata":"MT"},{"content":"Releases the unmanaged resources used by the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, and optionally releases the managed resources.","nodes":[{"pos":[0,144],"content":"Releases the unmanaged resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, and optionally releases the managed resources.","source":"Releases the unmanaged resources used by the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, and optionally releases the managed resources."}],"pos":[20887,21032],"yaml":true},{"content":"Unlike most of the members of <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> is not thread-safe and may not be used concurrently with other members of this instance.","nodes":[{"pos":[0,206],"content":"Unlike most of the members of <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> is not thread-safe and may not be used concurrently with other members of this instance.","nodes":[{"content":"Unlike most of the members of <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.Dispose%2A&gt;</ph> is not thread-safe and may not be used concurrently with other members of this instance.","pos":[0,206],"source":"Unlike most of the members of <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> is not thread-safe and may not be used concurrently with other members of this instance."}]}],"pos":[21043,21250],"yaml":true,"extradata":"MT"},{"content":"`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources.","nodes":[{"pos":[0,100],"content":"<ph id=\"ph1\">`true`</ph> to release both managed and unmanaged resources; <ph id=\"ph2\">`false`</ph> to release only unmanaged resources.","source":"`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources."}],"pos":[21404,21507],"yaml":true},{"content":"Releases the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object once.","nodes":[{"pos":[0,77],"content":"Releases the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> object once.","source":"Releases the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object once."}],"pos":[22996,23074],"yaml":true},{"content":"A call to the <xref:System.Threading.SemaphoreSlim.Release> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one. If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows one thread or task blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore.","nodes":[{"pos":[0,471],"content":"A call to the <xref:System.Threading.SemaphoreSlim.Release> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one. If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows one thread or task blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore.","nodes":[{"content":"A call to the <xref:System.Threading.SemaphoreSlim.Release> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one. If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows one thread or task blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore.","pos":[0,471],"nodes":[{"content":"A call to the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Release&gt;</ph> method increments the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by one.","pos":[0,152],"source":"A call to the <xref:System.Threading.SemaphoreSlim.Release> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one."},{"content":"If the value of the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property is zero before this method is called, the method also allows one thread or task blocked by a call to the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.Wait%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.WaitAsync%2A&gt;</ph> method to enter the semaphore.","pos":[153,471],"source":" If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows one thread or task blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore."}]}]}],"pos":[23085,23557],"yaml":true,"extradata":"MT"},{"content":"The previous count of the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.","nodes":[{"pos":[0,78],"content":"The previous count of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>.","source":"The previous count of the <xref href=\"System.Threading.SemaphoreSlim\"></xref>."}],"pos":[23678,23757],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[23929,23977],"yaml":true},{"content":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has already reached its maximum size.","nodes":[{"pos":[0,93],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> has already reached its maximum size.","source":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has already reached its maximum size."}],"pos":[24101,24195],"yaml":true},{"content":"Releases the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object a specified number of times.","nodes":[{"pos":[0,100],"content":"Releases the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> object a specified number of times.","source":"Releases the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object a specified number of times."}],"pos":[25672,25773],"yaml":true},{"content":"A call to the <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by `releaseCount`. If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows `releaseCount` threads or tasks blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore.","nodes":[{"pos":[0,513],"content":"A call to the <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by `releaseCount`. If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows `releaseCount` threads or tasks blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore.","nodes":[{"content":"A call to the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29&gt;</ph> method increments the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by <ph id=\"ph3\">`releaseCount`</ph>.","pos":[0,181],"source":"A call to the <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by `releaseCount`."},{"content":"If the value of the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property is zero before this method is called, the method also allows <ph id=\"ph2\">`releaseCount`</ph> threads or tasks blocked by a call to the <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim.Wait%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.SemaphoreSlim.WaitAsync%2A&gt;</ph> method to enter the semaphore.","pos":[182,513],"source":" If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows `releaseCount` threads or tasks blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore."}]}],"pos":[25784,26298],"yaml":true,"extradata":"MT"},{"content":"The number of times to exit the semaphore.","nodes":[{"pos":[0,42],"content":"The number of times to exit the semaphore.","nodes":[{"content":"The number of times to exit the semaphore.","pos":[0,42]}]}],"pos":[26443,26486],"yaml":true},{"content":"The previous count of the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.","nodes":[{"pos":[0,78],"content":"The previous count of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>.","source":"The previous count of the <xref href=\"System.Threading.SemaphoreSlim\"></xref>."}],"pos":[26542,26621],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[26793,26841],"yaml":true},{"content":"<code>releaseCount</code> is less than 1.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;releaseCount&lt;/code&gt;</ph> is less than 1.","source":"<code>releaseCount</code> is less than 1."}],"pos":[26955,26997],"yaml":true},{"content":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has already reached its maximum size.","nodes":[{"pos":[0,93],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> has already reached its maximum size.","source":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has already reached its maximum size."}],"pos":[27121,27215],"yaml":true},{"content":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.","nodes":[{"pos":[0,249],"content":"Blocks the current thread until it can enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies the timeout, while observing a <ph id=\"ph3\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph>.","source":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>."}],"pos":[28854,29104],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n \nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately. \n\nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \n  \nIf `cancellationToken` is cancelled, or if a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> and the timeout interval specified by `millisecondsTimeout` expires:\n\n- The thread or task doesn't enter the semaphore.\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.  \n\nIf `cancellationToken` is cancelled, the method throws an <xref:System.OperationCanceledException> exception.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[75,207],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]},{"pos":[210,350],"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.","nodes":[{"content":"If a thread or task is able to enter the semaphore, it decrements the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by one.","pos":[0,140],"source":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one."}]},{"pos":[356,609],"content":"If <ph id=\"ph1\">`cancellationToken`</ph> is cancelled, or if a thread or task is blocked when calling <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> and the timeout interval specified by <ph id=\"ph3\">`millisecondsTimeout`</ph> expires:","source":"If `cancellationToken` is cancelled, or if a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> and the timeout interval specified by `millisecondsTimeout` expires:"},{"pos":[613,660],"content":"The thread or task doesn't enter the semaphore.","nodes":[{"content":"The thread or task doesn't enter the semaphore.","pos":[0,47]}]},{"pos":[663,748],"content":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property isn't decremented.","pos":[0,85],"source":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented."}]},{"pos":[752,861],"content":"If <ph id=\"ph1\">`cancellationToken`</ph> is cancelled, the method throws an <ph id=\"ph2\">&lt;xref:System.OperationCanceledException&gt;</ph> exception.","source":"If `cancellationToken` is cancelled, the method throws an <xref:System.OperationCanceledException> exception."}],"pos":[29115,29990],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.","nodes":[{"pos":[0,304],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely, or a <ph id=\"ph3\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents 0 milliseconds to test the wait handle and return immediately.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately."}],"pos":[30185,30490],"yaml":true},{"content":"The <xref href=\"System.Threading.CancellationToken\"></xref> to observe.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph> to observe.","source":"The <xref href=\"System.Threading.CancellationToken\"></xref> to observe."}],"pos":[30584,30656],"yaml":true},{"content":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,126],"content":"<ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`."}],"pos":[30714,30843],"yaml":true},{"content":"<code>cancellationToken</code> was canceled.","nodes":[{"pos":[0,44],"content":"<ph id=\"ph1\">&lt;code&gt;cancellationToken&lt;/code&gt;</ph> was canceled.","source":"<code>cancellationToken</code> was canceled."}],"pos":[31018,31063],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,166],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[31177,31344],"yaml":true},{"content":"The semaphoreSlim instance has been disposed <code>.</code><code>-or-</code>  \n  \n The <xref href=\"System.Threading.CancellationTokenSource\"></xref> that created <code>cancellationToken</code> has already been disposed.","nodes":[{"pos":[0,76],"content":"The semaphoreSlim instance has been disposed <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">.</ph><ept id=\"p1\">&lt;/code&gt;</ept><bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">-or-</ph><ept id=\"p2\">&lt;/code&gt;</ept>","source":"The semaphoreSlim instance has been disposed <code>.</code><code>-or-</code>"},{"pos":[83,219],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationTokenSource\"&gt;&lt;/xref&gt;</ph> that created <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">cancellationToken</ph><ept id=\"p1\">&lt;/code&gt;</ept> has already been disposed.","source":"The <xref href=\"System.Threading.CancellationTokenSource\"></xref> that created <code>cancellationToken</code> has already been disposed."}],"pos":[31450,31676],"yaml":true},{"content":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.","nodes":[{"pos":[0,234],"content":"Blocks the current thread until it can enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a 32-bit signed integer that specifies the timeout, while observing a <ph id=\"ph2\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph>.","source":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>."}],"pos":[33297,33532],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n \nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\n\nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \n  \nIf `cancellationToken` is cancelled, or if a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> and the timeout interval specified by `millisecondsTimeout` expires:\n\n- The thread or task doesn't enter the semaphore.\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.  \n \nIf `cancellationToken` is cancelled, the method throws an   <xref:System.OperationCanceledException> exception.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[75,207],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]},{"pos":[209,349],"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.","nodes":[{"content":"If a thread or task is able to enter the semaphore, it decrements the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by one.","pos":[0,140],"source":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one."}]},{"pos":[355,605],"content":"If <ph id=\"ph1\">`cancellationToken`</ph> is cancelled, or if a thread or task is blocked when calling <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> and the timeout interval specified by <ph id=\"ph3\">`millisecondsTimeout`</ph> expires:","source":"If `cancellationToken` is cancelled, or if a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> and the timeout interval specified by `millisecondsTimeout` expires:"},{"pos":[609,656],"content":"The thread or task doesn't enter the semaphore.","nodes":[{"content":"The thread or task doesn't enter the semaphore.","pos":[0,47]}]},{"pos":[659,744],"content":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property isn't decremented.","pos":[0,85],"source":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented."}]},{"pos":[749,860],"content":"If <ph id=\"ph1\">`cancellationToken`</ph> is cancelled, the method throws an   <ph id=\"ph2\">&lt;xref:System.OperationCanceledException&gt;</ph> exception.","source":"If `cancellationToken` is cancelled, the method throws an   <xref:System.OperationCanceledException> exception."}],"pos":[33543,34417],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","nodes":[{"pos":[0,185],"content":"The number of milliseconds to wait, <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","source":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately."}],"pos":[34628,34814],"yaml":true},{"content":"The <xref href=\"System.Threading.CancellationToken\"></xref> to observe.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph> to observe.","source":"The <xref href=\"System.Threading.CancellationToken\"></xref> to observe."}],"pos":[34908,34980],"yaml":true},{"content":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,126],"content":"<ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`."}],"pos":[35038,35167],"yaml":true},{"content":"<code>cancellationToken</code> was canceled.","nodes":[{"pos":[0,44],"content":"<ph id=\"ph1\">&lt;code&gt;cancellationToken&lt;/code&gt;</ph> was canceled.","source":"<code>cancellationToken</code> was canceled."}],"pos":[35342,35387],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,178],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[35501,35680],"yaml":true},{"content":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> instance has been disposed, or the <xref href=\"System.Threading.CancellationTokenSource\"></xref> that created <code>cancellationToken</code> has been disposed.","nodes":[{"pos":[0,215],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph> instance has been disposed, or the <ph id=\"ph2\">&lt;xref href=\"System.Threading.CancellationTokenSource\"&gt;&lt;/xref&gt;</ph> that created <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">cancellationToken</ph><ept id=\"p1\">&lt;/code&gt;</ept> has been disposed.","source":"The <xref href=\"System.Threading.SemaphoreSlim\"></xref> instance has been disposed, or the <xref href=\"System.Threading.CancellationTokenSource\"></xref> that created <code>cancellationToken</code> has been disposed."}],"pos":[35786,36002],"yaml":true},{"content":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to specify the timeout.","nodes":[{"pos":[0,170],"content":"Blocks the current thread until it can enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> to specify the timeout.","source":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to specify the timeout."}],"pos":[37479,37650],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n \nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately. \n \nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \n  \nIf a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29> and the timeout interval specified by `millisecondsTimeout` expires:\n\n- The thread or task doesn't enter the semaphore.\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[75,207],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]},{"pos":[211,351],"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.","nodes":[{"content":"If a thread or task is able to enter the semaphore, it decrements the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by one.","pos":[0,140],"source":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one."}]},{"pos":[357,533],"content":"If a thread or task is blocked when calling <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29&gt;</ph> and the timeout interval specified by <ph id=\"ph2\">`millisecondsTimeout`</ph> expires:","source":"If a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29> and the timeout interval specified by `millisecondsTimeout` expires:"},{"pos":[537,584],"content":"The thread or task doesn't enter the semaphore.","nodes":[{"content":"The thread or task doesn't enter the semaphore.","pos":[0,47]}]},{"pos":[587,672],"content":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property isn't decremented.","pos":[0,85],"source":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented."}]}],"pos":[37661,38345],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.","nodes":[{"pos":[0,304],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely, or a <ph id=\"ph3\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents 0 milliseconds to test the wait handle and return immediately.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately."}],"pos":[38486,38791],"yaml":true},{"content":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,126],"content":"<ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`."}],"pos":[38849,38978],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,166],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[39155,39322],"yaml":true},{"content":"The semaphoreSlim instance has been disposed <code>.</code>","nodes":[{"pos":[0,59],"content":"The semaphoreSlim instance has been disposed <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">.</ph><ept id=\"p1\">&lt;/code&gt;</ept>","source":"The semaphoreSlim instance has been disposed <code>.</code>"}],"pos":[39428,39488],"yaml":true},{"content":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer that specifies the timeout.","nodes":[{"pos":[0,159],"content":"Blocks the current thread until it can enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a 32-bit signed integer that specifies the timeout.","source":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer that specifies the timeout."}],"pos":[40947,41107],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n \nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\n\nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \n  \nIf a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29> and the timeout interval specified by `millisecondsTimeout` expires:\n\n- The thread or task doesn't enter the semaphore.\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[75,207],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]},{"pos":[209,349],"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.","nodes":[{"content":"If a thread or task is able to enter the semaphore, it decrements the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by one.","pos":[0,140],"source":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one."}]},{"pos":[355,528],"content":"If a thread or task is blocked when calling <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29&gt;</ph> and the timeout interval specified by <ph id=\"ph2\">`millisecondsTimeout`</ph> expires:","source":"If a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29> and the timeout interval specified by `millisecondsTimeout` expires:"},{"pos":[532,579],"content":"The thread or task doesn't enter the semaphore.","nodes":[{"content":"The thread or task doesn't enter the semaphore.","pos":[0,47]}]},{"pos":[582,667],"content":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property isn't decremented.","pos":[0,85],"source":"The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented."}]}],"pos":[41118,41797],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","nodes":[{"pos":[0,185],"content":"The number of milliseconds to wait, <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","source":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately."}],"pos":[41954,42140],"yaml":true},{"content":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,126],"content":"<ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`."}],"pos":[42198,42327],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,178],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[42504,42683],"yaml":true},{"content":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.","nodes":[{"pos":[0,101],"content":"Blocks the current thread until it can enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>.","source":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>."}],"pos":[44085,44187],"yaml":true},{"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.","nodes":[{"pos":[0,140],"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.","nodes":[{"content":"If a thread or task is able to enter the semaphore, it decrements the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by one.","pos":[0,140],"source":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one."}]}],"pos":[44198,44339],"yaml":true,"extradata":"MT"},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[44571,44619],"yaml":true},{"content":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.","nodes":[{"pos":[0,176],"content":"Blocks the current thread until it can enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, while observing a <ph id=\"ph2\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph>.","source":"Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>."}],"pos":[46180,46357],"yaml":true},{"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \n  \n If `cancellationToken` is cancelled, the thread or task doesn't enter the semaphore, and the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented. Instead, the method throws an <xref:System.OperationCanceledException> exception.","nodes":[{"pos":[0,140],"content":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.","nodes":[{"content":"If a thread or task is able to enter the semaphore, it decrements the <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property by one.","pos":[0,140],"source":"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one."}]},{"pos":[147,403],"content":"If `cancellationToken` is cancelled, the thread or task doesn't enter the semaphore, and the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented. Instead, the method throws an <xref:System.OperationCanceledException> exception.","nodes":[{"content":"If <ph id=\"ph1\">`cancellationToken`</ph> is cancelled, the thread or task doesn't enter the semaphore, and the <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim.CurrentCount%2A&gt;</ph> property isn't decremented.","pos":[0,174],"source":"If `cancellationToken` is cancelled, the thread or task doesn't enter the semaphore, and the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented."},{"content":"Instead, the method throws an <ph id=\"ph1\">&lt;xref:System.OperationCanceledException&gt;</ph> exception.","pos":[175,256],"source":" Instead, the method throws an <xref:System.OperationCanceledException> exception."}]}],"pos":[46368,46776],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe.","nodes":[{"pos":[0,77],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph> token to observe.","source":"The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe."}],"pos":[46982,47060],"yaml":true},{"content":"<code>cancellationToken</code> was canceled.","nodes":[{"pos":[0,44],"content":"<ph id=\"ph1\">&lt;code&gt;cancellationToken&lt;/code&gt;</ph> was canceled.","source":"<code>cancellationToken</code> was canceled."}],"pos":[47235,47280],"yaml":true},{"content":"The current instance has already been disposed.  \n  \n -or-  \n  \n The <xref href=\"System.Threading.CancellationTokenSource\"></xref> that created <code>cancellationToken</code> has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]},{"pos":[54,58],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[65,201],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationTokenSource\"&gt;&lt;/xref&gt;</ph> that created <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">cancellationToken</ph><ept id=\"p1\">&lt;/code&gt;</ept> has already been disposed.","source":"The <xref href=\"System.Threading.CancellationTokenSource\"></xref> that created <code>cancellationToken</code> has already been disposed."}],"pos":[47386,47596],"yaml":true},{"content":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.","nodes":[{"pos":[0,221],"content":"Asynchronously waits to enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a 32-bit signed integer to measure the time interval, while observing a <ph id=\"ph2\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph>.","source":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>."}],"pos":[49247,49469],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n \n If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[76,208],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]}],"pos":[49480,49693],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","nodes":[{"pos":[0,186],"content":"The number of milliseconds to wait, <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","source":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately."}],"pos":[49938,50125],"yaml":true},{"content":"The <xref href=\"System.Threading.CancellationToken\"></xref> to observe.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph> to observe.","source":"The <xref href=\"System.Threading.CancellationToken\"></xref> to observe."}],"pos":[50219,50291],"yaml":true},{"content":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.","nodes":[{"pos":[0,185],"content":"A task that will complete with a result of <ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, otherwise with a result of <ph id=\"ph3\">`false`</ph>.","source":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`."}],"pos":[50378,50564],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,169],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is a number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[50746,50916],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[51022,51070],"yaml":true},{"content":"<code>cancellationToken</code> was canceled.","nodes":[{"pos":[0,44],"content":"<ph id=\"ph1\">&lt;code&gt;cancellationToken&lt;/code&gt;</ph> was canceled.","source":"<code>cancellationToken</code> was canceled."}],"pos":[51182,51227],"yaml":true},{"content":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.","nodes":[{"pos":[0,86],"content":"Asynchronously waits to enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>.","source":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>."}],"pos":[52659,52746],"yaml":true},{"content":"A task that will complete when the semaphore has been entered.","nodes":[{"pos":[0,62],"content":"A task that will complete when the semaphore has been entered.","nodes":[{"content":"A task that will complete when the semaphore has been entered.","pos":[0,62]}]}],"pos":[52908,52971],"yaml":true},{"content":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer to measure the time interval.","nodes":[{"pos":[0,146],"content":"Asynchronously waits to enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a 32-bit signed integer to measure the time interval.","source":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer to measure the time interval."}],"pos":[54531,54678],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n \n If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[76,208],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]}],"pos":[54689,54902],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","nodes":[{"pos":[0,186],"content":"The number of milliseconds to wait, <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","source":"The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately."}],"pos":[55093,55280],"yaml":true},{"content":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.","nodes":[{"pos":[0,185],"content":"A task that will complete with a result of <ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, otherwise with a result of <ph id=\"ph3\">`false`</ph>.","source":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`."}],"pos":[55367,55553],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[55727,55775],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,178],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[55889,56068],"yaml":true},{"content":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.","nodes":[{"pos":[0,161],"content":"Asynchronously waits to enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, while observing a <ph id=\"ph2\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph>.","source":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>."}],"pos":[57659,57821],"yaml":true},{"content":"The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe.","nodes":[{"pos":[0,77],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph> token to observe.","source":"The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe."}],"pos":[58055,58133],"yaml":true},{"content":"A task that will complete when the semaphore has been entered.","nodes":[{"pos":[0,62],"content":"A task that will complete when the semaphore has been entered.","nodes":[{"content":"A task that will complete when the semaphore has been entered.","pos":[0,62]}]}],"pos":[58204,58267],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[58441,58489],"yaml":true},{"content":"<code>cancellationToken</code> was canceled.","nodes":[{"pos":[0,44],"content":"<ph id=\"ph1\">&lt;code&gt;cancellationToken&lt;/code&gt;</ph> was canceled.","source":"<code>cancellationToken</code> was canceled."}],"pos":[58601,58646],"yaml":true},{"content":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to measure the time interval.","nodes":[{"pos":[0,161],"content":"Asynchronously waits to enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> to measure the time interval.","source":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to measure the time interval."}],"pos":[60153,60315],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n \n If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[76,208],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]}],"pos":[60326,60539],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.","nodes":[{"pos":[0,304],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely, or a <ph id=\"ph3\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents 0 milliseconds to test the wait handle and return immediately.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately."}],"pos":[60714,61019],"yaml":true},{"content":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.","nodes":[{"pos":[0,185],"content":"A task that will complete with a result of <ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, otherwise with a result of <ph id=\"ph3\">`false`</ph>.","source":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`."}],"pos":[61106,61292],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[61466,61514],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,178],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[61628,61807],"yaml":true},{"content":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.","nodes":[{"pos":[0,236],"content":"Asynchronously waits to enter the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, using a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> to measure the time interval, while observing a <ph id=\"ph3\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph>.","source":"Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>."}],"pos":[63476,63713],"yaml":true},{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.\n\n If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"pos":[0,72],"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","nodes":[{"content":"If the timeout is set to -1 milliseconds, the method waits indefinitely.","pos":[0,72]}]},{"pos":[75,207],"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.","pos":[0,132],"nodes":[{"content":"If the timeout is set to zero milliseconds, the method doesn't block.","pos":[0,69]},{"content":"It tests the state of the wait handle and returns immediately.","pos":[70,132]}]}]}],"pos":[63724,63943],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.","nodes":[{"pos":[0,304],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely, or a <ph id=\"ph3\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents 0 milliseconds to test the wait handle and return immediately.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately."}],"pos":[64172,64477],"yaml":true},{"content":"The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe.","nodes":[{"pos":[0,77],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.CancellationToken\"&gt;&lt;/xref&gt;</ph> token to observe.","source":"The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe."}],"pos":[64571,64649],"yaml":true},{"content":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.","nodes":[{"pos":[0,185],"content":"A task that will complete with a result of <ph id=\"ph1\">`true`</ph> if the current thread successfully entered the <ph id=\"ph2\">&lt;xref href=\"System.Threading.SemaphoreSlim\"&gt;&lt;/xref&gt;</ph>, otherwise with a result of <ph id=\"ph3\">`false`</ph>.","source":"A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`."}],"pos":[64736,64922],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,178],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[65104,65283],"yaml":true},{"content":"<code>cancellationToken</code> was canceled.","nodes":[{"pos":[0,44],"content":"<ph id=\"ph1\">&lt;code&gt;cancellationToken&lt;/code&gt;</ph> was canceled.","source":"<code>cancellationToken</code> was canceled."}],"pos":[65395,65440],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.SemaphoreSlim\n  commentId: T:System.Threading.SemaphoreSlim\n  id: SemaphoreSlim\n  children:\n  - System.Threading.SemaphoreSlim.#ctor(System.Int32)\n  - System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)\n  - System.Threading.SemaphoreSlim.AvailableWaitHandle\n  - System.Threading.SemaphoreSlim.CurrentCount\n  - System.Threading.SemaphoreSlim.Dispose\n  - System.Threading.SemaphoreSlim.Dispose(System.Boolean)\n  - System.Threading.SemaphoreSlim.Release\n  - System.Threading.SemaphoreSlim.Release(System.Int32)\n  - System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)\n  - System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)\n  - System.Threading.SemaphoreSlim.Wait(System.TimeSpan)\n  - System.Threading.SemaphoreSlim.Wait(System.Int32)\n  - System.Threading.SemaphoreSlim.Wait\n  - System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)\n  - System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)\n  - System.Threading.SemaphoreSlim.WaitAsync\n  - System.Threading.SemaphoreSlim.WaitAsync(System.Int32)\n  - System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)\n  - System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)\n  - System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)\n  langs:\n  - csharp\n  name: SemaphoreSlim\n  nameWithType: SemaphoreSlim\n  fullName: System.Threading.SemaphoreSlim\n  type: Class\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Represents a lightweight alternative to <xref href=\"System.Threading.Semaphore\"></xref> that limits the number of threads that can access a resource or pool of resources concurrently.\n  remarks: \"Semaphores are of two types: local semaphores and named system semaphores. The former is local to an app. The latter is visible throughout the operating system and is suitable for inter-process synchronization. The <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to the <xref:System.Threading.Semaphore> class that doesn't use Windows kernel semaphores. Unlike the <xref:System.Threading.Semaphore> class, the <xref:System.Threading.SemaphoreSlim> class doesn't support named system semaphores. You can use it as a local semaphore only. The <xref:System.Threading.SemaphoreSlim> class is the recommended semaphore for synchronization within a single app.  \\n  \\n A lightweight semaphore controls access to a pool of resources that is local to your application. When you instantiate a semaphore, you can specify the maximum number of threads that can enter the semaphore concurrently. You also specify the initial number of threads that can enter the semaphore concurrently. This defines the semaphore's count.  \\n  \\n The count is decremented each time a thread enters the semaphore, and incremented each time a thread releases the semaphore. To enter the semaphore, a thread calls one of the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> overloads. To release the semaphore, it calls one of the <xref:System.Threading.SemaphoreSlim.Release%2A> overloads. When the count reaches zero, subsequent calls to one of the `Wait` methods block until other threads release the semaphore. If multiple threads are blocked, there is no guaranteed order, such as FIFO or LIFO, that controls when threads enter the semaphore.  \\n  \\n The basic structure for code that uses a semaphore to protect resources is:  \\n  \\n```  \\n  \\n' Enter semaphore by calling one of the Wait or WaitAsync methods.  \\nSemaphoreSlim.Wait()  \\n'   \\n' Execute code protected by the semaphore.   \\n'  \\nSemaphoreSlim.Release()  \\n  \\n```  \\n  \\n When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created. The semaphore's count is available from the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property.  \\n  \\n> [!IMPORTANT]\\n>  The <xref:System.Threading.SemaphoreSlim> class doesn't enforce thread or task identity on calls to the <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A> methods. In addition, if the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> constructor is used to instantiate the <xref:System.Threading.SemaphoreSlim> object, the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property can increase beyond the value set by the constructor. It is the programmer's responsibility to ensure that calls to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods are appropriately paired with calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods.\"\n  example:\n  - \"The following example creates a semaphore with a maximum count of three threads and an initial count of zero threads. The example starts five tasks, all of which block waiting for the semaphore. The main thread calls the <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> overload to increase the semaphore count to its maximum, which allows three tasks to enter the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread to make the output easier to read.  \\n  \\n [!code-csharp[System.Threading.SemaphoreSlim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.semaphoreslim/cs/example.cs#1)]\\n [!code-vb[System.Threading.SemaphoreSlim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.semaphoreslim/vb/example.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public class SemaphoreSlim : IDisposable\n  inheritance:\n  - System.Object\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.#ctor(System.Int32)\n  commentId: M:System.Threading.SemaphoreSlim.#ctor(System.Int32)\n  id: '#ctor(System.Int32)'\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: SemaphoreSlim(Int32)\n  nameWithType: SemaphoreSlim.SemaphoreSlim(Int32)\n  fullName: SemaphoreSlim.SemaphoreSlim(Int32)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class, specifying the initial number of requests that can be granted concurrently.\n  remarks: The `initialCount` parameter defines the number of concurrent requests to enter the semaphore that can be granted. However, it doesn't define the maximum number of requests that can be granted concurrently. A   <xref:System.Threading.SemaphoreSlim> object instantiated by calling this constructor doesn't throw a <xref:System.Threading.SemaphoreFullException> exception if a call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method increases the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property beyond `initialCount`. This occurs if there are more calls to <xref:System.Threading.SemaphoreSlim.Release%2A> methods than there are to <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> methods. To set the maximum number of concurrent requests to enter the semaphore that can be granted, call the <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> constructor.\n  syntax:\n    content: public SemaphoreSlim (int initialCount);\n    parameters:\n    - id: initialCount\n      type: System.Int32\n      description: The initial number of requests for the semaphore that can be granted concurrently.\n  overload: System.Threading.SemaphoreSlim.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>initialCount</code> is less than 0.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)\n  commentId: M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)\n  id: '#ctor(System.Int32,System.Int32)'\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: SemaphoreSlim(Int32, Int32)\n  nameWithType: SemaphoreSlim.SemaphoreSlim(Int32, Int32)\n  fullName: SemaphoreSlim.SemaphoreSlim(Int32, Int32)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class, specifying the initial and maximum number of requests that can be granted concurrently.\n  syntax:\n    content: public SemaphoreSlim (int initialCount, int maxCount);\n    parameters:\n    - id: initialCount\n      type: System.Int32\n      description: The initial number of requests for the semaphore that can be granted concurrently.\n    - id: maxCount\n      type: System.Int32\n      description: The maximum number of requests for the semaphore that can be granted concurrently.\n  overload: System.Threading.SemaphoreSlim.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>initialCount</code> is less than 0, or <code>initialCount</code> is greater than <code>maxCount</code>, or <code>maxCount</code> is equal to or less than 0.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.AvailableWaitHandle\n  commentId: P:System.Threading.SemaphoreSlim.AvailableWaitHandle\n  id: AvailableWaitHandle\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: AvailableWaitHandle\n  nameWithType: SemaphoreSlim.AvailableWaitHandle\n  fullName: SemaphoreSlim.AvailableWaitHandle\n  type: Property\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Returns a <xref href=\"System.Threading.WaitHandle\"></xref> that can be used to wait on the semaphore.\n  remarks: Use this property only when you must wait on a SemaphoreSlim together with other kernel-based synchronization objects with the same wait handle. A successful wait on the <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> does not imply a successful wait on the <xref:System.Threading.SemaphoreSlim> itself, nor does it decrement the semaphore's count. After the available wait handle is signaled, you should wait on the <xref:System.Threading.SemaphoreSlim> specifically.\n  syntax:\n    content: public System.Threading.WaitHandle AvailableWaitHandle { get; }\n    return:\n      type: System.Threading.WaitHandle\n      description: A <xref href=\"System.Threading.WaitHandle\"></xref> that can be used to wait on the semaphore.\n  overload: System.Threading.SemaphoreSlim.AvailableWaitHandle*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.CurrentCount\n  commentId: P:System.Threading.SemaphoreSlim.CurrentCount\n  id: CurrentCount\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: CurrentCount\n  nameWithType: SemaphoreSlim.CurrentCount\n  fullName: SemaphoreSlim.CurrentCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the number of remaining threads that can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object.\n  remarks: The initial value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is set by the call to the <xref:System.Threading.SemaphoreSlim.%23ctor%2A> class constructor. It is decremented by each call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method, and incremented by each call to the <xref:System.Threading.SemaphoreSlim.Release%2A> method.\n  syntax:\n    content: public int CurrentCount { get; }\n    return:\n      type: System.Int32\n      description: The number of remaining threads that can enter the semaphore.\n  overload: System.Threading.SemaphoreSlim.CurrentCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Dispose\n  commentId: M:System.Threading.SemaphoreSlim.Dispose\n  id: Dispose\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: SemaphoreSlim.Dispose()\n  fullName: SemaphoreSlim.Dispose()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases all resources used by the current instance of the <xref href=\"System.Threading.SemaphoreSlim\"></xref> class.\n  remarks: \"Call `Dispose` when you are finished using the <xref:System.Threading.SemaphoreSlim>. The `Dispose` method leaves the <xref:System.Threading.SemaphoreSlim> in an unusable state. After calling `Dispose`, you must release all references to the <xref:System.Threading.SemaphoreSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.SemaphoreSlim> was occupying.  \\n  \\n For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \\n  \\n> [!NOTE]\\n>  Always call `Dispose` before you release your last reference to the <xref:System.Threading.SemaphoreSlim>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Threading.SemaphoreSlim> object's `Finalize` method.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Threading.SemaphoreSlim.Dispose*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Dispose(System.Boolean)\n  commentId: M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: SemaphoreSlim.Dispose(Boolean)\n  fullName: SemaphoreSlim.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the unmanaged resources used by the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, and optionally releases the managed resources.\n  remarks: Unlike most of the members of <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> is not thread-safe and may not be used concurrently with other members of this instance.\n  syntax:\n    content: protected virtual void Dispose (bool disposing);\n    parameters:\n    - id: disposing\n      type: System.Boolean\n      description: '`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources.'\n  overload: System.Threading.SemaphoreSlim.Dispose*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Release\n  commentId: M:System.Threading.SemaphoreSlim.Release\n  id: Release\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Release()\n  nameWithType: SemaphoreSlim.Release()\n  fullName: SemaphoreSlim.Release()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object once.\n  remarks: A call to the <xref:System.Threading.SemaphoreSlim.Release> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one. If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows one thread or task blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore.\n  syntax:\n    content: public int Release ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: The previous count of the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.\n  overload: System.Threading.SemaphoreSlim.Release*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.Threading.SemaphoreFullException\n    commentId: T:System.Threading.SemaphoreFullException\n    description: The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has already reached its maximum size.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Release(System.Int32)\n  commentId: M:System.Threading.SemaphoreSlim.Release(System.Int32)\n  id: Release(System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Release(Int32)\n  nameWithType: SemaphoreSlim.Release(Int32)\n  fullName: SemaphoreSlim.Release(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the <xref href=\"System.Threading.SemaphoreSlim\"></xref> object a specified number of times.\n  remarks: A call to the <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> method increments the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by `releaseCount`. If the value of the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property is zero before this method is called, the method also allows `releaseCount` threads or tasks blocked by a call to the <xref:System.Threading.SemaphoreSlim.Wait%2A> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> method to enter the semaphore.\n  syntax:\n    content: public int Release (int releaseCount);\n    parameters:\n    - id: releaseCount\n      type: System.Int32\n      description: The number of times to exit the semaphore.\n    return:\n      type: System.Int32\n      description: The previous count of the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.\n  overload: System.Threading.SemaphoreSlim.Release*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>releaseCount</code> is less than 1.\n  - type: System.Threading.SemaphoreFullException\n    commentId: T:System.Threading.SemaphoreFullException\n    description: The <xref href=\"System.Threading.SemaphoreSlim\"></xref> has already reached its maximum size.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)\n  commentId: M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)\n  id: Wait(System.TimeSpan,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Wait(TimeSpan, CancellationToken)\n  nameWithType: SemaphoreSlim.Wait(TimeSpan, CancellationToken)\n  fullName: SemaphoreSlim.Wait(TimeSpan, CancellationToken)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.\n  remarks: \"If the timeout is set to -1 milliseconds, the method waits indefinitely.\\n \\nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately. \\n\\nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \\n  \\nIf `cancellationToken` is cancelled, or if a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> and the timeout interval specified by `millisecondsTimeout` expires:\\n\\n- The thread or task doesn't enter the semaphore.\\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.  \\n\\nIf `cancellationToken` is cancelled, the method throws an <xref:System.OperationCanceledException> exception.\"\n  syntax:\n    content: public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The <xref href=\"System.Threading.CancellationToken\"></xref> to observe.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.'\n  overload: System.Threading.SemaphoreSlim.Wait*\n  exceptions:\n  - type: System.OperationCanceledException\n    commentId: T:System.OperationCanceledException\n    description: <code>cancellationToken</code> was canceled.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"The semaphoreSlim instance has been disposed <code>.</code><code>-or-</code>  \\n  \\n The <xref href=\\\"System.Threading.CancellationTokenSource\\\"></xref> that created <code>cancellationToken</code> has already been disposed.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)\n  commentId: M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)\n  id: Wait(System.Int32,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Wait(Int32, CancellationToken)\n  nameWithType: SemaphoreSlim.Wait(Int32, CancellationToken)\n  fullName: SemaphoreSlim.Wait(Int32, CancellationToken)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.\n  remarks: \"If the timeout is set to -1 milliseconds, the method waits indefinitely.\\n \\nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\\n\\nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \\n  \\nIf `cancellationToken` is cancelled, or if a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> and the timeout interval specified by `millisecondsTimeout` expires:\\n\\n- The thread or task doesn't enter the semaphore.\\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.  \\n \\nIf `cancellationToken` is cancelled, the method throws an   <xref:System.OperationCanceledException> exception.\"\n  syntax:\n    content: public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The <xref href=\"System.Threading.CancellationToken\"></xref> to observe.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.'\n  overload: System.Threading.SemaphoreSlim.Wait*\n  exceptions:\n  - type: System.OperationCanceledException\n    commentId: T:System.OperationCanceledException\n    description: <code>cancellationToken</code> was canceled.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.SemaphoreSlim\"></xref> instance has been disposed, or the <xref href=\"System.Threading.CancellationTokenSource\"></xref> that created <code>cancellationToken</code> has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Wait(System.TimeSpan)\n  commentId: M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)\n  id: Wait(System.TimeSpan)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Wait(TimeSpan)\n  nameWithType: SemaphoreSlim.Wait(TimeSpan)\n  fullName: SemaphoreSlim.Wait(TimeSpan)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to specify the timeout.\n  remarks: \"If the timeout is set to -1 milliseconds, the method waits indefinitely.\\n \\nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately. \\n \\nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \\n  \\nIf a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29> and the timeout interval specified by `millisecondsTimeout` expires:\\n\\n- The thread or task doesn't enter the semaphore.\\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.\"\n  syntax:\n    content: public bool Wait (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.'\n  overload: System.Threading.SemaphoreSlim.Wait*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The semaphoreSlim instance has been disposed <code>.</code>\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Wait(System.Int32)\n  commentId: M:System.Threading.SemaphoreSlim.Wait(System.Int32)\n  id: Wait(System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Wait(Int32)\n  nameWithType: SemaphoreSlim.Wait(Int32)\n  fullName: SemaphoreSlim.Wait(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer that specifies the timeout.\n  remarks: \"If the timeout is set to -1 milliseconds, the method waits indefinitely.\\n \\nIf the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\\n\\nIf a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \\n  \\nIf a thread or task is blocked when calling <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29> and the timeout interval specified by `millisecondsTimeout` expires:\\n\\n- The thread or task doesn't enter the semaphore.\\n- The <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented.\"\n  syntax:\n    content: public bool Wait (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref>(-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>; otherwise, `false`.'\n  overload: System.Threading.SemaphoreSlim.Wait*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Wait\n  commentId: M:System.Threading.SemaphoreSlim.Wait\n  id: Wait\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Wait()\n  nameWithType: SemaphoreSlim.Wait()\n  fullName: SemaphoreSlim.Wait()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.\n  remarks: If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.\n  syntax:\n    content: public void Wait ();\n    parameters: []\n  overload: System.Threading.SemaphoreSlim.Wait*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)\n  commentId: M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)\n  id: Wait(System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: Wait(CancellationToken)\n  nameWithType: SemaphoreSlim.Wait(CancellationToken)\n  fullName: SemaphoreSlim.Wait(CancellationToken)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.\n  remarks: \"If a thread or task is able to enter the semaphore, it decrements the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property by one.  \\n  \\n If `cancellationToken` is cancelled, the thread or task doesn't enter the semaphore, and the <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> property isn't decremented. Instead, the method throws an <xref:System.OperationCanceledException> exception.\"\n  syntax:\n    content: public void Wait (System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe.\n  overload: System.Threading.SemaphoreSlim.Wait*\n  exceptions:\n  - type: System.OperationCanceledException\n    commentId: T:System.OperationCanceledException\n    description: <code>cancellationToken</code> was canceled.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"The current instance has already been disposed.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Threading.CancellationTokenSource\\\"></xref> that created <code>cancellationToken</code> has already been disposed.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)\n  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)\n  id: WaitAsync(System.Int32,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: WaitAsync(Int32, CancellationToken)\n  nameWithType: SemaphoreSlim.WaitAsync(Int32, CancellationToken)\n  fullName: SemaphoreSlim.WaitAsync(Int32, CancellationToken)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.\n  remarks: \"If the timeout is set to -1 milliseconds, the method waits indefinitely.\\n \\n If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\"\n  syntax:\n    content: public System.Threading.Tasks.Task<bool> WaitAsync (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The <xref href=\"System.Threading.CancellationToken\"></xref> to observe.\n    return:\n      type: System.Threading.Tasks.Task{System.Boolean}\n      description: A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.\n  overload: System.Threading.SemaphoreSlim.WaitAsync*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.OperationCanceledException\n    commentId: T:System.OperationCanceledException\n    description: <code>cancellationToken</code> was canceled.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.WaitAsync\n  commentId: M:System.Threading.SemaphoreSlim.WaitAsync\n  id: WaitAsync\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: WaitAsync()\n  nameWithType: SemaphoreSlim.WaitAsync()\n  fullName: SemaphoreSlim.WaitAsync()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>.\n  syntax:\n    content: public System.Threading.Tasks.Task WaitAsync ();\n    parameters: []\n    return:\n      type: System.Threading.Tasks.Task\n      description: A task that will complete when the semaphore has been entered.\n  overload: System.Threading.SemaphoreSlim.WaitAsync*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Int32)\n  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)\n  id: WaitAsync(System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: WaitAsync(Int32)\n  nameWithType: SemaphoreSlim.WaitAsync(Int32)\n  fullName: SemaphoreSlim.WaitAsync(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a 32-bit signed integer to measure the time interval.\n  remarks: \"If the timeout is set to -1 milliseconds, the method waits indefinitely.\\n \\n If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\"\n  syntax:\n    content: public System.Threading.Tasks.Task<bool> WaitAsync (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.\n    return:\n      type: System.Threading.Tasks.Task{System.Boolean}\n      description: A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.\n  overload: System.Threading.SemaphoreSlim.WaitAsync*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)\n  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)\n  id: WaitAsync(System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: WaitAsync(CancellationToken)\n  nameWithType: SemaphoreSlim.WaitAsync(CancellationToken)\n  fullName: SemaphoreSlim.WaitAsync(CancellationToken)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.\n  syntax:\n    content: public System.Threading.Tasks.Task WaitAsync (System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe.\n    return:\n      type: System.Threading.Tasks.Task\n      description: A task that will complete when the semaphore has been entered.\n  overload: System.Threading.SemaphoreSlim.WaitAsync*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.OperationCanceledException\n    commentId: T:System.OperationCanceledException\n    description: <code>cancellationToken</code> was canceled.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)\n  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)\n  id: WaitAsync(System.TimeSpan)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: WaitAsync(TimeSpan)\n  nameWithType: SemaphoreSlim.WaitAsync(TimeSpan)\n  fullName: SemaphoreSlim.WaitAsync(TimeSpan)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to measure the time interval.\n  remarks: \"If the timeout is set to -1 milliseconds, the method waits indefinitely.\\n \\n If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\"\n  syntax:\n    content: public System.Threading.Tasks.Task<bool> WaitAsync (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.\n    return:\n      type: System.Threading.Tasks.Task{System.Boolean}\n      description: A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.\n  overload: System.Threading.SemaphoreSlim.WaitAsync*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)\n  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)\n  id: WaitAsync(System.TimeSpan,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  langs:\n  - csharp\n  name: WaitAsync(TimeSpan, CancellationToken)\n  nameWithType: SemaphoreSlim.WaitAsync(TimeSpan, CancellationToken)\n  fullName: SemaphoreSlim.WaitAsync(TimeSpan, CancellationToken)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, using a <xref href=\"System.TimeSpan\"></xref> to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\"></xref>.\n  remarks: >-\n    If the timeout is set to -1 milliseconds, the method waits indefinitely.\n\n     If the timeout is set to zero milliseconds, the method doesn't block. It tests the state of the wait handle and returns immediately.\n  syntax:\n    content: public System.Threading.Tasks.Task<bool> WaitAsync (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely, or a <xref href=\"System.TimeSpan\"></xref> that represents 0 milliseconds to test the wait handle and return immediately.\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The <xref href=\"System.Threading.CancellationToken\"></xref> token to observe.\n    return:\n      type: System.Threading.Tasks.Task{System.Boolean}\n      description: A task that will complete with a result of `true` if the current thread successfully entered the <xref href=\"System.Threading.SemaphoreSlim\"></xref>, otherwise with a result of `false`.\n  overload: System.Threading.SemaphoreSlim.WaitAsync*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite timeout -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  - type: System.OperationCanceledException\n    commentId: T:System.OperationCanceledException\n    description: <code>cancellationToken</code> was canceled.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.ObjectDisposedException\n  parent: System\n  isExternal: false\n  name: ObjectDisposedException\n  nameWithType: ObjectDisposedException\n  fullName: System.ObjectDisposedException\n- uid: System.Threading.SemaphoreFullException\n  parent: System.Threading\n  isExternal: false\n  name: SemaphoreFullException\n  nameWithType: SemaphoreFullException\n  fullName: System.Threading.SemaphoreFullException\n- uid: System.OperationCanceledException\n  parent: System\n  isExternal: false\n  name: OperationCanceledException\n  nameWithType: OperationCanceledException\n  fullName: System.OperationCanceledException\n- uid: System.Threading.SemaphoreSlim.#ctor(System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: SemaphoreSlim(Int32)\n  nameWithType: SemaphoreSlim.SemaphoreSlim(Int32)\n  fullName: SemaphoreSlim.SemaphoreSlim(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: SemaphoreSlim(Int32, Int32)\n  nameWithType: SemaphoreSlim.SemaphoreSlim(Int32, Int32)\n  fullName: SemaphoreSlim.SemaphoreSlim(Int32, Int32)\n- uid: System.Threading.SemaphoreSlim.AvailableWaitHandle\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: AvailableWaitHandle\n  nameWithType: SemaphoreSlim.AvailableWaitHandle\n  fullName: SemaphoreSlim.AvailableWaitHandle\n- uid: System.Threading.WaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandle\n  nameWithType: WaitHandle\n  fullName: System.Threading.WaitHandle\n- uid: System.Threading.SemaphoreSlim.CurrentCount\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: CurrentCount\n  nameWithType: SemaphoreSlim.CurrentCount\n  fullName: SemaphoreSlim.CurrentCount\n- uid: System.Threading.SemaphoreSlim.Dispose\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Dispose()\n  nameWithType: SemaphoreSlim.Dispose()\n  fullName: SemaphoreSlim.Dispose()\n- uid: System.Threading.SemaphoreSlim.Dispose(System.Boolean)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: SemaphoreSlim.Dispose(Boolean)\n  fullName: SemaphoreSlim.Dispose(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.SemaphoreSlim.Release\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Release()\n  nameWithType: SemaphoreSlim.Release()\n  fullName: SemaphoreSlim.Release()\n- uid: System.Threading.SemaphoreSlim.Release(System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Release(Int32)\n  nameWithType: SemaphoreSlim.Release(Int32)\n  fullName: SemaphoreSlim.Release(Int32)\n- uid: System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Wait(TimeSpan, CancellationToken)\n  nameWithType: SemaphoreSlim.Wait(TimeSpan, CancellationToken)\n  fullName: SemaphoreSlim.Wait(TimeSpan, CancellationToken)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.Threading.CancellationToken\n  parent: System.Threading\n  isExternal: false\n  name: CancellationToken\n  nameWithType: CancellationToken\n  fullName: System.Threading.CancellationToken\n- uid: System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Wait(Int32, CancellationToken)\n  nameWithType: SemaphoreSlim.Wait(Int32, CancellationToken)\n  fullName: SemaphoreSlim.Wait(Int32, CancellationToken)\n- uid: System.Threading.SemaphoreSlim.Wait(System.TimeSpan)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Wait(TimeSpan)\n  nameWithType: SemaphoreSlim.Wait(TimeSpan)\n  fullName: SemaphoreSlim.Wait(TimeSpan)\n- uid: System.Threading.SemaphoreSlim.Wait(System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Wait(Int32)\n  nameWithType: SemaphoreSlim.Wait(Int32)\n  fullName: SemaphoreSlim.Wait(Int32)\n- uid: System.Threading.SemaphoreSlim.Wait\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Wait()\n  nameWithType: SemaphoreSlim.Wait()\n  fullName: SemaphoreSlim.Wait()\n- uid: System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Wait(CancellationToken)\n  nameWithType: SemaphoreSlim.Wait(CancellationToken)\n  fullName: SemaphoreSlim.Wait(CancellationToken)\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: WaitAsync(Int32, CancellationToken)\n  nameWithType: SemaphoreSlim.WaitAsync(Int32, CancellationToken)\n  fullName: SemaphoreSlim.WaitAsync(Int32, CancellationToken)\n- uid: System.Threading.Tasks.Task`1\n  name: Task<TResult>\n  nameWithType: Task<TResult>\n  fullName: System.Threading.Tasks.Task<TResult>\n- uid: System.Threading.Tasks.Task{System.Boolean}\n  parent: System.Threading.Tasks\n  isExternal: false\n  name: Task<Boolean>\n  nameWithType: Task<Boolean>\n  fullName: System.Threading.Tasks.Task<System.Boolean>\n  spec.csharp:\n  - uid: System.Threading.Tasks.Task`1\n    name: Task\n    nameWithType: Task\n    fullName: System.Threading.Tasks.Task\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Boolean\n    name: Boolean\n    nameWithType: Boolean\n    fullName: System.Boolean\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.Threading.SemaphoreSlim.WaitAsync\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: WaitAsync()\n  nameWithType: SemaphoreSlim.WaitAsync()\n  fullName: SemaphoreSlim.WaitAsync()\n- uid: System.Threading.Tasks.Task\n  parent: System.Threading.Tasks\n  isExternal: false\n  name: Task\n  nameWithType: Task\n  fullName: System.Threading.Tasks.Task\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Int32)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: WaitAsync(Int32)\n  nameWithType: SemaphoreSlim.WaitAsync(Int32)\n  fullName: SemaphoreSlim.WaitAsync(Int32)\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: WaitAsync(CancellationToken)\n  nameWithType: SemaphoreSlim.WaitAsync(CancellationToken)\n  fullName: SemaphoreSlim.WaitAsync(CancellationToken)\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: WaitAsync(TimeSpan)\n  nameWithType: SemaphoreSlim.WaitAsync(TimeSpan)\n  fullName: SemaphoreSlim.WaitAsync(TimeSpan)\n- uid: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: WaitAsync(TimeSpan, CancellationToken)\n  nameWithType: SemaphoreSlim.WaitAsync(TimeSpan, CancellationToken)\n  fullName: SemaphoreSlim.WaitAsync(TimeSpan, CancellationToken)\n- uid: System.Threading.SemaphoreSlim.#ctor*\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: SemaphoreSlim\n  nameWithType: SemaphoreSlim.SemaphoreSlim\n  fullName: SemaphoreSlim.SemaphoreSlim\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n- uid: System.Threading.SemaphoreSlim.AvailableWaitHandle*\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: AvailableWaitHandle\n  nameWithType: SemaphoreSlim.AvailableWaitHandle\n  fullName: SemaphoreSlim.AvailableWaitHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n- uid: System.Threading.SemaphoreSlim.CurrentCount*\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: CurrentCount\n  nameWithType: SemaphoreSlim.CurrentCount\n  fullName: SemaphoreSlim.CurrentCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n- uid: System.Threading.SemaphoreSlim.Dispose*\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Dispose\n  nameWithType: SemaphoreSlim.Dispose\n  fullName: SemaphoreSlim.Dispose\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n- uid: System.Threading.SemaphoreSlim.Release*\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Release\n  nameWithType: SemaphoreSlim.Release\n  fullName: SemaphoreSlim.Release\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n- uid: System.Threading.SemaphoreSlim.Wait*\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: Wait\n  nameWithType: SemaphoreSlim.Wait\n  fullName: SemaphoreSlim.Wait\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n- uid: System.Threading.SemaphoreSlim.WaitAsync*\n  parent: System.Threading.SemaphoreSlim\n  isExternal: false\n  name: WaitAsync\n  nameWithType: SemaphoreSlim.WaitAsync\n  fullName: SemaphoreSlim.WaitAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SemaphoreSlim.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n"}