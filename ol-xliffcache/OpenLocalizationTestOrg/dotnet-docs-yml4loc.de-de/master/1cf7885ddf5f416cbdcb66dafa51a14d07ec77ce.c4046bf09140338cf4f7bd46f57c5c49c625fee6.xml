{"nodes":[{"content":"Represents a thread synchronization event.","nodes":[{"pos":[0,42],"content":"Represents a thread synchronization event.","nodes":[{"content":"Represents a thread synchronization event.","pos":[0,42]}]}],"pos":[1575,1618],"yaml":true},{"content":"The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling. Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads. A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=fullName> method.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.  \n  \n The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag resets automatically when signaled, after releasing a single waiting thread. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.  \n  \n Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads.  \n  \n Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed.  \n  \n <xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods.  \n  \n For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).","nodes":[{"pos":[0,550],"content":"The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling. Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads. A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=fullName> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class allows threads to communicate with each other by signaling.","pos":[0,109],"source":"The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling."},{"content":"Typically, one or more threads block on an <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> until an unblocked thread calls the <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, releasing one or more of the blocked threads.","pos":[110,329],"source":" Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads."},{"content":"A thread can signal an <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and then block on it, by calling the <ph id=\"ph2\">`static`</ph> (<ph id=\"ph3\">`Shared`</ph> in Visual Basic) <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=fullName&gt;</ph> method.","pos":[330,550],"source":" A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=fullName> method."}]},{"pos":[558,674],"content":"[!NOTE]\n The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class provides access to named system synchronization events.","pos":[9,114],"source":" The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events."}]},{"pos":[681,1240],"content":"The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag resets automatically when signaled, after releasing a single waiting thread. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.","nodes":[{"content":"The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag resets automatically when signaled, after releasing a single waiting thread. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.","pos":[0,559],"nodes":[{"content":"The behavior of an <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> that has been signaled depends on its reset mode.","pos":[0,108],"source":"The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName&gt;</ph> flag resets automatically when signaled, after releasing a single waiting thread.","pos":[109,324],"source":" An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag resets automatically when signaled, after releasing a single waiting thread."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName&gt;</ph> flag remains signaled until its <ph id=\"ph3\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.","pos":[325,559],"source":" An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called."}]}]},{"pos":[1247,1520],"content":"Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads.","nodes":[{"content":"Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads.","pos":[0,273],"nodes":[{"content":"Automatic reset events provide exclusive access to a resource.","pos":[0,62]},{"content":"If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.","pos":[63,190]},{"content":"The event releases the thread and immediately resets, blocking subsequent threads.","pos":[191,273]}]}]},{"pos":[1527,1948],"content":"Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed.","nodes":[{"content":"Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed.","pos":[0,421],"nodes":[{"content":"Manual reset events are like gates.","pos":[0,35]},{"content":"When the event is not signaled, threads that wait on it will block.","pos":[36,103]},{"content":"When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.","pos":[104,314],"source":" When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called."},{"content":"Manual reset events are useful when one thread must complete an activity before other threads can proceed.","pos":[315,421]}]}]},{"pos":[1955,2213],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects can be used with the <ph id=\"ph2\">`static`</ph>(<ph id=\"ph3\">`Shared`</ph> in Visual Basic) <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;</ph> methods.","source":"<xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods."},{"pos":[2220,2447],"content":"For more information about thread synchronization mechanisms, see <bpt id=\"p1\">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id=\"p1\">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.","source":"For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)."}],"pos":[1629,4092],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.","nodes":[{"pos":[0,201],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.","source":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually."}],"pos":[10075,10277],"yaml":true},{"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"pos":[0,500],"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block.","pos":[0,92]},{"content":"If the initial state is signaled, and the <ph id=\"ph1\">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id=\"ph2\">`mode`</ph>, threads that wait on the event will not block.","pos":[93,262],"source":" If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block."},{"content":"If the initial state is signaled, and <ph id=\"ph1\">`mode`</ph> is <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","pos":[263,500],"source":" If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block."}]}],"pos":[10288,10789],"yaml":true,"extradata":"MT"},{"content":"`true` to set the initial state to signaled; `false` to set it to nonsignaled.","nodes":[{"pos":[0,78],"content":"<ph id=\"ph1\">`true`</ph> to set the initial state to signaled; <ph id=\"ph2\">`false`</ph> to set it to nonsignaled.","source":"`true` to set the initial state to signaled; `false` to set it to nonsignaled."}],"pos":[12256,12337],"yaml":true},{"content":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.","nodes":[{"pos":[0,138],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventResetMode\"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.","source":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually."}],"pos":[12415,12554],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.","nodes":[{"pos":[0,281],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.","source":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event."}],"pos":[14376,14658],"yaml":true},{"content":"If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.  \n  \n If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.  \n  \n> [!IMPORTANT]\n>  When using this constructor for named system events, specify `false` for `initialState`. This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event. To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.  \n  \n If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"pos":[0,99],"content":"If <ph id=\"ph1\">`name`</ph> is <ph id=\"ph2\">`null`</ph> or an empty string, a local <ph id=\"ph3\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is created.","source":"If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created."},{"pos":[106,229],"content":"If a system event with the name specified for the <ph id=\"ph1\">`name`</ph> parameter already exists, the <ph id=\"ph2\">`initialState`</ph> parameter is ignored.","source":"If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored."},{"pos":[237,920],"content":"[!IMPORTANT]\n When using this constructor for named system events, specify `false` for `initialState`. This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event. To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.","leadings":["","> "],"nodes":[{"content":" When using this constructor for named system events, specify `false` for `initialState`. This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event. To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.","pos":[13,681],"nodes":[{"content":"When using this constructor for named system events, specify <ph id=\"ph1\">`false`</ph> for <ph id=\"ph2\">`initialState`</ph>.","pos":[1,89],"source":" When using this constructor for named system events, specify `false` for `initialState`."},{"content":"This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.","pos":[90,248]},{"content":"To determine whether a named event was created, use the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor or the <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> constructor.","pos":[249,668],"source":" To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor."}]}]},{"pos":[927,1427],"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block.","pos":[0,92]},{"content":"If the initial state is signaled, and the <ph id=\"ph1\">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id=\"ph2\">`mode`</ph>, threads that wait on the event will not block.","pos":[93,262],"source":" If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block."},{"content":"If the initial state is signaled, and <ph id=\"ph1\">`mode`</ph> is <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","pos":[263,500],"source":" If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block."}]}],"pos":[14669,16106],"yaml":true,"extradata":"MT"},{"content":"`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled.","nodes":[{"pos":[0,133],"content":"<ph id=\"ph1\">`true`</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id=\"ph2\">`false`</ph> to set it to nonsignaled.","source":"`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled."}],"pos":[16360,16496],"yaml":true},{"content":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.","nodes":[{"pos":[0,138],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventResetMode\"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.","source":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually."}],"pos":[16574,16713],"yaml":true},{"content":"The name of a system-wide synchronization event.","nodes":[{"pos":[0,48],"content":"The name of a system-wide synchronization event.","nodes":[{"content":"The name of a system-wide synchronization event.","pos":[0,48]}]}],"pos":[16773,16822],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[16976,17000],"yaml":true},{"content":"The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>.","nodes":[{"pos":[0,168],"content":"The named event exists and has access control security, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>."}],"pos":[17114,17283],"yaml":true},{"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,103],"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,103]}]}],"pos":[17429,17533],"yaml":true},{"content":"<code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[17627,17676],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.","nodes":[{"pos":[0,381],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.","source":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created."}],"pos":[19553,19935],"yaml":true},{"content":"If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored. After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.  \n  \n If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"pos":[0,343],"content":"If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored. After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.","nodes":[{"content":"If a system event with the name specified for the <ph id=\"ph1\">`name`</ph> parameter already exists, the <ph id=\"ph2\">`initialState`</ph> parameter is ignored.","pos":[0,123],"source":"If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored."},{"content":"After calling this constructor, use the value in the variable specified for the <ph id=\"ph1\">`ref`</ph> parameter (<ph id=\"ph2\">`ByRef`</ph> parameter in Visual Basic)<ph id=\"ph3\">`createdNew`</ph> to determine whether the named system event already existed or was created.","pos":[124,343],"source":" After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created."}]},{"pos":[350,850],"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block.","pos":[0,92]},{"content":"If the initial state is signaled, and the <ph id=\"ph1\">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id=\"ph2\">`mode`</ph>, threads that wait on the event will not block.","pos":[93,262],"source":" If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block."},{"content":"If the initial state is signaled, and <ph id=\"ph1\">`mode`</ph> is <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","pos":[263,500],"source":" If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block."}]}],"pos":[19946,20801],"yaml":true,"extradata":"MT"},{"content":"`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled.","nodes":[{"pos":[0,133],"content":"<ph id=\"ph1\">`true`</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id=\"ph2\">`false`</ph> to set it to nonsignaled.","source":"`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled."}],"pos":[21076,21212],"yaml":true},{"content":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.","nodes":[{"pos":[0,138],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventResetMode\"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.","source":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually."}],"pos":[21290,21429],"yaml":true},{"content":"The name of a system-wide synchronization event.","nodes":[{"pos":[0,48],"content":"The name of a system-wide synchronization event.","nodes":[{"content":"The name of a system-wide synchronization event.","pos":[0,48]}]}],"pos":[21489,21538],"yaml":true},{"content":"When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed. This parameter is passed uninitialized.","nodes":[{"pos":[0,284],"content":"When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed. This parameter is passed uninitialized.","nodes":[{"content":"When this method returns, contains <ph id=\"ph1\">`true`</ph> if a local event was created (that is, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph> or an empty string) or if the specified named system event was created; <ph id=\"ph4\">`false`</ph> if the specified named system event already existed.","pos":[0,244],"source":"When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed."},{"content":"This parameter is passed uninitialized.","pos":[245,284]}]}],"pos":[21605,21890],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[22044,22068],"yaml":true},{"content":"The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>.","nodes":[{"pos":[0,168],"content":"The named event exists and has access control security, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>."}],"pos":[22182,22351],"yaml":true},{"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,103],"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,103]}]}],"pos":[22497,22601],"yaml":true},{"content":"<code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[22695,22744],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.","nodes":[{"pos":[0,460],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.","source":"Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created."}],"pos":[24821,25282],"yaml":true},{"content":"Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.  \n  \n This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event. You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.  \n  \n If the system event does not exist, it is created with the specified access control security. If the event exists, the specified access control security is ignored.  \n  \n> [!NOTE]\n>  The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.  \n  \n If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored. After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.  \n  \n If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"pos":[0,153],"content":"Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.","nodes":[{"content":"Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.","pos":[0,153]}]},{"pos":[160,380],"content":"This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event. You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.","nodes":[{"content":"This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event. You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.","pos":[0,220],"nodes":[{"content":"This constructor initializes an <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object that represents a system event.","pos":[0,110],"source":"This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects that represent the same system event.","pos":[111,220],"source":" You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event."}]}]},{"pos":[387,551],"content":"If the system event does not exist, it is created with the specified access control security. If the event exists, the specified access control security is ignored.","nodes":[{"content":"If the system event does not exist, it is created with the specified access control security. If the event exists, the specified access control security is ignored.","pos":[0,164],"nodes":[{"content":"If the system event does not exist, it is created with the specified access control security.","pos":[0,93]},{"content":"If the event exists, the specified access control security is ignored.","pos":[94,164]}]}]},{"pos":[559,1033],"content":"[!NOTE]\n The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.","leadings":["","> "],"nodes":[{"content":" The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.","pos":[8,472],"nodes":[{"content":"The caller has full control over the newly created <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object even if <ph id=\"ph2\">`eventSecurity`</ph> denies or fails to grant some access rights to the current user.","pos":[1,187],"source":" The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user."},{"content":"However, if the current user attempts to get another <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object to represent the same named event, using either a constructor or the <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.","pos":[188,464],"source":" However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied."}]}]},{"pos":[1040,1384],"content":"If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored. After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.","nodes":[{"content":"If a system event with the name specified for the <ph id=\"ph1\">`name`</ph> parameter already exists, the <ph id=\"ph2\">`initialState`</ph> parameter is ignored.","pos":[0,123],"source":"If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored."},{"content":"After calling this constructor, use the value in the variable specified for the <ph id=\"ph1\">`ref`</ph> parameter (<ph id=\"ph2\">`ByRef`</ph> parameter in Visual Basic) <ph id=\"ph3\">`createdNew`</ph> to determine whether the named system event already existed or was created.","pos":[124,344],"source":" After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created."}]},{"pos":[1391,1891],"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","nodes":[{"content":"If the initial state of the event is nonsignaled, threads that wait on the event will block.","pos":[0,92]},{"content":"If the initial state is signaled, and the <ph id=\"ph1\">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id=\"ph2\">`mode`</ph>, threads that wait on the event will not block.","pos":[93,262],"source":" If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block."},{"content":"If the initial state is signaled, and <ph id=\"ph1\">`mode`</ph> is <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.","pos":[263,500],"source":" If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block."}]}],"pos":[25293,27198],"yaml":true,"extradata":"MT"},{"content":"`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled.","nodes":[{"pos":[0,133],"content":"<ph id=\"ph1\">`true`</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id=\"ph2\">`false`</ph> to set it to nonsignaled.","source":"`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled."}],"pos":[29297,29433],"yaml":true},{"content":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.","nodes":[{"pos":[0,138],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventResetMode\"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.","source":"One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually."}],"pos":[29511,29650],"yaml":true},{"content":"The name of a system-wide synchronization event.","nodes":[{"pos":[0,48],"content":"The name of a system-wide synchronization event.","nodes":[{"content":"The name of a system-wide synchronization event.","pos":[0,48]}]}],"pos":[29710,29759],"yaml":true},{"content":"When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed. This parameter is passed uninitialized.","nodes":[{"pos":[0,284],"content":"When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed. This parameter is passed uninitialized.","nodes":[{"content":"When this method returns, contains <ph id=\"ph1\">`true`</ph> if a local event was created (that is, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph> or an empty string) or if the specified named system event was created; <ph id=\"ph4\">`false`</ph> if the specified named system event already existed.","pos":[0,244],"source":"When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed."},{"content":"This parameter is passed uninitialized.","pos":[245,284]}]}],"pos":[29826,30111],"yaml":true},{"content":"An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security to be applied to the named system event.","nodes":[{"pos":[0,169],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system event.","source":"An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security to be applied to the named system event."}],"pos":[30220,30390],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[30544,30568],"yaml":true},{"content":"The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>.","nodes":[{"pos":[0,168],"content":"The named event exists and has access control security, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>."}],"pos":[30682,30851],"yaml":true},{"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,103],"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named event cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,103]}]}],"pos":[30997,31101],"yaml":true},{"content":"<code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[31195,31244],"yaml":true},{"content":"Gets an <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security for the named system event represented by the current <xref href=\"System.Threading.EventWaitHandle\"></xref> object.","nodes":[{"pos":[0,249],"content":"Gets an <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named system event represented by the current <ph id=\"ph2\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> object.","source":"Gets an <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security for the named system event represented by the current <xref href=\"System.Threading.EventWaitHandle\"></xref> object."}],"pos":[32383,32633],"yaml":true},{"content":"The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.  \n  \n The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag.","nodes":[{"pos":[0,438],"content":"The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>.","pos":[0,438],"source":"The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>."}]},{"pos":[445,710],"content":"The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag.","nodes":[{"content":"The user must have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights to call this method, and the event must have been opened with the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag.","pos":[0,265],"source":"The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag."}]}],"pos":[32644,33359],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security for the named system event.","nodes":[{"pos":[0,156],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named system event.","source":"An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security for the named system event."}],"pos":[35429,35586],"yaml":true},{"content":"The current <xref href=\"System.Threading.EventWaitHandle\"></xref> object represents a named system event, and the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\"></xref>.  \n  \n -or-  \n  \n The current <xref href=\"System.Threading.EventWaitHandle\"></xref> object represents a named system event, and was not opened with <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\"></xref>.","nodes":[{"pos":[0,222],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> object represents a named system event, and the user does not have <ph id=\"ph2\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The current <xref href=\"System.Threading.EventWaitHandle\"></xref> object represents a named system event, and the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\"></xref>."},{"pos":[229,233],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[240,459],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> object represents a named system event, and was not opened with <ph id=\"ph2\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The current <xref href=\"System.Threading.EventWaitHandle\"></xref> object represents a named system event, and was not opened with <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\"></xref>."}],"pos":[35777,36251],"yaml":true},{"content":"Not supported for Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,59],"content":"Not supported for Windows 98 or Windows Millennium Edition.","nodes":[{"content":"Not supported for Windows 98 or Windows Millennium Edition.","pos":[0,59]}]}],"pos":[36353,36413],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.","nodes":[{"pos":[0,150],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.Close\"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id=\"ph2\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph>.","source":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>."}],"pos":[36519,36670],"yaml":true},{"content":"Opens the specified named synchronization event, if it already exists.","nodes":[{"pos":[0,70],"content":"Opens the specified named synchronization event, if it already exists.","nodes":[{"content":"Opens the specified named synchronization event, if it already exists.","pos":[0,70]}]}],"pos":[37836,37907],"yaml":true},{"content":"The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.  \n  \n This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.  \n  \n Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.","nodes":[{"pos":[0,387],"content":"The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open the specified named system event.","pos":[0,114],"source":"The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event."},{"content":"If the system event does not exist, this method throws an exception instead of creating the system event.","pos":[115,220]},{"content":"To create the system event when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[221,387],"source":" To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[394,622],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event."},{"pos":[629,1059],"content":"This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.","nodes":[{"content":"This method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload and specifying <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.","pos":[0,430],"source":"This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation."}]},{"pos":[1066,1465],"content":"Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.","nodes":[{"content":"Specifying the <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id=\"ph3\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.","pos":[0,399],"source":"Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods."}]}],"pos":[37918,39392],"yaml":true,"extradata":"MT"},{"content":"The name of the system synchronization event to open.","nodes":[{"pos":[0,53],"content":"The name of the system synchronization event to open.","nodes":[{"content":"The name of the system synchronization event to open.","pos":[0,53]}]}],"pos":[41372,41426],"yaml":true},{"content":"An  object that represents the named system event.","nodes":[{"pos":[0,50],"content":"An  object that represents the named system event.","nodes":[{"content":"An  object that represents the named system event.","pos":[0,50]}]}],"pos":[41502,41553],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[41720,41830],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[41932,41961],"yaml":true},{"content":"The named system event does not exist.","nodes":[{"pos":[0,38],"content":"The named system event does not exist.","nodes":[{"content":"The named system event does not exist.","pos":[0,38]}]}],"pos":[42107,42146],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[42234,42258],"yaml":true},{"content":"The named event exists, but the user does not have the security access required to use it.","nodes":[{"pos":[0,90],"content":"The named event exists, but the user does not have the security access required to use it.","nodes":[{"content":"The named event exists, but the user does not have the security access required to use it.","pos":[0,90]}]}],"pos":[42372,42463],"yaml":true},{"content":"Opens the specified named synchronization event, if it already exists, with the desired security access.","nodes":[{"pos":[0,104],"content":"Opens the specified named synchronization event, if it already exists, with the desired security access.","nodes":[{"content":"Opens the specified named synchronization event, if it already exists, with the desired security access.","pos":[0,104]}]}],"pos":[44242,44347],"yaml":true},{"content":"The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  \n  \n The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.","nodes":[{"pos":[0,402],"content":"The <ph id=\"ph1\">`rights`</ph> parameter must include the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the event, and the <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id=\"ph4\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.","source":"The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods."},{"pos":[409,794],"content":"The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open an existing named system event.","pos":[0,112],"source":"The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event."},{"content":"If the system event does not exist, this method throws an exception instead of creating the system event.","pos":[113,218]},{"content":"To create the system event when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[219,385],"source":" To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[801,1029],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event."}],"pos":[44358,45394],"yaml":true,"extradata":"MT"},{"content":"The name of the system synchronization event to open.","nodes":[{"pos":[0,53],"content":"The name of the system synchronization event to open.","nodes":[{"content":"The name of the system synchronization event to open.","pos":[0,53]}]}],"pos":[47434,47488],"yaml":true},{"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"pos":[0,91],"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"content":"A bitwise combination of the enumeration values that represent the desired security access.","pos":[0,91]}]}],"pos":[47588,47680],"yaml":true},{"content":"An object that represents the named system event.","nodes":[{"pos":[0,49],"content":"An object that represents the named system event.","nodes":[{"content":"An object that represents the named system event.","pos":[0,49]}]}],"pos":[47756,47806],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[47973,48083],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[48185,48214],"yaml":true},{"content":"The named system event does not exist.","nodes":[{"pos":[0,38],"content":"The named system event does not exist.","nodes":[{"content":"The named system event does not exist.","pos":[0,38]}]}],"pos":[48360,48399],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[48487,48511],"yaml":true},{"content":"The named event exists, but the user does not have the desired security access.","nodes":[{"pos":[0,79],"content":"The named event exists, but the user does not have the desired security access.","nodes":[{"content":"The named event exists, but the user does not have the desired security access.","pos":[0,79]}]}],"pos":[48625,48705],"yaml":true},{"content":"Sets the state of the event to nonsignaled, causing threads to block.","nodes":[{"pos":[0,69],"content":"Sets the state of the event to nonsignaled, causing threads to block.","nodes":[{"content":"Sets the state of the event to nonsignaled, causing threads to block.","pos":[0,69]}]}],"pos":[49815,49885],"yaml":true},{"content":"`true` if the operation succeeds; otherwise, `false`.","nodes":[{"pos":[0,53],"content":"<ph id=\"ph1\">`true`</ph> if the operation succeeds; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the operation succeeds; otherwise, `false`."}],"pos":[50007,50063],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.","nodes":[{"pos":[0,150],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.Close\"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id=\"ph2\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph>.","source":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>."}],"pos":[50235,50386],"yaml":true},{"content":"Sets the state of the event to signaled, allowing one or more waiting threads to proceed.","nodes":[{"pos":[0,89],"content":"Sets the state of the event to signaled, allowing one or more waiting threads to proceed.","nodes":[{"content":"Sets the state of the event to signaled, allowing one or more waiting threads to proceed.","pos":[0,89]}]}],"pos":[51811,51901],"yaml":true},{"content":"For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread. If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.  \n  \n> [!IMPORTANT]\n>  There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName>. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.  \n  \n For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.","nodes":[{"pos":[0,446],"content":"For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread. If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.","nodes":[{"content":"For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread. If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.","pos":[0,446],"nodes":[{"content":"For an <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName&gt;</ph> (including <ph id=\"ph3\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), the <ph id=\"ph4\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method releases a single thread.","pos":[0,261],"source":"For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread."},{"content":"If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.","pos":[262,446],"source":" If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called."}]}]},{"pos":[454,1102],"content":"[!IMPORTANT]\n There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName>. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.","leadings":["","> "],"nodes":[{"content":" There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName>. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.","pos":[13,646],"nodes":[{"content":"There is no guarantee that every call to the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method will release a thread from an <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> whose reset mode is <ph id=\"ph3\">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName&gt;</ph>.","pos":[1,264],"source":" There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName>."},{"content":"If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.","pos":[265,396]},{"content":"It is as if the second call did not happen.","pos":[397,440]},{"content":"Also, if <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> is called when there are no threads waiting and the <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is already signaled, the call has no effect.","pos":[441,633],"source":" Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect."}]}]},{"pos":[1109,1476],"content":"For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.","nodes":[{"content":"For an <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName&gt;</ph> (including <ph id=\"ph3\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), calling the <ph id=\"ph4\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method leaves the wait handle in a signaled state until its <ph id=\"ph5\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.","pos":[0,367],"source":"For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called."}]}],"pos":[51912,53396],"yaml":true,"extradata":"MT"},{"content":"`true` if the operation succeeds; otherwise, `false`.","nodes":[{"pos":[0,53],"content":"<ph id=\"ph1\">`true`</ph> if the operation succeeds; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the operation succeeds; otherwise, `false`."}],"pos":[54797,54853],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.","nodes":[{"pos":[0,150],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.Close\"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id=\"ph2\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph>.","source":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>."}],"pos":[55023,55174],"yaml":true},{"content":"Sets the access control security for a named system event.","nodes":[{"pos":[0,58],"content":"Sets the access control security for a named system event.","nodes":[{"content":"Sets the access control security for a named system event.","pos":[0,58]}]}],"pos":[56874,56933],"yaml":true},{"content":"The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag.","nodes":[{"pos":[0,265],"content":"The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag.","nodes":[{"content":"The user must have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights to call this method, and the event must have been opened with the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag.","pos":[0,265],"source":"The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag."}]}],"pos":[56944,57210],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security to be applied to the named system event.","nodes":[{"pos":[0,169],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system event.","source":"An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security to be applied to the named system event."}],"pos":[59291,59461],"yaml":true},{"content":"<code>eventSecurity</code> is `null`.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;eventSecurity&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>eventSecurity</code> is `null`."}],"pos":[59640,59678],"yaml":true},{"content":"The user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\"></xref>.  \n  \n -or-  \n  \n The event was not opened with <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\"></xref>.","nodes":[{"pos":[0,114],"content":"The user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\"></xref>."},{"pos":[121,125],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[132,253],"content":"The event was not opened with <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The event was not opened with <xref href=\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\"></xref>."}],"pos":[59792,60056],"yaml":true},{"content":"The current <xref href=\"System.Threading.EventWaitHandle\"></xref> object does not represent a named system event.","nodes":[{"pos":[0,113],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> object does not represent a named system event.","source":"The current <xref href=\"System.Threading.EventWaitHandle\"></xref> object does not represent a named system event."}],"pos":[60146,60260],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.","nodes":[{"pos":[0,150],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.Close\"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id=\"ph2\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph>.","source":"The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>."}],"pos":[60366,60517],"yaml":true},{"content":"Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.","nodes":[{"pos":[0,138],"content":"Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.","nodes":[{"content":"Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.","pos":[0,138]}]}],"pos":[61768,61907],"yaml":true},{"content":"If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \n  \n If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.  \n  \n This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.","nodes":[{"pos":[0,249],"content":"If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"If the named synchronization event does not exist, this method does not create it.","pos":[0,82]},{"content":"To create the system event when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[83,249],"source":" To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[256,522],"content":"If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.","nodes":[{"content":"If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.","pos":[0,266],"source":"If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist."}]},{"pos":[529,1400],"content":"This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.","nodes":[{"content":"This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.","pos":[0,871],"nodes":[{"content":"This method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> method overload and specifying <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.","pos":[0,471],"source":"This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation."},{"content":"Specifying the <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id=\"ph3\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.","pos":[472,871],"source":" Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods."}]}]},{"pos":[1407,1635],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event."}],"pos":[61918,63562],"yaml":true,"extradata":"MT"},{"content":"The name of the system synchronization event to open.","nodes":[{"pos":[0,53],"content":"The name of the system synchronization event to open.","nodes":[{"content":"The name of the system synchronization event to open.","pos":[0,53]}]}],"pos":[63807,63861],"yaml":true},{"content":"When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"pos":[0,242],"content":"When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"content":"When this method returns, contains a <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id=\"ph2\">`null`</ph> if the call failed.","pos":[0,198],"source":"When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed."},{"content":"This parameter is treated as uninitialized.","pos":[199,242]}]}],"pos":[63942,64185],"yaml":true},{"content":"`true` if the named synchronization event was opened successfully; otherwise, `false`.","nodes":[{"pos":[0,86],"content":"<ph id=\"ph1\">`true`</ph> if the named synchronization event was opened successfully; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the named synchronization event was opened successfully; otherwise, `false`."}],"pos":[64243,64332],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[64502,64612],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[64714,64743],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[64831,64855],"yaml":true},{"content":"The named event exists, but the user does not have the desired security access.","nodes":[{"pos":[0,79],"content":"The named event exists, but the user does not have the desired security access.","nodes":[{"content":"The named event exists, but the user does not have the desired security access.","pos":[0,79]}]}],"pos":[64969,65049],"yaml":true},{"content":"Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","nodes":[{"pos":[0,172],"content":"Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","nodes":[{"content":"Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","pos":[0,172]}]}],"pos":[66999,67172],"yaml":true},{"content":"If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \n  \n If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.  \n  \n The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.","nodes":[{"pos":[0,249],"content":"If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"If the named synchronization event does not exist, this method does not create it.","pos":[0,82]},{"content":"To create the system event when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[83,249],"source":" To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[256,576],"content":"If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.","nodes":[{"content":"If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.","pos":[0,320],"source":"If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist."}]},{"pos":[583,985],"content":"The <ph id=\"ph1\">`rights`</ph> parameter must include the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the event, and the <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id=\"ph4\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.","source":"The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods."},{"pos":[992,1220],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event."}],"pos":[67183,68412],"yaml":true,"extradata":"MT"},{"content":"The name of the system synchronization event to open.","nodes":[{"pos":[0,53],"content":"The name of the system synchronization event to open.","nodes":[{"content":"The name of the system synchronization event to open.","pos":[0,53]}]}],"pos":[68717,68771],"yaml":true},{"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"pos":[0,91],"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"content":"A bitwise combination of the enumeration values that represent the desired security access.","pos":[0,91]}]}],"pos":[68871,68963],"yaml":true},{"content":"When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"pos":[0,242],"content":"When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"content":"When this method returns, contains a <ph id=\"ph1\">&lt;xref href=\"System.Threading.EventWaitHandle\"&gt;&lt;/xref&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id=\"ph2\">`null`</ph> if the call failed.","pos":[0,198],"source":"When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed."},{"content":"This parameter is treated as uninitialized.","pos":[199,242]}]}],"pos":[69044,69287],"yaml":true},{"content":"`true` if the named synchronization event was opened successfully; otherwise, `false`.","nodes":[{"pos":[0,86],"content":"<ph id=\"ph1\">`true`</ph> if the named synchronization event was opened successfully; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the named synchronization event was opened successfully; otherwise, `false`."}],"pos":[69345,69434],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[69604,69714],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[69816,69845],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[69933,69957],"yaml":true},{"content":"The named event exists, but the user does not have the desired security access.","nodes":[{"pos":[0,79],"content":"The named event exists, but the user does not have the desired security access.","nodes":[{"content":"The named event exists, but the user does not have the desired security access.","pos":[0,79]}]}],"pos":[70071,70151],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.EventWaitHandle\n  commentId: T:System.Threading.EventWaitHandle\n  id: EventWaitHandle\n  children:\n  - System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)\n  - System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)\n  - System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)\n  - System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)\n  - System.Threading.EventWaitHandle.GetAccessControl\n  - System.Threading.EventWaitHandle.OpenExisting(System.String)\n  - System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\n  - System.Threading.EventWaitHandle.Reset\n  - System.Threading.EventWaitHandle.Set\n  - System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)\n  - System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)\n  - System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\n  langs:\n  - csharp\n  name: EventWaitHandle\n  nameWithType: EventWaitHandle\n  fullName: System.Threading.EventWaitHandle\n  type: Class\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Represents a thread synchronization event.\n  remarks: \"The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling. Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads. A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=fullName> method.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.  \\n  \\n The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag resets automatically when signaled, after releasing a single waiting thread. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.  \\n  \\n Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads.  \\n  \\n Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed.  \\n  \\n <xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods.  \\n  \\n For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).\"\n  example:\n  - \"The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  \\n  \\n The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag, then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class EventWaitHandle : System.Threading.WaitHandle\n  inheritance:\n  - System.Object\n  - System.Threading.WaitHandle\n  derivedClasses:\n  - System.Threading.AutoResetEvent\n  - System.Threading.ManualResetEvent\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  - System.Threading.WaitHandle.Close\n  - System.Threading.WaitHandle.Dispose\n  - System.Threading.WaitHandle.Dispose(System.Boolean)\n  - System.Threading.WaitHandle.Handle\n  - System.Threading.WaitHandle.InvalidHandle\n  - System.Threading.WaitHandle.SafeWaitHandle\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne\n  - System.Threading.WaitHandle.WaitOne(System.Int32)\n  - System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitTimeout\n  extensionMethods:\n  - System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.EventWaitHandle)\n  - System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.EventWaitHandle,System.Security.AccessControl.EventWaitHandleSecurity)\n  - System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  - System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)\n  commentId: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)\n  id: '#ctor(System.Boolean,System.Threading.EventResetMode)'\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: EventWaitHandle(Boolean, EventResetMode)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.\n  remarks: If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.\n  example:\n  - \"The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  \\n  \\n The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag, then releases one thread each time the user presses ENTER key. The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]\"\n  syntax:\n    content: public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);\n    parameters:\n    - id: initialState\n      type: System.Boolean\n      description: '`true` to set the initial state to signaled; `false` to set it to nonsignaled.'\n    - id: mode\n      type: System.Threading.EventResetMode\n      description: One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.\n  overload: System.Threading.EventWaitHandle.#ctor*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)\n  commentId: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)\n  id: '#ctor(System.Boolean,System.Threading.EventResetMode,System.String)'\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: EventWaitHandle(Boolean, EventResetMode, String)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.\n  remarks: \"If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.  \\n  \\n If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.  \\n  \\n> [!IMPORTANT]\\n>  When using this constructor for named system events, specify `false` for `initialState`. This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event. To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.  \\n  \\n If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);\n    parameters:\n    - id: initialState\n      type: System.Boolean\n      description: '`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled.'\n    - id: mode\n      type: System.Threading.EventResetMode\n      description: One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.\n    - id: name\n      type: System.String\n      description: The name of a system-wide synchronization event.\n  overload: System.Threading.EventWaitHandle.#ctor*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named event cannot be created, perhaps because a wait handle of a different type has the same name.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>name</code> is longer than 260 characters.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)\n  commentId: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)\n  id: '#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)'\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: EventWaitHandle(Boolean, EventResetMode, String, Boolean)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.\n  remarks: \"If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored. After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.  \\n  \\n If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);\n    parameters:\n    - id: initialState\n      type: System.Boolean\n      description: '`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled.'\n    - id: mode\n      type: System.Threading.EventResetMode\n      description: One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.\n    - id: name\n      type: System.String\n      description: The name of a system-wide synchronization event.\n    - id: createdNew\n      type: System.Boolean\n      description: When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed. This parameter is passed uninitialized.\n  overload: System.Threading.EventWaitHandle.#ctor*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named event cannot be created, perhaps because a wait handle of a different type has the same name.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>name</code> is longer than 260 characters.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)\n  commentId: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)\n  id: '#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)'\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: EventWaitHandle(Boolean, EventResetMode, String, Boolean, EventWaitHandleSecurity)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean, EventWaitHandleSecurity)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean, EventWaitHandleSecurity)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.\n  remarks: \"Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.  \\n  \\n This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event. You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.  \\n  \\n If the system event does not exist, it is created with the specified access control security. If the event exists, the specified access control security is ignored.  \\n  \\n> [!NOTE]\\n>  The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.  \\n  \\n If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored. After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.  \\n  \\n If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block. If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.  \\n  \\n If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]\\n [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);\n    parameters:\n    - id: initialState\n      type: System.Boolean\n      description: '`true` to set the initial state to signaled if the named event is created as a result of this call; `false` to set it to nonsignaled.'\n    - id: mode\n      type: System.Threading.EventResetMode\n      description: One of the <xref href=\"System.Threading.EventResetMode\"></xref> values that determines whether the event resets automatically or manually.\n    - id: name\n      type: System.String\n      description: The name of a system-wide synchronization event.\n    - id: createdNew\n      type: System.Boolean\n      description: When this method returns, contains `true` if a local event was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system event was created; `false` if the specified named system event already existed. This parameter is passed uninitialized.\n    - id: eventSecurity\n      type: System.Security.AccessControl.EventWaitHandleSecurity\n      description: An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security to be applied to the named system event.\n  overload: System.Threading.EventWaitHandle.#ctor*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\"></xref>.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named event cannot be created, perhaps because a wait handle of a different type has the same name.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>name</code> is longer than 260 characters.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.GetAccessControl\n  commentId: M:System.Threading.EventWaitHandle.GetAccessControl\n  id: GetAccessControl\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: GetAccessControl()\n  nameWithType: EventWaitHandle.GetAccessControl()\n  fullName: EventWaitHandle.GetAccessControl()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets an <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security for the named system event represented by the current <xref href=\"System.Threading.EventWaitHandle\"></xref> object.\n  remarks: \"The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.  \\n  \\n The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.  \\n  \\n If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.  \\n  \\n After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]\\n [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]\"\n  syntax:\n    content: public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();\n    parameters: []\n    return:\n      type: System.Security.AccessControl.EventWaitHandleSecurity\n      description: An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security for the named system event.\n  overload: System.Threading.EventWaitHandle.GetAccessControl*\n  exceptions:\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The current <xref href=\\\"System.Threading.EventWaitHandle\\\"></xref> object represents a named system event, and the user does not have <xref href=\\\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\\\"></xref>.  \\n  \\n -or-  \\n  \\n The current <xref href=\\\"System.Threading.EventWaitHandle\\\"></xref> object represents a named system event, and was not opened with <xref href=\\\"System.Security.AccessControl.EventWaitHandleRights.ReadPermissions\\\"></xref>.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Not supported for Windows 98 or Windows Millennium Edition.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.\n  attributes: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.OpenExisting(System.String)\n  commentId: M:System.Threading.EventWaitHandle.OpenExisting(System.String)\n  id: OpenExisting(System.String)\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: OpenExisting(String)\n  nameWithType: EventWaitHandle.OpenExisting(String)\n  fullName: EventWaitHandle.OpenExisting(String)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Opens the specified named synchronization event, if it already exists.\n  remarks: \"The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.  \\n  \\n This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.  \\n  \\n Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.  \\n  \\n If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]\\n [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static System.Threading.EventWaitHandle OpenExisting (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system synchronization event to open.\n    return:\n      type: System.Threading.EventWaitHandle\n      description: An  object that represents the named system event.\n  overload: System.Threading.EventWaitHandle.OpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named system event does not exist.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named event exists, but the user does not have the security access required to use it.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\n  commentId: M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\n  id: OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: OpenExisting(String, EventWaitHandleRights)\n  nameWithType: EventWaitHandle.OpenExisting(String, EventWaitHandleRights)\n  fullName: EventWaitHandle.OpenExisting(String, EventWaitHandleRights)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Opens the specified named synchronization event, if it already exists, with the desired security access.\n  remarks: \"The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  \\n  \\n The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.  \\n  \\n If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]\\n [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system synchronization event to open.\n    - id: rights\n      type: System.Security.AccessControl.EventWaitHandleRights\n      description: A bitwise combination of the enumeration values that represent the desired security access.\n    return:\n      type: System.Threading.EventWaitHandle\n      description: An object that represents the named system event.\n  overload: System.Threading.EventWaitHandle.OpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named system event does not exist.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named event exists, but the user does not have the desired security access.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.Reset\n  commentId: M:System.Threading.EventWaitHandle.Reset\n  id: Reset\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: Reset()\n  nameWithType: EventWaitHandle.Reset()\n  fullName: EventWaitHandle.Reset()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets the state of the event to nonsignaled, causing threads to block.\n  syntax:\n    content: public bool Reset ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the operation succeeds; otherwise, `false`.'\n  overload: System.Threading.EventWaitHandle.Reset*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.Set\n  commentId: M:System.Threading.EventWaitHandle.Set\n  id: Set\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: Set()\n  nameWithType: EventWaitHandle.Set()\n  fullName: EventWaitHandle.Set()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets the state of the event to signaled, allowing one or more waiting threads to proceed.\n  remarks: \"For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread. If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.  \\n  \\n> [!IMPORTANT]\\n>  There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName>. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.  \\n  \\n For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.\"\n  example:\n  - \"The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  \\n  \\n The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag, then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]\"\n  syntax:\n    content: public bool Set ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the operation succeeds; otherwise, `false`.'\n  overload: System.Threading.EventWaitHandle.Set*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)\n  commentId: M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)\n  id: SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: SetAccessControl(EventWaitHandleSecurity)\n  nameWithType: EventWaitHandle.SetAccessControl(EventWaitHandleSecurity)\n  fullName: EventWaitHandle.SetAccessControl(EventWaitHandleSecurity)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Sets the access control security for a named system event.\n  remarks: The user must have <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag.\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.  \\n  \\n If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]\\n [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]\"\n  syntax:\n    content: public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);\n    parameters:\n    - id: eventSecurity\n      type: System.Security.AccessControl.EventWaitHandleSecurity\n      description: An <xref href=\"System.Security.AccessControl.EventWaitHandleSecurity\"></xref> object that represents the access control security to be applied to the named system event.\n  overload: System.Threading.EventWaitHandle.SetAccessControl*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>eventSecurity</code> is `null`.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The user does not have <xref href=\\\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\\\"></xref>.  \\n  \\n -or-  \\n  \\n The event was not opened with <xref href=\\\"System.Security.AccessControl.EventWaitHandleRights.ChangePermissions\\\"></xref>.\"\n  - type: System.SystemException\n    commentId: T:System.SystemException\n    description: The current <xref href=\"System.Threading.EventWaitHandle\"></xref> object does not represent a named system event.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.WaitHandle.Close\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\"></xref>.\n  attributes: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)\n  commentId: M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)\n  id: TryOpenExisting(System.String,System.Threading.EventWaitHandle@)\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: TryOpenExisting(String, EventWaitHandle)\n  nameWithType: EventWaitHandle.TryOpenExisting(String, EventWaitHandle)\n  fullName: EventWaitHandle.TryOpenExisting(String, EventWaitHandle)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.\n  remarks: \"If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.  \\n  \\n This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system synchronization event to open.\n    - id: result\n      type: System.Threading.EventWaitHandle\n      description: When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.\n    return:\n      type: System.Boolean\n      description: '`true` if the named synchronization event was opened successfully; otherwise, `false`.'\n  overload: System.Threading.EventWaitHandle.TryOpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named event exists, but the user does not have the desired security access.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\n  commentId: M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\n  id: TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\n  parent: System.Threading.EventWaitHandle\n  langs:\n  - csharp\n  name: TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n  nameWithType: EventWaitHandle.TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n  fullName: EventWaitHandle.TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.\n  remarks: \"If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.  \\n  \\n The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system synchronization event to open.\n    - id: rights\n      type: System.Security.AccessControl.EventWaitHandleRights\n      description: A bitwise combination of the enumeration values that represent the desired security access.\n    - id: result\n      type: System.Threading.EventWaitHandle\n      description: When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\"></xref> object that represents the named synchronization event if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.\n    return:\n      type: System.Boolean\n      description: '`true` if the named synchronization event was opened successfully; otherwise, `false`.'\n  overload: System.Threading.EventWaitHandle.TryOpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named event exists, but the user does not have the desired security access.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Threading.WaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandle\n  nameWithType: WaitHandle\n  fullName: System.Threading.WaitHandle\n- uid: System.IO.IOException\n  parent: System.IO\n  isExternal: false\n  name: IOException\n  nameWithType: IOException\n  fullName: System.IO.IOException\n- uid: System.UnauthorizedAccessException\n  parent: System\n  isExternal: false\n  name: UnauthorizedAccessException\n  nameWithType: UnauthorizedAccessException\n  fullName: System.UnauthorizedAccessException\n- uid: System.Threading.WaitHandleCannotBeOpenedException\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandleCannotBeOpenedException\n  nameWithType: WaitHandleCannotBeOpenedException\n  fullName: System.Threading.WaitHandleCannotBeOpenedException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.ObjectDisposedException\n  parent: System\n  isExternal: false\n  name: ObjectDisposedException\n  nameWithType: ObjectDisposedException\n  fullName: System.ObjectDisposedException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.SystemException\n  parent: System\n  isExternal: false\n  name: SystemException\n  nameWithType: SystemException\n  fullName: System.SystemException\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: EventWaitHandle(Boolean, EventResetMode)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.EventResetMode\n  parent: System.Threading\n  isExternal: false\n  name: EventResetMode\n  nameWithType: EventResetMode\n  fullName: System.Threading.EventResetMode\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: EventWaitHandle(Boolean, EventResetMode, String)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String)\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: EventWaitHandle(Boolean, EventResetMode, String, Boolean)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean)\n- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: EventWaitHandle(Boolean, EventResetMode, String, Boolean, EventWaitHandleSecurity)\n  nameWithType: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean, EventWaitHandleSecurity)\n  fullName: EventWaitHandle.EventWaitHandle(Boolean, EventResetMode, String, Boolean, EventWaitHandleSecurity)\n- uid: System.Security.AccessControl.EventWaitHandleSecurity\n  parent: System.Security.AccessControl\n  isExternal: false\n  name: EventWaitHandleSecurity\n  nameWithType: EventWaitHandleSecurity\n  fullName: System.Security.AccessControl.EventWaitHandleSecurity\n- uid: System.Threading.EventWaitHandle.GetAccessControl\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: GetAccessControl()\n  nameWithType: EventWaitHandle.GetAccessControl()\n  fullName: EventWaitHandle.GetAccessControl()\n- uid: System.Threading.EventWaitHandle.OpenExisting(System.String)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: OpenExisting(String)\n  nameWithType: EventWaitHandle.OpenExisting(String)\n  fullName: EventWaitHandle.OpenExisting(String)\n- uid: System.Threading.EventWaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: EventWaitHandle\n  nameWithType: EventWaitHandle\n  fullName: System.Threading.EventWaitHandle\n- uid: System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: OpenExisting(String, EventWaitHandleRights)\n  nameWithType: EventWaitHandle.OpenExisting(String, EventWaitHandleRights)\n  fullName: EventWaitHandle.OpenExisting(String, EventWaitHandleRights)\n- uid: System.Security.AccessControl.EventWaitHandleRights\n  parent: System.Security.AccessControl\n  isExternal: false\n  name: EventWaitHandleRights\n  nameWithType: EventWaitHandleRights\n  fullName: System.Security.AccessControl.EventWaitHandleRights\n- uid: System.Threading.EventWaitHandle.Reset\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: Reset()\n  nameWithType: EventWaitHandle.Reset()\n  fullName: EventWaitHandle.Reset()\n- uid: System.Threading.EventWaitHandle.Set\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: Set()\n  nameWithType: EventWaitHandle.Set()\n  fullName: EventWaitHandle.Set()\n- uid: System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: SetAccessControl(EventWaitHandleSecurity)\n  nameWithType: EventWaitHandle.SetAccessControl(EventWaitHandleSecurity)\n  fullName: EventWaitHandle.SetAccessControl(EventWaitHandleSecurity)\n- uid: System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: TryOpenExisting(String, EventWaitHandle)\n  nameWithType: EventWaitHandle.TryOpenExisting(String, EventWaitHandle)\n  fullName: EventWaitHandle.TryOpenExisting(String, EventWaitHandle)\n- uid: System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n  nameWithType: EventWaitHandle.TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n  fullName: EventWaitHandle.TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n- uid: System.Threading.EventWaitHandle.#ctor*\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: EventWaitHandle\n  nameWithType: EventWaitHandle.EventWaitHandle\n  fullName: EventWaitHandle.EventWaitHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n- uid: System.Threading.EventWaitHandle.GetAccessControl*\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: GetAccessControl\n  nameWithType: EventWaitHandle.GetAccessControl\n  fullName: EventWaitHandle.GetAccessControl\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n- uid: System.Threading.EventWaitHandle.OpenExisting*\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: OpenExisting\n  nameWithType: EventWaitHandle.OpenExisting\n  fullName: EventWaitHandle.OpenExisting\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n- uid: System.Threading.EventWaitHandle.Reset*\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: Reset\n  nameWithType: EventWaitHandle.Reset\n  fullName: EventWaitHandle.Reset\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n- uid: System.Threading.EventWaitHandle.Set*\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: Set\n  nameWithType: EventWaitHandle.Set\n  fullName: EventWaitHandle.Set\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n- uid: System.Threading.EventWaitHandle.SetAccessControl*\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: SetAccessControl\n  nameWithType: EventWaitHandle.SetAccessControl\n  fullName: EventWaitHandle.SetAccessControl\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n- uid: System.Threading.EventWaitHandle.TryOpenExisting*\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: TryOpenExisting\n  nameWithType: EventWaitHandle.TryOpenExisting\n  fullName: EventWaitHandle.TryOpenExisting\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventWaitHandle.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Threading.WaitHandle.Close\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Close()\n  nameWithType: WaitHandle.Close()\n  fullName: WaitHandle.Close()\n- uid: System.Threading.WaitHandle.Dispose\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose()\n  nameWithType: WaitHandle.Dispose()\n  fullName: WaitHandle.Dispose()\n- uid: System.Threading.WaitHandle.Dispose(System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: WaitHandle.Dispose(Boolean)\n  fullName: WaitHandle.Dispose(Boolean)\n- uid: System.Threading.WaitHandle.Handle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Handle\n  nameWithType: WaitHandle.Handle\n  fullName: WaitHandle.Handle\n- uid: System.Threading.WaitHandle.InvalidHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: InvalidHandle\n  nameWithType: WaitHandle.InvalidHandle\n  fullName: WaitHandle.InvalidHandle\n- uid: System.Threading.WaitHandle.SafeWaitHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SafeWaitHandle\n  nameWithType: WaitHandle.SafeWaitHandle\n  fullName: WaitHandle.SafeWaitHandle\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[])\n  nameWithType: WaitHandle.WaitAll(WaitHandle[])\n  fullName: WaitHandle.WaitAll(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[])\n  nameWithType: WaitHandle.WaitAny(WaitHandle[])\n  fullName: WaitHandle.WaitAny(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne()\n  nameWithType: WaitHandle.WaitOne()\n  fullName: WaitHandle.WaitOne()\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32)\n  nameWithType: WaitHandle.WaitOne(Int32)\n  fullName: WaitHandle.WaitOne(Int32)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan)\n  nameWithType: WaitHandle.WaitOne(TimeSpan)\n  fullName: WaitHandle.WaitOne(TimeSpan)\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32, Boolean)\n  nameWithType: WaitHandle.WaitOne(Int32, Boolean)\n  fullName: WaitHandle.WaitOne(Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitOne(TimeSpan, Boolean)\n  fullName: WaitHandle.WaitOne(TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitTimeout\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitTimeout\n  nameWithType: WaitHandle.WaitTimeout\n  fullName: WaitHandle.WaitTimeout\n- uid: System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.EventWaitHandle)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: GetAccessControl(EventWaitHandle)\n  nameWithType: ThreadingAclExtensions.GetAccessControl(EventWaitHandle)\n  fullName: ThreadingAclExtensions.GetAccessControl(EventWaitHandle)\n- uid: System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.EventWaitHandle,System.Security.AccessControl.EventWaitHandleSecurity)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: SetAccessControl(EventWaitHandle, EventWaitHandleSecurity)\n  nameWithType: ThreadingAclExtensions.SetAccessControl(EventWaitHandle, EventWaitHandleSecurity)\n  fullName: ThreadingAclExtensions.SetAccessControl(EventWaitHandle, EventWaitHandleSecurity)\n- uid: System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: GetSafeWaitHandle(WaitHandle)\n  nameWithType: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n  fullName: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n- uid: System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  nameWithType: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  fullName: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n"}