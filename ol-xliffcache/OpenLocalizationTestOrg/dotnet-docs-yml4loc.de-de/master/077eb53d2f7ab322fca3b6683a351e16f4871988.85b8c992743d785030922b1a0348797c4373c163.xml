{"nodes":[{"content":"Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.","nodes":[{"pos":[0,218],"content":"Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.","nodes":[{"content":"Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.","pos":[0,218],"nodes":[{"content":"Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.","pos":[0,110]},{"content":"This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.","pos":[111,218]}]}]}],"pos":[627,846],"yaml":true},{"content":"> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.  \n  \n Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system. Derived classes can and do override some of these methods, including:  \n  \n-   <xref:System.Object.Equals%2A> - Supports comparisons between objects.  \n  \n-   <xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.  \n  \n-   <xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.  \n  \n-   <xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.  \n  \n## Performance Considerations  \n If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class. However, the process of boxing and unboxing a type carries a performance cost. If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.  \n  \n-   Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle. If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked. If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.  \n  \n-   Design your type and its members to use generics. The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument. The generic method is type-specific and can be invoked without boxing the calling parameter.  \n  \n Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type. For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.","nodes":[{"pos":[2,405],"content":"[!NOTE]\n To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","leadings":["","> "],"nodes":[{"content":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","pos":[8,401],"nodes":[{"content":"To view the .NET Framework source code for this type, see the <bpt id=\"p1\">[</bpt>Reference Source<ept id=\"p1\">](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab)</ept>.","pos":[1,164],"source":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab)."},{"content":"You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id=\"p1\">[</bpt>instructions<ept id=\"p1\">](http://referencesource.microsoft.com/)</ept>.","pos":[165,393],"source":" You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/)."}]}]},{"pos":[412,540],"content":"Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.","nodes":[{"content":"Languages typically do not require a class to declare inheritance from <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> because the inheritance is implicit.","pos":[0,128],"source":"Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit."}]},{"pos":[547,795],"content":"Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system. Derived classes can and do override some of these methods, including:","nodes":[{"content":"Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system. Derived classes can and do override some of these methods, including:","pos":[0,248],"nodes":[{"content":"Because all classes in the .NET Framework are derived from <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, every method defined in the <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> class is available in all objects in the system.","pos":[0,178],"source":"Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system."},{"content":"Derived classes can and do override some of these methods, including:","pos":[179,248]}]}]},{"pos":[805,875],"content":"<xref:System.Object.Equals%2A> - Supports comparisons between objects.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> - Supports comparisons between objects.","pos":[0,70],"source":"<xref:System.Object.Equals%2A> - Supports comparisons between objects."}]},{"pos":[885,992],"content":"<xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> - Performs cleanup operations before an object is automatically reclaimed.","pos":[0,107],"source":"<xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed."}]},{"pos":[1002,1135],"content":"<xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> - Generates a number corresponding to the value of the object to support the use of a hash table.","pos":[0,133],"source":"<xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table."}]},{"pos":[1145,1262],"content":"<xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph> - Manufactures a human-readable text string that describes an instance of the class.","pos":[0,117],"source":"<xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class."}]},{"pos":[1271,1297],"content":"Performance Considerations","linkify":"Performance Considerations","nodes":[{"content":"Performance Considerations","pos":[0,26]}]},{"pos":[1301,1687],"content":"If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class. However, the process of boxing and unboxing a type carries a performance cost. If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.","nodes":[{"content":"If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class. However, the process of boxing and unboxing a type carries a performance cost. If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.","pos":[0,386],"nodes":[{"content":"If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> class.","pos":[0,174],"source":"If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class."},{"content":"However, the process of boxing and unboxing a type carries a performance cost.","pos":[175,253]},{"content":"If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.","pos":[254,386]}]}]},{"pos":[1697,2141],"content":"Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle. If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked. If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.","nodes":[{"content":"Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle. If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked. If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.","pos":[0,444],"nodes":[{"content":"Create a general method that accepts an <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.","pos":[0,182],"source":"Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle."},{"content":"If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.","pos":[183,314]},{"content":"If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.","pos":[315,444]}]}]},{"pos":[2151,2430],"content":"Design your type and its members to use generics. The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument. The generic method is type-specific and can be invoked without boxing the calling parameter.","nodes":[{"content":"Design your type and its members to use generics. The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument. The generic method is type-specific and can be invoked without boxing the calling parameter.","pos":[0,279],"nodes":[{"content":"Design your type and its members to use generics.","pos":[0,49]},{"content":"The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.","pos":[50,186]},{"content":"The generic method is type-specific and can be invoked without boxing the calling parameter.","pos":[187,279]}]}]},{"pos":[2437,2804],"content":"Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type. For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.","nodes":[{"content":"Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type. For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.","pos":[0,367],"nodes":[{"content":"Although it is sometimes necessary to develop general purpose classes that accept and return <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> types, you can improve performance by also providing a type-specific class to handle a frequently used type.","pos":[0,222],"source":"Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type."},{"content":"For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.","pos":[223,367]}]}]}],"pos":[857,3686],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Object\"></xref> class.","nodes":[{"pos":[0,75],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.Object\"></xref> class."}],"pos":[6018,6094],"yaml":true},{"content":"This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.","nodes":[{"pos":[0,152],"content":"This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.","nodes":[{"content":"This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> class.","pos":[0,152],"source":"This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class."}]}],"pos":[6105,6258],"yaml":true,"extradata":"MT"},{"content":"Determines whether the specified object is equal to the current object.","nodes":[{"pos":[0,71],"content":"Determines whether the specified object is equal to the current object.","nodes":[{"content":"Determines whether the specified object is equal to the current object.","pos":[0,71]}]}],"pos":[7808,7880],"yaml":true},{"content":"The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.  \n  \n-   If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method. Reference equality means that the object variables that are compared refer to the same object. The following example illustrates the result of such a comparison. It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value. It also assigns `person1a` to another object variable, `person1b`. As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object. However, `person1a` and `person2` are not equal, although they have the same value.  \n  \n     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]\n     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  \n  \n-   If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality. Value equality means the following:  \n  \n    -   The two objects are of the same type. As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.  \n  \n         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]\n         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  \n  \n    -   The values of the public and private fields of the two objects are equal. The following example tests for value equality. It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value. As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.  \n  \n         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]\n         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  \n  \n Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method provides the default equality comparison for all other types. However, types often override the <xref:System.Object.Equals%2A> method to implement value equality. For more information, see the Notes for Callers and Notes for Inheritors sections.  \n  \n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \n When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29>method. However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.  \n  \n> [!NOTE]\n>  [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.  \n  \n## Notes for Callers  \n Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to implement value equality. In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface. When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=fullName> and understand how a particular call to an `Equals` method is resolved. Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.  \n  \n The following example provides an illustration. It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods. The first method call returns `true`, and the remaining three return `false`.  \n  \n [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]\n [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  \n  \n In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=fullName> method overload, which tests for value equality, is called. Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`. However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>. Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=fullName> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method is called. Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method. Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects. As a result, these three method calls return `false`.  \n  \n You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method. In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).  \n  \n## Notes for Inheritors  \n When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type. The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.  \n  \n|Type category|Equality defined by|Comments|  \n|-------------------|-------------------------|--------------|  \n|Class derived directly from <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>|Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>.|  \n|Structure|<xref:System.ValueType.Equals%2A?displayProperty=fullName>|Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.|  \n|Enumeration|<xref:System.Enum.Equals%2A?displayProperty=fullName>|Values must have the same enumeration type and the same underlying value.|  \n|Delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=fullName>|Delegates must have the same type with identical invocation lists.|  \n|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>|Reference equality.|  \n  \n For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance. You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality. Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance. The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object. For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=fullName> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to return `true` for any two string instances that contain the same characters in the same order.  \n  \n The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to test for value equality. It overrides the <xref:System.Object.Equals%2A> method for the `Person` class. If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object. However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.  \n  \n [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]\n [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  \n  \n In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.  \n  \n The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method. In the list, `x`, `y`, and `z` represent object references that are not **null**.  \n  \n-   `x.Equals(x)` returns `true`, except in cases that involve floating-point types. See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.  \n  \n-   `x.Equals(y)` returns the same value as `y.Equals(x)`.  \n  \n-   `x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.  \n  \n-   If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.  \n  \n-   Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.  \n  \n-   `x.Equals(null)` returns `false`.  \n  \n Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value. For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.  \n  \n Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:  \n  \n-   Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.  \n  \n-   Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.  \n  \n-   You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality. Your <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.  \n  \n-   If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator. This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.  \n  \n### Guidelines for Reference Types  \n The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:  \n  \n-   Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).  \n  \n-   Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>. However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.  \n  \n-   You should not override <xref:System.Object.Equals%2A> on a mutable reference type. This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section. This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.  \n  \n### Guidelines for Value Types  \n The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:  \n  \n-   If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>. The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.  \n  \n-   If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.  \n  \n-   You should implement the <xref:System.IEquatable%601> interface. Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> method avoids boxing the `obj` argument.","nodes":[{"pos":[0,152],"content":"The type of comparison between the current instance and the <ph id=\"ph1\">`obj`</ph> parameter depends on whether the current instance is a reference type or a value type.","source":"The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type."},{"pos":[162,1063],"content":"If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method. Reference equality means that the object variables that are compared refer to the same object. The following example illustrates the result of such a comparison. It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value. It also assigns `person1a` to another object variable, `person1b`. As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object. However, `person1a` and `person2` are not equal, although they have the same value.","nodes":[{"content":"If the current instance is a reference type, the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for reference equality, and a call to the <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method is equivalent to a call to the <ph id=\"ph3\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.","pos":[0,283],"source":"If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method."},{"content":"Reference equality means that the object variables that are compared refer to the same object.","pos":[284,378]},{"content":"The following example illustrates the result of such a comparison.","pos":[379,445]},{"content":"It defines a <ph id=\"ph1\">`Person`</ph> class, which is a reference type, and calls the <ph id=\"ph2\">`Person`</ph> class constructor to instantiate two new <ph id=\"ph3\">`Person`</ph> objects, <ph id=\"ph4\">`person1a`</ph> and <ph id=\"ph5\">`person2`</ph>, which have the same value.","pos":[446,636],"source":" It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value."},{"content":"It also assigns <ph id=\"ph1\">`person1a`</ph> to another object variable, <ph id=\"ph2\">`person1b`</ph>.","pos":[637,703],"source":" It also assigns `person1a` to another object variable, `person1b`."},{"content":"As the output from the example shows, <ph id=\"ph1\">`person1a`</ph> and <ph id=\"ph2\">`person1b`</ph> are equal because they reference the same object.","pos":[704,817],"source":" As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object."},{"content":"However, <ph id=\"ph1\">`person1a`</ph> and <ph id=\"ph2\">`person2`</ph> are not equal, although they have the same value.","pos":[818,901],"source":" However, `person1a` and `person2` are not equal, although they have the same value."}]},{"pos":[1074,1337],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.Equals#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.Equals#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]\n [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]"},{"pos":[1347,1507],"content":"If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality. Value equality means the following:","nodes":[{"content":"If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality. Value equality means the following:","pos":[0,160],"nodes":[{"content":"If the current instance is a value type, the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for value equality.","pos":[0,124],"source":"If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality."},{"content":"Value equality means the following:","pos":[125,160]}]}]},{"pos":[1521,1765],"content":"The two objects are of the same type. As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.","nodes":[{"content":"The two objects are of the same type. As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.","pos":[0,244],"nodes":[{"content":"The two objects are of the same type.","pos":[0,37]},{"content":"As the following example shows, a <ph id=\"ph1\">&lt;xref:System.Byte&gt;</ph> object that has a value of 12 does not equal an <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> object that has a value of 12, because the two objects have different run-time types.","pos":[38,244],"source":" As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types."}]}]},{"pos":[1780,2049],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.Equals#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.Equals#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)</ept><ept id=\"p3\">]</ept>","leadings":["","        "],"source":"[!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]\n [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]"},{"pos":[2063,2577],"content":"The values of the public and private fields of the two objects are equal. The following example tests for value equality. It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value. As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.","nodes":[{"content":"The values of the public and private fields of the two objects are equal.","pos":[0,73]},{"content":"The following example tests for value equality.","pos":[74,121]},{"content":"It defines a <ph id=\"ph1\">`Person`</ph> structure, which is a value type, and calls the <ph id=\"ph2\">`Person`</ph> class constructor to instantiate two new <ph id=\"ph3\">`Person`</ph> objects, <ph id=\"ph4\">`person1`</ph> and <ph id=\"ph5\">`person2`</ph>, which have the same value.","pos":[122,311],"source":" It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value."},{"content":"As the output from the example shows, although the two object variables refer to different objects, <ph id=\"ph1\">`person1`</ph> and <ph id=\"ph2\">`person2`</ph> are equal because they have the same value for the private <ph id=\"ph3\">`personName`</ph> field.","pos":[312,514],"source":" As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field."}]},{"pos":[2592,2861],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.Equals#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.Equals#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)</ept><ept id=\"p3\">]</ept>","leadings":["","        "],"source":"[!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]\n [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]"},{"pos":[2868,3290],"content":"Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method provides the default equality comparison for all other types. However, types often override the <xref:System.Object.Equals%2A> method to implement value equality. For more information, see the Notes for Callers and Notes for Inheritors sections.","nodes":[{"content":"Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method provides the default equality comparison for all other types. However, types often override the <xref:System.Object.Equals%2A> method to implement value equality. For more information, see the Notes for Callers and Notes for Inheritors sections.","pos":[0,422],"nodes":[{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> class is the base class for all types in the .NET Framework, the <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method provides the default equality comparison for all other types.","pos":[0,238],"source":"Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method provides the default equality comparison for all other types."},{"content":"However, types often override the <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> method to implement value equality.","pos":[239,339],"source":" However, types often override the <xref:System.Object.Equals%2A> method to implement value equality."},{"content":"For more information, see the Notes for Callers and Notes for Inheritors sections.","pos":[340,422]}]}]},{"pos":[3299,3350],"content":"Notes for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>","linkify":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]","source":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]"},{"pos":[3354,4330],"content":"When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29>method. However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload on a class in the <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id=\"ph3\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.","pos":[0,250],"source":"When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>."},{"content":"This is part of the support that the .NET Framework provides for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id=\"p1\">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id=\"p1\">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).","pos":[251,518],"source":" This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))."},{"content":"Classes in the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, and currently don’t implement an <ph id=\"ph3\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>method.","pos":[519,694],"source":" Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29>method."},{"content":"However, they appear to have <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","pos":[695,976],"source":" However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods."}]},{"pos":[4338,4514],"content":"[!NOTE]\n [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> [!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload.","pos":[8,174],"source":" [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload."}]},{"pos":[4523,4540],"content":"Notes for Callers","linkify":"Notes for Callers","nodes":[{"content":"Notes for Callers","pos":[0,17]}]},{"pos":[4544,5247],"content":"Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to implement value equality. In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface. When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=fullName> and understand how a particular call to an `Equals` method is resolved. Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.","nodes":[{"content":"Derived classes frequently override the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method to implement value equality.","pos":[0,147],"source":"Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to implement value equality."},{"content":"In addition, types also frequently provide an additional strongly typed overload to the <ph id=\"ph1\">`Equals`</ph> method, typically by implementing the <ph id=\"ph2\">&lt;xref:System.IEquatable%601&gt;</ph> interface.","pos":[148,322],"source":" In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface."},{"content":"When you call the <ph id=\"ph1\">`Equals`</ph> method to test for equality, you should know whether the current instance overrides <ph id=\"ph2\">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> and understand how a particular call to an <ph id=\"ph3\">`Equals`</ph> method is resolved.","pos":[323,561],"source":" When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=fullName> and understand how a particular call to an `Equals` method is resolved."},{"content":"Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.","pos":[562,703]}]},{"pos":[5254,5513],"content":"The following example provides an illustration. It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods. The first method call returns `true`, and the remaining three return `false`.","nodes":[{"content":"The following example provides an illustration.","pos":[0,47]},{"content":"It instantiates three <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> objects with identical strings, and then makes four calls to <ph id=\"ph2\">`Equals`</ph> methods.","pos":[48,181],"source":" It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods."},{"content":"The first method call returns <ph id=\"ph1\">`true`</ph>, and the remaining three return <ph id=\"ph2\">`false`</ph>.","pos":[182,259],"source":" The first method call returns `true`, and the remaining three return `false`."}]},{"pos":[5520,5777],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.Equals#5<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.Equals#5<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]\n [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]"},{"pos":[5784,7077],"content":"In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=fullName> method overload, which tests for value equality, is called. Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`. However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>. Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=fullName> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method is called. Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method. Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects. As a result, these three method calls return `false`.","nodes":[{"content":"In the first case, the strongly typed <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=fullName&gt;</ph> method overload, which tests for value equality, is called.","pos":[0,193],"source":"In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=fullName> method overload, which tests for value equality, is called."},{"content":"Because the strings assigned to the two <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are equal, the method returns <ph id=\"ph2\">`true`</ph>.","pos":[194,312],"source":" Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`."},{"content":"However, <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> does not override <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph>.","pos":[313,445],"source":" However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>."},{"content":"Because of this, when the <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> object is cast to an <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, when a <ph id=\"ph3\">&lt;xref:System.Text.StringBuilder&gt;</ph> instance is assigned to a variable of type <ph id=\"ph4\">&lt;xref:System.Object&gt;</ph>, and when the <ph id=\"ph5\">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=fullName&gt;</ph> method is passed two <ph id=\"ph6\">&lt;xref:System.Text.StringBuilder&gt;</ph> objects, the default <ph id=\"ph7\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method is called.","pos":[446,918],"source":" Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=fullName> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method is called."},{"content":"Because <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> is a reference type, this is equivalent to passing the two <ph id=\"ph2\">&lt;xref:System.Text.StringBuilder&gt;</ph> objects to the <ph id=\"ph3\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.","pos":[919,1114],"source":" Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method."},{"content":"Although all three <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph> objects contain identical strings, they refer to three distinct objects.","pos":[1115,1239],"source":" Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects."},{"content":"As a result, these three method calls return <ph id=\"ph1\">`false`</ph>.","pos":[1240,1293],"source":" As a result, these three method calls return `false`."}]},{"pos":[7084,7321],"content":"You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method. In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).","nodes":[{"content":"You can compare the current object to another object for reference equality by calling the <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.","pos":[0,138],"source":"You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method."},{"content":"In Visual Basic, you can also use the <ph id=\"ph1\">`is`</ph> keyword (for example, <ph id=\"ph2\">`If Me Is otherObject Then ...`</ph>).","pos":[139,237],"source":" In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`)."}]},{"pos":[7330,7350],"content":"Notes for Inheritors","linkify":"Notes for Inheritors","nodes":[{"content":"Notes for Inheritors","pos":[0,20]}]},{"pos":[7354,7603],"content":"When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type. The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.","nodes":[{"content":"When you define your own type, that type inherits the functionality defined by the <ph id=\"ph1\">`Equals`</ph> method of its base type.","pos":[0,116],"source":"When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type."},{"content":"The following table lists the default implementation of the <ph id=\"ph1\">`Equals`</ph> method for the major categories of types in the .NET Framework.","pos":[117,249],"source":" The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework."}]},{"pos":[7610,7623],"content":"Type category","nodes":[{"content":"Type category","pos":[0,13]}]},{"pos":[7624,7643],"content":"Equality defined by","nodes":[{"content":"Equality defined by","pos":[0,19]}]},{"pos":[7644,7652],"content":"Comments","nodes":[{"content":"Comments","pos":[0,8]}]},{"pos":[7722,7770],"content":"Class derived directly from <xref:System.Object>","nodes":[{"content":"Class derived directly from <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>","pos":[0,48],"source":"Class derived directly from <xref:System.Object>"}]},{"pos":[7771,7842],"content":"<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>","nodes":[]},{"pos":[7843,7950],"content":"Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>.","nodes":[{"content":"Reference equality; equivalent to calling <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=fullName&gt;</ph>.","pos":[0,107],"source":"Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>."}]},{"pos":[7955,7964],"content":"Structure","nodes":[{"content":"Structure","pos":[0,9]}]},{"pos":[7965,8023],"content":"<xref:System.ValueType.Equals%2A?displayProperty=fullName>","nodes":[]},{"pos":[8024,8124],"content":"Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.","nodes":[{"content":"Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.","pos":[0,100]}]},{"pos":[8129,8140],"content":"Enumeration","nodes":[{"content":"Enumeration","pos":[0,11]}]},{"pos":[8141,8194],"content":"<xref:System.Enum.Equals%2A?displayProperty=fullName>","nodes":[]},{"pos":[8195,8268],"content":"Values must have the same enumeration type and the same underlying value.","nodes":[{"content":"Values must have the same enumeration type and the same underlying value.","pos":[0,73]}]},{"pos":[8273,8281],"content":"Delegate","nodes":[{"content":"Delegate","pos":[0,8]}]},{"pos":[8282,8348],"content":"<xref:System.MulticastDelegate.Equals%2A?displayProperty=fullName>","nodes":[]},{"pos":[8349,8415],"content":"Delegates must have the same type with identical invocation lists.","nodes":[{"content":"Delegates must have the same type with identical invocation lists.","pos":[0,66]}]},{"pos":[8420,8429],"content":"Interface","nodes":[{"content":"Interface","pos":[0,9]}]},{"pos":[8430,8501],"content":"<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>","nodes":[]},{"pos":[8502,8521],"content":"Reference equality.","nodes":[{"content":"Reference equality.","pos":[0,19]}]},{"pos":[8529,9570],"content":"For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance. You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality. Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance. The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object. For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=fullName> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to return `true` for any two string instances that contain the same characters in the same order.","nodes":[{"content":"For a value type, you should always override <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph>, because tests for equality that rely on reflection offer poor performance.","pos":[0,151],"source":"For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance."},{"content":"You can also override the default implementation of <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.","pos":[152,364],"source":" You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality."},{"content":"Such implementations of <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> return <ph id=\"ph2\">`true`</ph> if the two objects have the same value, even if they are not the same instance.","pos":[365,513],"source":" Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance."},{"content":"The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.","pos":[514,669]},{"content":"For example, the value of a <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> object is based on the characters of the string; the <ph id=\"ph2\">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method overrides the <ph id=\"ph3\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method to return <ph id=\"ph4\">`true`</ph> for any two string instances that contain the same characters in the same order.","pos":[670,1041],"source":" For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=fullName> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to return `true` for any two string instances that contain the same characters in the same order."}]},{"pos":[9577,10063],"content":"The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to test for value equality. It overrides the <xref:System.Object.Equals%2A> method for the `Person` class. If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object. However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.","nodes":[{"content":"The following example shows how to override the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method to test for value equality.","pos":[0,154],"source":"The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to test for value equality."},{"content":"It overrides the <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> method for the <ph id=\"ph2\">`Person`</ph> class.","pos":[155,233],"source":" It overrides the <xref:System.Object.Equals%2A> method for the `Person` class."},{"content":"If <ph id=\"ph1\">`Person`</ph> accepted its base class implementation of equality, two <ph id=\"ph2\">`Person`</ph> objects would be equal only if they referenced a single object.","pos":[234,374],"source":" If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object."},{"content":"However, in this case, two <ph id=\"ph1\">`Person`</ph> objects are equal if they have the same value for the <ph id=\"ph2\">`Person.Id`</ph> property.","pos":[375,486],"source":" However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property."}]},{"pos":[10070,10337],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.Equals#6<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.Equals#6<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]\n [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]"},{"pos":[10344,10509],"content":"In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.","nodes":[{"content":"In addition to overriding <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph>, you can implement the <ph id=\"ph2\">&lt;xref:System.IEquatable%601&gt;</ph> interface to provide a strongly typed test for equality.","pos":[0,165],"source":"In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality."}]},{"pos":[10516,10721],"content":"The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method. In the list, `x`, `y`, and `z` represent object references that are not **null**.","nodes":[{"content":"The following statements must be true for all implementations of the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.","pos":[0,123],"source":"The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method."},{"content":"In the list, <ph id=\"ph1\">`x`</ph>, <ph id=\"ph2\">`y`</ph>, and <ph id=\"ph3\">`z`</ph> represent object references that are not <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>.","pos":[124,205],"source":" In the list, `x`, `y`, and `z` represent object references that are not **null**."}]},{"pos":[10731,10919],"content":"`x.Equals(x)` returns `true`, except in cases that involve floating-point types. See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.","nodes":[{"content":"<ph id=\"ph1\">`x.Equals(x)`</ph> returns <ph id=\"ph2\">`true`</ph>, except in cases that involve floating-point types.","pos":[0,80],"source":"`x.Equals(x)` returns `true`, except in cases that involve floating-point types."},{"content":"See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.","pos":[81,188]}]},{"pos":[10929,10983],"content":"<ph id=\"ph1\">`x.Equals(y)`</ph> returns the same value as <ph id=\"ph2\">`y.Equals(x)`</ph>.","source":"`x.Equals(y)` returns the same value as `y.Equals(x)`."},{"pos":[10993,11052],"content":"<ph id=\"ph1\">`x.Equals(y)`</ph> returns <ph id=\"ph2\">`true`</ph> if both <ph id=\"ph3\">`x`</ph> and <ph id=\"ph4\">`y`</ph> are <ph id=\"ph5\">`NaN`</ph>.","source":"`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`."},{"pos":[11062,11146],"content":"If <ph id=\"ph1\">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> returns <ph id=\"ph2\">`true`</ph>, then <ph id=\"ph3\">`x.Equals(z)`</ph> returns <ph id=\"ph4\">`true`</ph>.","source":"If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`."},{"pos":[11156,11278],"content":"Successive calls to <ph id=\"ph1\">`x.Equals(y)`</ph> return the same value as long as the objects referenced by <ph id=\"ph2\">`x`</ph> and <ph id=\"ph3\">`y`</ph> are not modified.","source":"Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified."},{"pos":[11288,11321],"content":"<ph id=\"ph1\">`x.Equals(null)`</ph> returns <ph id=\"ph2\">`false`</ph>.","source":"`x.Equals(null)` returns `false`."},{"pos":[11328,11596],"content":"Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value. For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.","nodes":[{"content":"Implementations of <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> must not throw exceptions; they should always return a value.","pos":[0,111],"source":"Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value."},{"content":"For example, if <ph id=\"ph1\">`obj`</ph> is <ph id=\"ph2\">`null`</ph>, the <ph id=\"ph3\">&lt;xref:System.Object.Equals%2A&gt;</ph> method should return <ph id=\"ph4\">`false`</ph> instead of throwing an <ph id=\"ph5\">&lt;xref:System.ArgumentNullException&gt;</ph>.","pos":[112,268],"source":" For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>."}]},{"pos":[11603,11690],"content":"Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:","nodes":[{"content":"Follow these guidelines when overriding <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:","pos":[0,87],"source":"Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:"}]},{"pos":[11700,11808],"content":"Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.","nodes":[{"content":"Types that implement <ph id=\"ph1\">&lt;xref:System.IComparable&gt;</ph> must override <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.","pos":[0,108],"source":"Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>."}]},{"pos":[11818,11990],"content":"Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.","nodes":[{"content":"Types that override <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> must also override <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; otherwise, hash tables  might not work correctly.","pos":[0,172],"source":"Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly."}]},{"pos":[12000,12284],"content":"You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality. Your <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.","nodes":[{"content":"You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality. Your <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.","pos":[0,284],"nodes":[{"content":"You should consider implementing the <ph id=\"ph1\">&lt;xref:System.IEquatable%601&gt;</ph> interface to support strongly typed tests for equality.","pos":[0,121],"source":"You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality."},{"content":"Your <ph id=\"ph1\">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=fullName&gt;</ph> implementation should return results that are consistent with <ph id=\"ph2\">&lt;xref:System.Object.Equals%2A&gt;</ph>.","pos":[122,284],"source":" Your <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> implementation should return results that are consistent with <xref:System.Object.Equals%2A>."}]}]},{"pos":[12294,12815],"content":"If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator. This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.","nodes":[{"content":"If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator. This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.","pos":[0,521],"nodes":[{"content":"If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to return the same result as the equality operator.","pos":[0,248],"source":"If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator."},{"content":"This  helps ensure that class library code that uses <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> (such as <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Collections.Hashtable&gt;</ph>) behaves in a manner that is consistent with the way the equality operator is used by application code.","pos":[249,521],"source":" This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code."}]}]},{"pos":[12825,12855],"content":"Guidelines for Reference Types","linkify":"Guidelines for Reference Types","nodes":[{"content":"Guidelines for Reference Types","pos":[0,30]}]},{"pos":[12859,12972],"content":"The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:","nodes":[{"content":"The following guidelines apply to overriding <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a reference type:","pos":[0,113],"source":"The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:"}]},{"pos":[12982,13123],"content":"Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).","nodes":[{"content":"Consider overriding <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> if the semantics of the type are based on the fact that the type represents some value(s).","pos":[0,141],"source":"Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s)."}]},{"pos":[13133,13412],"content":"Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>. However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.","nodes":[{"content":"Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>. However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.","pos":[0,279],"nodes":[{"content":"Most reference types must not overload the equality operator, even if they override <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph>.","pos":[0,115],"source":"Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>."},{"content":"However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.","pos":[116,279]}]}]},{"pos":[13422,13841],"content":"You should not override <xref:System.Object.Equals%2A> on a mutable reference type. This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section. This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.","nodes":[{"content":"You should not override <xref:System.Object.Equals%2A> on a mutable reference type. This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section. This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.","pos":[0,419],"nodes":[{"content":"You should not override <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> on a mutable reference type.","pos":[0,83],"source":"You should not override <xref:System.Object.Equals%2A> on a mutable reference type."},{"content":"This is because overriding <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> requires that you also override the <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, as discussed in the previous section.","pos":[84,259],"source":" This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section."},{"content":"This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.","pos":[260,419]}]}]},{"pos":[13851,13877],"content":"Guidelines for Value Types","linkify":"Guidelines for Value Types","nodes":[{"content":"Guidelines for Value Types","pos":[0,26]}]},{"pos":[13881,13990],"content":"The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:","nodes":[{"content":"The following guidelines apply to overriding <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a value type:","pos":[0,109],"source":"The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:"}]},{"pos":[14000,14469],"content":"If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>. The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.","nodes":[{"content":"If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>. The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.","pos":[0,469],"nodes":[{"content":"If you are defining a value type that includes one or more fields whose values are reference types, you should override <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.","pos":[0,167],"source":"If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementation provided by <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.","pos":[168,469],"source":" The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types."}]}]},{"pos":[14479,14627],"content":"If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.","nodes":[{"content":"If you override <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> and your development language supports operator overloading, you must overload the equality operator.","pos":[0,148],"source":"If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator."}]},{"pos":[14637,14833],"content":"You should implement the <xref:System.IEquatable%601> interface. Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> method avoids boxing the `obj` argument.","nodes":[{"content":"You should implement the <ph id=\"ph1\">&lt;xref:System.IEquatable%601&gt;</ph> interface.","pos":[0,64],"source":"You should implement the <xref:System.IEquatable%601> interface."},{"content":"Calling the strongly typed <ph id=\"ph1\">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=fullName&gt;</ph> method avoids boxing the <ph id=\"ph2\">`obj`</ph> argument.","pos":[65,196],"source":" Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> method avoids boxing the `obj` argument."}]}],"pos":[7891,22828],"yaml":true,"extradata":"MT"},{"content":"The object to compare with the current object.","nodes":[{"pos":[0,46],"content":"The object to compare with the current object.","nodes":[{"content":"The object to compare with the current object.","pos":[0,46]}]}],"pos":[26957,27004],"yaml":true},{"content":"`true` if the specified object  is equal to the current object; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if the specified object  is equal to the current object; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the specified object  is equal to the current object; otherwise, `false`."}],"pos":[27062,27148],"yaml":true},{"content":"Determines whether the specified object instances are considered equal.","nodes":[{"pos":[0,71],"content":"Determines whether the specified object instances are considered equal.","nodes":[{"content":"Determines whether the specified object instances are considered equal.","pos":[0,71]}]}],"pos":[28688,28760],"yaml":true},{"content":"The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal. It also enables you to test objects whose value is **null** for equality. It compares `objA` and `objB` for equality as follows:  \n  \n-   It determines whether the two objects represent the same object reference. If they do, the method returns `true`. This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method. In addition, if both `objA` and `objB` are **null**, the method returns `true`.  \n  \n-   It determines whether either `objA` or `objB` is **null**. If so, it returns `false`.  \n  \n-   If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result. This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method, this override is called.","nodes":[{"pos":[0,271],"content":"The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal. It also enables you to test objects whose value is **null** for equality. It compares `objA` and `objB` for equality as follows:","nodes":[{"content":"The static <ph id=\"ph1\">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method indicates whether two objects, <ph id=\"ph2\">`objA`</ph> and  <ph id=\"ph3\">`objB`</ph>, are equal.","pos":[0,142],"source":"The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal."},{"content":"It also enables you to test objects whose value is <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> for equality.","pos":[143,216],"source":" It also enables you to test objects whose value is **null** for equality."},{"content":"It compares <ph id=\"ph1\">`objA`</ph> and <ph id=\"ph2\">`objB`</ph> for equality as follows:","pos":[217,271],"source":" It compares `objA` and `objB` for equality as follows:"}]},{"pos":[281,561],"content":"It determines whether the two objects represent the same object reference. If they do, the method returns `true`. This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method. In addition, if both `objA` and `objB` are **null**, the method returns `true`.","nodes":[{"content":"It determines whether the two objects represent the same object reference.","pos":[0,74]},{"content":"If they do, the method returns <ph id=\"ph1\">`true`</ph>.","pos":[75,113],"source":" If they do, the method returns `true`."},{"content":"This test is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.","pos":[114,200],"source":" This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method."},{"content":"In addition, if both <ph id=\"ph1\">`objA`</ph> and <ph id=\"ph2\">`objB`</ph> are <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>, the method returns <ph id=\"ph3\">`true`</ph>.","pos":[201,280],"source":" In addition, if both `objA` and `objB` are **null**, the method returns `true`."}]},{"pos":[571,656],"content":"It determines whether either `objA` or `objB` is **null**. If so, it returns `false`.","nodes":[{"content":"It determines whether either <ph id=\"ph1\">`objA`</ph> or <ph id=\"ph2\">`objB`</ph> is <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>.","pos":[0,58],"source":"It determines whether either `objA` or `objB` is **null**."},{"content":"If so, it returns <ph id=\"ph1\">`false`</ph>.","pos":[59,85],"source":" If so, it returns `false`."}]},{"pos":[666,954],"content":"If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result. This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method, this override is called.","nodes":[{"content":"If the two objects do not represent the same object reference and neither is <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>, it calls <ph id=\"ph1\">`objA`</ph>.<ph id=\"ph2\">`Equals`</ph>(<ph id=\"ph3\">`objB`</ph>) and returns the result.","pos":[0,143],"source":"If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result."},{"content":"This means that if <ph id=\"ph1\">`objA`</ph> overrides the <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method, this override is called.","pos":[144,288],"source":" This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method, this override is called."}]}],"pos":[28771,29734],"yaml":true,"extradata":"MT"},{"content":"The first object to compare.","nodes":[{"pos":[0,28],"content":"The first object to compare.","nodes":[{"content":"The first object to compare.","pos":[0,28]}]}],"pos":[30362,30391],"yaml":true},{"content":"The second object to compare.","nodes":[{"pos":[0,29],"content":"The second object to compare.","nodes":[{"content":"The second object to compare.","pos":[0,29]}]}],"pos":[30451,30481],"yaml":true},{"content":"`true` if the objects are considered equal; otherwise, `false`. If both <code>objA</code> and <code>objB</code> are **null**, the method returns `true`.","nodes":[{"pos":[0,152],"content":"`true` if the objects are considered equal; otherwise, `false`. If both <code>objA</code> and <code>objB</code> are **null**, the method returns `true`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the objects are considered equal; otherwise, <ph id=\"ph2\">`false`</ph>.","pos":[0,63],"source":"`true` if the objects are considered equal; otherwise, `false`."},{"content":"If both <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">objA</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">objB</ph><ept id=\"p2\">&lt;/code&gt;</ept> are <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept>, the method returns <ph id=\"ph3\">`true`</ph>.","pos":[64,152],"source":" If both <code>objA</code> and <code>objB</code> are **null**, the method returns `true`."}]}],"pos":[30539,30694],"yaml":true},{"content":"Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.","nodes":[{"pos":[0,124],"content":"Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.","nodes":[{"content":"Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.","pos":[0,124]}]}],"pos":[32117,32242],"yaml":true},{"content":"The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed. The method is protected and therefore is accessible only through this class or through a derived class.  \n  \n In this section:  \n  \n-   [How finalization works](#How)  \n  \n-   [Notes for implementers](#Notes)  \n  \n-   [The SafeHandle alternative](#SafeHandle)  \n  \n<a name=\"How\"></a>   \n## How finalization works  \n The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.  \n  \n If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue. The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory. The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:  \n  \n-   After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  \n  \n-   During shutdown of an application domain, unless the object is exempt from finalization. During shutdown, even objects that are still accessible are finalized.  \n  \n <xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=fullName> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method has not been subsequently called.  \n  \n <xref:System.Object.Finalize%2A> operations have the following limitations:  \n  \n-   The exact time when the finalizer executes is undefined. To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation.  \n  \n-   The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other. That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.  \n  \n-   The thread on which the finalizer runs is unspecified.  \n  \n The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:  \n  \n-   If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on). Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.  \n  \n-   If the process terminates without giving the runtime a chance to clean up. In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.  \n  \n The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.  \n  \n If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed. This behavior ensures process integrity if the finalizer cannot free or destroy resources.  \n  \n<a name=\"Notes\"></a>   \n## Notes for implementers  \n You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.  \n  \n> [!IMPORTANT]\n>  If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>. For more information, see [The SafeHandle alternative](#SafeHandle) section.  \n  \n The <xref:System.Object.Finalize%2A?displayProperty=fullName> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources. Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections. In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only. The common language runtime only finalizes reference types. It ignores finalizers on value types.  \n  \n Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>. This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.  \n  \n> [!NOTE]\n>  The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method. Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class. A C# destructor automatically calls the destructor of its base class.  \n>   \n>  Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method. For more information, see the \"Destructors and finalizers\" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  \n  \n Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization. To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface. The <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.  \n  \n <xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection. However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection. There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.  \n  \n<a name=\"SafeHandle\"></a>   \n## The SafeHandle alternative  \n Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer. Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer. The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=fullName> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>:  \n  \n-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.  \n  \n-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.  \n  \n-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.  \n  \n-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.  \n  \n-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.  \n  \n-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.  \n  \n-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.  \n  \n The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method. It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension. The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor. The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.  \n  \n [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]\n [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]","nodes":[{"pos":[0,267],"content":"The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed. The method is protected and therefore is accessible only through this class or through a derived class.","nodes":[{"content":"The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed. The method is protected and therefore is accessible only through this class or through a derived class.","pos":[0,267],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.","pos":[0,163],"source":"The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed."},{"content":"The method is protected and therefore is accessible only through this class or through a derived class.","pos":[164,267]}]}]},{"pos":[274,290],"content":"In this section:","nodes":[{"content":"In this section:","pos":[0,16]}]},{"pos":[300,330],"content":"<bpt id=\"p1\">[</bpt>How finalization works<ept id=\"p1\">](#How)</ept>","source":"[How finalization works](#How)"},{"pos":[340,372],"content":"<bpt id=\"p1\">[</bpt>Notes for implementers<ept id=\"p1\">](#Notes)</ept>","source":"[Notes for implementers](#Notes)"},{"pos":[382,423],"content":"<bpt id=\"p1\">[</bpt>The SafeHandle alternative<ept id=\"p1\">](#SafeHandle)</ept>","source":"[The SafeHandle alternative](#SafeHandle)"},{"pos":[454,476],"content":"How finalization works","linkify":"How finalization works","nodes":[{"content":"How finalization works","pos":[0,22]}]},{"pos":[480,749],"content":"The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> class provides no implementation for the <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, and the garbage collector does not mark types derived from <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph> for finalization unless they override the <ph id=\"ph4\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.","pos":[0,269],"source":"The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method."}]},{"pos":[756,1237],"content":"If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue. The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory. The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:","nodes":[{"content":"If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue. The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory. The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:","pos":[0,481],"nodes":[{"content":"If a type does override the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.","pos":[0,190],"source":"If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue."},{"content":"The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.","pos":[191,358]},{"content":"The garbage collector then calls the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method automatically under the following conditions:","pos":[359,481],"source":" The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:"}]}]},{"pos":[1247,1462],"content":"After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.","nodes":[{"content":"After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[0,215],"source":"After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method."}]},{"pos":[1472,1631],"content":"During shutdown of an application domain, unless the object is exempt from finalization. During shutdown, even objects that are still accessible are finalized.","nodes":[{"content":"During shutdown of an application domain, unless the object is exempt from finalization. During shutdown, even objects that are still accessible are finalized.","pos":[0,159],"nodes":[{"content":"During shutdown of an application domain, unless the object is exempt from finalization.","pos":[0,88]},{"content":"During shutdown, even objects that are still accessible are finalized.","pos":[89,159]}]}]},{"pos":[1638,1967],"content":"<xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=fullName> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method has not been subsequently called.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <ph id=\"ph2\">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=fullName&gt;</ph> and the <ph id=\"ph3\">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> method has not been subsequently called.","pos":[0,329],"source":"<xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=fullName> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method has not been subsequently called."}]},{"pos":[1974,2049],"content":"<xref:System.Object.Finalize%2A> operations have the following limitations:","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> operations have the following limitations:","pos":[0,75],"source":"<xref:System.Object.Finalize%2A> operations have the following limitations:"}]},{"pos":[2059,2307],"content":"The exact time when the finalizer executes is undefined. To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation.","nodes":[{"content":"The exact time when the finalizer executes is undefined.","pos":[0,56]},{"content":"To ensure deterministic release of resources for instances of your class, implement a <ph id=\"ph1\">`Close`</ph> method or provide a <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation.","pos":[57,248],"source":" To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation."}]},{"pos":[2317,2592],"content":"The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other. That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.","nodes":[{"content":"The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other. That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.","pos":[0,275],"nodes":[{"content":"The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.","pos":[0,118]},{"content":"That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.","pos":[119,275]}]}]},{"pos":[2602,2656],"content":"The thread on which the finalizer runs is unspecified.","nodes":[{"content":"The thread on which the finalizer runs is unspecified.","pos":[0,54]}]},{"pos":[2663,2805],"content":"The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method might not run to completion or might not run at all under the following exceptional circumstances:","pos":[0,142],"source":"The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:"}]},{"pos":[2815,3072],"content":"If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on). Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.","nodes":[{"content":"If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on). Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.","pos":[0,257],"nodes":[{"content":"If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).","pos":[0,125]},{"content":"Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.","pos":[126,257]}]}]},{"pos":[3082,3264],"content":"If the process terminates without giving the runtime a chance to clean up. In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.","nodes":[{"content":"If the process terminates without giving the runtime a chance to clean up. In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.","pos":[0,182],"nodes":[{"content":"If the process terminates without giving the runtime a chance to clean up.","pos":[0,74]},{"content":"In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.","pos":[75,182]}]}]},{"pos":[3271,3396],"content":"The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.","nodes":[{"content":"The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.","pos":[0,125]}]},{"pos":[3403,3784],"content":"If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed. This behavior ensures process integrity if the finalizer cannot free or destroy resources.","nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> or an override of <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active <ph id=\"ph3\">`try`</ph><ph id=\"ph4\">/</ph><ph id=\"ph5\">`finally`</ph> blocks or finalizers are executed.","pos":[0,290],"source":"If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed."},{"content":"This behavior ensures process integrity if the finalizer cannot free or destroy resources.","pos":[291,381]}]},{"pos":[3817,3839],"content":"Notes for implementers","linkify":"Notes for implementers","nodes":[{"content":"Notes for implementers","pos":[0,22]}]},{"pos":[3843,4083],"content":"You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.","nodes":[{"content":"You should override <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> for a class that uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.","pos":[0,240],"source":"You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection."}]},{"pos":[4091,4427],"content":"[!IMPORTANT]\n If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>. For more information, see [The SafeHandle alternative](#SafeHandle) section.","leadings":["","> "],"nodes":[{"content":" If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>. For more information, see [The SafeHandle alternative](#SafeHandle) section.","pos":[13,334],"nodes":[{"content":"If a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph>.","pos":[1,244],"source":" If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>The SafeHandle alternative<ept id=\"p1\">](#SafeHandle)</ept> section.","pos":[245,321],"source":" For more information, see [The SafeHandle alternative](#SafeHandle) section."}]}]},{"pos":[4434,4977],"content":"The <xref:System.Object.Finalize%2A?displayProperty=fullName> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources. Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections. In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only. The common language runtime only finalizes reference types. It ignores finalizers on value types.","nodes":[{"content":"The <xref:System.Object.Finalize%2A?displayProperty=fullName> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources. Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections. In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only. The common language runtime only finalizes reference types. It ignores finalizers on value types.","pos":[0,543],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method does nothing by default, but you should override <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> only if necessary, and only to release unmanaged resources.","pos":[0,210],"source":"The <xref:System.Object.Finalize%2A?displayProperty=fullName> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources."},{"content":"Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.","pos":[211,342]},{"content":"In addition, you should override the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for reference types only.","pos":[343,445],"source":" In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only."},{"content":"The common language runtime only finalizes reference types.","pos":[446,505]},{"content":"It ignores finalizers on value types.","pos":[506,543]}]}]},{"pos":[4984,5237],"content":"Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>. This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.","nodes":[{"content":"Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>. This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.","pos":[0,253],"nodes":[{"content":"Every implementation of <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> in a derived type must call its base type's implementation of <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph>.","pos":[0,152],"source":"Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>."},{"content":"This is the only case in which application code is allowed to call <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph>.","pos":[153,253],"source":" This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>."}]}]},{"pos":[5245,5565],"content":"[!NOTE]\n The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method. Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class. A C# destructor automatically calls the destructor of its base class.","leadings":["","> "],"nodes":[{"content":" The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method. Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class. A C# destructor automatically calls the destructor of its base class.","pos":[8,318],"nodes":[{"content":"The C# compiler does not allow you to override the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.","pos":[1,92],"source":" The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method."},{"content":"Instead, you provide a finalizer by implementing a <bpt id=\"p1\">[</bpt>destructor<ept id=\"p1\">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> for your class.","pos":[93,240],"source":" Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class."},{"content":"A C# destructor automatically calls the destructor of its base class.","pos":[241,310]}]}]},{"pos":[5576,5879],"content":"Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method. For more information, see the \"Destructors and finalizers\" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).","nodes":[{"content":"Visual C++ also provides its own syntax for implementing the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.","pos":[0,101],"source":"Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method."},{"content":"For more information, see the \"Destructors and finalizers\" section of <bpt id=\"p1\">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id=\"p1\">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.","pos":[102,303],"source":" For more information, see the \"Destructors and finalizers\" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)."}]},{"pos":[5886,6518],"content":"Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization. To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface. The <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.","nodes":[{"content":"Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.","pos":[0,124]},{"content":"To release resources immediately, you can also choose to implement the <bpt id=\"p1\">[</bpt>dispose pattern<ept id=\"p1\">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> and the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface.","pos":[125,312],"source":" To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface."},{"content":"The <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method to free unmanaged resources in the event that the <ph id=\"ph3\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.","pos":[313,632],"source":" The <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called."}]},{"pos":[6525,7006],"content":"<xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection. However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection. There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.","nodes":[{"content":"<xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection. However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection. There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.","pos":[0,481],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.","pos":[0,195],"source":"<xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection."},{"content":"However, the object can only be resurrected once; <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> cannot be called on resurrected objects during garbage collection.","pos":[196,345],"source":" However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection."},{"content":"There is one action that your implementation of <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> should never take: it should never throw an exception.","pos":[346,481],"source":" There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception."}]}]},{"pos":[7044,7070],"content":"The SafeHandle alternative","linkify":"The SafeHandle alternative","nodes":[{"content":"The SafeHandle alternative","pos":[0,26]}]},{"pos":[7074,7860],"content":"Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer. Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer. The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=fullName> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>:","nodes":[{"content":"Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer. Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer. The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=fullName> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>:","pos":[0,786],"nodes":[{"content":"Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.StackOverflowException&gt;</ph> terminate the finalizer.","pos":[0,270],"source":"Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer."},{"content":"Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.","pos":[271,574],"source":" Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer."},{"content":"The .NET Framework provides the following classes in the <ph id=\"ph1\">&lt;xref:Microsoft.Win32?displayProperty=fullName&gt;</ph> namespace that are derived from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph>:","pos":[575,786],"source":" The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=fullName> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>:"}]}]},{"pos":[7870,7957],"content":"<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> is a wrapper class for a file handle.","pos":[0,87],"source":"<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle."}]},{"pos":[7967,8079],"content":"<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> is a wrapper class for memory-mapped file handles.","pos":[0,112],"source":"<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles."}]},{"pos":[8089,8215],"content":"<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> is a wrapper class for a pointer to a block of unmanaged memory.","pos":[0,126],"source":"<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory."}]},{"pos":[8225,8450],"content":"<xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id=\"ph3\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> are wrapper classes for cryptographic handles.","pos":[0,225],"source":"<xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles."}]},{"pos":[8460,8546],"content":"<xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> is a wrapper class for pipe handles.","pos":[0,86],"source":"<xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles."}]},{"pos":[8556,8660],"content":"<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> is a wrapper class for a handle to a registry key.","pos":[0,104],"source":"<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key."}]},{"pos":[8670,8757],"content":"<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> is a wrapper class for a wait handle.","pos":[0,87],"source":"<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle."}]},{"pos":[8764,9457],"content":"The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method. It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension. The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor. The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.","nodes":[{"content":"The following example uses the <bpt id=\"p1\">[</bpt>dispose pattern<ept id=\"p1\">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> with safe handles instead of overriding the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.","pos":[0,187],"source":"The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method."},{"content":"It defines a <ph id=\"ph1\">`FileAssociation`</ph> class that wraps registry information about the application that handles files with a particular file extension.","pos":[188,331],"source":" It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension."},{"content":"The two registry handles returned as <ph id=\"ph1\">`out`</ph> parameters by Windows <bpt id=\"p1\">[</bpt>RegOpenKeyEx<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> function calls are passed to the <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.","pos":[332,576],"source":" The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor."},{"content":"The type's protected <ph id=\"ph1\">`Dispose`</ph> method then calls the <ph id=\"ph2\">`SafeRegistryHandle.Dispose`</ph> method  to free these two handles.","pos":[577,693],"source":" The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles."}]},{"pos":[9464,9737],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.Finalize#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.Finalize#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]\n[!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]"}],"pos":[32253,42082],"yaml":true,"extradata":"MT"},{"content":"Serves as the default hash function.","nodes":[{"pos":[0,36],"content":"Serves as the default hash function.","nodes":[{"content":"Serves as the default hash function.","pos":[0,36]}]}],"pos":[44501,44538],"yaml":true},{"content":"A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class. The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.  \n  \n> [!NOTE]\n>  For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](http://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.  \n  \n Two objects that are equal return hash codes that are equal. However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes. Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms. For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes. Two consequences follow from this:  \n  \n-   You should not assume that equal hash codes imply object equality.  \n  \n-   You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.  \n  \n> [!WARNING]\n>  A hash code is intended for efficient insertion and lookup in collections that are based on a hash table. A hash code is not a permanent value. For this reason:  \n>   \n>  -   Do not serialize hash code values or store them in databases.  \n> -   Do not use the hash code as the key to retrieve an object from a keyed collection.  \n> -   Do not send hash codes across application domains or processes. In some cases, hash codes may be computed on a per-process or per-application domain basis.  \n> -   Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName> class.  \n> -   Do not test for equality of hash codes to determine whether two objects are equal. (Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.  \n  \n The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type. If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName>. In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes. If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=fullName> method of the base class uses reflection to compute the hash code based on the values of the type's fields. In other words, value types whose fields have equal values have equal hash codes. For more information about overriding <xref:System.Object.GetHashCode%2A>, see the \"Notes to Inheritors\" section.  \n  \n> [!WARNING]\n>  If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa. If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.  \n  \n If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.  \n  \n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \n When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>. However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.  \n  \n> [!NOTE]\n>  [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.","nodes":[{"pos":[0,422],"content":"A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class. The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.","nodes":[{"content":"A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class. The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.","pos":[0,422],"nodes":[{"content":"A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class, the <ph id=\"ph2\">&lt;xref:System.Collections.Hashtable&gt;</ph> class, or a type derived from the <ph id=\"ph3\">&lt;xref:System.Collections.DictionaryBase&gt;</ph> class.","pos":[0,293],"source":"A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method provides this hash code for algorithms that need quick checks of object equality.","pos":[294,422],"source":" The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality."}]}]},{"pos":[430,635],"content":"[!NOTE]\n For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](http://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.","leadings":["","> "],"nodes":[{"content":"For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <bpt id=\"p1\">[</bpt>Hash Function<ept id=\"p1\">](http://en.wikipedia.org/wiki/Hash_function)</ept> entry in Wikipedia.","pos":[9,203],"source":" For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](http://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia."}]},{"pos":[642,1267],"content":"Two objects that are equal return hash codes that are equal. However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes. Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms. For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes. Two consequences follow from this:","nodes":[{"content":"Two objects that are equal return hash codes that are equal. However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes. Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms. For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes. Two consequences follow from this:","pos":[0,625],"nodes":[{"content":"Two objects that are equal return hash codes that are equal.","pos":[0,60]},{"content":"However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.","pos":[61,208]},{"content":"Furthermore, the .NET Framework does not guarantee the default implementation of the <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.","pos":[209,466],"source":" Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms."},{"content":"For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.","pos":[467,590]},{"content":"Two consequences follow from this:","pos":[591,625]}]}]},{"pos":[1277,1343],"content":"You should not assume that equal hash codes imply object equality.","nodes":[{"content":"You should not assume that equal hash codes imply object equality.","pos":[0,66]}]},{"pos":[1353,1539],"content":"You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.","nodes":[{"content":"You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.","pos":[0,186]}]},{"pos":[1547,1721],"content":"[!WARNING]\n A hash code is intended for efficient insertion and lookup in collections that are based on a hash table. A hash code is not a permanent value. For this reason:","leadings":["","> "],"nodes":[{"content":" A hash code is intended for efficient insertion and lookup in collections that are based on a hash table. A hash code is not a permanent value. For this reason:","pos":[11,172],"nodes":[{"content":"A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.","pos":[1,106]},{"content":"A hash code is not a permanent value.","pos":[107,144]},{"content":"For this reason:","pos":[145,161]}]}]},{"pos":[1736,1797],"content":"Do not serialize hash code values or store them in databases.","nodes":[{"content":"Do not serialize hash code values or store them in databases.","pos":[0,61]}]},{"pos":[1806,1888],"content":"Do not use the hash code as the key to retrieve an object from a keyed collection.","nodes":[{"content":"Do not use the hash code as the key to retrieve an object from a keyed collection.","pos":[0,82]}]},{"pos":[1897,2052],"content":"Do not send hash codes across application domains or processes. In some cases, hash codes may be computed on a per-process or per-application domain basis.","nodes":[{"content":"Do not send hash codes across application domains or processes. In some cases, hash codes may be computed on a per-process or per-application domain basis.","pos":[0,155],"nodes":[{"content":"Do not send hash codes across application domains or processes.","pos":[0,63]},{"content":"In some cases, hash codes may be computed on a per-process or per-application domain basis.","pos":[64,155]}]}]},{"pos":[2061,2414],"content":"Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName> class.","nodes":[{"content":"Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName> class.","pos":[0,353],"nodes":[{"content":"Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.","pos":[0,133]},{"content":"For cryptographic hashes, use a class derived from the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName&gt;</ph> class.","pos":[134,353],"source":" For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName> class."}]}]},{"pos":[2423,2667],"content":"Do not test for equality of hash codes to determine whether two objects are equal. (Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.","nodes":[{"content":"Do not test for equality of hash codes to determine whether two objects are equal. (Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.","pos":[0,244],"nodes":[{"content":"Do not test for equality of hash codes to determine whether two objects are equal.","pos":[0,82]},{"content":"(Unequal objects can have identical hash codes.) To test for equality, call the <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Object.Equals%2A&gt;</ph> method.","pos":[83,244],"source":" (Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method."}]}]},{"pos":[2674,3712],"content":"The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type. If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName>. In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes. If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=fullName> method of the base class uses reflection to compute the hash code based on the values of the type's fields. In other words, value types whose fields have equal values have equal hash codes. For more information about overriding <xref:System.Object.GetHashCode%2A>, see the \"Notes to Inheritors\" section.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method can be overridden by a derived type.","pos":[0,83],"source":"The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type."},{"content":"If <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> is not overridden, hash codes for reference types are computed by calling the <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method of the base class, which computes a hash code based on an object's reference; for more information, see <ph id=\"ph3\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph>.","pos":[84,467],"source":" If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName>."},{"content":"In other words, two objects for which the <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> have identical hash codes.","pos":[468,598],"source":" In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes."},{"content":"If value types do not override <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=fullName&gt;</ph> method of the base class uses reflection to compute the hash code based on the values of the type's fields.","pos":[599,842],"source":" If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=fullName> method of the base class uses reflection to compute the hash code based on the values of the type's fields."},{"content":"In other words, value types whose fields have equal values have equal hash codes.","pos":[843,924]},{"content":"For more information about overriding <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, see the \"Notes to Inheritors\" section.","pos":[925,1038],"source":" For more information about overriding <xref:System.Object.GetHashCode%2A>, see the \"Notes to Inheritors\" section."}]},{"pos":[3720,4091],"content":"[!WARNING]\n If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa. If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.","leadings":["","> "],"nodes":[{"content":" If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa. If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.","pos":[11,369],"nodes":[{"content":"If you override the <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, you should also override <ph id=\"ph2\">&lt;xref:System.Object.Equals%2A&gt;</ph>, and vice versa.","pos":[1,137],"source":" If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa."},{"content":"If your overridden <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> when two objects are tested for equality, your overridden <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method must return the same value for the two objects.","pos":[138,358],"source":" If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects."}]}]},{"pos":[4098,4427],"content":"If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.","nodes":[{"content":"If an object that is used as a key in a hash table does not provide a useful implementation of <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, you can specify a hash code provider by supplying an <ph id=\"ph2\">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementation to one of the overloads of the <ph id=\"ph3\">&lt;xref:System.Collections.Hashtable&gt;</ph> class constructor.","pos":[0,329],"source":"If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor."}]},{"pos":[4436,4487],"content":"Notes for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>","linkify":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]","source":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]"},{"pos":[4491,5418],"content":"When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>. However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method on a class in the <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.","pos":[0,219],"source":"When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>."},{"content":"This is part of the support that the .NET Framework provides for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id=\"p1\">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id=\"p1\">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).","pos":[220,487],"source":" This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))."},{"content":"Classes in the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, and currently don’t implement a <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.","pos":[488,645],"source":" Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>."},{"content":"However, they appear to have <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","pos":[646,927],"source":" However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods."}]},{"pos":[5426,5582],"content":"[!NOTE]\n [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> [!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method.","pos":[8,154],"source":" [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method."}]}],"pos":[44549,50167],"yaml":true,"extradata":"MT"},{"content":"A hash code for the current object.","nodes":[{"pos":[0,35],"content":"A hash code for the current object.","nodes":[{"content":"A hash code for the current object.","pos":[0,35]}]}],"pos":[53386,53422],"yaml":true},{"content":"Gets the <xref href=\"System.Type\"></xref> of the current instance.","nodes":[{"pos":[0,66],"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> of the current instance.","source":"Gets the <xref href=\"System.Type\"></xref> of the current instance."}],"pos":[54844,54911],"yaml":true},{"content":"Because <xref:System.Object?displayProperty=fullName> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types. The .NET Framework recognizes the following five categories of types:  \n  \n-   Classes, which are derived from <xref:System.Object?displayProperty=fullName>,  \n  \n-   Value types, which are derived from <xref:System.ValueType?displayProperty=fullName>.  \n  \n-   Interfaces, which are derived from <xref:System.Object?displayProperty=fullName> starting with the .NET Framework 2.0.  \n  \n-   Enumerations, which are derived from <xref:System.Enum?displayProperty=fullName>.  \n  \n-   Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=fullName>.  \n  \n For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`. The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.  \n  \n [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]\n [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  \n  \n> [!NOTE]\n>  To determine whether an object is a specific type, you can use your language's type comparison keyword or construct. For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.  \n  \n The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>. This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.  \n  \n [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]\n [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  \n  \n The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.","nodes":[{"pos":[0,323],"content":"Because <xref:System.Object?displayProperty=fullName> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types. The .NET Framework recognizes the following five categories of types:","nodes":[{"content":"Because <xref:System.Object?displayProperty=fullName> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types. The .NET Framework recognizes the following five categories of types:","pos":[0,323],"nodes":[{"content":"Because <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> is the base class for all types in the .NET Framework type system, the <ph id=\"ph2\">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be used to return <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> objects that represent all .NET Framework types.","pos":[0,253],"source":"Because <xref:System.Object?displayProperty=fullName> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types."},{"content":"The .NET Framework recognizes the following five categories of types:","pos":[254,323]}]}]},{"pos":[333,411],"content":"Classes, which are derived from <xref:System.Object?displayProperty=fullName>,","nodes":[{"content":"Classes, which are derived from <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>,","pos":[0,78],"source":"Classes, which are derived from <xref:System.Object?displayProperty=fullName>,"}]},{"pos":[421,506],"content":"Value types, which are derived from <xref:System.ValueType?displayProperty=fullName>.","nodes":[{"content":"Value types, which are derived from <ph id=\"ph1\">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>.","pos":[0,85],"source":"Value types, which are derived from <xref:System.ValueType?displayProperty=fullName>."}]},{"pos":[516,634],"content":"Interfaces, which are derived from <xref:System.Object?displayProperty=fullName> starting with the .NET Framework 2.0.","nodes":[{"content":"Interfaces, which are derived from <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> starting with the .NET Framework 2.0.","pos":[0,118],"source":"Interfaces, which are derived from <xref:System.Object?displayProperty=fullName> starting with the .NET Framework 2.0."}]},{"pos":[644,725],"content":"Enumerations, which are derived from <xref:System.Enum?displayProperty=fullName>.","nodes":[{"content":"Enumerations, which are derived from <ph id=\"ph1\">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph>.","pos":[0,81],"source":"Enumerations, which are derived from <xref:System.Enum?displayProperty=fullName>."}]},{"pos":[735,826],"content":"Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=fullName>.","nodes":[{"content":"Delegates, which are derived from <ph id=\"ph1\">&lt;xref:System.MulticastDelegate?displayProperty=fullName&gt;</ph>.","pos":[0,91],"source":"Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=fullName>."}]},{"pos":[833,1172],"content":"For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`. The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.","nodes":[{"content":"For two objects <ph id=\"ph1\">`x`</ph> and <ph id=\"ph2\">`y`</ph> that have identical runtime types, <ph id=\"ph3\">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> returns <ph id=\"ph4\">`true`</ph>.","pos":[0,128],"source":"For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`."},{"content":"The following example uses the <ph id=\"ph1\">&lt;xref:System.Object.GetType%2A&gt;</ph> method with the <ph id=\"ph2\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method to determine whether one numeric value is the same type as two other numeric values.","pos":[129,339],"source":" The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values."}]},{"pos":[1179,1438],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.GetType#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.GetType#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]\n[!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]"},{"pos":[1446,1667],"content":"[!NOTE]\n To determine whether an object is a specific type, you can use your language's type comparison keyword or construct. For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.","leadings":["","> "],"nodes":[{"content":" To determine whether an object is a specific type, you can use your language's type comparison keyword or construct. For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.","pos":[8,219],"nodes":[{"content":"To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.","pos":[1,117]},{"content":"For example, you can use the <ph id=\"ph1\">`TypeOf…Is`</ph> construct in Visual Basic or the <ph id=\"ph2\">`is`</ph> keyword in C#.","pos":[118,211],"source":" For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#."}]}]},{"pos":[1674,1992],"content":"The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>. This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.","nodes":[{"content":"The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>. This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.","pos":[0,318],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.GetType%2A&gt;</ph> method is inherited by all types that derive from <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[0,107],"source":"The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>."},{"content":"This means that, in addition to using your own language's comparison keyword, you can use the <ph id=\"ph1\">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine the type of a particular object, as the following example shows.","pos":[108,318],"source":" This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows."}]}]},{"pos":[1999,2262],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.GetType#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.GetType#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]\n [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]"},{"pos":[2269,2382],"content":"The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object exposes the metadata associated with the class of the current <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[0,113],"source":"The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>."}]}],"pos":[54922,57332],"yaml":true,"extradata":"MT"},{"content":"The exact runtime type of the current instance.","nodes":[{"pos":[0,47],"content":"The exact runtime type of the current instance.","nodes":[{"content":"The exact runtime type of the current instance.","pos":[0,47]}]}],"pos":[57999,58047],"yaml":true},{"content":"Creates a shallow copy of the current <xref href=\"System.Object\"></xref>.","nodes":[{"pos":[0,73],"content":"Creates a shallow copy of the current <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph>.","source":"Creates a shallow copy of the current <xref href=\"System.Object\"></xref>."}],"pos":[59513,59587],"yaml":true},{"content":"The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a value type, a bit-by-bit copy of the field is performed. If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.  \n  \n For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.  \n  \n There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs. These include the following:  \n  \n-   Call a class constructor of the object to be copied to create a second object with property values taken from the first object. This assumes that the values of an object are entirely defined by its class constructor.  \n  \n-   Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types. The `DeepCopy` method in the example illustrates this approach.  \n  \n-   Serialize the object to be deep copied, and then restore the serialized data to a different object variable.  \n  \n-   Use reflection with recursion to perform the deep copy operation.","nodes":[{"pos":[0,410],"content":"The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a value type, a bit-by-bit copy of the field is performed. If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.","nodes":[{"content":"The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a value type, a bit-by-bit copy of the field is performed. If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.","pos":[0,410],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.","pos":[0,178],"source":"The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object."},{"content":"If a field is a value type, a bit-by-bit copy of the field is performed.","pos":[179,251]},{"content":"If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.","pos":[252,410]}]}]},{"pos":[417,885],"content":"For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.","nodes":[{"content":"For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.","pos":[0,468]}]},{"pos":[892,1099],"content":"There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs. These include the following:","nodes":[{"content":"There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs. These include the following:","pos":[0,207],"nodes":[{"content":"There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <ph id=\"ph1\">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method does not meet your needs.","pos":[0,178],"source":"There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs."},{"content":"These include the following:","pos":[179,207]}]}]},{"pos":[1109,1325],"content":"Call a class constructor of the object to be copied to create a second object with property values taken from the first object. This assumes that the values of an object are entirely defined by its class constructor.","nodes":[{"content":"Call a class constructor of the object to be copied to create a second object with property values taken from the first object. This assumes that the values of an object are entirely defined by its class constructor.","pos":[0,216],"nodes":[{"content":"Call a class constructor of the object to be copied to create a second object with property values taken from the first object.","pos":[0,127]},{"content":"This assumes that the values of an object are entirely defined by its class constructor.","pos":[128,216]}]}]},{"pos":[1335,1632],"content":"Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types. The `DeepCopy` method in the example illustrates this approach.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.","pos":[0,233],"source":"Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types."},{"content":"The <ph id=\"ph1\">`DeepCopy`</ph> method in the example illustrates this approach.","pos":[234,297],"source":" The `DeepCopy` method in the example illustrates this approach."}]},{"pos":[1642,1750],"content":"Serialize the object to be deep copied, and then restore the serialized data to a different object variable.","nodes":[{"content":"Serialize the object to be deep copied, and then restore the serialized data to a different object variable.","pos":[0,108]}]},{"pos":[1760,1825],"content":"Use reflection with recursion to perform the deep copy operation.","nodes":[{"content":"Use reflection with recursion to perform the deep copy operation.","pos":[0,65]}]}],"pos":[59598,61438],"yaml":true,"extradata":"MT"},{"content":"A shallow copy of the current <xref href=\"System.Object\"></xref>.","nodes":[{"pos":[0,65],"content":"A shallow copy of the current <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph>.","source":"A shallow copy of the current <xref href=\"System.Object\"></xref>."}],"pos":[62897,62963],"yaml":true},{"content":"Determines whether the specified <xref href=\"System.Object\"></xref> instances are the same instance.","nodes":[{"pos":[0,100],"content":"Determines whether the specified <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> instances are the same instance.","source":"Determines whether the specified <xref href=\"System.Object\"></xref> instances are the same instance."}],"pos":[64566,64667],"yaml":true},{"content":"Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden. Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.  \n  \n However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:  \n  \n-   When comparing value types. If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method. This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.  \n  \n     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]\n     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  \n  \n     For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  \n  \n-   When comparing strings. If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned. It does not perform a test for value equality.  In the following example, `s1` and `s2` are equal because they are two instances of a single interned string. However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.  \n  \n     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]\n     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  \n  \n     For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=fullName>.","nodes":[{"pos":[0,353],"content":"Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden. Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.","nodes":[{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> method and the equality operator, the <ph id=\"ph2\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method cannot be overridden.","pos":[0,148],"source":"Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden."},{"content":"Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <ph id=\"ph1\">`Equals`</ph> method, you can call the <ph id=\"ph2\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.","pos":[149,353],"source":" Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method."}]},{"pos":[360,490],"content":"However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:","nodes":[{"content":"However, the return value of the <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method may appear to be anomalous in these two scenarios:","pos":[0,130],"source":"However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:"}]},{"pos":[500,858],"content":"When comparing value types. If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method. This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.","nodes":[{"content":"When comparing value types.","pos":[0,27]},{"content":"If <ph id=\"ph1\">`objA`</ph> and <ph id=\"ph2\">`objB`</ph> are value types, they are boxed before they are passed to the <ph id=\"ph3\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.","pos":[28,158],"source":" If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method."},{"content":"This means that if both <ph id=\"ph1\">`objA`</ph> and <ph id=\"ph2\">`objB`</ph> represent the same instance of a value type, the <ph id=\"ph3\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method nevertheless returns <ph id=\"ph4\">`false`</ph>, as the following example shows.","pos":[159,358],"source":" This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows."}]},{"pos":[869,1180],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.ReferenceEquals#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.ReferenceEquals#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]\n [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]"},{"pos":[1191,1318],"content":"For information on boxing value types, see <bpt id=\"p1\">[</bpt>Boxing and Unboxing<ept id=\"p1\">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.","source":"For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)."},{"pos":[1328,1759],"content":"When comparing strings. If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned. It does not perform a test for value equality.  In the following example, `s1` and `s2` are equal because they are two instances of a single interned string. However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.","nodes":[{"content":"When comparing strings.","pos":[0,23]},{"content":"If <ph id=\"ph1\">`objA`</ph> and <ph id=\"ph2\">`objB`</ph> are strings, the <ph id=\"ph3\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id=\"ph4\">`true`</ph> if the string is interned.","pos":[24,150],"source":" If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned."},{"content":"It does not perform a test for value equality.","pos":[151,197]},{"content":"In the following example, <ph id=\"ph1\">`s1`</ph> and <ph id=\"ph2\">`s2`</ph> are equal because they are two instances of a single interned string.","pos":[199,308],"source":"  In the following example, `s1` and `s2` are equal because they are two instances of a single interned string."},{"content":"However, <ph id=\"ph1\">`s3`</ph> and <ph id=\"ph2\">`s4`</ph> are not equal, because although they are have identical string values, that string is not interned.","pos":[309,431],"source":" However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned."}]},{"pos":[1770,2081],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.ReferenceEquals#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.ReferenceEquals#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]\n [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]"},{"pos":[2092,2201],"content":"For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=fullName>.","nodes":[{"content":"For more information about string interning, see <ph id=\"ph1\">&lt;xref:System.String.IsInterned%2A?displayProperty=fullName&gt;</ph>.","pos":[0,109],"source":"For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=fullName>."}]}],"pos":[64678,66898],"yaml":true,"extradata":"MT"},{"content":"The first object to compare.","nodes":[{"pos":[0,28],"content":"The first object to compare.","nodes":[{"content":"The first object to compare.","pos":[0,28]}]}],"pos":[67669,67698],"yaml":true},{"content":"The second object  to compare.","nodes":[{"pos":[0,30],"content":"The second object  to compare.","nodes":[{"content":"The second object  to compare.","pos":[0,30]}]}],"pos":[67758,67789],"yaml":true},{"content":"`true` if <code>objA</code> is the same instance as <code>objB</code> or if both are **null**; otherwise, `false`.","nodes":[{"pos":[0,114],"content":"<ph id=\"ph1\">`true`</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">objA</ph><ept id=\"p1\">&lt;/code&gt;</ept> is the same instance as <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">objB</ph><ept id=\"p2\">&lt;/code&gt;</ept> or if both are <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if <code>objA</code> is the same instance as <code>objB</code> or if both are **null**; otherwise, `false`."}],"pos":[67847,67964],"yaml":true},{"content":"Returns a string that represents the current object.","nodes":[{"pos":[0,52],"content":"Returns a string that represents the current object.","nodes":[{"content":"Returns a string that represents the current object.","pos":[0,52]}]}],"pos":[69413,69466],"yaml":true},{"content":"<xref:System.Object.ToString%2A?displayProperty=fullName> is the major formatting method in the .NET Framework. It converts an object to its string representation so that it is suitable for display. (For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=fullName> method return the fully qualified name of the object's type.  \n  \n> [!IMPORTANT]\n>  You may have reached this page by following the link from the member list of another type. That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=fullName>. Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=fullName> method.  \n  \n Types frequently override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide a more suitable string representation of a particular type. Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide support for format strings or culture-sensitive formatting.  \n  \n In this section:  \n  \n [The default Object.ToString() method](#Default)   \n [Overriding the Object.ToString() method](#Overriding)   \n [Overloading the ToString method](#Overloading)   \n [Extending the Object.ToString method](#Extending)   \n [Notes for the Windows Runtime](#WinRT)  \n  \n<a name=\"Default\"></a>   \n## The default Object.ToString() method  \n The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.  \n  \n [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]\n [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]\n [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  \n  \n Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method. The following example illustrates this. It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members. Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.  \n  \n [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]\n [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]\n [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  \n  \n<a name=\"Overriding\"></a>   \n## Overriding the Object.ToString() method  \n Types commonly override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return a string that represents the object instance. For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents. The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.  \n  \n [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]\n [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]\n [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  \n  \n The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=fullName> method.  \n  \n|Type category|Overrides Object.ToString()|Behavior|  \n|-------------------|-----------------------------------|--------------|  \n|Class|n/a|n/a|  \n|Structure|Yes (<xref:System.ValueType.ToString%2A?displayProperty=fullName>)|Same as Object.ToString()|  \n|Enumeration|Yes (<xref:System.Enum.ToString?displayProperty=fullName>)|The member name|  \n|Interface|No|n/a|  \n|Delegate|No|n/a|  \n  \n See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.  \n  \n<a name=\"Overloading\"></a>   \n## Overloading the ToString method  \n In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=fullName> method, many types overload the `ToString` method to provide versions of the method that accept parameters. Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.  \n  \n The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class. It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.  \n  \n [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]\n [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  \n  \n The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method to display culture-sensitive formatting of a currency value.  \n  \n [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]\n [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  \n  \n For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md). For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  \n  \n<a name=\"Extending\"></a>   \n## Extending the Object.ToString method  \n Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=fullName> method, you may find its behavior undesirable and want to change it. This is particularly true of arrays and collection classes. While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.  \n  \n [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]\n [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  \n  \n You have several options to produce the result string that you'd like.  \n  \n-   If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.  \n  \n-   If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=fullName> method you want to customize. At a minimum, this requires that you do the following:  \n  \n    1.  Implement any necessary constructors. Derived classes do not inherit their base class constructors.  \n  \n    2.  Override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return the result string that you'd like.  \n  \n     The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class. It overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method to display the value of each method of the collection rather than the fully qualified type name.  \n  \n     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]\n     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  \n  \n-   Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want. Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=fullName> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method. You'll have to provide some other name for your parameterless `ToString` replacement.  \n  \n     The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.  \n  \n     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]\n     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  \n  \n<a name=\"WinRT\"></a>   \n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \n When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>. However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.  \n  \n Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=fullName>.  \n  \n> [!NOTE]\n>  [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.  \n  \n### The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface  \n Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=fullName>. To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.  \n  \n When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=fullName> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.  \n  \n> [!WARNING]\n>  Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation. Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.  \n  \n If you do choose to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:  \n  \n-   You can define the [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a \"class implements\" relationship, such as  \n  \n    ```  \n    public class NewClass : IStringable  \n    ```  \n  \n     in C#, or  \n  \n    ```  \n    Public Class NewClass : Implements IStringable  \n    ```  \n  \n     in Visual Basic.  \n  \n-   You cannot implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.  \n  \n-   You cannot declare a parameter to be of type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  \n  \n-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.  \n  \n-   You cannot hide your [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:  \n  \n    ```  \n  \n    public class NewClass : IStringable  \n    {  \n       public new string ToString()  \n       {  \n          return \"New ToString in NewClass\";  \n       }  \n    }  \n  \n    ```  \n  \n     Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation. You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.  \n  \n Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.","nodes":[{"pos":[0,486],"content":"<xref:System.Object.ToString%2A?displayProperty=fullName> is the major formatting method in the .NET Framework. It converts an object to its string representation so that it is suitable for display. (For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=fullName> method return the fully qualified name of the object's type.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> is the major formatting method in the .NET Framework.","pos":[0,111],"source":"<xref:System.Object.ToString%2A?displayProperty=fullName> is the major formatting method in the .NET Framework."},{"content":"It converts an object to its string representation so that it is suitable for display.","pos":[112,198]},{"content":"(For information about formatting support in the .NET Framework, see <bpt id=\"p1\">[</bpt>Formatting Types<ept id=\"p1\">](~/docs/standard/base-types/formatting-types.md)</ept>.) Default implementations of the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method return the fully qualified name of the object's type.","pos":[199,486],"source":" (For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=fullName> method return the fully qualified name of the object's type."}]},{"pos":[494,815],"content":"[!IMPORTANT]\n You may have reached this page by following the link from the member list of another type. That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=fullName>. Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=fullName> method.","leadings":["","> "],"nodes":[{"content":" You may have reached this page by following the link from the member list of another type. That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=fullName>. Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=fullName> method.","pos":[13,319],"nodes":[{"content":"You may have reached this page by following the link from the member list of another type.","pos":[1,91]},{"content":"That is because that type does not override <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph>.","pos":[92,194],"source":" That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=fullName>."},{"content":"Instead, it inherits the functionality of the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method.","pos":[195,306],"source":" Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=fullName> method."}]}]},{"pos":[822,1158],"content":"Types frequently override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide a more suitable string representation of a particular type. Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide support for format strings or culture-sensitive formatting.","nodes":[{"content":"Types frequently override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide a more suitable string representation of a particular type. Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide support for format strings or culture-sensitive formatting.","pos":[0,336],"nodes":[{"content":"Types frequently override the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to provide a more suitable string representation of a particular type.","pos":[0,165],"source":"Types frequently override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide a more suitable string representation of a particular type."},{"content":"Types also frequently overload the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to provide support for format strings or culture-sensitive formatting.","pos":[166,336],"source":" Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide support for format strings or culture-sensitive formatting."}]}]},{"pos":[1165,1181],"content":"In this section:","nodes":[{"content":"In this section:","pos":[0,16]}]},{"pos":[1188,1446],"content":"[The default Object.ToString() method](#Default)   \n [Overriding the Object.ToString() method](#Overriding)   \n [Overloading the ToString method](#Overloading)   \n [Extending the Object.ToString method](#Extending)   \n [Notes for the Windows Runtime](#WinRT)","nodes":[{"content":"<bpt id=\"p1\">[</bpt>The default Object.ToString() method<ept id=\"p1\">](#Default)</ept><ph id=\"ph1\"> </ph>","pos":[0,49],"source":"[The default Object.ToString() method](#Default) "},{"content":"<bpt id=\"p1\"> [</bpt>Overriding the Object.ToString() method<ept id=\"p1\">](#Overriding)</ept><ph id=\"ph1\"> </ph>","pos":[52,108],"source":" [Overriding the Object.ToString() method](#Overriding) "},{"content":"<bpt id=\"p1\"> [</bpt>Overloading the ToString method<ept id=\"p1\">](#Overloading)</ept><ph id=\"ph1\"> </ph>","pos":[111,160],"source":" [Overloading the ToString method](#Overloading) "},{"content":"<bpt id=\"p1\"> [</bpt>Extending the Object.ToString method<ept id=\"p1\">](#Extending)</ept><ph id=\"ph1\"> </ph>","pos":[163,215],"source":" [Extending the Object.ToString method](#Extending) "},{"content":"<bpt id=\"p1\"> [</bpt>Notes for the Windows Runtime<ept id=\"p1\">](#WinRT)</ept>","pos":[218,258],"source":" [Notes for the Windows Runtime](#WinRT)"}]},{"pos":[1481,1517],"content":"The default Object.ToString() method","linkify":"The default Object.ToString() method","nodes":[{"content":"The default Object.ToString() method","pos":[0,36]}]},{"pos":[1521,1700],"content":"The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.","nodes":[{"content":"The default implementation of the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the fully qualified name of the type of the <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, as the following example shows.","pos":[0,179],"source":"The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows."}]},{"pos":[1707,2101],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#1<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#1<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Object.ToString#1<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]\n [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]\n [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]"},{"pos":[2108,2556],"content":"Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method. The following example illustrates this. It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members. Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.","nodes":[{"content":"Because <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A&gt;</ph> method.","pos":[0,204],"source":"Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method."},{"content":"The following example illustrates this.","pos":[205,244]},{"content":"It defines a class named <ph id=\"ph1\">`Object1`</ph> that accepts the default implementation of all <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> members.","pos":[245,356],"source":" It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members."},{"content":"Its <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the object's fully qualified type name.","pos":[357,448],"source":" Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name."}]},{"pos":[2563,2957],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#2<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#2<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Object.ToString#2<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]\n [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]\n [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]"},{"pos":[2995,3034],"content":"Overriding the Object.ToString() method","linkify":"Overriding the Object.ToString() method","nodes":[{"content":"Overriding the Object.ToString() method","pos":[0,39]}]},{"pos":[3038,3569],"content":"Types commonly override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return a string that represents the object instance. For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents. The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.","nodes":[{"content":"Types commonly override the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to return a string that represents the object instance.","pos":[0,148],"source":"Types commonly override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return a string that represents the object instance."},{"content":"For example, the base types such as <ph id=\"ph1\">&lt;xref:System.Char&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.String&gt;</ph> provide <ph id=\"ph4\">&lt;xref:System.Object.ToString%2A&gt;</ph> implementations that return the string form of the value that the object represents.","pos":[149,376],"source":" For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents."},{"content":"The following example defines a class, <ph id=\"ph1\">`Object2`</ph>, that overrides the <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A&gt;</ph> method to return the type name along with its value.","pos":[377,531],"source":" The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value."}]},{"pos":[3576,3970],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#3<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#3<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Object.ToString#3<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]\n [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]\n [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]"},{"pos":[3977,4157],"content":"The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=fullName> method.","nodes":[{"content":"The following table lists the type categories in the .NET Framework and indicates whether or not they override the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method.","pos":[0,180],"source":"The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=fullName> method."}]},{"pos":[4164,4177],"content":"Type category","nodes":[{"content":"Type category","pos":[0,13]}]},{"pos":[4178,4205],"content":"Overrides Object.ToString()","nodes":[{"content":"Overrides Object.ToString()","pos":[0,27]}]},{"pos":[4206,4214],"content":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"pos":[4294,4299],"content":"Class","nodes":[{"content":"Class","pos":[0,5]}]},{"pos":[4300,4303],"content":"n/a","nodes":[{"content":"n/a","pos":[0,3]}]},{"pos":[4304,4307],"content":"n/a","nodes":[{"content":"n/a","pos":[0,3]}]},{"pos":[4312,4321],"content":"Structure","nodes":[{"content":"Structure","pos":[0,9]}]},{"pos":[4322,4388],"content":"Yes (<xref:System.ValueType.ToString%2A?displayProperty=fullName>)","nodes":[{"content":"Yes (<ph id=\"ph1\">&lt;xref:System.ValueType.ToString%2A?displayProperty=fullName&gt;</ph>)","pos":[0,66],"source":"Yes (<xref:System.ValueType.ToString%2A?displayProperty=fullName>)"}]},{"pos":[4389,4414],"content":"Same as Object.ToString()","nodes":[{"content":"Same as Object.ToString()","pos":[0,25]}]},{"pos":[4419,4430],"content":"Enumeration","nodes":[{"content":"Enumeration","pos":[0,11]}]},{"pos":[4431,4489],"content":"Yes (<xref:System.Enum.ToString?displayProperty=fullName>)","nodes":[{"content":"Yes (<ph id=\"ph1\">&lt;xref:System.Enum.ToString?displayProperty=fullName&gt;</ph>)","pos":[0,58],"source":"Yes (<xref:System.Enum.ToString?displayProperty=fullName>)"}]},{"pos":[4490,4505],"content":"The member name","nodes":[{"content":"The member name","pos":[0,15]}]},{"pos":[4510,4519],"content":"Interface","nodes":[{"content":"Interface","pos":[0,9]}]},{"pos":[4520,4522],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[4523,4526],"content":"n/a","nodes":[{"content":"n/a","pos":[0,3]}]},{"pos":[4531,4539],"content":"Delegate","nodes":[{"content":"Delegate","pos":[0,8]}]},{"pos":[4540,4542],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[4543,4546],"content":"n/a","nodes":[{"content":"n/a","pos":[0,3]}]},{"pos":[4554,4664],"content":"See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.","nodes":[{"content":"See the Notes to Inheritors section for additional information on overriding <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph>.","pos":[0,110],"source":"See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>."}]},{"pos":[4703,4734],"content":"Overloading the ToString method","linkify":"Overloading the ToString method","nodes":[{"content":"Overloading the ToString method","pos":[0,31]}]},{"pos":[4738,5049],"content":"In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=fullName> method, many types overload the `ToString` method to provide versions of the method that accept parameters. Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.","nodes":[{"content":"In addition to overriding the parameterless <ph id=\"ph1\">&lt;xref:System.Object.ToString?displayProperty=fullName&gt;</ph> method, many types overload the <ph id=\"ph2\">`ToString`</ph> method to provide versions of the method that accept parameters.","pos":[0,206],"source":"In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=fullName> method, many types overload the `ToString` method to provide versions of the method that accept parameters."},{"content":"Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.","pos":[207,311]}]},{"pos":[5056,5459],"content":"The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class. It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.","nodes":[{"content":"The following example overloads the <ph id=\"ph1\">`ToString`</ph> method to return a result string that includes the value of various fields of an <ph id=\"ph2\">`Automobile`</ph> class.","pos":[0,147],"source":"The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class."},{"content":"It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.","pos":[148,403]}]},{"pos":[5466,5747],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]\n [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]"},{"pos":[5754,5964],"content":"The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method to display culture-sensitive formatting of a currency value.","nodes":[{"content":"The following example calls the overloaded <ph id=\"ph1\">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method to display culture-sensitive formatting of a currency value.","pos":[0,210],"source":"The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method to display culture-sensitive formatting of a currency value."}]},{"pos":[5971,6252],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#5<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#5<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]\n [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]"},{"pos":[6259,6935],"content":"For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md). For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).","nodes":[{"content":"For more information on format strings and culture-sensitive formatting, see <bpt id=\"p1\">[</bpt>Formatting Types<ept id=\"p1\">](~/docs/standard/base-types/formatting-types.md)</ept>.","pos":[0,144],"source":"For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md)."},{"content":"For the format strings supported by numeric values, see <bpt id=\"p1\">[</bpt>Standard Numeric Format Strings<ept id=\"p1\">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id=\"p2\">[</bpt>Custom Numeric Format Strings<ept id=\"p2\">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.","pos":[145,395],"source":" For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)."},{"content":"For the format strings supported by date and time values, see <bpt id=\"p1\">[</bpt>Standard Date and Time Format Strings<ept id=\"p1\">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id=\"p2\">[</bpt>Custom Date and Time Format Strings<ept id=\"p2\">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.","pos":[396,676],"source":" For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md)."}]},{"pos":[6972,7008],"content":"Extending the Object.ToString method","linkify":"Extending the Object.ToString method","nodes":[{"content":"Extending the Object.ToString method","pos":[0,36]}]},{"pos":[7012,7435],"content":"Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=fullName> method, you may find its behavior undesirable and want to change it. This is particularly true of arrays and collection classes. While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.","nodes":[{"content":"Because a type inherits the default <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method, you may find its behavior undesirable and want to change it.","pos":[0,162],"source":"Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=fullName> method, you may find its behavior undesirable and want to change it."},{"content":"This is particularly true of arrays and collection classes.","pos":[163,222]},{"content":"While you may expect the <ph id=\"ph1\">`ToString`</ph> method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.","pos":[223,423],"source":" While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows."}]},{"pos":[7442,7701],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#6<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#6<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]\n [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]"},{"pos":[7708,7778],"content":"You have several options to produce the result string that you'd like.","nodes":[{"content":"You have several options to produce the result string that you'd like.","pos":[0,70]}]},{"pos":[7788,8091],"content":"If the type is an array, a collection object, or an object that implements the <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, you can enumerate its elements by using the <ph id=\"ph3\">`foreach`</ph> statement in C# or the <ph id=\"ph4\">`For Each...Next`</ph> construct in Visual Basic.","source":"If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic."},{"pos":[8101,8391],"content":"If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=fullName> method you want to customize. At a minimum, this requires that you do the following:","nodes":[{"content":"If the class is not <ph id=\"ph1\">`sealed`</ph> (in C#) or <ph id=\"ph2\">`NotInheritable`</ph> (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <ph id=\"ph3\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method you want to customize.","pos":[0,235],"source":"If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=fullName> method you want to customize."},{"content":"At a minimum, this requires that you do the following:","pos":[236,290]}]},{"pos":[8405,8504],"content":"Implement any necessary constructors. Derived classes do not inherit their base class constructors.","nodes":[{"content":"Implement any necessary constructors. Derived classes do not inherit their base class constructors.","pos":[0,99],"nodes":[{"content":"Implement any necessary constructors.","pos":[0,37]},{"content":"Derived classes do not inherit their base class constructors.","pos":[38,99]}]}]},{"pos":[8518,8640],"content":"Override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return the result string that you'd like.","nodes":[{"content":"Override the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to return the result string that you'd like.","pos":[0,122],"source":"Override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return the result string that you'd like."}]},{"pos":[8651,8933],"content":"The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class. It overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method to display the value of each method of the collection rather than the fully qualified type name.","nodes":[{"content":"The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class. It overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method to display the value of each method of the collection rather than the fully qualified type name.","pos":[0,282],"nodes":[{"content":"The following example defines a wrapper class for the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.","pos":[0,103],"source":"The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class."},{"content":"It overrides the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to display the value of each method of the collection rather than the fully qualified type name.","pos":[104,282],"source":" It overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method to display the value of each method of the collection rather than the fully qualified type name."}]}]},{"pos":[8944,9215],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#7<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#7<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)</ept><ept id=\"p3\">]</ept>","leadings":["","     "],"source":"[!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]\n[!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]"},{"pos":[9225,9745],"content":"Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want. Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=fullName> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method. You'll have to provide some other name for your parameterless `ToString` replacement.","nodes":[{"content":"Develop an <bpt id=\"p1\">[</bpt>extension method<ept id=\"p1\">](~/docs/standard/design-guidelines/extension-methods.md)</ept> that returns the result string that you want.","pos":[0,131],"source":"Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want."},{"content":"Note that you can't override the default <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named <ph id=\"ph2\">`ToString`</ph> that is called in place of the original type's <ph id=\"ph3\">`ToString`</ph> method.","pos":[132,434],"source":" Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=fullName> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method."},{"content":"You'll have to provide some other name for your parameterless <ph id=\"ph1\">`ToString`</ph> replacement.","pos":[435,520],"source":" You'll have to provide some other name for your parameterless `ToString` replacement."}]},{"pos":[9756,9994],"content":"The following example defines two methods that extend the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class: a parameterless <ph id=\"ph2\">`ToString2`</ph> method, and a <ph id=\"ph3\">`ToString`</ph> method with a <ph id=\"ph4\">&lt;xref:System.String&gt;</ph> parameter that represents a format string.","source":"The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string."},{"pos":[10005,10276],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Object.ToString#8<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Object.ToString#8<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]\n [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]"},{"pos":[10309,10360],"content":"Notes for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>","linkify":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]","source":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]"},{"pos":[10364,11284],"content":"When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>. However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph> method on a class in the <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id=\"ph3\">&lt;xref:System.Object.ToString%2A&gt;</ph>.","pos":[0,213],"source":"When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>."},{"content":"This is part of the support that the .NET Framework provides for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id=\"p1\">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id=\"p1\">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).","pos":[214,481],"source":" This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))."},{"content":"Classes in the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>, and don’t always implement a <ph id=\"ph3\">&lt;xref:System.Object.ToString%2A&gt;</ph>.","pos":[482,633],"source":" Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>."},{"content":"However, they always appear to have <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.","pos":[634,920],"source":" However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods."}]},{"pos":[11291,11672],"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, the common language runtime will use <bpt id=\"p1\">[</bpt>IStringable.ToString<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> on a <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object before falling back to the default implementation of <ph id=\"ph3\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph>.","source":"Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=fullName>."},{"pos":[11680,11833],"content":"[!NOTE]\n [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> [!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A&gt;</ph> method.","pos":[8,151],"source":" [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method."}]},{"pos":[11843,11914],"content":"The <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> and the IStringable Interface","linkify":"The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface","source":"The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface"},{"pos":[11918,12561],"content":"Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=fullName>. To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.","nodes":[{"content":"Starting with <ph id=\"ph1\">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> includes an <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface whose single method, <bpt id=\"p2\">[</bpt>IStringable.ToString<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, provides basic formatting support comparable to that provided by <ph id=\"ph3\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph>.","pos":[0,480],"source":"Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=fullName>."},{"content":"To prevent ambiguity, you should not implement <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on managed types.","pos":[481,643],"source":" To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types."}]},{"pos":[12568,13194],"content":"When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=fullName> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.","nodes":[{"content":"When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.","pos":[0,232],"source":"When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)."},{"content":"The common language runtime will automatically route calls from <bpt id=\"p1\">[</bpt>IStringable.ToString<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> to <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> in the event <bpt id=\"p2\">[</bpt>IStringable<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> is not implemented on the managed object.","pos":[233,626],"source":" The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=fullName> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object."}]},{"pos":[13202,13864],"content":"[!WARNING]\n Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation. Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.","leadings":["","> "],"nodes":[{"content":" Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation. Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.","pos":[11,660],"nodes":[{"content":"Because the common language runtime auto-implements <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> for all managed types in <ph id=\"ph1\">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, we recommend that you do not provide your own <bpt id=\"p2\">[</bpt>IStringable<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation.","pos":[1,409],"source":" Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation."},{"content":"Implementing <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> may result in unintended behavior when calling <ph id=\"ph1\">`ToString`</ph> from the <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++/CX, or JavaScript.","pos":[410,649],"source":" Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript."}]}]},{"pos":[13871,14128],"content":"If you do choose to implement <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in a public managed type that is exported in a <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> component, the following restrictions apply:","source":"If you do choose to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:"},{"pos":[14138,14315],"content":"You can define the <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface only in a \"class implements\" relationship, such as","source":"You can define the [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a \"class implements\" relationship, such as"},{"pos":[14391,14400],"content":"in C#, or","nodes":[{"content":"in C#, or","pos":[0,9]}]},{"pos":[14487,14503],"content":"in Visual Basic.","nodes":[{"content":"in Visual Basic.","pos":[0,16]}]},{"pos":[14513,14648],"content":"You cannot implement <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on an interface.","source":"You cannot implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface."},{"pos":[14658,14801],"content":"You cannot declare a parameter to be of type <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.","source":"You cannot declare a parameter to be of type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)."},{"pos":[14811,14967],"content":"<bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> cannot be the return type of a method, property, or field.","source":"[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field."},{"pos":[14977,15180],"content":"You cannot hide your <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation from base classes by using a method definition such as the following:","source":"You cannot hide your [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:"},{"pos":[15385,15677],"content":"Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation. You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.","nodes":[{"content":"Instead, the <bpt id=\"p1\">[</bpt>IStringable.ToString<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation must always override the base class implementation.","pos":[0,195],"source":"Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation."},{"content":"You can hide a <ph id=\"ph1\">`ToString`</ph> implementation only by invoking it on a strongly typed class instance.","pos":[196,292],"source":" You can hide a `ToString` implementation only by invoking it on a strongly typed class instance."}]},{"pos":[15684,16044],"content":"Note that under a variety of conditions, calls from native code to a managed type that implements <bpt id=\"p1\">[</bpt>IStringable<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> or hides its <bpt id=\"p2\">[</bpt>ToString<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation can produce unexpected behavior.","source":"Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior."}],"pos":[69477,85687],"yaml":true,"extradata":"MT"},{"content":"A string that represents the current object.","nodes":[{"pos":[0,44],"content":"A string that represents the current object.","nodes":[{"content":"A string that represents the current object.","pos":[0,44]}]}],"pos":[85821,85866],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Object\n  commentId: T:System.Object\n  id: Object\n  children:\n  - System.Object.#ctor\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.Finalize\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  langs:\n  - csharp\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n  type: Class\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.\n  remarks: \"> [!NOTE]\\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \\n  \\n Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.  \\n  \\n Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system. Derived classes can and do override some of these methods, including:  \\n  \\n-   <xref:System.Object.Equals%2A> - Supports comparisons between objects.  \\n  \\n-   <xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.  \\n  \\n-   <xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.  \\n  \\n-   <xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.  \\n  \\n## Performance Considerations  \\n If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class. However, the process of boxing and unboxing a type carries a performance cost. If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.  \\n  \\n-   Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle. If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked. If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.  \\n  \\n-   Design your type and its members to use generics. The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument. The generic method is type-specific and can be invoked without boxing the calling parameter.  \\n  \\n Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type. For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.\"\n  example:\n  - \"The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class. In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.  \\n  \\n [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]\\n [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]\\n [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)]\n\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class Object\n  implements: []\n  attributes:\n  - type: System.Runtime.InteropServices.ClassInterfaceAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.#ctor\n  commentId: M:System.Object.#ctor\n  id: '#ctor'\n  parent: System.Object\n  langs:\n  - csharp\n  name: Object()\n  nameWithType: Object.Object()\n  fullName: Object.Object()\n  type: Constructor\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Initializes a new instance of the <xref href=\"System.Object\"></xref> class.\n  remarks: This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.\n  syntax:\n    content: public Object ();\n    parameters: []\n  overload: System.Object.#ctor*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.Equals(System.Object)\n  commentId: M:System.Object.Equals(System.Object)\n  id: Equals(System.Object)\n  parent: System.Object\n  langs:\n  - csharp\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Determines whether the specified object is equal to the current object.\n  remarks: \"The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.  \\n  \\n-   If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method. Reference equality means that the object variables that are compared refer to the same object. The following example illustrates the result of such a comparison. It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value. It also assigns `person1a` to another object variable, `person1b`. As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object. However, `person1a` and `person2` are not equal, although they have the same value.  \\n  \\n     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]\\n     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  \\n  \\n-   If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality. Value equality means the following:  \\n  \\n    -   The two objects are of the same type. As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.  \\n  \\n         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]\\n         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  \\n  \\n    -   The values of the public and private fields of the two objects are equal. The following example tests for value equality. It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value. As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.  \\n  \\n         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]\\n         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  \\n  \\n Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method provides the default equality comparison for all other types. However, types often override the <xref:System.Object.Equals%2A> method to implement value equality. For more information, see the Notes for Callers and Notes for Inheritors sections.  \\n  \\n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \\n When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29>method. However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.  \\n  \\n> [!NOTE]\\n>  [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.  \\n  \\n## Notes for Callers  \\n Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to implement value equality. In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface. When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=fullName> and understand how a particular call to an `Equals` method is resolved. Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.  \\n  \\n The following example provides an illustration. It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods. The first method call returns `true`, and the remaining three return `false`.  \\n  \\n [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]\\n [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  \\n  \\n In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=fullName> method overload, which tests for value equality, is called. Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`. However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>. Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=fullName> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method is called. Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method. Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects. As a result, these three method calls return `false`.  \\n  \\n You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method. In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).  \\n  \\n## Notes for Inheritors  \\n When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type. The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.  \\n  \\n|Type category|Equality defined by|Comments|  \\n|-------------------|-------------------------|--------------|  \\n|Class derived directly from <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>|Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>.|  \\n|Structure|<xref:System.ValueType.Equals%2A?displayProperty=fullName>|Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.|  \\n|Enumeration|<xref:System.Enum.Equals%2A?displayProperty=fullName>|Values must have the same enumeration type and the same underlying value.|  \\n|Delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=fullName>|Delegates must have the same type with identical invocation lists.|  \\n|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>|Reference equality.|  \\n  \\n For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance. You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality. Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance. The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object. For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=fullName> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to return `true` for any two string instances that contain the same characters in the same order.  \\n  \\n The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method to test for value equality. It overrides the <xref:System.Object.Equals%2A> method for the `Person` class. If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object. However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.  \\n  \\n [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]\\n [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  \\n  \\n In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.  \\n  \\n The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method. In the list, `x`, `y`, and `z` represent object references that are not **null**.  \\n  \\n-   `x.Equals(x)` returns `true`, except in cases that involve floating-point types. See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.  \\n  \\n-   `x.Equals(y)` returns the same value as `y.Equals(x)`.  \\n  \\n-   `x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.  \\n  \\n-   If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.  \\n  \\n-   Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.  \\n  \\n-   `x.Equals(null)` returns `false`.  \\n  \\n Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value. For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.  \\n  \\n Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:  \\n  \\n-   Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.  \\n  \\n-   Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.  \\n  \\n-   You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality. Your <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.  \\n  \\n-   If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator. This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.  \\n  \\n### Guidelines for Reference Types  \\n The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:  \\n  \\n-   Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).  \\n  \\n-   Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>. However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.  \\n  \\n-   You should not override <xref:System.Object.Equals%2A> on a mutable reference type. This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section. This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.  \\n  \\n### Guidelines for Value Types  \\n The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:  \\n  \\n-   If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>. The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.  \\n  \\n-   If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.  \\n  \\n-   You should implement the <xref:System.IEquatable%601> interface. Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> method avoids boxing the `obj` argument.\"\n  example:\n  - \"The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`. Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method is not called. However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> in a manner that provides value equality.  \\n  \\n [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]\\n [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  \\n  \\n The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object. If either check fails, the method returns `false`.  \\n  \\n The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical. If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type. Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.  \\n  \\n In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>, is invoked before anything else is done. Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object. If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>. Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.  \\n  \\n The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects. The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> to provide for value equality.  \\n  \\n [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]\\n [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  \\n  \\n Some languages such as C# and Visual Basic support operator overloading. When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality. This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.  \\n  \\n [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]\\n [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  \\n  \\n Because `Complex` is a value type, it cannot be derived from.  Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.\"\n  syntax:\n    content: public virtual bool Equals (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object to compare with the current object.\n    return:\n      type: System.Boolean\n      description: '`true` if the specified object  is equal to the current object; otherwise, `false`.'\n  overload: System.Object.Equals*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.Equals(System.Object,System.Object)\n  commentId: M:System.Object.Equals(System.Object,System.Object)\n  id: Equals(System.Object,System.Object)\n  parent: System.Object\n  langs:\n  - csharp\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Determines whether the specified object instances are considered equal.\n  remarks: \"The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal. It also enables you to test objects whose value is **null** for equality. It compares `objA` and `objB` for equality as follows:  \\n  \\n-   It determines whether the two objects represent the same object reference. If they do, the method returns `true`. This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method. In addition, if both `objA` and `objB` are **null**, the method returns `true`.  \\n  \\n-   It determines whether either `objA` or `objB` is **null**. If so, it returns `false`.  \\n  \\n-   If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result. This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method, this override is called.\"\n  example:\n  - \"The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.  \\n  \\n [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]\\n [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]\"\n  syntax:\n    content: public static bool Equals (object objA, object objB);\n    parameters:\n    - id: objA\n      type: System.Object\n      description: The first object to compare.\n    - id: objB\n      type: System.Object\n      description: The second object to compare.\n    return:\n      type: System.Boolean\n      description: '`true` if the objects are considered equal; otherwise, `false`. If both <code>objA</code> and <code>objB</code> are **null**, the method returns `true`.'\n  overload: System.Object.Equals*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.Finalize\n  commentId: M:System.Object.Finalize\n  id: Finalize\n  parent: System.Object\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: Object.Finalize()\n  fullName: Object.Finalize()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.\n  remarks: \"The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed. The method is protected and therefore is accessible only through this class or through a derived class.  \\n  \\n In this section:  \\n  \\n-   [How finalization works](#How)  \\n  \\n-   [Notes for implementers](#Notes)  \\n  \\n-   [The SafeHandle alternative](#SafeHandle)  \\n  \\n<a name=\\\"How\\\"></a>   \\n## How finalization works  \\n The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.  \\n  \\n If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue. The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory. The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:  \\n  \\n-   After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  \\n  \\n-   During shutdown of an application domain, unless the object is exempt from finalization. During shutdown, even objects that are still accessible are finalized.  \\n  \\n <xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=fullName> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method has not been subsequently called.  \\n  \\n <xref:System.Object.Finalize%2A> operations have the following limitations:  \\n  \\n-   The exact time when the finalizer executes is undefined. To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation.  \\n  \\n-   The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other. That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.  \\n  \\n-   The thread on which the finalizer runs is unspecified.  \\n  \\n The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:  \\n  \\n-   If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on). Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.  \\n  \\n-   If the process terminates without giving the runtime a chance to clean up. In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.  \\n  \\n The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.  \\n  \\n If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed. This behavior ensures process integrity if the finalizer cannot free or destroy resources.  \\n  \\n<a name=\\\"Notes\\\"></a>   \\n## Notes for implementers  \\n You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.  \\n  \\n> [!IMPORTANT]\\n>  If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>. For more information, see [The SafeHandle alternative](#SafeHandle) section.  \\n  \\n The <xref:System.Object.Finalize%2A?displayProperty=fullName> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources. Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections. In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only. The common language runtime only finalizes reference types. It ignores finalizers on value types.  \\n  \\n Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>. This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.  \\n  \\n> [!NOTE]\\n>  The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method. Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class. A C# destructor automatically calls the destructor of its base class.  \\n>   \\n>  Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method. For more information, see the \\\"Destructors and finalizers\\\" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  \\n  \\n Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization. To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface. The <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.  \\n  \\n <xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection. However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection. There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.  \\n  \\n<a name=\\\"SafeHandle\\\"></a>   \\n## The SafeHandle alternative  \\n Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer. Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer. The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=fullName> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>:  \\n  \\n-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.  \\n  \\n-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.  \\n  \\n-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.  \\n  \\n-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.  \\n  \\n-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.  \\n  \\n-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.  \\n  \\n-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.  \\n  \\n The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method. It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension. The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor. The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.  \\n  \\n [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]\\n [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]\"\n  example:\n  - \"The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed. Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object. Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.  \\n  \\n [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]\\n [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  \\n  \\n For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.\"\n  syntax:\n    content: ~Object ();\n    parameters: []\n  overload: System.Object.Finalize*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.GetHashCode\n  commentId: M:System.Object.GetHashCode\n  id: GetHashCode\n  parent: System.Object\n  langs:\n  - csharp\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Serves as the default hash function.\n  remarks: \"A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class. The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.  \\n  \\n> [!NOTE]\\n>  For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](http://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.  \\n  \\n Two objects that are equal return hash codes that are equal. However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes. Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms. For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes. Two consequences follow from this:  \\n  \\n-   You should not assume that equal hash codes imply object equality.  \\n  \\n-   You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.  \\n  \\n> [!WARNING]\\n>  A hash code is intended for efficient insertion and lookup in collections that are based on a hash table. A hash code is not a permanent value. For this reason:  \\n>   \\n>  -   Do not serialize hash code values or store them in databases.  \\n> -   Do not use the hash code as the key to retrieve an object from a keyed collection.  \\n> -   Do not send hash codes across application domains or processes. In some cases, hash codes may be computed on a per-process or per-application domain basis.  \\n> -   Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName> class.  \\n> -   Do not test for equality of hash codes to determine whether two objects are equal. (Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.  \\n  \\n The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type. If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName>. In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes. If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=fullName> method of the base class uses reflection to compute the hash code based on the values of the type's fields. In other words, value types whose fields have equal values have equal hash codes. For more information about overriding <xref:System.Object.GetHashCode%2A>, see the \\\"Notes to Inheritors\\\" section.  \\n  \\n> [!WARNING]\\n>  If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa. If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.  \\n  \\n If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.  \\n  \\n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \\n When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>. However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.  \\n  \\n> [!NOTE]\\n>  [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.\"\n  example:\n  - \"One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value. The following example shows such an implementation for a `Number` structure.  \\n  \\n [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]\\n [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  \\n  \\n Frequently, a type has multiple data fields that can participate in generating the hash code. One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.  \\n  \\n [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]\\n [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  \\n  \\n The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable. A number of solutions are available so that hash codes in these cases are not identical. One is to return the hash code of a `Tuple` object that reflects the order of each field. The following example shows a possible implementation that uses the <xref:System.Tuple%602> class. Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.  \\n  \\n [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]\\n [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  \\n  \\n A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits. Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded. Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:  \\n  \\n [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]\\n [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  \\n  \\n The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.  \\n  \\n [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]\\n [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]\"\n  syntax:\n    content: public virtual int GetHashCode ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: A hash code for the current object.\n  overload: System.Object.GetHashCode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.GetType\n  commentId: M:System.Object.GetType\n  id: GetType\n  parent: System.Object\n  langs:\n  - csharp\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the <xref href=\"System.Type\"></xref> of the current instance.\n  remarks: \"Because <xref:System.Object?displayProperty=fullName> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types. The .NET Framework recognizes the following five categories of types:  \\n  \\n-   Classes, which are derived from <xref:System.Object?displayProperty=fullName>,  \\n  \\n-   Value types, which are derived from <xref:System.ValueType?displayProperty=fullName>.  \\n  \\n-   Interfaces, which are derived from <xref:System.Object?displayProperty=fullName> starting with the .NET Framework 2.0.  \\n  \\n-   Enumerations, which are derived from <xref:System.Enum?displayProperty=fullName>.  \\n  \\n-   Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=fullName>.  \\n  \\n For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`. The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.  \\n  \\n [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]\\n [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  \\n  \\n> [!NOTE]\\n>  To determine whether an object is a specific type, you can use your language's type comparison keyword or construct. For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.  \\n  \\n The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>. This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.  \\n  \\n [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]\\n [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  \\n  \\n The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.\"\n  example:\n  - \"The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.  \\n  \\n [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]\\n [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]\\n [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]\"\n  syntax:\n    content: public Type GetType ();\n    parameters: []\n    return:\n      type: System.Type\n      description: The exact runtime type of the current instance.\n  overload: System.Object.GetType*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.MemberwiseClone\n  commentId: M:System.Object.MemberwiseClone\n  id: MemberwiseClone\n  parent: System.Object\n  langs:\n  - csharp\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Creates a shallow copy of the current <xref href=\"System.Object\"></xref>.\n  remarks: \"The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a value type, a bit-by-bit copy of the field is performed. If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.  \\n  \\n For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.  \\n  \\n There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs. These include the following:  \\n  \\n-   Call a class constructor of the object to be copied to create a second object with property values taken from the first object. This assumes that the values of an object are entirely defined by its class constructor.  \\n  \\n-   Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types. The `DeepCopy` method in the example illustrates this approach.  \\n  \\n-   Serialize the object to be deep copied, and then restore the serialized data to a different object variable.  \\n  \\n-   Use reflection with recursion to perform the deep copy operation.\"\n  example:\n  - \"The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method. It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object. It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.  \\n  \\n [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]\\n [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  \\n  \\n In this example, the `Person.IdInfo` property returns an `IdInfo` object. As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference. As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property. On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.\"\n  syntax:\n    content: protected object MemberwiseClone ();\n    parameters: []\n    return:\n      type: System.Object\n      description: A shallow copy of the current <xref href=\"System.Object\"></xref>.\n  overload: System.Object.MemberwiseClone*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)\n  id: ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  langs:\n  - csharp\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Determines whether the specified <xref href=\"System.Object\"></xref> instances are the same instance.\n  remarks: \"Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden. Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.  \\n  \\n However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:  \\n  \\n-   When comparing value types. If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method. This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.  \\n  \\n     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]\\n     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  \\n  \\n     For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  \\n  \\n-   When comparing strings. If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned. It does not perform a test for value equality.  In the following example, `s1` and `s2` are equal because they are two instances of a single interned string. However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.  \\n  \\n     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]\\n     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  \\n  \\n     For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=fullName>.\"\n  example:\n  - \"The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.  \\n  \\n [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]\\n [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]\\n [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]\"\n  syntax:\n    content: public static bool ReferenceEquals (object objA, object objB);\n    parameters:\n    - id: objA\n      type: System.Object\n      description: The first object to compare.\n    - id: objB\n      type: System.Object\n      description: The second object  to compare.\n    return:\n      type: System.Boolean\n      description: '`true` if <code>objA</code> is the same instance as <code>objB</code> or if both are **null**; otherwise, `false`.'\n  overload: System.Object.ReferenceEquals*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Object.ToString\n  commentId: M:System.Object.ToString\n  id: ToString\n  parent: System.Object\n  langs:\n  - csharp\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a string that represents the current object.\n  remarks: \"<xref:System.Object.ToString%2A?displayProperty=fullName> is the major formatting method in the .NET Framework. It converts an object to its string representation so that it is suitable for display. (For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=fullName> method return the fully qualified name of the object's type.  \\n  \\n> [!IMPORTANT]\\n>  You may have reached this page by following the link from the member list of another type. That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=fullName>. Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=fullName> method.  \\n  \\n Types frequently override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide a more suitable string representation of a particular type. Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=fullName> method to provide support for format strings or culture-sensitive formatting.  \\n  \\n In this section:  \\n  \\n [The default Object.ToString() method](#Default)   \\n [Overriding the Object.ToString() method](#Overriding)   \\n [Overloading the ToString method](#Overloading)   \\n [Extending the Object.ToString method](#Extending)   \\n [Notes for the Windows Runtime](#WinRT)  \\n  \\n<a name=\\\"Default\\\"></a>   \\n## The default Object.ToString() method  \\n The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.  \\n  \\n [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]\\n [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]\\n [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  \\n  \\n Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method. The following example illustrates this. It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members. Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.  \\n  \\n [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]\\n [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]\\n [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  \\n  \\n<a name=\\\"Overriding\\\"></a>   \\n## Overriding the Object.ToString() method  \\n Types commonly override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return a string that represents the object instance. For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents. The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.  \\n  \\n [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]\\n [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]\\n [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  \\n  \\n The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=fullName> method.  \\n  \\n|Type category|Overrides Object.ToString()|Behavior|  \\n|-------------------|-----------------------------------|--------------|  \\n|Class|n/a|n/a|  \\n|Structure|Yes (<xref:System.ValueType.ToString%2A?displayProperty=fullName>)|Same as Object.ToString()|  \\n|Enumeration|Yes (<xref:System.Enum.ToString?displayProperty=fullName>)|The member name|  \\n|Interface|No|n/a|  \\n|Delegate|No|n/a|  \\n  \\n See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.  \\n  \\n<a name=\\\"Overloading\\\"></a>   \\n## Overloading the ToString method  \\n In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=fullName> method, many types overload the `ToString` method to provide versions of the method that accept parameters. Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.  \\n  \\n The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class. It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.  \\n  \\n [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]\\n [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  \\n  \\n The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method to display culture-sensitive formatting of a currency value.  \\n  \\n [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]\\n [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  \\n  \\n For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md). For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  \\n  \\n<a name=\\\"Extending\\\"></a>   \\n## Extending the Object.ToString method  \\n Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=fullName> method, you may find its behavior undesirable and want to change it. This is particularly true of arrays and collection classes. While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.  \\n  \\n [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]\\n [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  \\n  \\n You have several options to produce the result string that you'd like.  \\n  \\n-   If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.  \\n  \\n-   If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=fullName> method you want to customize. At a minimum, this requires that you do the following:  \\n  \\n    1.  Implement any necessary constructors. Derived classes do not inherit their base class constructors.  \\n  \\n    2.  Override the <xref:System.Object.ToString%2A?displayProperty=fullName> method to return the result string that you'd like.  \\n  \\n     The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class. It overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method to display the value of each method of the collection rather than the fully qualified type name.  \\n  \\n     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]\\n     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  \\n  \\n-   Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want. Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=fullName> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method. You'll have to provide some other name for your parameterless `ToString` replacement.  \\n  \\n     The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.  \\n  \\n     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]\\n     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  \\n  \\n<a name=\\\"WinRT\\\"></a>   \\n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \\n When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>. However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.  \\n  \\n Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=fullName>.  \\n  \\n> [!NOTE]\\n>  [!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.  \\n  \\n### The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface  \\n Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=fullName>. To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.  \\n  \\n When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=fullName> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.  \\n  \\n> [!WARNING]\\n>  Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation. Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.  \\n  \\n If you do choose to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:  \\n  \\n-   You can define the [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a \\\"class implements\\\" relationship, such as  \\n  \\n    ```  \\n    public class NewClass : IStringable  \\n    ```  \\n  \\n     in C#, or  \\n  \\n    ```  \\n    Public Class NewClass : Implements IStringable  \\n    ```  \\n  \\n     in Visual Basic.  \\n  \\n-   You cannot implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.  \\n  \\n-   You cannot declare a parameter to be of type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  \\n  \\n-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.  \\n  \\n-   You cannot hide your [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:  \\n  \\n    ```  \\n  \\n    public class NewClass : IStringable  \\n    {  \\n       public new string ToString()  \\n       {  \\n          return \\\"New ToString in NewClass\\\";  \\n       }  \\n    }  \\n  \\n    ```  \\n  \\n     Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation. You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.  \\n  \\n Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.\"\n  syntax:\n    content: public virtual string ToString ();\n    parameters: []\n    return:\n      type: System.String\n      description: A string that represents the current object.\n  overload: System.Object.ToString*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object.#ctor\n  parent: System.Object\n  isExternal: false\n  name: Object()\n  nameWithType: Object.Object()\n  fullName: Object.Object()\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.Finalize\n  parent: System.Object\n  isExternal: false\n  name: Finalize()\n  nameWithType: Object.Finalize()\n  fullName: Object.Finalize()\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Type\n  parent: System\n  isExternal: false\n  name: Type\n  nameWithType: Type\n  fullName: System.Type\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Object.#ctor*\n  parent: System.Object\n  isExternal: false\n  name: Object\n  nameWithType: Object.Object\n  fullName: Object.Object\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n- uid: System.Object.Equals*\n  parent: System.Object\n  isExternal: false\n  name: Equals\n  nameWithType: Object.Equals\n  fullName: Object.Equals\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n- uid: System.Object.Finalize*\n  parent: System.Object\n  isExternal: false\n  name: Finalize\n  nameWithType: Object.Finalize\n  fullName: Object.Finalize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n- uid: System.Object.GetHashCode*\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode\n  nameWithType: Object.GetHashCode\n  fullName: Object.GetHashCode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n- uid: System.Object.GetType*\n  parent: System.Object\n  isExternal: false\n  name: GetType\n  nameWithType: Object.GetType\n  fullName: Object.GetType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n- uid: System.Object.MemberwiseClone*\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone\n  nameWithType: Object.MemberwiseClone\n  fullName: Object.MemberwiseClone\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n- uid: System.Object.ReferenceEquals*\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals\n  nameWithType: Object.ReferenceEquals\n  fullName: Object.ReferenceEquals\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n- uid: System.Object.ToString*\n  parent: System.Object\n  isExternal: false\n  name: ToString\n  nameWithType: Object.ToString\n  fullName: Object.ToString\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Object.xml\n"}