{"nodes":[{"content":"Provides the base class for value types.","nodes":[{"pos":[0,40],"content":"Provides the base class for value types.","nodes":[{"content":"Provides the base class for value types.","pos":[0,40]}]}],"pos":[453,494],"yaml":true},{"content":"<xref:System.ValueType> overrides the virtual methods from <xref:System.Object> with more appropriate implementations for value types. See also <xref:System.Enum>, which inherits from <xref:System.ValueType>.  \n  \n Data types are separated into value types and reference types. Value types are either stack-allocated or allocated inline in a structure. Reference types are heap-allocated. Both reference and value types are derived from the ultimate base class <xref:System.Object>. In cases where it is necessary for a value type to behave like an object, a wrapper that makes the value type look like a reference object is allocated on the heap, and the value type's value is copied into it. The wrapper is marked so the system knows that it contains a value type. This process is known as boxing, and the reverse process is known as unboxing. Boxing and unboxing allow any type to be treated as an object.  \n  \n Although <xref:System.ValueType> is the implicit base class for value types, you cannot create a class that inherits from <xref:System.ValueType> directly. Instead, individual compilers provide a language keyword or construct (such as `struct` in C# and `Structure`…`End Structure` in Visual Basic) to support the creation of value types.  \n  \n Aside from serving as the base class for value types in the .NET Framework, the <xref:System.ValueType> structure is generally not used directly in code. However, it can be used as a parameter in method calls to restrict possible arguments to value types instead of all objects, or to permit a method to handle a number of different value types. The following example illustrates how <xref:System.ValueType> prevents reference types from being passed to methods. It defines a class named `Utility` that contains four methods: `IsNumeric`, which indicates whether its argument is a number; `IsInteger`, which indicates whether its argument is an integer; `IsFloat`, which indicates whether its argument is a floating-point number; and `Compare`, which indicates the relationship between two numeric values. In each case, the method parameters are of type <xref:System.ValueType>, and reference types are prevented from being passed to the methods.  \n  \n [!code-csharp[System.ValueType.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#1)]\n [!code-vb[System.ValueType.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#1)]  \n  \n The following example illustrates calls to the methods of the `Utility` class.  \n  \n [!code-csharp[System.ValueType.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#2)]\n [!code-vb[System.ValueType.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#2)]","nodes":[{"pos":[0,208],"content":"<xref:System.ValueType> overrides the virtual methods from <xref:System.Object> with more appropriate implementations for value types. See also <xref:System.Enum>, which inherits from <xref:System.ValueType>.","nodes":[{"content":"<xref:System.ValueType> overrides the virtual methods from <xref:System.Object> with more appropriate implementations for value types. See also <xref:System.Enum>, which inherits from <xref:System.ValueType>.","pos":[0,208],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph> overrides the virtual methods from <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> with more appropriate implementations for value types.","pos":[0,134],"source":"<xref:System.ValueType> overrides the virtual methods from <xref:System.Object> with more appropriate implementations for value types."},{"content":"See also <ph id=\"ph1\">&lt;xref:System.Enum&gt;</ph>, which inherits from <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph>.","pos":[135,208],"source":" See also <xref:System.Enum>, which inherits from <xref:System.ValueType>."}]}]},{"pos":[215,908],"content":"Data types are separated into value types and reference types. Value types are either stack-allocated or allocated inline in a structure. Reference types are heap-allocated. Both reference and value types are derived from the ultimate base class <xref:System.Object>. In cases where it is necessary for a value type to behave like an object, a wrapper that makes the value type look like a reference object is allocated on the heap, and the value type's value is copied into it. The wrapper is marked so the system knows that it contains a value type. This process is known as boxing, and the reverse process is known as unboxing. Boxing and unboxing allow any type to be treated as an object.","nodes":[{"content":"Data types are separated into value types and reference types. Value types are either stack-allocated or allocated inline in a structure. Reference types are heap-allocated. Both reference and value types are derived from the ultimate base class <xref:System.Object>. In cases where it is necessary for a value type to behave like an object, a wrapper that makes the value type look like a reference object is allocated on the heap, and the value type's value is copied into it. The wrapper is marked so the system knows that it contains a value type. This process is known as boxing, and the reverse process is known as unboxing. Boxing and unboxing allow any type to be treated as an object.","pos":[0,693],"nodes":[{"content":"Data types are separated into value types and reference types.","pos":[0,62]},{"content":"Value types are either stack-allocated or allocated inline in a structure.","pos":[63,137]},{"content":"Reference types are heap-allocated.","pos":[138,173]},{"content":"Both reference and value types are derived from the ultimate base class <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>.","pos":[174,267],"source":" Both reference and value types are derived from the ultimate base class <xref:System.Object>."},{"content":"In cases where it is necessary for a value type to behave like an object, a wrapper that makes the value type look like a reference object is allocated on the heap, and the value type's value is copied into it.","pos":[268,478]},{"content":"The wrapper is marked so the system knows that it contains a value type.","pos":[479,551]},{"content":"This process is known as boxing, and the reverse process is known as unboxing.","pos":[552,630]},{"content":"Boxing and unboxing allow any type to be treated as an object.","pos":[631,693]}]}]},{"pos":[915,1253],"content":"Although <xref:System.ValueType> is the implicit base class for value types, you cannot create a class that inherits from <xref:System.ValueType> directly. Instead, individual compilers provide a language keyword or construct (such as `struct` in C# and `Structure`…`End Structure` in Visual Basic) to support the creation of value types.","nodes":[{"content":"Although <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph> is the implicit base class for value types, you cannot create a class that inherits from <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph> directly.","pos":[0,155],"source":"Although <xref:System.ValueType> is the implicit base class for value types, you cannot create a class that inherits from <xref:System.ValueType> directly."},{"content":"Instead, individual compilers provide a language keyword or construct (such as <ph id=\"ph1\">`struct`</ph> in C# and <ph id=\"ph2\">`Structure`</ph>…<ph id=\"ph3\">`End Structure`</ph>","pos":[156,281],"source":" Instead, individual compilers provide a language keyword or construct (such as `struct` in C# and `Structure`…`End Structure`"},{"content":"in Visual Basic) to support the creation of value types.","pos":[282,338]}]},{"pos":[1260,2206],"content":"Aside from serving as the base class for value types in the .NET Framework, the <xref:System.ValueType> structure is generally not used directly in code. However, it can be used as a parameter in method calls to restrict possible arguments to value types instead of all objects, or to permit a method to handle a number of different value types. The following example illustrates how <xref:System.ValueType> prevents reference types from being passed to methods. It defines a class named `Utility` that contains four methods: `IsNumeric`, which indicates whether its argument is a number; `IsInteger`, which indicates whether its argument is an integer; `IsFloat`, which indicates whether its argument is a floating-point number; and `Compare`, which indicates the relationship between two numeric values. In each case, the method parameters are of type <xref:System.ValueType>, and reference types are prevented from being passed to the methods.","nodes":[{"content":"Aside from serving as the base class for value types in the .NET Framework, the <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph> structure is generally not used directly in code.","pos":[0,153],"source":"Aside from serving as the base class for value types in the .NET Framework, the <xref:System.ValueType> structure is generally not used directly in code."},{"content":"However, it can be used as a parameter in method calls to restrict possible arguments to value types instead of all objects, or to permit a method to handle a number of different value types.","pos":[154,345]},{"content":"The following example illustrates how <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph> prevents reference types from being passed to methods.","pos":[346,462],"source":" The following example illustrates how <xref:System.ValueType> prevents reference types from being passed to methods."},{"content":"It defines a class named <ph id=\"ph1\">`Utility`</ph> that contains four methods: <ph id=\"ph2\">`IsNumeric`</ph>, which indicates whether its argument is a number; <ph id=\"ph3\">`IsInteger`</ph>, which indicates whether its argument is an integer; <ph id=\"ph4\">`IsFloat`</ph>, which indicates whether its argument is a floating-point number; and <ph id=\"ph5\">`Compare`</ph>, which indicates the relationship between two numeric values.","pos":[463,805],"source":" It defines a class named `Utility` that contains four methods: `IsNumeric`, which indicates whether its argument is a number; `IsInteger`, which indicates whether its argument is an integer; `IsFloat`, which indicates whether its argument is a floating-point number; and `Compare`, which indicates the relationship between two numeric values."},{"content":"In each case, the method parameters are of type <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph>, and reference types are prevented from being passed to the methods.","pos":[806,946],"source":" In each case, the method parameters are of type <xref:System.ValueType>, and reference types are prevented from being passed to the methods."}]},{"pos":[2213,2492],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.ValueType.Structure#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.ValueType.Structure#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.ValueType.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#1)]\n [!code-vb[System.ValueType.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#1)]"},{"pos":[2499,2577],"content":"The following example illustrates calls to the methods of the <ph id=\"ph1\">`Utility`</ph> class.","source":"The following example illustrates calls to the methods of the `Utility` class."},{"pos":[2584,2863],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.ValueType.Structure#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.ValueType.Structure#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.ValueType.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#2)]\n [!code-vb[System.ValueType.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#2)]"}],"pos":[505,3385],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.ValueType\"></xref> class.","nodes":[{"pos":[0,78],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.ValueType\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.ValueType\"></xref> class."}],"pos":[34281,34360],"yaml":true},{"content":"Indicates whether this instance and a specified object are equal.","nodes":[{"pos":[0,65],"content":"Indicates whether this instance and a specified object are equal.","nodes":[{"content":"Indicates whether this instance and a specified object are equal.","pos":[0,65]}]}],"pos":[35920,35986],"yaml":true},{"content":"The <xref:System.ValueType.Equals%28System.Object%29?displayProperty=fullName> method overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> and provides the default implementation of value equality for all value types in the .NET Framework.  \n  \n If none of the fields of the current instance and `obj` are reference types, the <xref:System.ValueType.Equals%2A> method performs a byte-by-byte comparison of the two objects in memory. Otherwise, it uses reflection to compare the corresponding fields of `obj` and this instance.  \n  \n> [!TIP]\n>  Particularly if your value type contains fields that are reference types, you should override the <xref:System.ValueType.Equals%28System.Object%29> method. This can improve performance and enable you to more closely represent the meaning of equality for the type.  \n  \n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \n When you call the <xref:System.ValueType.Equals%2A>method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.Equals%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.Equals%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"pos":[0,268],"content":"The <xref:System.ValueType.Equals%28System.Object%29?displayProperty=fullName> method overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> and provides the default implementation of value equality for all value types in the .NET Framework.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ValueType.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method overrides <ph id=\"ph2\">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> and provides the default implementation of value equality for all value types in the .NET Framework.","pos":[0,268],"source":"The <xref:System.ValueType.Equals%28System.Object%29?displayProperty=fullName> method overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> and provides the default implementation of value equality for all value types in the .NET Framework."}]},{"pos":[275,555],"content":"If none of the fields of the current instance and `obj` are reference types, the <xref:System.ValueType.Equals%2A> method performs a byte-by-byte comparison of the two objects in memory. Otherwise, it uses reflection to compare the corresponding fields of `obj` and this instance.","nodes":[{"content":"If none of the fields of the current instance and <ph id=\"ph1\">`obj`</ph> are reference types, the <ph id=\"ph2\">&lt;xref:System.ValueType.Equals%2A&gt;</ph> method performs a byte-by-byte comparison of the two objects in memory.","pos":[0,186],"source":"If none of the fields of the current instance and `obj` are reference types, the <xref:System.ValueType.Equals%2A> method performs a byte-by-byte comparison of the two objects in memory."},{"content":"Otherwise, it uses reflection to compare the corresponding fields of <ph id=\"ph1\">`obj`</ph> and this instance.","pos":[187,280],"source":" Otherwise, it uses reflection to compare the corresponding fields of `obj` and this instance."}]},{"pos":[563,836],"content":"[!TIP]\n Particularly if your value type contains fields that are reference types, you should override the <xref:System.ValueType.Equals%28System.Object%29> method. This can improve performance and enable you to more closely represent the meaning of equality for the type.","leadings":["","> "],"nodes":[{"content":" Particularly if your value type contains fields that are reference types, you should override the <xref:System.ValueType.Equals%28System.Object%29> method. This can improve performance and enable you to more closely represent the meaning of equality for the type.","pos":[7,271],"nodes":[{"content":"Particularly if your value type contains fields that are reference types, you should override the <ph id=\"ph1\">&lt;xref:System.ValueType.Equals%28System.Object%29&gt;</ph> method.","pos":[1,156],"source":" Particularly if your value type contains fields that are reference types, you should override the <xref:System.ValueType.Equals%28System.Object%29> method."},{"content":"This can improve performance and enable you to more closely represent the meaning of equality for the type.","pos":[157,264]}]}]},{"pos":[845,896],"content":"Notes for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>","linkify":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]","source":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]"},{"pos":[900,1956],"content":"When you call the <xref:System.ValueType.Equals%2A>method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.Equals%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.Equals%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.ValueType.Equals%2A&gt;</ph>method on a <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id=\"ph3\">&lt;xref:System.ValueType.Equals%2A&gt;</ph>.","pos":[0,215],"source":"When you call the <xref:System.ValueType.Equals%2A>method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.Equals%2A>."},{"content":"This is part of the support that the .NET Framework provides for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id=\"p1\">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id=\"p1\">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).","pos":[216,483],"source":" This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))."},{"content":"<ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id=\"ph2\">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.","pos":[484,664],"source":"[!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.Equals%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods."},{"content":"(In addition, structures in the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id=\"ph3\">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","pos":[665,1056],"source":" (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods."}]}],"pos":[35997,37964],"yaml":true,"extradata":"MT"},{"content":"The object to compare with the current instance.","nodes":[{"pos":[0,48],"content":"The object to compare with the current instance.","nodes":[{"content":"The object to compare with the current instance.","pos":[0,48]}]}],"pos":[38635,38684],"yaml":true},{"content":"`true` if <code>obj</code> and this instance are the same type and represent the same value; otherwise, `false`.","nodes":[{"pos":[0,112],"content":"<ph id=\"ph1\">`true`</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> and this instance are the same type and represent the same value; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if <code>obj</code> and this instance are the same type and represent the same value; otherwise, `false`."}],"pos":[38742,38857],"yaml":true},{"content":"Returns the hash code for this instance.","nodes":[{"pos":[0,40],"content":"Returns the hash code for this instance.","nodes":[{"content":"Returns the hash code for this instance.","pos":[0,40]}]}],"pos":[40319,40360],"yaml":true},{"content":"The <xref:System.ValueType.GetHashCode%2A> method applies to types derived from <xref:System.ValueType>. One or more fields of the derived type is used to calculate the return value. If you call the derived type's `GetHashCode` method, the return value is not likely to be suitable for use as a key in a hash table. Additionally, if the value of one or more of those fields changes, the return value might become unsuitable for use as a key in a hash table. In either case, consider writing your own implementation of the <xref:System.ValueType.GetHashCode%2A> method that more closely represents the concept of a hash code for the type.  \n  \n For more information, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>, and <xref:System.Collections.Hashtable?displayProperty=fullName>.  \n  \n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \n When you call the <xref:System.ValueType.GetHashCode%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.GetHashCode%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.GetHashCode%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"pos":[0,637],"content":"The <xref:System.ValueType.GetHashCode%2A> method applies to types derived from <xref:System.ValueType>. One or more fields of the derived type is used to calculate the return value. If you call the derived type's `GetHashCode` method, the return value is not likely to be suitable for use as a key in a hash table. Additionally, if the value of one or more of those fields changes, the return value might become unsuitable for use as a key in a hash table. In either case, consider writing your own implementation of the <xref:System.ValueType.GetHashCode%2A> method that more closely represents the concept of a hash code for the type.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method applies to types derived from <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph>.","pos":[0,104],"source":"The <xref:System.ValueType.GetHashCode%2A> method applies to types derived from <xref:System.ValueType>."},{"content":"One or more fields of the derived type is used to calculate the return value.","pos":[105,182]},{"content":"If you call the derived type's <ph id=\"ph1\">`GetHashCode`</ph> method, the return value is not likely to be suitable for use as a key in a hash table.","pos":[183,315],"source":" If you call the derived type's `GetHashCode` method, the return value is not likely to be suitable for use as a key in a hash table."},{"content":"Additionally, if the value of one or more of those fields changes, the return value might become unsuitable for use as a key in a hash table.","pos":[316,457]},{"content":"In either case, consider writing your own implementation of the <ph id=\"ph1\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method that more closely represents the concept of a hash code for the type.","pos":[458,637],"source":" In either case, consider writing your own implementation of the <xref:System.ValueType.GetHashCode%2A> method that more closely represents the concept of a hash code for the type."}]},{"pos":[644,797],"content":"For more information, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>, and <xref:System.Collections.Hashtable?displayProperty=fullName>.","nodes":[{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>, and <ph id=\"ph2\">&lt;xref:System.Collections.Hashtable?displayProperty=fullName&gt;</ph>.","pos":[0,153],"source":"For more information, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>, and <xref:System.Collections.Hashtable?displayProperty=fullName>."}]},{"pos":[806,857],"content":"Notes for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>","linkify":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]","source":"Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]"},{"pos":[861,1933],"content":"When you call the <xref:System.ValueType.GetHashCode%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.GetHashCode%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.GetHashCode%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method on a <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id=\"ph3\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>.","pos":[0,226],"source":"When you call the <xref:System.ValueType.GetHashCode%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.GetHashCode%2A>."},{"content":"This is part of the support that the .NET Framework provides for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id=\"p1\">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id=\"p1\">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).","pos":[227,494],"source":" This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))."},{"content":"<ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id=\"ph2\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.","pos":[495,680],"source":"[!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.GetHashCode%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods."},{"content":"(In addition, structures in the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id=\"ph3\">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","pos":[681,1072],"source":" (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods."}]}],"pos":[40371,42312],"yaml":true,"extradata":"MT"},{"content":"A 32-bit signed integer that is the hash code for this instance.","nodes":[{"pos":[0,64],"content":"A 32-bit signed integer that is the hash code for this instance.","nodes":[{"content":"A 32-bit signed integer that is the hash code for this instance.","pos":[0,64]}]}],"pos":[42982,43047],"yaml":true},{"content":"Returns the fully qualified type name of this instance.","nodes":[{"pos":[0,55],"content":"Returns the fully qualified type name of this instance.","nodes":[{"content":"Returns the fully qualified type name of this instance.","pos":[0,55]}]}],"pos":[44496,44552],"yaml":true},{"content":"The <xref:System.ValueType.ToString%2A?displayProperty=fullName> method overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method and provides the default implementation of the `ToString` method for value types. (Value types are types defined by the `struct` keyword in C#, and by the `Structure`...`End Structure` construct in Visual Basic.) Functionally, however, the implementation is that same as that of <xref:System.Object.ToString%2A?displayProperty=fullName>: the method returns the fully qualified type name.  \n  \n Value types defined by the `struct` keyword in C# and the `Structure`...`End Structure` construct in Visual Basic typically override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method to provide a more meaningful string representation of the value type. The following example illustrates the difference. It defines two value types, `EmployeeA` and `EmployeeB`, creates an instance of each, and calls its `ToString` method. Because the `EmployeeA` structure does not override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method, it displays only the fully qualified type name. The `EmployeeB.ToString` method, on the other hand, provides meaningful information about the object.  \n  \n [!code-csharp[System.ValueType.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.ValueType.ToString/cs/ToString2.cs#1)]\n [!code-vb[System.ValueType.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.ValueType.ToString/vb/ToString2.vb#1)]  \n  \n Note that, although enumeration types are also value types, they derive from the <xref:System.Enum> class, which overrides  <xref:System.ValueType.ToString%2A?displayProperty=fullName>.  \n  \n## Notes for the Windows Runtime  \n When you call the <xref:System.ValueType.ToString%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.ToString%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.ToString%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"pos":[0,538],"content":"The <xref:System.ValueType.ToString%2A?displayProperty=fullName> method overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method and provides the default implementation of the `ToString` method for value types. (Value types are types defined by the `struct` keyword in C#, and by the `Structure`...`End Structure` construct in Visual Basic.) Functionally, however, the implementation is that same as that of <xref:System.Object.ToString%2A?displayProperty=fullName>: the method returns the fully qualified type name.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ValueType.ToString%2A?displayProperty=fullName&gt;</ph> method overrides the <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method and provides the default implementation of the <ph id=\"ph3\">`ToString`</ph> method for value types.","pos":[0,232],"source":"The <xref:System.ValueType.ToString%2A?displayProperty=fullName> method overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method and provides the default implementation of the `ToString` method for value types."},{"content":"(Value types are types defined by the <ph id=\"ph1\">`struct`</ph> keyword in C#, and by the <ph id=\"ph2\">`Structure`</ph>...<ph id=\"ph3\">`End Structure`</ph> construct in Visual Basic.) Functionally, however, the implementation is that same as that of <ph id=\"ph4\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph>: the method returns the fully qualified type name.","pos":[233,538],"source":" (Value types are types defined by the `struct` keyword in C#, and by the `Structure`...`End Structure` construct in Visual Basic.) Functionally, however, the implementation is that same as that of <xref:System.Object.ToString%2A?displayProperty=fullName>: the method returns the fully qualified type name."}]},{"pos":[545,1263],"content":"Value types defined by the `struct` keyword in C# and the `Structure`...`End Structure` construct in Visual Basic typically override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method to provide a more meaningful string representation of the value type. The following example illustrates the difference. It defines two value types, `EmployeeA` and `EmployeeB`, creates an instance of each, and calls its `ToString` method. Because the `EmployeeA` structure does not override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method, it displays only the fully qualified type name. The `EmployeeB.ToString` method, on the other hand, provides meaningful information about the object.","nodes":[{"content":"Value types defined by the <ph id=\"ph1\">`struct`</ph> keyword in C# and the <ph id=\"ph2\">`Structure`</ph>...<ph id=\"ph3\">`End Structure`</ph> construct in Visual Basic typically override the <ph id=\"ph4\">&lt;xref:System.ValueType.ToString%2A?displayProperty=fullName&gt;</ph> method to provide a more meaningful string representation of the value type.","pos":[0,274],"source":"Value types defined by the `struct` keyword in C# and the `Structure`...`End Structure` construct in Visual Basic typically override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method to provide a more meaningful string representation of the value type."},{"content":"The following example illustrates the difference.","pos":[275,324]},{"content":"It defines two value types, <ph id=\"ph1\">`EmployeeA`</ph> and <ph id=\"ph2\">`EmployeeB`</ph>, creates an instance of each, and calls its <ph id=\"ph3\">`ToString`</ph> method.","pos":[325,443],"source":" It defines two value types, `EmployeeA` and `EmployeeB`, creates an instance of each, and calls its `ToString` method."},{"content":"Because the <ph id=\"ph1\">`EmployeeA`</ph> structure does not override the <ph id=\"ph2\">&lt;xref:System.ValueType.ToString%2A?displayProperty=fullName&gt;</ph> method, it displays only the fully qualified type name.","pos":[444,616],"source":" Because the `EmployeeA` structure does not override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method, it displays only the fully qualified type name."},{"content":"The <ph id=\"ph1\">`EmployeeB.ToString`</ph> method, on the other hand, provides meaningful information about the object.","pos":[617,718],"source":" The `EmployeeB.ToString` method, on the other hand, provides meaningful information about the object."}]},{"pos":[1270,1547],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.ValueType.ToString#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.ValueType.ToString/cs/ToString2.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.ValueType.ToString#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.ValueType.ToString/vb/ToString2.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.ValueType.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.ValueType.ToString/cs/ToString2.cs#1)]\n [!code-vb[System.ValueType.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.ValueType.ToString/vb/ToString2.vb#1)]"},{"pos":[1554,1739],"content":"Note that, although enumeration types are also value types, they derive from the <xref:System.Enum> class, which overrides  <xref:System.ValueType.ToString%2A?displayProperty=fullName>.","nodes":[{"content":"Note that, although enumeration types are also value types, they derive from the <ph id=\"ph1\">&lt;xref:System.Enum&gt;</ph> class, which overrides  <ph id=\"ph2\">&lt;xref:System.ValueType.ToString%2A?displayProperty=fullName&gt;</ph>.","pos":[0,185],"source":"Note that, although enumeration types are also value types, they derive from the <xref:System.Enum> class, which overrides  <xref:System.ValueType.ToString%2A?displayProperty=fullName>."}]},{"pos":[1748,1777],"content":"Notes for the Windows Runtime","linkify":"Notes for the Windows Runtime","nodes":[{"content":"Notes for the Windows Runtime","pos":[0,29]}]},{"pos":[1781,2844],"content":"When you call the <xref:System.ValueType.ToString%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.ToString%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.ToString%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.ValueType.ToString%2A&gt;</ph> method on a <ph id=\"ph2\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id=\"ph3\">&lt;xref:System.ValueType.ToString%2A&gt;</ph>.","pos":[0,220],"source":"When you call the <xref:System.ValueType.ToString%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.ToString%2A>."},{"content":"This is part of the support that the .NET Framework provides for the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id=\"p1\">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id=\"p1\">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).","pos":[221,488],"source":" This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))."},{"content":"<ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id=\"ph2\">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.","pos":[489,671],"source":"[!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.ToString%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods."},{"content":"(In addition, structures in the <ph id=\"ph1\">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id=\"ph3\">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.","pos":[672,1063],"source":" (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods."}]}],"pos":[44563,47420],"yaml":true,"extradata":"MT"},{"content":"The fully qualified type name.","nodes":[{"pos":[0,30],"content":"The fully qualified type name.","nodes":[{"content":"The fully qualified type name.","pos":[0,30]}]}],"pos":[47555,47586],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.ValueType\n  commentId: T:System.ValueType\n  id: ValueType\n  children:\n  - System.ValueType.#ctor\n  - System.ValueType.Equals(System.Object)\n  - System.ValueType.GetHashCode\n  - System.ValueType.ToString\n  langs:\n  - csharp\n  name: ValueType\n  nameWithType: ValueType\n  fullName: System.ValueType\n  type: Class\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Provides the base class for value types.\n  remarks: \"<xref:System.ValueType> overrides the virtual methods from <xref:System.Object> with more appropriate implementations for value types. See also <xref:System.Enum>, which inherits from <xref:System.ValueType>.  \\n  \\n Data types are separated into value types and reference types. Value types are either stack-allocated or allocated inline in a structure. Reference types are heap-allocated. Both reference and value types are derived from the ultimate base class <xref:System.Object>. In cases where it is necessary for a value type to behave like an object, a wrapper that makes the value type look like a reference object is allocated on the heap, and the value type's value is copied into it. The wrapper is marked so the system knows that it contains a value type. This process is known as boxing, and the reverse process is known as unboxing. Boxing and unboxing allow any type to be treated as an object.  \\n  \\n Although <xref:System.ValueType> is the implicit base class for value types, you cannot create a class that inherits from <xref:System.ValueType> directly. Instead, individual compilers provide a language keyword or construct (such as `struct` in C# and `Structure`…`End Structure` in Visual Basic) to support the creation of value types.  \\n  \\n Aside from serving as the base class for value types in the .NET Framework, the <xref:System.ValueType> structure is generally not used directly in code. However, it can be used as a parameter in method calls to restrict possible arguments to value types instead of all objects, or to permit a method to handle a number of different value types. The following example illustrates how <xref:System.ValueType> prevents reference types from being passed to methods. It defines a class named `Utility` that contains four methods: `IsNumeric`, which indicates whether its argument is a number; `IsInteger`, which indicates whether its argument is an integer; `IsFloat`, which indicates whether its argument is a floating-point number; and `Compare`, which indicates the relationship between two numeric values. In each case, the method parameters are of type <xref:System.ValueType>, and reference types are prevented from being passed to the methods.  \\n  \\n [!code-csharp[System.ValueType.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#1)]\\n [!code-vb[System.ValueType.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#1)]  \\n  \\n The following example illustrates calls to the methods of the `Utility` class.  \\n  \\n [!code-csharp[System.ValueType.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.valuetype.structure/cs/example1.cs#2)]\\n [!code-vb[System.ValueType.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.valuetype.structure/vb/example1.vb#2)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract class ValueType\n  inheritance:\n  - System.Object\n  derivedClasses:\n  - Accessibility._RemotableHandle\n  - Accessibility.__MIDL_IWinTypes_0009\n  - Microsoft.Build.Evaluation.ResolvedImport\n  - Microsoft.Build.Framework.BuildEngineResult\n  - Microsoft.Build.Tasks.ExtractedClassName\n  - Microsoft.VisualBasic.SpcInfo\n  - Microsoft.VisualBasic.TabInfo\n  - Microsoft.VisualBasic.Compatibility.VB6.CONNECTDATA\n  - Microsoft.VisualBasic.Compatibility.VB6.DBBINDING\n  - Microsoft.VisualBasic.Compatibility.VB6.DBCOLUMNINFO\n  - Microsoft.VisualBasic.Compatibility.VB6.DBID\n  - Microsoft.VisualBasic.Compatibility.VB6.DBPROPIDSET\n  - Microsoft.VisualBasic.Compatibility.VB6.UGUID\n  - Microsoft.VisualBasic.Compatibility.VB6.UNAME\n  - System.ArgIterator\n  - System.ArraySegment`1.Enumerator\n  - System.ArraySegment`1\n  - System.Boolean\n  - System.Byte\n  - System.Char\n  - System.ConsoleKeyInfo\n  - System.DateTime\n  - System.DateTimeOffset\n  - System.Decimal\n  - System.Double\n  - System.Enum\n  - System.Guid\n  - System.Int16\n  - System.Int32\n  - System.Int64\n  - System.IntPtr\n  - System.ModuleHandle\n  - System.Nullable`1\n  - System.ReadOnlySpan`1\n  - System.RuntimeArgumentHandle\n  - System.RuntimeFieldHandle\n  - System.RuntimeMethodHandle\n  - System.RuntimeTypeHandle\n  - System.SByte\n  - System.Single\n  - System.Span`1\n  - System.TimeSpan\n  - System.TimeZoneInfo.TransitionTime\n  - System.TypedReference\n  - System.UInt16\n  - System.UInt32\n  - System.UInt64\n  - System.UIntPtr\n  - System.ValueTuple\n  - System.ValueTuple`1\n  - System.ValueTuple`2\n  - System.ValueTuple`3\n  - System.ValueTuple`4\n  - System.ValueTuple`5\n  - System.ValueTuple`6\n  - System.ValueTuple`7\n  - System.ValueTuple`8\n  - System.Void\n  - System.Activities.ActivityMetadata\n  - System.Activities.CodeActivityMetadata\n  - System.Activities.CodeActivityPublicEnvironmentAccessor\n  - System.Activities.NativeActivityMetadata\n  - System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl\n  - System.AddIn.Contract.RemoteArgument\n  - System.AddIn.Contract.SerializableObjectData\n  - System.AddIn.Contract.Automation.RemoteFieldData\n  - System.AddIn.Contract.Automation.RemoteMemberData\n  - System.AddIn.Contract.Automation.RemoteMethodData\n  - System.AddIn.Contract.Automation.RemoteParameterData\n  - System.AddIn.Contract.Automation.RemotePropertyData\n  - System.AddIn.Contract.Automation.RemoteTypeData\n  - System.AddIn.Contract.Collections.RemoteArgumentDictionaryEntry\n  - System.AddIn.Hosting.QualificationDataItem\n  - System.Collections.DictionaryEntry\n  - System.Collections.Generic.Dictionary`2.Enumerator\n  - System.Collections.Generic.Dictionary`2.KeyCollection.Enumerator\n  - System.Collections.Generic.Dictionary`2.ValueCollection.Enumerator\n  - System.Collections.Generic.HashSet`1.Enumerator\n  - System.Collections.Generic.KeyValuePair`2\n  - System.Collections.Generic.LinkedList`1.Enumerator\n  - System.Collections.Generic.List`1.Enumerator\n  - System.Collections.Generic.Queue`1.Enumerator\n  - System.Collections.Generic.SortedDictionary`2.Enumerator\n  - System.Collections.Generic.SortedDictionary`2.KeyCollection.Enumerator\n  - System.Collections.Generic.SortedDictionary`2.ValueCollection.Enumerator\n  - System.Collections.Generic.SortedSet`1.Enumerator\n  - System.Collections.Generic.Stack`1.Enumerator\n  - System.Collections.Immutable.ImmutableArray`1.Enumerator\n  - System.Collections.Immutable.ImmutableArray`1\n  - System.Collections.Immutable.ImmutableDictionary`2.Enumerator\n  - System.Collections.Immutable.ImmutableHashSet`1.Enumerator\n  - System.Collections.Immutable.ImmutableList`1.Enumerator\n  - System.Collections.Immutable.ImmutableQueue`1.Enumerator\n  - System.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator\n  - System.Collections.Immutable.ImmutableSortedSet`1.Enumerator\n  - System.Collections.Immutable.ImmutableStack`1.Enumerator\n  - System.Collections.Specialized.BitVector32.Section\n  - System.Collections.Specialized.BitVector32\n  - System.ComponentModel.SortDescription\n  - System.ComponentModel.Composition.ReflectionModel.LazyMemberInfo\n  - System.ComponentModel.Design.Serialization.MemberRelationship\n  - System.Configuration.Assemblies.AssemblyHash\n  - System.Data.Common.FieldMetadata\n  - System.Data.Linq.EntityRef`1\n  - System.Data.Linq.Link`1\n  - System.Data.Linq.ModifiedMemberInfo\n  - System.Data.Metadata.Edm.ReadOnlyMetadataCollection`1.Enumerator\n  - System.Data.OracleClient.OracleBinary\n  - System.Data.OracleClient.OracleBoolean\n  - System.Data.OracleClient.OracleDateTime\n  - System.Data.OracleClient.OracleMonthSpan\n  - System.Data.OracleClient.OracleNumber\n  - System.Data.OracleClient.OracleString\n  - System.Data.OracleClient.OracleTimeSpan\n  - System.Data.SqlTypes.SqlBinary\n  - System.Data.SqlTypes.SqlBoolean\n  - System.Data.SqlTypes.SqlByte\n  - System.Data.SqlTypes.SqlDateTime\n  - System.Data.SqlTypes.SqlDecimal\n  - System.Data.SqlTypes.SqlDouble\n  - System.Data.SqlTypes.SqlGuid\n  - System.Data.SqlTypes.SqlInt16\n  - System.Data.SqlTypes.SqlInt32\n  - System.Data.SqlTypes.SqlInt64\n  - System.Data.SqlTypes.SqlMoney\n  - System.Data.SqlTypes.SqlSingle\n  - System.Data.SqlTypes.SqlString\n  - System.Diagnostics.CounterSample\n  - System.Diagnostics.Eventing.EventDescriptor\n  - System.Diagnostics.SymbolStore.SymbolToken\n  - System.Diagnostics.Tracing.EventSource.EventData\n  - System.Diagnostics.Tracing.EventSourceOptions\n  - System.Drawing.CharacterRange\n  - System.Drawing.Color\n  - System.Drawing.Point\n  - System.Drawing.PointF\n  - System.Drawing.Rectangle\n  - System.Drawing.RectangleF\n  - System.Drawing.Size\n  - System.Drawing.SizeF\n  - System.IO.WaitForChangedResult\n  - System.IO.Log.PolicyUnit\n  - System.IO.Log.SequenceNumber\n  - System.Net.Sockets.IPPacketInformation\n  - System.Net.Sockets.SocketInformation\n  - System.Net.Sockets.SocketReceiveFromResult\n  - System.Net.Sockets.SocketReceiveMessageFromResult\n  - System.Net.Sockets.UdpReceiveResult\n  - System.Numerics.BigInteger\n  - System.Numerics.Complex\n  - System.Numerics.Matrix3x2\n  - System.Numerics.Matrix4x4\n  - System.Numerics.Plane\n  - System.Numerics.Quaternion\n  - System.Numerics.Vector2\n  - System.Numerics.Vector3\n  - System.Numerics.Vector4\n  - System.Numerics.Vector`1\n  - System.Printing.ValidationResult\n  - System.Reflection.CustomAttributeNamedArgument\n  - System.Reflection.CustomAttributeTypedArgument\n  - System.Reflection.InterfaceMapping\n  - System.Reflection.ParameterModifier\n  - System.Reflection.Emit.EventToken\n  - System.Reflection.Emit.ExceptionHandler\n  - System.Reflection.Emit.FieldToken\n  - System.Reflection.Emit.Label\n  - System.Reflection.Emit.MethodToken\n  - System.Reflection.Emit.OpCode\n  - System.Reflection.Emit.ParameterToken\n  - System.Reflection.Emit.PropertyToken\n  - System.Reflection.Emit.SignatureToken\n  - System.Reflection.Emit.StringToken\n  - System.Reflection.Emit.TypeToken\n  - System.Reflection.Metadata.ArrayShape\n  - System.Reflection.Metadata.AssemblyDefinition\n  - System.Reflection.Metadata.AssemblyDefinitionHandle\n  - System.Reflection.Metadata.AssemblyFile\n  - System.Reflection.Metadata.AssemblyFileHandle\n  - System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator\n  - System.Reflection.Metadata.AssemblyFileHandleCollection\n  - System.Reflection.Metadata.AssemblyReference\n  - System.Reflection.Metadata.AssemblyReferenceHandle\n  - System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator\n  - System.Reflection.Metadata.AssemblyReferenceHandleCollection\n  - System.Reflection.Metadata.Blob\n  - System.Reflection.Metadata.BlobBuilder.Blobs\n  - System.Reflection.Metadata.BlobContentId\n  - System.Reflection.Metadata.BlobHandle\n  - System.Reflection.Metadata.BlobReader\n  - System.Reflection.Metadata.BlobWriter\n  - System.Reflection.Metadata.Constant\n  - System.Reflection.Metadata.ConstantHandle\n  - System.Reflection.Metadata.CustomAttribute\n  - System.Reflection.Metadata.CustomAttributeHandle\n  - System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator\n  - System.Reflection.Metadata.CustomAttributeHandleCollection\n  - System.Reflection.Metadata.CustomAttributeNamedArgument`1\n  - System.Reflection.Metadata.CustomAttributeTypedArgument`1\n  - System.Reflection.Metadata.CustomAttributeValue`1\n  - System.Reflection.Metadata.CustomDebugInformation\n  - System.Reflection.Metadata.CustomDebugInformationHandle\n  - System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator\n  - System.Reflection.Metadata.CustomDebugInformationHandleCollection\n  - System.Reflection.Metadata.DeclarativeSecurityAttribute\n  - System.Reflection.Metadata.DeclarativeSecurityAttributeHandle\n  - System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator\n  - System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection\n  - System.Reflection.Metadata.Document\n  - System.Reflection.Metadata.DocumentHandle\n  - System.Reflection.Metadata.DocumentHandleCollection.Enumerator\n  - System.Reflection.Metadata.DocumentHandleCollection\n  - System.Reflection.Metadata.DocumentNameBlobHandle\n  - System.Reflection.Metadata.EntityHandle\n  - System.Reflection.Metadata.EventAccessors\n  - System.Reflection.Metadata.EventDefinition\n  - System.Reflection.Metadata.EventDefinitionHandle\n  - System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator\n  - System.Reflection.Metadata.EventDefinitionHandleCollection\n  - System.Reflection.Metadata.ExceptionRegion\n  - System.Reflection.Metadata.ExportedType\n  - System.Reflection.Metadata.ExportedTypeHandle\n  - System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator\n  - System.Reflection.Metadata.ExportedTypeHandleCollection\n  - System.Reflection.Metadata.FieldDefinition\n  - System.Reflection.Metadata.FieldDefinitionHandle\n  - System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator\n  - System.Reflection.Metadata.FieldDefinitionHandleCollection\n  - System.Reflection.Metadata.GenericParameter\n  - System.Reflection.Metadata.GenericParameterConstraint\n  - System.Reflection.Metadata.GenericParameterConstraintHandle\n  - System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator\n  - System.Reflection.Metadata.GenericParameterConstraintHandleCollection\n  - System.Reflection.Metadata.GenericParameterHandle\n  - System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator\n  - System.Reflection.Metadata.GenericParameterHandleCollection\n  - System.Reflection.Metadata.GuidHandle\n  - System.Reflection.Metadata.Handle\n  - System.Reflection.Metadata.ImportDefinition\n  - System.Reflection.Metadata.ImportDefinitionCollection.Enumerator\n  - System.Reflection.Metadata.ImportDefinitionCollection\n  - System.Reflection.Metadata.ImportScope\n  - System.Reflection.Metadata.ImportScopeCollection.Enumerator\n  - System.Reflection.Metadata.ImportScopeCollection\n  - System.Reflection.Metadata.ImportScopeHandle\n  - System.Reflection.Metadata.InterfaceImplementation\n  - System.Reflection.Metadata.InterfaceImplementationHandle\n  - System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator\n  - System.Reflection.Metadata.InterfaceImplementationHandleCollection\n  - System.Reflection.Metadata.LocalConstant\n  - System.Reflection.Metadata.LocalConstantHandle\n  - System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator\n  - System.Reflection.Metadata.LocalConstantHandleCollection\n  - System.Reflection.Metadata.LocalScope\n  - System.Reflection.Metadata.LocalScopeHandle\n  - System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator\n  - System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator\n  - System.Reflection.Metadata.LocalScopeHandleCollection\n  - System.Reflection.Metadata.LocalVariable\n  - System.Reflection.Metadata.LocalVariableHandle\n  - System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator\n  - System.Reflection.Metadata.LocalVariableHandleCollection\n  - System.Reflection.Metadata.ManifestResource\n  - System.Reflection.Metadata.ManifestResourceHandle\n  - System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator\n  - System.Reflection.Metadata.ManifestResourceHandleCollection\n  - System.Reflection.Metadata.MemberReference\n  - System.Reflection.Metadata.MemberReferenceHandle\n  - System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator\n  - System.Reflection.Metadata.MemberReferenceHandleCollection\n  - System.Reflection.Metadata.MetadataStringComparer\n  - System.Reflection.Metadata.MethodDebugInformation\n  - System.Reflection.Metadata.MethodDebugInformationHandle\n  - System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator\n  - System.Reflection.Metadata.MethodDebugInformationHandleCollection\n  - System.Reflection.Metadata.MethodDefinition\n  - System.Reflection.Metadata.MethodDefinitionHandle\n  - System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator\n  - System.Reflection.Metadata.MethodDefinitionHandleCollection\n  - System.Reflection.Metadata.MethodImplementation\n  - System.Reflection.Metadata.MethodImplementationHandle\n  - System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator\n  - System.Reflection.Metadata.MethodImplementationHandleCollection\n  - System.Reflection.Metadata.MethodImport\n  - System.Reflection.Metadata.MethodSignature`1\n  - System.Reflection.Metadata.MethodSpecification\n  - System.Reflection.Metadata.MethodSpecificationHandle\n  - System.Reflection.Metadata.ModuleDefinition\n  - System.Reflection.Metadata.ModuleDefinitionHandle\n  - System.Reflection.Metadata.ModuleReference\n  - System.Reflection.Metadata.ModuleReferenceHandle\n  - System.Reflection.Metadata.NamespaceDefinition\n  - System.Reflection.Metadata.NamespaceDefinitionHandle\n  - System.Reflection.Metadata.Parameter\n  - System.Reflection.Metadata.ParameterHandle\n  - System.Reflection.Metadata.ParameterHandleCollection.Enumerator\n  - System.Reflection.Metadata.ParameterHandleCollection\n  - System.Reflection.Metadata.PropertyAccessors\n  - System.Reflection.Metadata.PropertyDefinition\n  - System.Reflection.Metadata.PropertyDefinitionHandle\n  - System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator\n  - System.Reflection.Metadata.PropertyDefinitionHandleCollection\n  - System.Reflection.Metadata.ReservedBlob`1\n  - System.Reflection.Metadata.SequencePoint\n  - System.Reflection.Metadata.SequencePointCollection.Enumerator\n  - System.Reflection.Metadata.SequencePointCollection\n  - System.Reflection.Metadata.SignatureHeader\n  - System.Reflection.Metadata.StandaloneSignature\n  - System.Reflection.Metadata.StandaloneSignatureHandle\n  - System.Reflection.Metadata.StringHandle\n  - System.Reflection.Metadata.TypeDefinition\n  - System.Reflection.Metadata.TypeDefinitionHandle\n  - System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator\n  - System.Reflection.Metadata.TypeDefinitionHandleCollection\n  - System.Reflection.Metadata.TypeLayout\n  - System.Reflection.Metadata.TypeReference\n  - System.Reflection.Metadata.TypeReferenceHandle\n  - System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator\n  - System.Reflection.Metadata.TypeReferenceHandleCollection\n  - System.Reflection.Metadata.TypeSpecification\n  - System.Reflection.Metadata.TypeSpecificationHandle\n  - System.Reflection.Metadata.UserStringHandle\n  - System.Reflection.Metadata.Ecma335.ArrayShapeEncoder\n  - System.Reflection.Metadata.Ecma335.BlobEncoder\n  - System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder\n  - System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder\n  - System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder\n  - System.Reflection.Metadata.Ecma335.CustomModifiersEncoder\n  - System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry\n  - System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder\n  - System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder\n  - System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder\n  - System.Reflection.Metadata.Ecma335.InstructionEncoder\n  - System.Reflection.Metadata.Ecma335.LabelHandle\n  - System.Reflection.Metadata.Ecma335.LiteralEncoder\n  - System.Reflection.Metadata.Ecma335.LiteralsEncoder\n  - System.Reflection.Metadata.Ecma335.LocalVariablesEncoder\n  - System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder\n  - System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody\n  - System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder\n  - System.Reflection.Metadata.Ecma335.MethodSignatureEncoder\n  - System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder\n  - System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder\n  - System.Reflection.Metadata.Ecma335.NameEncoder\n  - System.Reflection.Metadata.Ecma335.ParametersEncoder\n  - System.Reflection.Metadata.Ecma335.ParameterTypeEncoder\n  - System.Reflection.Metadata.Ecma335.PermissionSetEncoder\n  - System.Reflection.Metadata.Ecma335.ReturnTypeEncoder\n  - System.Reflection.Metadata.Ecma335.ScalarEncoder\n  - System.Reflection.Metadata.Ecma335.SignatureDecoder`1\n  - System.Reflection.Metadata.Ecma335.SignatureDecoder`2\n  - System.Reflection.Metadata.Ecma335.SignatureTypeEncoder\n  - System.Reflection.Metadata.Ecma335.VectorEncoder\n  - System.Reflection.PortableExecutable.CodeViewDebugDirectoryData\n  - System.Reflection.PortableExecutable.DebugDirectoryEntry\n  - System.Reflection.PortableExecutable.DirectoryEntry\n  - System.Reflection.PortableExecutable.PEBuilder.Section\n  - System.Reflection.PortableExecutable.PEMemoryBlock\n  - System.Reflection.PortableExecutable.SectionHeader\n  - System.Reflection.PortableExecutable.SectionLocation\n  - System.Runtime.CompilerServices.AsyncTaskMethodBuilder\n  - System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1\n  - System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1\n  - System.Runtime.CompilerServices.AsyncVoidMethodBuilder\n  - System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter\n  - System.Runtime.CompilerServices.ConfiguredTaskAwaitable\n  - System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter\n  - System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1\n  - System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter\n  - System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1\n  - System.Runtime.CompilerServices.TaskAwaiter\n  - System.Runtime.CompilerServices.TaskAwaiter`1\n  - System.Runtime.CompilerServices.ValueTaskAwaiter`1\n  - System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter\n  - System.Runtime.CompilerServices.YieldAwaitable\n  - System.Runtime.InteropServices.ArrayWithOffset\n  - System.Runtime.InteropServices.BINDPTR\n  - System.Runtime.InteropServices.BIND_OPTS\n  - System.Runtime.InteropServices.CONNECTDATA\n  - System.Runtime.InteropServices.DISPPARAMS\n  - System.Runtime.InteropServices.ELEMDESC.DESCUNION\n  - System.Runtime.InteropServices.ELEMDESC\n  - System.Runtime.InteropServices.EXCEPINFO\n  - System.Runtime.InteropServices.FILETIME\n  - System.Runtime.InteropServices.FUNCDESC\n  - System.Runtime.InteropServices.GCHandle\n  - System.Runtime.InteropServices.HandleRef\n  - System.Runtime.InteropServices.IDLDESC\n  - System.Runtime.InteropServices.OSPlatform\n  - System.Runtime.InteropServices.PARAMDESC\n  - System.Runtime.InteropServices.STATSTG\n  - System.Runtime.InteropServices.TYPEATTR\n  - System.Runtime.InteropServices.TYPEDESC\n  - System.Runtime.InteropServices.TYPELIBATTR\n  - System.Runtime.InteropServices.VARDESC.DESCUNION\n  - System.Runtime.InteropServices.VARDESC\n  - System.Runtime.InteropServices.ComTypes.BINDPTR\n  - System.Runtime.InteropServices.ComTypes.BIND_OPTS\n  - System.Runtime.InteropServices.ComTypes.CONNECTDATA\n  - System.Runtime.InteropServices.ComTypes.DISPPARAMS\n  - System.Runtime.InteropServices.ComTypes.ELEMDESC.DESCUNION\n  - System.Runtime.InteropServices.ComTypes.ELEMDESC\n  - System.Runtime.InteropServices.ComTypes.EXCEPINFO\n  - System.Runtime.InteropServices.ComTypes.FILETIME\n  - System.Runtime.InteropServices.ComTypes.FORMATETC\n  - System.Runtime.InteropServices.ComTypes.FUNCDESC\n  - System.Runtime.InteropServices.ComTypes.IDLDESC\n  - System.Runtime.InteropServices.ComTypes.PARAMDESC\n  - System.Runtime.InteropServices.ComTypes.STATDATA\n  - System.Runtime.InteropServices.ComTypes.STATSTG\n  - System.Runtime.InteropServices.ComTypes.STGMEDIUM\n  - System.Runtime.InteropServices.ComTypes.TYPEATTR\n  - System.Runtime.InteropServices.ComTypes.TYPEDESC\n  - System.Runtime.InteropServices.ComTypes.TYPELIBATTR\n  - System.Runtime.InteropServices.ComTypes.VARDESC.DESCUNION\n  - System.Runtime.InteropServices.ComTypes.VARDESC\n  - System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken\n  - System.Runtime.Serialization.SerializationEntry\n  - System.Runtime.Serialization.StreamingContext\n  - System.Security.Cryptography.CngProperty\n  - System.Security.Cryptography.DSAParameters\n  - System.Security.Cryptography.ECCurve\n  - System.Security.Cryptography.ECParameters\n  - System.Security.Cryptography.ECPoint\n  - System.Security.Cryptography.HashAlgorithmName\n  - System.Security.Cryptography.RSAParameters\n  - System.Security.Cryptography.X509Certificates.X509ChainStatus\n  - System.Security.Cryptography.Xml.X509IssuerSerial\n  - System.ServiceProcess.SessionChangeDescription\n  - System.Speech.Synthesis.TtsEngine.ContourPoint\n  - System.Speech.Synthesis.TtsEngine.FragmentState\n  - System.Speech.Synthesis.TtsEngine.ProsodyNumber\n  - System.Speech.Synthesis.TtsEngine.SpeechEventInfo\n  - System.Threading.AsyncFlowControl\n  - System.Threading.AsyncLocalValueChangedArgs`1\n  - System.Threading.CancellationToken\n  - System.Threading.CancellationTokenRegistration\n  - System.Threading.LockCookie\n  - System.Threading.NativeOverlapped\n  - System.Threading.SpinLock\n  - System.Threading.SpinWait\n  - System.Threading.Tasks.ParallelLoopResult\n  - System.Threading.Tasks.ValueTask`1\n  - System.Threading.Tasks.Dataflow.DataflowMessageHeader\n  - System.Transactions.TransactionOptions\n  - System.Web.UI.WebControls.FontUnit\n  - System.Web.UI.WebControls.Unit\n  - System.Windows.CornerRadius\n  - System.Windows.DependencyPropertyChangedEventArgs\n  - System.Windows.DpiScale\n  - System.Windows.Duration\n  - System.Windows.FigureLength\n  - System.Windows.FontStretch\n  - System.Windows.FontStyle\n  - System.Windows.FontWeight\n  - System.Windows.FreezableCollection`1.Enumerator\n  - System.Windows.GridLength\n  - System.Windows.Int32Rect\n  - System.Windows.LocalValueEntry\n  - System.Windows.LocalValueEnumerator\n  - System.Windows.Point\n  - System.Windows.Rect\n  - System.Windows.RoutedEventHandlerInfo\n  - System.Windows.Size\n  - System.Windows.TextDecorationCollection.Enumerator\n  - System.Windows.Thickness\n  - System.Windows.ValueSource\n  - System.Windows.Vector\n  - System.Windows.Automation.AutomationElement.AutomationElementInformation\n  - System.Windows.Automation.ClientSideProviderDescription\n  - System.Windows.Automation.DockPattern.DockPatternInformation\n  - System.Windows.Automation.ExpandCollapsePattern.ExpandCollapsePatternInformation\n  - System.Windows.Automation.GridItemPattern.GridItemPatternInformation\n  - System.Windows.Automation.GridPattern.GridPatternInformation\n  - System.Windows.Automation.MultipleViewPattern.MultipleViewPatternInformation\n  - System.Windows.Automation.RangeValuePattern.RangeValuePatternInformation\n  - System.Windows.Automation.ScrollPattern.ScrollPatternInformation\n  - System.Windows.Automation.SelectionItemPattern.SelectionItemPatternInformation\n  - System.Windows.Automation.SelectionPattern.SelectionPatternInformation\n  - System.Windows.Automation.TableItemPattern.TableItemPatternInformation\n  - System.Windows.Automation.TablePattern.TablePatternInformation\n  - System.Windows.Automation.TogglePattern.TogglePatternInformation\n  - System.Windows.Automation.TransformPattern.TransformPatternInformation\n  - System.Windows.Automation.ValuePattern.ValuePatternInformation\n  - System.Windows.Automation.WindowPattern.WindowPatternInformation\n  - System.Windows.Controls.DataGridCellInfo\n  - System.Windows.Controls.DataGridClipboardCellContent\n  - System.Windows.Controls.DataGridLength\n  - System.Windows.Controls.HierarchicalVirtualizationConstraints\n  - System.Windows.Controls.HierarchicalVirtualizationHeaderDesiredSizes\n  - System.Windows.Controls.HierarchicalVirtualizationItemDesiredSizes\n  - System.Windows.Controls.PageRange\n  - System.Windows.Controls.VirtualizationCacheLength\n  - System.Windows.Controls.Primitives.CustomPopupPlacement\n  - System.Windows.Controls.Primitives.GeneratorPosition\n  - System.Windows.Controls.Ribbon.RibbonControlLength\n  - System.Windows.Forms.BindingMemberInfo\n  - System.Windows.Forms.DataGridCell\n  - System.Windows.Forms.ImeModeConversion\n  - System.Windows.Forms.LinkArea\n  - System.Windows.Forms.Message\n  - System.Windows.Forms.Padding\n  - System.Windows.Forms.TableLayoutPanelCellPosition\n  - System.Windows.Forms.Design.ThemedScrollbarWindow\n  - System.Windows.Forms.VisualStyles.TextMetrics\n  - System.Windows.Input.StylusPoint\n  - System.Windows.Input.Manipulations.Manipulator2D\n  - System.Windows.Interop.HwndSourceParameters\n  - System.Windows.Interop.MSG\n  - System.Windows.Media.Color\n  - System.Windows.Media.DoubleCollection.Enumerator\n  - System.Windows.Media.DrawingCollection.Enumerator\n  - System.Windows.Media.GeneralTransformCollection.Enumerator\n  - System.Windows.Media.GeometryCollection.Enumerator\n  - System.Windows.Media.GradientStopCollection.Enumerator\n  - System.Windows.Media.Int32Collection.Enumerator\n  - System.Windows.Media.Matrix\n  - System.Windows.Media.PathFigureCollection.Enumerator\n  - System.Windows.Media.PathSegmentCollection.Enumerator\n  - System.Windows.Media.PixelFormat\n  - System.Windows.Media.PixelFormatChannelMask\n  - System.Windows.Media.PointCollection.Enumerator\n  - System.Windows.Media.TextEffectCollection.Enumerator\n  - System.Windows.Media.TransformCollection.Enumerator\n  - System.Windows.Media.VectorCollection.Enumerator\n  - System.Windows.Media.VisualCollection.Enumerator\n  - System.Windows.Media.Animation.KeyTime\n  - System.Windows.Media.Animation.RepeatBehavior\n  - System.Windows.Media.Animation.TimelineCollection.Enumerator\n  - System.Windows.Media.Effects.BitmapEffectCollection.Enumerator\n  - System.Windows.Media.Media3D.GeneralTransform3DCollection.Enumerator\n  - System.Windows.Media.Media3D.MaterialCollection.Enumerator\n  - System.Windows.Media.Media3D.Matrix3D\n  - System.Windows.Media.Media3D.Model3DCollection.Enumerator\n  - System.Windows.Media.Media3D.Point3D\n  - System.Windows.Media.Media3D.Point3DCollection.Enumerator\n  - System.Windows.Media.Media3D.Point4D\n  - System.Windows.Media.Media3D.Quaternion\n  - System.Windows.Media.Media3D.Rect3D\n  - System.Windows.Media.Media3D.Size3D\n  - System.Windows.Media.Media3D.Transform3DCollection.Enumerator\n  - System.Windows.Media.Media3D.Vector3D\n  - System.Windows.Media.Media3D.Vector3DCollection.Enumerator\n  - System.Windows.Media.Media3D.Visual3DCollection.Enumerator\n  - System.Windows.Media.TextFormatting.CharacterBufferRange\n  - System.Windows.Media.TextFormatting.CharacterBufferReference\n  - System.Windows.Media.TextFormatting.CharacterHit\n  - System.Windows.Media.TextFormatting.MinMaxParagraphWidth\n  - System.Windows.Threading.DispatcherPriorityAwaitable\n  - System.Windows.Threading.DispatcherPriorityAwaiter\n  - System.Windows.Threading.DispatcherProcessingDisabled\n  - System.Workflow.Runtime.DebugEngine.ActivityHandlerDescriptor\n  - System.Xml.Serialization.XmlDeserializationEvents\n  - System.Xml.Xsl.Runtime.AncestorDocOrderIterator\n  - System.Xml.Xsl.Runtime.AncestorIterator\n  - System.Xml.Xsl.Runtime.AttributeContentIterator\n  - System.Xml.Xsl.Runtime.AttributeIterator\n  - System.Xml.Xsl.Runtime.ContentIterator\n  - System.Xml.Xsl.Runtime.ContentMergeIterator\n  - System.Xml.Xsl.Runtime.DecimalAggregator\n  - System.Xml.Xsl.Runtime.DescendantIterator\n  - System.Xml.Xsl.Runtime.DescendantMergeIterator\n  - System.Xml.Xsl.Runtime.DifferenceIterator\n  - System.Xml.Xsl.Runtime.DodSequenceMerge\n  - System.Xml.Xsl.Runtime.DoubleAggregator\n  - System.Xml.Xsl.Runtime.ElementContentIterator\n  - System.Xml.Xsl.Runtime.FollowingSiblingIterator\n  - System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator\n  - System.Xml.Xsl.Runtime.IdIterator\n  - System.Xml.Xsl.Runtime.Int32Aggregator\n  - System.Xml.Xsl.Runtime.Int64Aggregator\n  - System.Xml.Xsl.Runtime.IntersectIterator\n  - System.Xml.Xsl.Runtime.NamespaceIterator\n  - System.Xml.Xsl.Runtime.NodeKindContentIterator\n  - System.Xml.Xsl.Runtime.NodeRangeIterator\n  - System.Xml.Xsl.Runtime.ParentIterator\n  - System.Xml.Xsl.Runtime.PrecedingIterator\n  - System.Xml.Xsl.Runtime.PrecedingSiblingDocOrderIterator\n  - System.Xml.Xsl.Runtime.PrecedingSiblingIterator\n  - System.Xml.Xsl.Runtime.StringConcat\n  - System.Xml.Xsl.Runtime.UnionIterator\n  - System.Xml.Xsl.Runtime.XmlSortKeyAccumulator\n  - System.Xml.Xsl.Runtime.XPathFollowingIterator\n  - System.Xml.Xsl.Runtime.XPathFollowingMergeIterator\n  - System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator\n  - System.Xml.Xsl.Runtime.XPathPrecedingIterator\n  - System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.ValueType.#ctor\n  commentId: M:System.ValueType.#ctor\n  id: '#ctor'\n  parent: System.ValueType\n  langs:\n  - csharp\n  name: ValueType()\n  nameWithType: ValueType.ValueType()\n  fullName: ValueType.ValueType()\n  type: Constructor\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Initializes a new instance of the <xref href=\"System.ValueType\"></xref> class.\n  syntax:\n    content: protected ValueType ();\n    parameters: []\n  overload: System.ValueType.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.ValueType.Equals(System.Object)\n  commentId: M:System.ValueType.Equals(System.Object)\n  id: Equals(System.Object)\n  parent: System.ValueType\n  langs:\n  - csharp\n  name: Equals(Object)\n  nameWithType: ValueType.Equals(Object)\n  fullName: ValueType.Equals(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Indicates whether this instance and a specified object are equal.\n  remarks: \"The <xref:System.ValueType.Equals%28System.Object%29?displayProperty=fullName> method overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> and provides the default implementation of value equality for all value types in the .NET Framework.  \\n  \\n If none of the fields of the current instance and `obj` are reference types, the <xref:System.ValueType.Equals%2A> method performs a byte-by-byte comparison of the two objects in memory. Otherwise, it uses reflection to compare the corresponding fields of `obj` and this instance.  \\n  \\n> [!TIP]\\n>  Particularly if your value type contains fields that are reference types, you should override the <xref:System.ValueType.Equals%28System.Object%29> method. This can improve performance and enable you to more closely represent the meaning of equality for the type.  \\n  \\n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \\n When you call the <xref:System.ValueType.Equals%2A>method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.Equals%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.Equals%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.\"\n  example:\n  - \"The following example demonstrates how the <xref:System.ValueType.Equals%2A> method can be overridden by a derived value type.  \\n  \\n [!code-cpp[ValueType.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/ValueType.Equals Example/CPP/source.cpp#1)]\\n [!code-csharp[ValueType.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/ValueType.Equals Example/CS/source.cs#1)]\\n [!code-vb[ValueType.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ValueType.Equals Example/VB/source.vb#1)]\"\n  syntax:\n    content: public override bool Equals (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object to compare with the current instance.\n    return:\n      type: System.Boolean\n      description: '`true` if <code>obj</code> and this instance are the same type and represent the same value; otherwise, `false`.'\n  overload: System.ValueType.Equals*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.ValueType.GetHashCode\n  commentId: M:System.ValueType.GetHashCode\n  id: GetHashCode\n  parent: System.ValueType\n  langs:\n  - csharp\n  name: GetHashCode()\n  nameWithType: ValueType.GetHashCode()\n  fullName: ValueType.GetHashCode()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns the hash code for this instance.\n  remarks: \"The <xref:System.ValueType.GetHashCode%2A> method applies to types derived from <xref:System.ValueType>. One or more fields of the derived type is used to calculate the return value. If you call the derived type's `GetHashCode` method, the return value is not likely to be suitable for use as a key in a hash table. Additionally, if the value of one or more of those fields changes, the return value might become unsuitable for use as a key in a hash table. In either case, consider writing your own implementation of the <xref:System.ValueType.GetHashCode%2A> method that more closely represents the concept of a hash code for the type.  \\n  \\n For more information, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>, and <xref:System.Collections.Hashtable?displayProperty=fullName>.  \\n  \\n## Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]  \\n When you call the <xref:System.ValueType.GetHashCode%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.GetHashCode%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.GetHashCode%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.\"\n  example:\n  - \"The following example demonstrates how the <xref:System.ValueType.GetHashCode%2A> method can be overridden by a derived value type.  \\n  \\n [!code-cpp[ValueType.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/ValueType.Equals Example/CPP/source.cpp#1)]\\n [!code-csharp[ValueType.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/ValueType.Equals Example/CS/source.cs#1)]\\n [!code-vb[ValueType.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ValueType.Equals Example/VB/source.vb#1)]\"\n  syntax:\n    content: public override int GetHashCode ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: A 32-bit signed integer that is the hash code for this instance.\n  overload: System.ValueType.GetHashCode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.ValueType.ToString\n  commentId: M:System.ValueType.ToString\n  id: ToString\n  parent: System.ValueType\n  langs:\n  - csharp\n  name: ToString()\n  nameWithType: ValueType.ToString()\n  fullName: ValueType.ToString()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns the fully qualified type name of this instance.\n  remarks: \"The <xref:System.ValueType.ToString%2A?displayProperty=fullName> method overrides the <xref:System.Object.ToString%2A?displayProperty=fullName> method and provides the default implementation of the `ToString` method for value types. (Value types are types defined by the `struct` keyword in C#, and by the `Structure`...`End Structure` construct in Visual Basic.) Functionally, however, the implementation is that same as that of <xref:System.Object.ToString%2A?displayProperty=fullName>: the method returns the fully qualified type name.  \\n  \\n Value types defined by the `struct` keyword in C# and the `Structure`...`End Structure` construct in Visual Basic typically override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method to provide a more meaningful string representation of the value type. The following example illustrates the difference. It defines two value types, `EmployeeA` and `EmployeeB`, creates an instance of each, and calls its `ToString` method. Because the `EmployeeA` structure does not override the <xref:System.ValueType.ToString%2A?displayProperty=fullName> method, it displays only the fully qualified type name. The `EmployeeB.ToString` method, on the other hand, provides meaningful information about the object.  \\n  \\n [!code-csharp[System.ValueType.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.ValueType.ToString/cs/ToString2.cs#1)]\\n [!code-vb[System.ValueType.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.ValueType.ToString/vb/ToString2.vb#1)]  \\n  \\n Note that, although enumeration types are also value types, they derive from the <xref:System.Enum> class, which overrides  <xref:System.ValueType.ToString%2A?displayProperty=fullName>.  \\n  \\n## Notes for the Windows Runtime  \\n When you call the <xref:System.ValueType.ToString%2A> method on a [!INCLUDE[wrt](~/includes/wrt-md.md)] structure, it provides the default behavior for value types that don’t override <xref:System.ValueType.ToString%2A>. This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). [!INCLUDE[wrt](~/includes/wrt-md.md)] structures can’t override <xref:System.ValueType.ToString%2A>, even if they’re written with C# or Visual Basic, because they can’t have methods. (In addition, structures in the [!INCLUDE[wrt](~/includes/wrt-md.md)] itself don’t inherit <xref:System.ValueType>.) However, they appear to have <xref:System.ValueType.ToString%2A>, <xref:System.ValueType.Equals%2A>, and <xref:System.ValueType.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.\"\n  syntax:\n    content: public override string ToString ();\n    parameters: []\n    return:\n      type: System.String\n      description: The fully qualified type name.\n  overload: System.ValueType.ToString*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ValueType.#ctor\n  parent: System.ValueType\n  isExternal: false\n  name: ValueType()\n  nameWithType: ValueType.ValueType()\n  fullName: ValueType.ValueType()\n- uid: System.ValueType.Equals(System.Object)\n  parent: System.ValueType\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: ValueType.Equals(Object)\n  fullName: ValueType.Equals(Object)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.ValueType.GetHashCode\n  parent: System.ValueType\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: ValueType.GetHashCode()\n  fullName: ValueType.GetHashCode()\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.ValueType.ToString\n  parent: System.ValueType\n  isExternal: false\n  name: ToString()\n  nameWithType: ValueType.ToString()\n  fullName: ValueType.ToString()\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.ValueType.#ctor*\n  parent: System.ValueType\n  isExternal: false\n  name: ValueType\n  nameWithType: ValueType.ValueType\n  fullName: ValueType.ValueType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n- uid: System.ValueType.Equals*\n  parent: System.ValueType\n  isExternal: false\n  name: Equals\n  nameWithType: ValueType.Equals\n  fullName: ValueType.Equals\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n- uid: System.ValueType.GetHashCode*\n  parent: System.ValueType\n  isExternal: false\n  name: GetHashCode\n  nameWithType: ValueType.GetHashCode\n  fullName: ValueType.GetHashCode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n- uid: System.ValueType.ToString*\n  parent: System.ValueType\n  isExternal: false\n  name: ToString\n  nameWithType: ValueType.ToString\n  fullName: ValueType.ToString\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/ValueType.xml\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n"}