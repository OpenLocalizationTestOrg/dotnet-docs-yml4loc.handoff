{"nodes":[{"content":"Ensures that all finalization code in derived classes is marked as critical.","nodes":[{"pos":[0,76],"content":"Ensures that all finalization code in derived classes is marked as critical.","nodes":[{"content":"Ensures that all finalization code in derived classes is marked as critical.","pos":[0,76]}]}],"pos":[663,740],"yaml":true},{"content":"Classes deriving from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class are implicitly treated as a constrained execution region (CER).  This requires code in the finalizer to only call code with a strong reliability contract. For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace.  \n  \n In classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread. If a finalizer violates the rules for a CER, it might not successfully execute. In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers. For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, can run a standard finalizer to flush out existing buffered data.  \n  \n In most cases, you do not need to write classes that derive from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class. The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources. Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace. These classes are designed to provide common functionality for supporting file and operating system handles.","nodes":[{"pos":[0,348],"content":"Classes deriving from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class are implicitly treated as a constrained execution region (CER).  This requires code in the finalizer to only call code with a strong reliability contract. For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace.","nodes":[{"content":"Classes deriving from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class are implicitly treated as a constrained execution region (CER).  This requires code in the finalizer to only call code with a strong reliability contract. For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace.","pos":[0,348],"nodes":[{"content":"Classes deriving from the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class are implicitly treated as a constrained execution region (CER).","pos":[0,162],"source":"Classes deriving from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class are implicitly treated as a constrained execution region (CER)."},{"content":"This requires code in the finalizer to only call code with a strong reliability contract.","pos":[164,253]},{"content":"For more information about CERs, see the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.","pos":[254,348],"source":" For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace."}]}]},{"pos":[355,1325],"content":"In classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread. If a finalizer violates the rules for a CER, it might not successfully execute. In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers. For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, can run a standard finalizer to flush out existing buffered data.","nodes":[{"content":"In classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread. If a finalizer violates the rules for a CER, it might not successfully execute. In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers. For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, can run a standard finalizer to flush out existing buffered data.","pos":[0,970],"nodes":[{"content":"In classes derived from the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread.","pos":[0,368],"source":"In classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread."},{"content":"If a finalizer violates the rules for a CER, it might not successfully execute.","pos":[369,448]},{"content":"In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers.","pos":[449,678]},{"content":"For example, a class such as <ph id=\"ph1\">&lt;xref:System.IO.FileStream&gt;</ph>, which holds data in the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class that is derived from <ph id=\"ph3\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph>, can run a standard finalizer to flush out existing buffered data.","pos":[679,970],"source":" For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, can run a standard finalizer to flush out existing buffered data."}]}]},{"pos":[1332,2035],"content":"In most cases, you do not need to write classes that derive from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class. The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources. Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace. These classes are designed to provide common functionality for supporting file and operating system handles.","nodes":[{"content":"In most cases, you do not need to write classes that derive from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class. The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources. Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace. These classes are designed to provide common functionality for supporting file and operating system handles.","pos":[0,703],"nodes":[{"content":"In most cases, you do not need to write classes that derive from the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class.","pos":[0,142],"source":"In most cases, you do not need to write classes that derive from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class."},{"content":"The .NET Framework class library provides two classes, <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>, that provide critical finalization functionality for handle resources.","pos":[143,375],"source":" The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources."},{"content":"Furthermore, the .NET Framework provides a set of prewritten classes derived from the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, and this set is located in the <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles&gt;</ph> namespace.","pos":[376,594],"source":" Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace."},{"content":"These classes are designed to provide common functionality for supporting file and operating system handles.","pos":[595,703]}]}]}],"pos":[751,2793],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class.","nodes":[{"pos":[0,121],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class."}],"pos":[5427,5549],"yaml":true},{"content":"Releases all the resources used by the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class.","nodes":[{"pos":[0,126],"content":"Releases all the resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"&gt;&lt;/xref&gt;</ph> class.","source":"Releases all the resources used by the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class."}],"pos":[7017,7144],"yaml":true},{"content":"The finalizer for any types deriving from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER).","nodes":[{"pos":[0,262],"content":"The finalizer for any types deriving from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER).","nodes":[{"content":"The finalizer for any types deriving from <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER).","pos":[0,262],"source":"The finalizer for any types deriving from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER)."}]}],"pos":[7155,7418],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  commentId: T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  id: CriticalFinalizerObject\n  children:\n  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor\n  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize\n  langs:\n  - csharp\n  name: CriticalFinalizerObject\n  nameWithType: CriticalFinalizerObject\n  fullName: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  type: Class\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.ConstrainedExecution\n  summary: Ensures that all finalization code in derived classes is marked as critical.\n  remarks: \"Classes deriving from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class are implicitly treated as a constrained execution region (CER).  This requires code in the finalizer to only call code with a strong reliability contract. For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace.  \\n  \\n In classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread. If a finalizer violates the rules for a CER, it might not successfully execute. In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers. For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, can run a standard finalizer to flush out existing buffered data.  \\n  \\n In most cases, you do not need to write classes that derive from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class. The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources. Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace. These classes are designed to provide common functionality for supporting file and operating system handles.\"\n  example:\n  - \"The following code example shows the use of the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class to provide critical finalization for the standard input and output streams. The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, is passed to the file stream in the <xref:System.IO.FileStream> constructor.  \\n  \\n [!code-csharp[SafeHandle.SafeFileHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle.SafeFileHandle/CS/program.cs#1)]\\n [!code-vb[SafeHandle.SafeFileHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle.SafeFileHandle/vb/program.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract class CriticalFinalizerObject\n  inheritance:\n  - System.Object\n  derivedClasses:\n  - System.Runtime.MemoryFailPoint\n  - System.Threading.ReaderWriterLock\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/CriticalFinalizerObject.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor\n  commentId: M:System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor\n  id: '#ctor'\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  langs:\n  - csharp\n  name: CriticalFinalizerObject()\n  nameWithType: CriticalFinalizerObject.CriticalFinalizerObject()\n  fullName: CriticalFinalizerObject.CriticalFinalizerObject()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.ConstrainedExecution\n  summary: Initializes a new instance of the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class.\n  syntax:\n    content: protected CriticalFinalizerObject ();\n    parameters: []\n  overload: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/CriticalFinalizerObject.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize\n  commentId: M:System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize\n  id: Finalize\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: CriticalFinalizerObject.Finalize()\n  fullName: CriticalFinalizerObject.Finalize()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.ConstrainedExecution\n  summary: Releases all the resources used by the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class.\n  remarks: The finalizer for any types deriving from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER).\n  syntax:\n    content: ~CriticalFinalizerObject ();\n    parameters: []\n  overload: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/CriticalFinalizerObject.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: CriticalFinalizerObject()\n  nameWithType: CriticalFinalizerObject.CriticalFinalizerObject()\n  fullName: CriticalFinalizerObject.CriticalFinalizerObject()\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: Finalize()\n  nameWithType: CriticalFinalizerObject.Finalize()\n  fullName: CriticalFinalizerObject.Finalize()\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor*\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: CriticalFinalizerObject\n  nameWithType: CriticalFinalizerObject.CriticalFinalizerObject\n  fullName: CriticalFinalizerObject.CriticalFinalizerObject\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/CriticalFinalizerObject.xml\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize*\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: Finalize\n  nameWithType: CriticalFinalizerObject.Finalize\n  fullName: CriticalFinalizerObject.Finalize\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/CriticalFinalizerObject.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}