{"nodes":[{"content":"An <xref href=\"System.Windows.Media.ImageSource\"></xref> that displays a user-created Direct3D surface.","nodes":[{"pos":[0,103],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.ImageSource\"&gt;&lt;/xref&gt;</ph> that displays a user-created Direct3D surface.","source":"An <xref href=\"System.Windows.Media.ImageSource\"></xref> that displays a user-created Direct3D surface."}],"pos":[1966,2070],"yaml":true},{"content":"Use the <xref:System.Windows.Interop.D3DImage> class to host Direct3D content in a Windows Presentation Foundation (WPF) application.  \n  \n Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the Direct3D content displayed by the <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to a <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to track updates to the Direct3D surface. Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to display the changed areas.  \n  \n The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*. The back buffer is your Direct3D surface.  Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware. Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.  \n  \n## Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering  \n When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  \n  \n## Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering  \n When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.  There may be situations where the user’s device becomes unavailable.  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.  \n  \n> [!NOTE]\n>  Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  \n  \n> [!NOTE]\n>  The <xref:System.Windows.Interop.D3DImage> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> and specify `true` for the `enableSoftwareFallback` parameter.","nodes":[{"pos":[0,133],"content":"Use the <xref:System.Windows.Interop.D3DImage> class to host Direct3D content in a Windows Presentation Foundation (WPF) application.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class to host Direct3D content in a Windows Presentation Foundation (WPF) application.","pos":[0,133],"source":"Use the <xref:System.Windows.Interop.D3DImage> class to host Direct3D content in a Windows Presentation Foundation (WPF) application."}]},{"pos":[140,644],"content":"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the Direct3D content displayed by the <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to a <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to track updates to the Direct3D surface. Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to display the changed areas.","nodes":[{"content":"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the Direct3D content displayed by the <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to a <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to track updates to the Direct3D surface. Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to display the changed areas.","pos":[0,504],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method to change the Direct3D content displayed by the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.","pos":[0,150],"source":"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the Direct3D content displayed by the <xref:System.Windows.Interop.D3DImage>."},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method to assign a Direct3D surface to a <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.","pos":[151,296],"source":" Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to a <xref:System.Windows.Interop.D3DImage>."},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method to track updates to the Direct3D surface.","pos":[297,409],"source":" Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to track updates to the Direct3D surface."},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method to display the changed areas.","pos":[410,504],"source":" Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to display the changed areas."}]}]},{"pos":[651,1662],"content":"The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*. The back buffer is your Direct3D surface.  Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware. Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class manages two display buffers, which are called the <bpt id=\"p1\">*</bpt>back buffer<ept id=\"p1\">*</ept> and the <bpt id=\"p2\">*</bpt>front buffer<ept id=\"p2\">*</ept>.","pos":[0,136],"source":"The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*."},{"content":"The back buffer is your Direct3D surface.","pos":[137,178]},{"content":"Changes to the back buffer are copied forward to the front buffer when you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method, where it is displayed on the hardware.","pos":[180,359],"source":"  Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware."},{"content":"Occasionally, the front buffer becomes unavailable.","pos":[360,411]},{"content":"This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.","pos":[412,559]},{"content":"When this occurs, your WPF application is notified by handling the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event.","pos":[560,702],"source":" When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event."},{"content":"How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.","pos":[704,844]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.","pos":[845,1011],"source":" The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering."}]},{"pos":[1671,1762],"content":"Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering","linkify":"Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering","nodes":[{"content":"Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering","pos":[0,91]}]},{"pos":[1766,2695],"content":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> overload or call the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id=\"ph3\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph4\">`false`</ph>, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.","pos":[0,481],"source":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed."},{"content":"When the front buffer is available again, the rendering system raises the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to notify your WPF application.","pos":[482,662],"source":" When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application."},{"content":"You can create an event handler for the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to restart rendering again with a valid Direct3D surface.","pos":[664,836],"source":"  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface."},{"content":"To restart rendering, you must call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.","pos":[837,929],"source":" To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>."}]},{"pos":[2704,2787],"content":"Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering","linkify":"Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering","nodes":[{"content":"Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering","pos":[0,83]}]},{"pos":[2791,3704],"content":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.  There may be situations where the user’s device becomes unavailable.  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id=\"ph2\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph3\">`true`</ph>, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <ph id=\"ph4\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> when the front buffer is available again.","pos":[0,446],"source":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again."},{"content":"There may be situations where the user’s device becomes unavailable.","pos":[448,516]},{"content":"When that occurs, call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> to release WPF’s reference to the back buffer.","pos":[518,643],"source":"  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer."},{"content":"If you need to reset your device, call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> with the <ph id=\"ph2\">`backBuffer`</ph> parameter set to <ph id=\"ph3\">`null`</ph>, and then call <ph id=\"ph4\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> again with <ph id=\"ph5\">`backBuffer`</ph> set to a valid Direct3D surface.","pos":[645,913],"source":"  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface."}]},{"pos":[3712,3986],"content":"[!NOTE]\n Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).","leadings":["","> "],"nodes":[{"content":" Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).","pos":[8,272],"nodes":[{"content":"Performance depends greatly on the settings of the Direct3D surface.","pos":[1,69]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Performance Considerations for Direct3D9 and WPF Interoperability<ept id=\"p1\">](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.","pos":[70,264],"source":" For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)."}]}]},{"pos":[3994,4368],"content":"[!NOTE]\n The <xref:System.Windows.Interop.D3DImage> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> and specify `true` for the `enableSoftwareFallback` parameter.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> and specify <ph id=\"ph3\">`true`</ph> for the <ph id=\"ph4\">`enableSoftwareFallback`</ph> parameter.","pos":[9,372],"source":" The <xref:System.Windows.Interop.D3DImage> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> and specify `true` for the `enableSoftwareFallback` parameter."}]}],"pos":[2081,6468],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> class.","nodes":[{"pos":[0,93],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> class."}],"pos":[11898,11992],"yaml":true},{"content":"The default display resolution is 1/96th inch.","nodes":[{"pos":[0,46],"content":"The default display resolution is 1/96th inch.","nodes":[{"content":"The default display resolution is 1/96th inch.","pos":[0,46]}]}],"pos":[12003,12050],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> class with the specified display resolution.","nodes":[{"pos":[0,131],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> class with the specified display resolution.","source":"Initializes a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> class with the specified display resolution."}],"pos":[13198,13330],"yaml":true},{"content":"The default display resolution is 1/96th inch.","nodes":[{"pos":[0,46],"content":"The default display resolution is 1/96th inch.","nodes":[{"content":"The default display resolution is 1/96th inch.","pos":[0,46]}]}],"pos":[13341,13388],"yaml":true,"extradata":"MT"},{"content":"The display resolution on the x-axis.","nodes":[{"pos":[0,37],"content":"The display resolution on the x-axis.","nodes":[{"content":"The display resolution on the x-axis.","pos":[0,37]}]}],"pos":[13582,13620],"yaml":true},{"content":"The display resolution on the y-axis.","nodes":[{"pos":[0,37],"content":"The display resolution on the y-axis.","nodes":[{"content":"The display resolution on the y-axis.","pos":[0,37]}]}],"pos":[13680,13718],"yaml":true},{"content":"<code>dpiX</code> or <code>dpiY</code> is less than zero.","nodes":[{"pos":[0,57],"content":"<ph id=\"ph1\">&lt;code&gt;dpiX&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;dpiY&lt;/code&gt;</ph> is less than zero.","source":"<code>dpiX</code> or <code>dpiY</code> is less than zero."}],"pos":[13897,13955],"yaml":true},{"content":"Specifies the area of the back buffer that changed.","nodes":[{"pos":[0,51],"content":"Specifies the area of the back buffer that changed.","nodes":[{"content":"Specifies the area of the back buffer that changed.","pos":[0,51]}]}],"pos":[15019,15071],"yaml":true},{"content":"Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer. To be rendered, the changed area on the back buffer must have a corresponding changed area on the <xref:System.Windows.Interop.D3DImage>.  \n  \n Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> and <xref:System.Windows.Interop.D3DImage.Lock%2A> methods before calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.  \n  \n Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the changed areas to the front buffer.  \n  \n> [!NOTE]\n>  After a few calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method, the changed areas are merged into a single area. This means you must have valid data outside of the changed areas.","nodes":[{"pos":[0,267],"content":"Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer. To be rendered, the changed area on the back buffer must have a corresponding changed area on the <xref:System.Windows.Interop.D3DImage>.","nodes":[{"content":"Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer. To be rendered, the changed area on the back buffer must have a corresponding changed area on the <xref:System.Windows.Interop.D3DImage>.","pos":[0,267],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method to indicate changes your code has made to the back buffer.","pos":[0,129],"source":"Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer."},{"content":"To be rendered, the changed area on the back buffer must have a corresponding changed area on the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>.","pos":[130,267],"source":" To be rendered, the changed area on the back buffer must have a corresponding changed area on the <xref:System.Windows.Interop.D3DImage>."}]}]},{"pos":[274,479],"content":"Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> and <xref:System.Windows.Interop.D3DImage.Lock%2A> methods before calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> methods before calling the <ph id=\"ph3\">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method.","pos":[0,205],"source":"Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> and <xref:System.Windows.Interop.D3DImage.Lock%2A> methods before calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method."}]},{"pos":[486,597],"content":"Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the changed areas to the front buffer.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method to copy the changed areas to the front buffer.","pos":[0,111],"source":"Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the changed areas to the front buffer."}]},{"pos":[605,818],"content":"[!NOTE]\n After a few calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method, the changed areas are merged into a single area. This means you must have valid data outside of the changed areas.","leadings":["","> "],"nodes":[{"content":" After a few calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method, the changed areas are merged into a single area. This means you must have valid data outside of the changed areas.","pos":[8,211],"nodes":[{"content":"After a few calls to the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method, the changed areas are merged into a single area.","pos":[1,137],"source":" After a few calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method, the changed areas are merged into a single area."},{"content":"This means you must have valid data outside of the changed areas.","pos":[138,203]}]}]}],"pos":[15082,15910],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Windows.Int32Rect\"></xref> that represents the area that changed.","nodes":[{"pos":[0,87],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Windows.Int32Rect\"&gt;&lt;/xref&gt;</ph> that represents the area that changed.","source":"An <xref href=\"System.Windows.Int32Rect\"></xref> that represents the area that changed."}],"pos":[16625,16713],"yaml":true},{"content":"The bitmap has not been locked by a call to the <xref href=\"System.Windows.Interop.D3DImage.Lock\"></xref> or <xref href=\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\"></xref> methods.  \n  \n -or-  \n  \n The back buffer has not been assigned by a call to the <xref href=\"System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\"></xref> method.","nodes":[{"pos":[0,203],"content":"The bitmap has not been locked by a call to the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage.Lock\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\"&gt;&lt;/xref&gt;</ph> methods.","source":"The bitmap has not been locked by a call to the <xref href=\"System.Windows.Interop.D3DImage.Lock\"></xref> or <xref href=\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\"></xref> methods."},{"pos":[210,214],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[221,404],"content":"The back buffer has not been assigned by a call to the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\"&gt;&lt;/xref&gt;</ph> method.","source":"The back buffer has not been assigned by a call to the <xref href=\"System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\"></xref> method."}],"pos":[16895,17312],"yaml":true},{"content":"One or more of the following conditions is true.  \n  \n <code>dirtyRect.X</code> < 0  \n  \n <code>dirtyRect.Y</code> < 0  \n  \n <code>dirtyRect.Width</code> < 0 or <code>dirtyRect.Width</code> > <xref href=\"System.Windows.Interop.D3DImage.PixelWidth\"></xref><code>dirtyRect.Height</code> < 0 or <code>dirtyRect.Height</code> > <xref href=\"System.Windows.Interop.D3DImage.PixelHeight\"></xref>","nodes":[{"pos":[0,48],"content":"One or more of the following conditions is true.","nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]}]},{"pos":[55,389],"content":"<ph id=\"ph1\">&lt;code&gt;dirtyRect.X&lt;/code&gt;</ph> &lt; 0  <ph id=\"ph2\">&lt;code&gt;dirtyRect.Y&lt;/code&gt;</ph> &lt; 0  <ph id=\"ph3\">&lt;code&gt;dirtyRect.Width&lt;/code&gt;</ph> &lt; 0 or <ph id=\"ph4\">&lt;code&gt;dirtyRect.Width&lt;/code&gt;</ph><ph id=\"ph5\"> &gt; &lt;xref href=\"System.Windows.Interop.D3DImage.PixelWidth\"&gt;&lt;/xref&gt;</ph><ph id=\"ph6\">&lt;code&gt;dirtyRect.Height&lt;/code&gt;</ph> &lt; 0 or <ph id=\"ph7\">&lt;code&gt;dirtyRect.Height&lt;/code&gt;</ph><ph id=\"ph8\"> &gt; &lt;xref href=\"System.Windows.Interop.D3DImage.PixelHeight\"&gt;&lt;/xref&gt;</ph>","source":"<code>dirtyRect.X</code> < 0  \n  \n <code>dirtyRect.Y</code> < 0  \n  \n <code>dirtyRect.Width</code> < 0 or <code>dirtyRect.Width</code> > <xref href=\"System.Windows.Interop.D3DImage.PixelWidth\"></xref><code>dirtyRect.Height</code> < 0 or <code>dirtyRect.Height</code> > <xref href=\"System.Windows.Interop.D3DImage.PixelHeight\"></xref>"}],"pos":[17426,17827],"yaml":true},{"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (which may no longer resolve), but not animations or their current values.","nodes":[{"pos":[0,307],"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (which may no longer resolve), but not animations or their current values.","nodes":[{"content":"Creates a modifiable clone of this <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> object, making deep copies of this object's values.","pos":[0,139],"source":"Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's values."},{"content":"When copying dependency properties, this method copies resource references and data bindings (which may no longer resolve), but not animations or their current values.","pos":[140,307]}]}],"pos":[18766,19074],"yaml":true},{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \n  \n For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.","nodes":[{"pos":[0,244],"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","nodes":[{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[0,244],"nodes":[{"content":"This method is used to produce modifiable copies of frozen <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> objects (or any <ph id=\"ph2\">&lt;xref:System.Windows.Freezable&gt;</ph> object).","pos":[0,147],"source":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object)."},{"content":"For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[148,244]}]}]},{"pos":[251,343],"content":"For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.","nodes":[{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName&gt;</ph>.","pos":[0,92],"source":"For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>."}]}],"pos":[19085,19433],"yaml":true,"extradata":"MT"},{"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`","nodes":[{"pos":[0,238],"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`","nodes":[{"content":"A modifiable clone of the current object.","pos":[0,41]},{"content":"The cloned object's <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property will be <ph id=\"ph2\">`false`</ph> even if the source's <ph id=\"ph3\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property was <ph id=\"ph4\">`true.`</ph>","pos":[42,238],"source":" The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`"}]}],"pos":[19599,19838],"yaml":true},{"content":"Makes the instance a clone (deep copy) of the specified <xref href=\"System.Windows.Freezable\"></xref> using base (non-animated) property values.","nodes":[{"pos":[0,144],"content":"Makes the instance a clone (deep copy) of the specified <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable\"&gt;&lt;/xref&gt;</ph> using base (non-animated) property values.","source":"Makes the instance a clone (deep copy) of the specified <xref href=\"System.Windows.Freezable\"></xref> using base (non-animated) property values."}],"pos":[20908,21053],"yaml":true},{"content":"The object to clone.","nodes":[{"pos":[0,20],"content":"The object to clone.","nodes":[{"content":"The object to clone.","pos":[0,20]}]}],"pos":[21252,21273],"yaml":true},{"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are copied.","nodes":[{"pos":[0,251],"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are copied.","nodes":[{"content":"Creates a modifiable clone of this <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> object, making deep copies of this object's current values.","pos":[0,147],"source":"Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's current values."},{"content":"Resource references, data bindings, and animations are not copied, but their current values are copied.","pos":[148,251]}]}],"pos":[22290,22542],"yaml":true},{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \n  \n For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.","nodes":[{"pos":[0,244],"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","nodes":[{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[0,244],"nodes":[{"content":"This method is used to produce modifiable copies of frozen <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> objects (or any <ph id=\"ph2\">&lt;xref:System.Windows.Freezable&gt;</ph> object).","pos":[0,147],"source":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object)."},{"content":"For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[148,244]}]}]},{"pos":[251,355],"content":"For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.","nodes":[{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName&gt;</ph>.","pos":[0,104],"source":"For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>."}]}],"pos":[22553,22913],"yaml":true,"extradata":"MT"},{"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`.","nodes":[{"pos":[0,238],"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`.","nodes":[{"content":"A modifiable clone of the current object.","pos":[0,41]},{"content":"The cloned object's <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property will be <ph id=\"ph2\">`false`</ph> even if the source's <ph id=\"ph3\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property was <ph id=\"ph4\">`true`</ph>.","pos":[42,238],"source":" The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`."}]}],"pos":[23091,23330],"yaml":true},{"content":"Makes the instance a modifiable clone (deep copy) of the specified <xref href=\"System.Windows.Freezable\"></xref> using current property values.","nodes":[{"pos":[0,143],"content":"Makes the instance a modifiable clone (deep copy) of the specified <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable\"&gt;&lt;/xref&gt;</ph> using current property values.","source":"Makes the instance a modifiable clone (deep copy) of the specified <xref href=\"System.Windows.Freezable\"></xref> using current property values."}],"pos":[24462,24606],"yaml":true},{"content":"The <xref href=\"System.Windows.Freezable\"></xref> to be cloned.","nodes":[{"pos":[0,63],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable\"&gt;&lt;/xref&gt;</ph> to be cloned.","source":"The <xref href=\"System.Windows.Freezable\"></xref> to be cloned."}],"pos":[24817,24881],"yaml":true},{"content":"Creates a software copy of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.","nodes":[{"pos":[0,84],"content":"Creates a software copy of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>.","source":"Creates a software copy of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>."}],"pos":[25892,25977],"yaml":true},{"content":"The <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method is called by clients such as the printing system and the <xref:System.Windows.Media.Imaging.RenderTargetBitmap> class.  \n  \n Optionally override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to implement custom logic and return a different <xref:System.Windows.Media.Imaging.BitmapSource>. For example, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource> if the default <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementation returns `null`.","nodes":[{"pos":[0,186],"content":"The <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method is called by clients such as the printing system and the <xref:System.Windows.Media.Imaging.RenderTargetBitmap> class.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> method is called by clients such as the printing system and the <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.RenderTargetBitmap&gt;</ph> class.","pos":[0,186],"source":"The <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method is called by clients such as the printing system and the <xref:System.Windows.Media.Imaging.RenderTargetBitmap> class."}]},{"pos":[193,573],"content":"Optionally override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to implement custom logic and return a different <xref:System.Windows.Media.Imaging.BitmapSource>. For example, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource> if the default <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementation returns `null`.","nodes":[{"content":"Optionally override the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> method to implement custom logic and return a different <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.BitmapSource&gt;</ph>.","pos":[0,186],"source":"Optionally override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to implement custom logic and return a different <xref:System.Windows.Media.Imaging.BitmapSource>."},{"content":"For example, you can return a placeholder <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.BitmapSource&gt;</ph> if the default <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> implementation returns <ph id=\"ph3\">`null`</ph>.","pos":[187,380],"source":" For example, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource> if the default <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementation returns `null`."}]}],"pos":[25988,26566],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that is a software copy of the current state of the back buffer; otherwise, `null` if the back buffer cannot be read.","nodes":[{"pos":[0,182],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapSource\"&gt;&lt;/xref&gt;</ph> that is a software copy of the current state of the back buffer; otherwise, <ph id=\"ph2\">`null`</ph> if the back buffer cannot be read.","source":"A <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that is a software copy of the current state of the back buffer; otherwise, `null` if the back buffer cannot be read."}],"pos":[26868,27051],"yaml":true},{"content":"When implemented in a derived class, creates a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> derived class.","nodes":[{"pos":[0,134],"content":"When implemented in a derived class, creates a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> derived class.","source":"When implemented in a derived class, creates a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> derived class."}],"pos":[28200,28335],"yaml":true},{"content":"If you derive from the <xref:System.Windows.Interop.D3DImage> class, you must override the <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> method to enable correct cloning. The default implementation performs a `return new D3DImage()`, which will not be correct if the instance is a different class.","nodes":[{"pos":[0,312],"content":"If you derive from the <xref:System.Windows.Interop.D3DImage> class, you must override the <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> method to enable correct cloning. The default implementation performs a `return new D3DImage()`, which will not be correct if the instance is a different class.","nodes":[{"content":"If you derive from the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class, you must override the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A&gt;</ph> method to enable correct cloning.","pos":[0,185],"source":"If you derive from the <xref:System.Windows.Interop.D3DImage> class, you must override the <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> method to enable correct cloning."},{"content":"The default implementation performs a <ph id=\"ph1\">`return new D3DImage()`</ph>, which will not be correct if the instance is a different class.","pos":[186,312],"source":" The default implementation performs a `return new D3DImage()`, which will not be correct if the instance is a different class."}]}],"pos":[28346,28659],"yaml":true,"extradata":"MT"},{"content":"The new instance.","nodes":[{"pos":[0,17],"content":"The new instance.","nodes":[{"content":"The new instance.","pos":[0,17]}]}],"pos":[28836,28854],"yaml":true},{"content":"Frees resources and performs other cleanup operations before the <xref href=\"System.Windows.Interop.D3DImage\"></xref> is reclaimed by garbage collection.","nodes":[{"pos":[0,153],"content":"Frees resources and performs other cleanup operations before the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> is reclaimed by garbage collection.","source":"Frees resources and performs other cleanup operations before the <xref href=\"System.Windows.Interop.D3DImage\"></xref> is reclaimed by garbage collection."}],"pos":[29826,29980],"yaml":true},{"content":"This method overrides <xref:System.Object.Finalize%2A>. Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.  \n  \n For more information, see [Finalize Methods and Destructors](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).","nodes":[{"pos":[0,308],"content":"This method overrides <xref:System.Object.Finalize%2A>. Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.","nodes":[{"content":"This method overrides <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph>.","pos":[0,55],"source":"This method overrides <xref:System.Object.Finalize%2A>."},{"content":"Application code should not call this method; an object's <ph id=\"ph1\">`Finalize`</ph> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <ph id=\"ph2\">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.","pos":[56,308],"source":" Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method."}]},{"pos":[315,638],"content":"For more information, see <bpt id=\"p1\">[</bpt>Finalize Methods and Destructors<ept id=\"p1\">](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70)</ept>, <bpt id=\"p2\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p2\">](~/docs/standard/garbage-collection/unmanaged.md)</ept>, and <bpt id=\"p3\">[</bpt>Overriding the Finalize Method<ept id=\"p3\">](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.","source":"For more information, see [Finalize Methods and Destructors](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."}],"pos":[29991,30634],"yaml":true,"extradata":"MT"},{"content":"Makes the <xref href=\"System.Windows.Interop.D3DImage\"></xref> unmodifiable or determines whether it can be made unmodifiable.","nodes":[{"pos":[0,126],"content":"Makes the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> unmodifiable or determines whether it can be made unmodifiable.","source":"Makes the <xref href=\"System.Windows.Interop.D3DImage\"></xref> unmodifiable or determines whether it can be made unmodifiable."}],"pos":[31950,32077],"yaml":true},{"content":"The <xref:System.Windows.Interop.D3DImage> class does not allow freezing because changes are always possible due to front buffer availability.","nodes":[{"pos":[0,142],"content":"The <xref:System.Windows.Interop.D3DImage> class does not allow freezing because changes are always possible due to front buffer availability.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class does not allow freezing because changes are always possible due to front buffer availability.","pos":[0,142],"source":"The <xref:System.Windows.Interop.D3DImage> class does not allow freezing because changes are always possible due to front buffer availability."}]}],"pos":[32088,32231],"yaml":true,"extradata":"MT"},{"content":"Has no effect.","nodes":[{"pos":[0,14],"content":"Has no effect.","nodes":[{"content":"Has no effect.","pos":[0,14]}]}],"pos":[32398,32413],"yaml":true},{"content":"`false` in all cases.","nodes":[{"pos":[0,21],"content":"<ph id=\"ph1\">`false`</ph> in all cases.","source":"`false` in all cases."}],"pos":[32471,32495],"yaml":true},{"content":"Makes the instance a frozen clone of the specified <xref href=\"System.Windows.Freezable\"></xref> using base (non-animated) property values.","nodes":[{"pos":[0,139],"content":"Makes the instance a frozen clone of the specified <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable\"&gt;&lt;/xref&gt;</ph> using base (non-animated) property values.","source":"Makes the instance a frozen clone of the specified <xref href=\"System.Windows.Freezable\"></xref> using base (non-animated) property values."}],"pos":[33606,33746],"yaml":true},{"content":"The instance to copy.","nodes":[{"pos":[0,21],"content":"The instance to copy.","nodes":[{"content":"The instance to copy.","pos":[0,21]}]}],"pos":[33951,33973],"yaml":true},{"content":"Makes the current instance a frozen clone of the specified <xref href=\"System.Windows.Freezable\"></xref>. If the object has animated dependency properties, their current animated values are copied.","nodes":[{"pos":[0,197],"content":"Makes the current instance a frozen clone of the specified <xref href=\"System.Windows.Freezable\"></xref>. If the object has animated dependency properties, their current animated values are copied.","nodes":[{"content":"Makes the current instance a frozen clone of the specified <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable\"&gt;&lt;/xref&gt;</ph>.","pos":[0,105],"source":"Makes the current instance a frozen clone of the specified <xref href=\"System.Windows.Freezable\"></xref>."},{"content":"If the object has animated dependency properties, their current animated values are copied.","pos":[106,197]}]}],"pos":[35139,35337],"yaml":true},{"content":"The <xref href=\"System.Windows.Freezable\"></xref> to copy and freeze.","nodes":[{"pos":[0,69],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable\"&gt;&lt;/xref&gt;</ph> to copy and freeze.","source":"The <xref href=\"System.Windows.Freezable\"></xref> to copy and freeze."}],"pos":[35554,35624],"yaml":true},{"content":"Gets the height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.","nodes":[{"pos":[0,76],"content":"Gets the height of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>."}],"pos":[36589,36666],"yaml":true},{"content":"The value of <xref:System.Windows.Interop.D3DImage.Height%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"pos":[0,188],"content":"The value of <xref:System.Windows.Interop.D3DImage.Height%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"content":"The value of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Height%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.","pos":[0,188],"source":"The value of <xref:System.Windows.Interop.D3DImage.Height%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method."}]}],"pos":[36677,36866],"yaml":true,"extradata":"MT"},{"content":"The height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units. A measure unit is 1/96th inch.","nodes":[{"pos":[0,120],"content":"The height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units. A measure unit is 1/96th inch.","nodes":[{"content":"The height of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>, in measure units.","pos":[0,89],"source":"The height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units."},{"content":"A measure unit is 1/96th inch.","pos":[90,120]}]}],"pos":[36992,37113],"yaml":true},{"content":"Gets a value that indicates whether a front buffer exists.","nodes":[{"pos":[0,58],"content":"Gets a value that indicates whether a front buffer exists.","nodes":[{"content":"Gets a value that indicates whether a front buffer exists.","pos":[0,58]}]}],"pos":[38131,38190],"yaml":true},{"content":"Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.  \n  \n<a name=\"dependencyPropertyInfo_IsFrontBufferAvailable\"></a>   \n## Dependency Property Information  \n  \n|||  \n|-|-|  \n|Identifier field|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  \n|Metadata properties set to `true`|None|","nodes":[{"pos":[0,742],"content":"Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.","nodes":[{"content":"Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.","pos":[0,742],"nodes":[{"content":"Occasionally, the front buffer becomes unavailable.","pos":[0,51]},{"content":"This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.","pos":[52,199]},{"content":"When this occurs, your WPF application is notified by handling the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event.","pos":[200,342],"source":" When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event."},{"content":"How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.","pos":[344,484]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.","pos":[485,651],"source":" The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering."},{"content":"For more information, see the remarks in the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class.","pos":[652,742],"source":" For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class."}]}]},{"pos":[815,846],"content":"Dependency Property Information","linkify":"Dependency Property Information","nodes":[{"content":"Dependency Property Information","pos":[0,31]}]},{"pos":[867,883],"content":"Identifier field","nodes":[{"content":"Identifier field","pos":[0,16]}]},{"pos":[884,953],"content":"<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>","nodes":[]},{"pos":[958,991],"content":"Metadata properties set to <ph id=\"ph1\">`true`</ph>","source":"Metadata properties set to `true`"},{"pos":[992,996],"content":"None","nodes":[{"content":"None","pos":[0,4]}]}],"pos":[38201,39211],"yaml":true,"extradata":"MT"},{"content":"`true` if a front buffer exists; otherwise, `false`.","nodes":[{"pos":[0,52],"content":"<ph id=\"ph1\">`true`</ph> if a front buffer exists; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if a front buffer exists; otherwise, `false`."}],"pos":[39824,39879],"yaml":true},{"content":"Occurs when the <xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"></xref> property changes.","nodes":[{"pos":[0,109],"content":"Occurs when the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"&gt;&lt;/xref&gt;</ph> property changes.","source":"Occurs when the <xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"></xref> property changes."}],"pos":[40974,41084],"yaml":true},{"content":"Handle the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> to be notified when the status of the front buffer changes. How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.","nodes":[{"pos":[0,538],"content":"Handle the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> to be notified when the status of the front buffer changes. How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.","nodes":[{"content":"Handle the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> to be notified when the status of the front buffer changes. How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.","pos":[0,538],"nodes":[{"content":"Handle the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> to be notified when the status of the front buffer changes.","pos":[0,139],"source":"Handle the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> to be notified when the status of the front buffer changes."},{"content":"How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.","pos":[140,280]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.","pos":[281,447],"source":" The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering."},{"content":"For more information, see the remarks in the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class.","pos":[448,538],"source":" For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class."}]}]}],"pos":[41095,41634],"yaml":true,"extradata":"MT"},{"content":"Identifies the <xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"></xref> dependency property.","nodes":[{"pos":[0,111],"content":"Identifies the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"&gt;&lt;/xref&gt;</ph> dependency property.","source":"Identifies the <xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"></xref> dependency property."}],"pos":[42886,42998],"yaml":true},{"content":"Locks the <xref href=\"System.Windows.Interop.D3DImage\"></xref> and enables operations on the back buffer.","nodes":[{"pos":[0,105],"content":"Locks the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> and enables operations on the back buffer.","source":"Locks the <xref href=\"System.Windows.Interop.D3DImage\"></xref> and enables operations on the back buffer."}],"pos":[44074,44180],"yaml":true},{"content":"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the back buffer by calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> and <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> methods. While the <xref:System.Windows.Interop.D3DImage> is locked, your application can also render to the Direct3D surface assigned to the back buffer.  \n  \n> [!NOTE]\n>  The <xref:System.Windows.Interop.D3DImage.Lock%2A> method blocks when the rendering system is reading the back buffer to update the front buffer. Use the <xref:System.Windows.Interop.D3DImage.TryLock%2A> method to avoid blocking indefinitely.","nodes":[{"pos":[0,373],"content":"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the back buffer by calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> and <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> methods. While the <xref:System.Windows.Interop.D3DImage> is locked, your application can also render to the Direct3D surface assigned to the back buffer.","nodes":[{"content":"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the back buffer by calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> and <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> methods. While the <xref:System.Windows.Interop.D3DImage> is locked, your application can also render to the Direct3D surface assigned to the back buffer.","pos":[0,373],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method to change the back buffer by calling the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> methods.","pos":[0,227],"source":"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the back buffer by calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> and <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> methods."},{"content":"While the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is locked, your application can also render to the Direct3D surface assigned to the back buffer.","pos":[228,373],"source":" While the <xref:System.Windows.Interop.D3DImage> is locked, your application can also render to the Direct3D surface assigned to the back buffer."}]}]},{"pos":[381,634],"content":"[!NOTE]\n The <xref:System.Windows.Interop.D3DImage.Lock%2A> method blocks when the rendering system is reading the back buffer to update the front buffer. Use the <xref:System.Windows.Interop.D3DImage.TryLock%2A> method to avoid blocking indefinitely.","leadings":["","> "],"nodes":[{"content":" The <xref:System.Windows.Interop.D3DImage.Lock%2A> method blocks when the rendering system is reading the back buffer to update the front buffer. Use the <xref:System.Windows.Interop.D3DImage.TryLock%2A> method to avoid blocking indefinitely.","pos":[8,251],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method blocks when the rendering system is reading the back buffer to update the front buffer.","pos":[1,146],"source":" The <xref:System.Windows.Interop.D3DImage.Lock%2A> method blocks when the rendering system is reading the back buffer to update the front buffer."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.TryLock%2A&gt;</ph> method to avoid blocking indefinitely.","pos":[147,243],"source":" Use the <xref:System.Windows.Interop.D3DImage.TryLock%2A> method to avoid blocking indefinitely."}]}]}],"pos":[44191,44831],"yaml":true,"extradata":"MT"},{"content":"The lock count equals <xref href=\"System.UInt32.MaxValue\"></xref>.","nodes":[{"pos":[0,66],"content":"The lock count equals <ph id=\"ph1\">&lt;xref href=\"System.UInt32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"The lock count equals <xref href=\"System.UInt32.MaxValue\"></xref>."}],"pos":[45534,45601],"yaml":true},{"content":"Gets the metadata associated with the image source.","nodes":[{"pos":[0,51],"content":"Gets the metadata associated with the image source.","nodes":[{"content":"Gets the metadata associated with the image source.","pos":[0,51]}]}],"pos":[46488,46540],"yaml":true},{"content":"`null` in all cases.","nodes":[{"pos":[0,20],"content":"<ph id=\"ph1\">`null`</ph> in all cases.","source":"`null` in all cases."}],"pos":[46717,46740],"yaml":true},{"content":"Gets the height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.","nodes":[{"pos":[0,87],"content":"Gets the height of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>, in pixels.","source":"Gets the height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels."}],"pos":[47716,47804],"yaml":true},{"content":"The value of <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"pos":[0,193],"content":"The value of <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"content":"The value of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.PixelHeight%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.","pos":[0,193],"source":"The value of <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method."}]}],"pos":[47815,48009],"yaml":true,"extradata":"MT"},{"content":"The height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.","nodes":[{"pos":[0,82],"content":"The height of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>, in pixels.","source":"The height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels."}],"pos":[48606,48689],"yaml":true},{"content":"Gets the width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.","nodes":[{"pos":[0,86],"content":"Gets the width of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>, in pixels.","source":"Gets the width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels."}],"pos":[49640,49727],"yaml":true},{"content":"The value of <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"pos":[0,192],"content":"The value of <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"content":"The value of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.PixelWidth%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.","pos":[0,192],"source":"The value of <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method."}]}],"pos":[49738,49931],"yaml":true,"extradata":"MT"},{"content":"The width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.","nodes":[{"pos":[0,81],"content":"The width of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>, in pixels.","source":"The width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels."}],"pos":[50526,50608],"yaml":true},{"content":"Assigns a Direct3D surface as the source of the back buffer.","nodes":[{"pos":[0,60],"content":"Assigns a Direct3D surface as the source of the back buffer.","nodes":[{"content":"Assigns a Direct3D surface as the source of the back buffer.","pos":[0,60]}]}],"pos":[51811,51872],"yaml":true},{"content":"Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to the back buffer.  \n  \n> [!NOTE]\n>  Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  \n  \n Calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload is identical to calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`. When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> or call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  \n  \n The following list shows the required back buffer settings for the `IDirect3DSurface9` type.  \n  \n-   `D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`  \n  \n-   `D3DUSAGE_RENDERTARGET`  \n  \n-   `D3DPOOL_DEFAULT`  \n  \n Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.","nodes":[{"pos":[0,120],"content":"Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to the back buffer.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method to assign a Direct3D surface to the back buffer.","pos":[0,120],"source":"Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to the back buffer."}]},{"pos":[128,402],"content":"[!NOTE]\n Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).","leadings":["","> "],"nodes":[{"content":" Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).","pos":[8,272],"nodes":[{"content":"Performance depends greatly on the settings of the Direct3D surface.","pos":[1,69]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Performance Considerations for Direct3D9 and WPF Interoperability<ept id=\"p1\">](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.","pos":[70,264],"source":" For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)."}]}]},{"pos":[409,1669],"content":"Calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload is identical to calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`. When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> or call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.","nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> overload is identical to calling the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id=\"ph3\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph4\">`false`</ph>.","pos":[0,360],"source":"Calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload is identical to calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`."},{"content":"When you call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> or call <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> with the <ph id=\"ph3\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph4\">`false`</ph>, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed.","pos":[361,812],"source":" When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> or call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed."},{"content":"When the front buffer is available again, the rendering system raises the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to notify your WPF application.","pos":[813,993],"source":" When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application."},{"content":"You can create an event handler for the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to restart rendering again with a valid Direct3D surface.","pos":[995,1167],"source":"  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface."},{"content":"To restart rendering, you must call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.","pos":[1168,1260],"source":" To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>."}]},{"pos":[1676,1768],"content":"The following list shows the required back buffer settings for the <ph id=\"ph1\">`IDirect3DSurface9`</ph> type.","source":"The following list shows the required back buffer settings for the `IDirect3DSurface9` type."},{"pos":[1778,1816],"content":"<ph id=\"ph1\">`D3DFMT_A8R8G8B8`</ph> or <ph id=\"ph2\">`D3DFMT_X8R8G8B8`</ph>","source":"`D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`"},{"pos":[1883,1947],"content":"Multisampling is allowed on <ph id=\"ph1\">`IDirect3DSurface9Ex`</ph> surfaces only.","source":"Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only."}],"pos":[51883,53848],"yaml":true,"extradata":"MT"},{"content":"The type of Direct3D surface. Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.","nodes":[{"pos":[0,106],"content":"The type of Direct3D surface. Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.","nodes":[{"content":"The type of Direct3D surface.","pos":[0,29]},{"content":"Must be a valid <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DResourceType\"&gt;&lt;/xref&gt;</ph>.","pos":[30,106],"source":" Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>."}]}],"pos":[54551,54658],"yaml":true},{"content":"The Direct3D surface to assign as the back buffer.","nodes":[{"pos":[0,50],"content":"The Direct3D surface to assign as the back buffer.","nodes":[{"content":"The Direct3D surface to assign as the back buffer.","pos":[0,50]}]}],"pos":[54724,54775],"yaml":true},{"content":"The <xref href=\"System.Windows.Interop.D3DImage\"></xref> has not been locked by a call to the <xref href=\"System.Windows.Interop.D3DImage.Lock\"></xref> or <xref href=\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\"></xref> methods.","nodes":[{"pos":[0,249],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> has not been locked by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Windows.Interop.D3DImage.Lock\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph3\">&lt;xref href=\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\"&gt;&lt;/xref&gt;</ph> methods.","source":"The <xref href=\"System.Windows.Interop.D3DImage\"></xref> has not been locked by a call to the <xref href=\"System.Windows.Interop.D3DImage.Lock\"></xref> or <xref href=\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\"></xref> methods."}],"pos":[54958,55208],"yaml":true},{"content":"<code>backBufferType</code> is not a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.","nodes":[{"pos":[0,103],"content":"<ph id=\"ph1\">&lt;code&gt;backBufferType&lt;/code&gt;</ph> is not a valid <ph id=\"ph2\">&lt;xref href=\"System.Windows.Interop.D3DResourceType\"&gt;&lt;/xref&gt;</ph>.","source":"<code>backBufferType</code> is not a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>."}],"pos":[55322,55426],"yaml":true},{"content":"The creation parameters for <code>backBuffer</code> do not meet the requirements for the <code>backBufferType</code>-or-The <code>backBuffer</code> device is not valid.","nodes":[{"pos":[0,168],"content":"The creation parameters for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">backBuffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> do not meet the requirements for the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">backBufferType</ph><ept id=\"p2\">&lt;/code&gt;</ept>-or-The <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph3\">backBuffer</ph><ept id=\"p3\">&lt;/code&gt;</ept> device is not valid.","source":"The creation parameters for <code>backBuffer</code> do not meet the requirements for the <code>backBufferType</code>-or-The <code>backBuffer</code> device is not valid."}],"pos":[55520,55689],"yaml":true},{"content":"Assigns a Direct3D surface as the source of the back buffer.","nodes":[{"pos":[0,60],"content":"Assigns a Direct3D surface as the source of the back buffer.","nodes":[{"content":"Assigns a Direct3D surface as the source of the back buffer.","pos":[0,60]}]}],"pos":[56913,56974],"yaml":true},{"content":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  \n  \n When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.  There may be situations where the user’s device becomes unavailable.  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with `backBuffer` set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.  \n  \n The following list shows the required back buffer settings for the `IDirect3DSurface9` type.  \n  \n-   `D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`  \n  \n-   `D3DUSAGE_RENDERTARGET`  \n  \n-   `D3DPOOL_DEFAULT`  \n  \n Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.","nodes":[{"pos":[0,929],"content":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.","nodes":[{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> overload or call the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id=\"ph3\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph4\">`false`</ph>, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.","pos":[0,481],"source":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed."},{"content":"When the front buffer is available again, the rendering system raises the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to notify your WPF application.","pos":[482,662],"source":" When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application."},{"content":"You can create an event handler for the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to restart rendering again with a valid Direct3D surface.","pos":[664,836],"source":"  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface."},{"content":"To restart rendering, you must call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.","pos":[837,929],"source":" To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>."}]},{"pos":[936,1822],"content":"When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.  There may be situations where the user’s device becomes unavailable.  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with `backBuffer` set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.","nodes":[{"content":"When you call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> with the <ph id=\"ph2\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph3\">`true`</ph>, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <ph id=\"ph4\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> when the front buffer is available again.","pos":[0,433],"source":"When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again."},{"content":"There may be situations where the user’s device becomes unavailable.","pos":[435,503]},{"content":"When that occurs, call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> to release WPF’s reference to the back buffer.","pos":[505,630],"source":"  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer."},{"content":"If you need to reset your device, call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> with <ph id=\"ph2\">`backBuffer`</ph> set to <ph id=\"ph3\">`null`</ph>, and then call <ph id=\"ph4\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> again with <ph id=\"ph5\">`backBuffer`</ph> set to a valid Direct3D surface.","pos":[632,886],"source":"  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with `backBuffer` set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface."}]},{"pos":[1829,1921],"content":"The following list shows the required back buffer settings for the <ph id=\"ph1\">`IDirect3DSurface9`</ph> type.","source":"The following list shows the required back buffer settings for the `IDirect3DSurface9` type."},{"pos":[1931,1969],"content":"<ph id=\"ph1\">`D3DFMT_A8R8G8B8`</ph> or <ph id=\"ph2\">`D3DFMT_X8R8G8B8`</ph>","source":"`D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`"},{"pos":[2036,2100],"content":"Multisampling is allowed on <ph id=\"ph1\">`IDirect3DSurface9Ex`</ph> surfaces only.","source":"Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only."}],"pos":[56985,59100],"yaml":true,"extradata":"MT"},{"content":"The type of Direct3D surface. Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.","nodes":[{"pos":[0,106],"content":"The type of Direct3D surface. Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.","nodes":[{"content":"The type of Direct3D surface.","pos":[0,29]},{"content":"Must be a valid <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DResourceType\"&gt;&lt;/xref&gt;</ph>.","pos":[30,106],"source":" Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>."}]}],"pos":[59416,59523],"yaml":true},{"content":"The Direct3D surface to assign as the back buffer.","nodes":[{"pos":[0,50],"content":"The Direct3D surface to assign as the back buffer.","nodes":[{"content":"The Direct3D surface to assign as the back buffer.","pos":[0,50]}]}],"pos":[59589,59640],"yaml":true},{"content":"`true` to fall back on software rendering; otherwise, `false`.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">`true`</ph> to fall back on software rendering; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to fall back on software rendering; otherwise, `false`."}],"pos":[59719,59784],"yaml":true},{"content":"Attempts to lock the <xref href=\"System.Windows.Interop.D3DImage\"></xref> and waits for the specified duration.","nodes":[{"pos":[0,111],"content":"Attempts to lock the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph> and waits for the specified duration.","source":"Attempts to lock the <xref href=\"System.Windows.Interop.D3DImage\"></xref> and waits for the specified duration."}],"pos":[60888,61000],"yaml":true},{"content":"The duration to wait for the lock to be acquired.","nodes":[{"pos":[0,49],"content":"The duration to wait for the lock to be acquired.","nodes":[{"content":"The duration to wait for the lock to be acquired.","pos":[0,49]}]}],"pos":[61167,61217],"yaml":true},{"content":"`true` if the lock was acquired; otherwise, `false`.","nodes":[{"pos":[0,52],"content":"<ph id=\"ph1\">`true`</ph> if the lock was acquired; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the lock was acquired; otherwise, `false`."}],"pos":[61275,61330],"yaml":true},{"content":"<code>timeout</code> is set to <xref href=\"System.Windows.Duration.Automatic\"></xref>.","nodes":[{"pos":[0,86],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Windows.Duration.Automatic\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is set to <xref href=\"System.Windows.Duration.Automatic\"></xref>."}],"pos":[61511,61598],"yaml":true},{"content":"The lock count equals <xref href=\"System.UInt32.MaxValue\"></xref>.","nodes":[{"pos":[0,66],"content":"The lock count equals <ph id=\"ph1\">&lt;xref href=\"System.UInt32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"The lock count equals <xref href=\"System.UInt32.MaxValue\"></xref>."}],"pos":[61708,61775],"yaml":true},{"content":"Decrements the lock count for the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.","nodes":[{"pos":[0,87],"content":"Decrements the lock count for the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>.","source":"Decrements the lock count for the <xref href=\"System.Windows.Interop.D3DImage\"></xref>."}],"pos":[62654,62742],"yaml":true},{"content":"When the lock count for the <xref:System.Windows.Interop.D3DImage> reaches zero, the <xref:System.Windows.Interop.D3DImage> is fully unlocked. The <xref:System.Windows.Interop.D3DImage> is marked for rendering if the image has changed areas that were specified by previous calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.  \n  \n When the changes are committed and rendering occurs, additional calls to the <xref:System.Windows.Interop.D3DImage.Lock%2A> method block until the render thread has copied the contents of the back buffer to the front buffer. This synchronization avoids display artifacts, such as tearing.  \n  \n> [!NOTE]\n>  Do not update the Direct3D surface while the <xref:System.Windows.Interop.D3DImage> is unlocked.","nodes":[{"pos":[0,348],"content":"When the lock count for the <xref:System.Windows.Interop.D3DImage> reaches zero, the <xref:System.Windows.Interop.D3DImage> is fully unlocked. The <xref:System.Windows.Interop.D3DImage> is marked for rendering if the image has changed areas that were specified by previous calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.","nodes":[{"content":"When the lock count for the <xref:System.Windows.Interop.D3DImage> reaches zero, the <xref:System.Windows.Interop.D3DImage> is fully unlocked. The <xref:System.Windows.Interop.D3DImage> is marked for rendering if the image has changed areas that were specified by previous calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.","pos":[0,348],"nodes":[{"content":"When the lock count for the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> reaches zero, the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is fully unlocked.","pos":[0,142],"source":"When the lock count for the <xref:System.Windows.Interop.D3DImage> reaches zero, the <xref:System.Windows.Interop.D3DImage> is fully unlocked."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is marked for rendering if the image has changed areas that were specified by previous calls to the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A&gt;</ph> method.","pos":[143,348],"source":" The <xref:System.Windows.Interop.D3DImage> is marked for rendering if the image has changed areas that were specified by previous calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method."}]}]},{"pos":[355,643],"content":"When the changes are committed and rendering occurs, additional calls to the <xref:System.Windows.Interop.D3DImage.Lock%2A> method block until the render thread has copied the contents of the back buffer to the front buffer. This synchronization avoids display artifacts, such as tearing.","nodes":[{"content":"When the changes are committed and rendering occurs, additional calls to the <xref:System.Windows.Interop.D3DImage.Lock%2A> method block until the render thread has copied the contents of the back buffer to the front buffer. This synchronization avoids display artifacts, such as tearing.","pos":[0,288],"nodes":[{"content":"When the changes are committed and rendering occurs, additional calls to the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Lock%2A&gt;</ph> method block until the render thread has copied the contents of the back buffer to the front buffer.","pos":[0,224],"source":"When the changes are committed and rendering occurs, additional calls to the <xref:System.Windows.Interop.D3DImage.Lock%2A> method block until the render thread has copied the contents of the back buffer to the front buffer."},{"content":"This synchronization avoids display artifacts, such as tearing.","pos":[225,288]}]}]},{"pos":[651,758],"content":"[!NOTE]\n Do not update the Direct3D surface while the <xref:System.Windows.Interop.D3DImage> is unlocked.","leadings":["","> "],"nodes":[{"content":"Do not update the Direct3D surface while the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is unlocked.","pos":[9,105],"source":" Do not update the Direct3D surface while the <xref:System.Windows.Interop.D3DImage> is unlocked."}]}],"pos":[62753,63519],"yaml":true,"extradata":"MT"},{"content":"Gets the width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.","nodes":[{"pos":[0,75],"content":"Gets the width of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>."}],"pos":[65005,65081],"yaml":true},{"content":"The value of <xref:System.Windows.Interop.D3DImage.Width%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"pos":[0,187],"content":"The value of <xref:System.Windows.Interop.D3DImage.Width%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.","nodes":[{"content":"The value of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Width%2A&gt;</ph> can change when a new back buffer is assigned by a call to the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.","pos":[0,187],"source":"The value of <xref:System.Windows.Interop.D3DImage.Width%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method."}]}],"pos":[65092,65280],"yaml":true,"extradata":"MT"},{"content":"The width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units. A measure unit is 1/96th inch.","nodes":[{"pos":[0,119],"content":"The width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units. A measure unit is 1/96th inch.","nodes":[{"content":"The width of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Interop.D3DImage\"&gt;&lt;/xref&gt;</ph>, in measure units.","pos":[0,88],"source":"The width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units."},{"content":"A measure unit is 1/96th inch.","pos":[89,119]}]}],"pos":[65405,65525],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Windows.Interop.D3DImage\n  commentId: T:System.Windows.Interop.D3DImage\n  id: D3DImage\n  children:\n  - System.Windows.Interop.D3DImage.#ctor\n  - System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)\n  - System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)\n  - System.Windows.Interop.D3DImage.Clone\n  - System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)\n  - System.Windows.Interop.D3DImage.CloneCurrentValue\n  - System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)\n  - System.Windows.Interop.D3DImage.CopyBackBuffer\n  - System.Windows.Interop.D3DImage.CreateInstanceCore\n  - System.Windows.Interop.D3DImage.Finalize\n  - System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)\n  - System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)\n  - System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  - System.Windows.Interop.D3DImage.Height\n  - System.Windows.Interop.D3DImage.IsFrontBufferAvailable\n  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged\n  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty\n  - System.Windows.Interop.D3DImage.Lock\n  - System.Windows.Interop.D3DImage.Metadata\n  - System.Windows.Interop.D3DImage.PixelHeight\n  - System.Windows.Interop.D3DImage.PixelWidth\n  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\n  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)\n  - System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\n  - System.Windows.Interop.D3DImage.Unlock\n  - System.Windows.Interop.D3DImage.Width\n  langs:\n  - csharp\n  name: D3DImage\n  nameWithType: D3DImage\n  fullName: System.Windows.Interop.D3DImage\n  type: Class\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: An <xref href=\"System.Windows.Media.ImageSource\"></xref> that displays a user-created Direct3D surface.\n  remarks: \"Use the <xref:System.Windows.Interop.D3DImage> class to host Direct3D content in a Windows Presentation Foundation (WPF) application.  \\n  \\n Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the Direct3D content displayed by the <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to a <xref:System.Windows.Interop.D3DImage>. Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to track updates to the Direct3D surface. Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to display the changed areas.  \\n  \\n The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*. The back buffer is your Direct3D surface.  Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware. Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.  \\n  \\n## Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering  \\n When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  \\n  \\n## Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering  \\n When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.  There may be situations where the user’s device becomes unavailable.  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.  \\n  \\n> [!NOTE]\\n>  Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  \\n  \\n> [!NOTE]\\n>  The <xref:System.Windows.Interop.D3DImage> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> and specify `true` for the `enableSoftwareFallback` parameter.\"\n  example:\n  - \"The following code example shows how to declare a <xref:System.Windows.Interop.D3DImage> in XAML. You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-xml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]\"\n  syntax:\n    content: 'public class D3DImage : System.Windows.Media.ImageSource'\n  inheritance:\n  - System.Object\n  - System.Windows.Threading.DispatcherObject\n  - System.Windows.DependencyObject\n  - System.Windows.Freezable\n  - System.Windows.Media.Animation.Animatable\n  - System.Windows.Media.ImageSource\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)\n  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.DependencyObjectType\n  - System.Windows.DependencyObject.Equals(System.Object)\n  - System.Windows.DependencyObject.GetHashCode\n  - System.Windows.DependencyObject.GetLocalValueEnumerator\n  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.IsSealed\n  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)\n  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)\n  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)\n  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)\n  - System.Windows.Freezable.CanFreeze\n  - System.Windows.Freezable.Changed\n  - System.Windows.Freezable.CreateInstance\n  - System.Windows.Freezable.Freeze\n  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)\n  - System.Windows.Freezable.GetAsFrozen\n  - System.Windows.Freezable.GetCurrentValueAsFrozen\n  - System.Windows.Freezable.IsFrozen\n  - System.Windows.Freezable.OnChanged\n  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)\n  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)\n  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\n  - System.Windows.Freezable.ReadPreamble\n  - System.Windows.Freezable.WritePostscript\n  - System.Windows.Freezable.WritePreamble\n  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)\n  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)\n  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)\n  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)\n  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)\n  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties\n  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)\n  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)\n  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)\n  - System.Windows.Media.ImageSource.ToString\n  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)\n  - System.Windows.Threading.DispatcherObject.CheckAccess\n  - System.Windows.Threading.DispatcherObject.Dispatcher\n  - System.Windows.Threading.DispatcherObject.VerifyAccess\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.#ctor\n  commentId: M:System.Windows.Interop.D3DImage.#ctor\n  id: '#ctor'\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: D3DImage()\n  nameWithType: D3DImage.D3DImage()\n  fullName: D3DImage.D3DImage()\n  type: Constructor\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Initializes a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> class.\n  remarks: The default display resolution is 1/96th inch.\n  syntax:\n    content: public D3DImage ();\n    parameters: []\n  overload: System.Windows.Interop.D3DImage.#ctor*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)\n  commentId: M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)\n  id: '#ctor(System.Double,System.Double)'\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: D3DImage(Double, Double)\n  nameWithType: D3DImage.D3DImage(Double, Double)\n  fullName: D3DImage.D3DImage(Double, Double)\n  type: Constructor\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Initializes a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> class with the specified display resolution.\n  remarks: The default display resolution is 1/96th inch.\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public D3DImage (double dpiX, double dpiY);\n    parameters:\n    - id: dpiX\n      type: System.Double\n      description: The display resolution on the x-axis.\n    - id: dpiY\n      type: System.Double\n      description: The display resolution on the y-axis.\n  overload: System.Windows.Interop.D3DImage.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>dpiX</code> or <code>dpiY</code> is less than zero.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)\n  commentId: M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)\n  id: AddDirtyRect(System.Windows.Int32Rect)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: AddDirtyRect(Int32Rect)\n  nameWithType: D3DImage.AddDirtyRect(Int32Rect)\n  fullName: D3DImage.AddDirtyRect(Int32Rect)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Specifies the area of the back buffer that changed.\n  remarks: \"Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer. To be rendered, the changed area on the back buffer must have a corresponding changed area on the <xref:System.Windows.Interop.D3DImage>.  \\n  \\n Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> and <xref:System.Windows.Interop.D3DImage.Lock%2A> methods before calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.  \\n  \\n Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the changed areas to the front buffer.  \\n  \\n> [!NOTE]\\n>  After a few calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method, the changed areas are merged into a single area. This means you must have valid data outside of the changed areas.\"\n  example:\n  - \"The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);\n    parameters:\n    - id: dirtyRect\n      type: System.Windows.Int32Rect\n      description: An <xref href=\"System.Windows.Int32Rect\"></xref> that represents the area that changed.\n  overload: System.Windows.Interop.D3DImage.AddDirtyRect*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"The bitmap has not been locked by a call to the <xref href=\\\"System.Windows.Interop.D3DImage.Lock\\\"></xref> or <xref href=\\\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\\\"></xref> methods.  \\n  \\n -or-  \\n  \\n The back buffer has not been assigned by a call to the <xref href=\\\"System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\\\"></xref> method.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>dirtyRect.X</code> < 0  \\n  \\n <code>dirtyRect.Y</code> < 0  \\n  \\n <code>dirtyRect.Width</code> < 0 or <code>dirtyRect.Width</code> > <xref href=\\\"System.Windows.Interop.D3DImage.PixelWidth\\\"></xref><code>dirtyRect.Height</code> < 0 or <code>dirtyRect.Height</code> > <xref href=\\\"System.Windows.Interop.D3DImage.PixelHeight\\\"></xref>\"\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.Clone\n  commentId: M:System.Windows.Interop.D3DImage.Clone\n  id: Clone\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: Clone()\n  nameWithType: D3DImage.Clone()\n  fullName: D3DImage.Clone()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (which may no longer resolve), but not animations or their current values.\n  remarks: \"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \\n  \\n For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.\"\n  syntax:\n    content: public System.Windows.Interop.D3DImage Clone ();\n    parameters: []\n    return:\n      type: System.Windows.Interop.D3DImage\n      description: A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`\n  overload: System.Windows.Interop.D3DImage.Clone*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)\n  id: CloneCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: CloneCore(Freezable)\n  nameWithType: D3DImage.CloneCore(Freezable)\n  fullName: D3DImage.CloneCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Makes the instance a clone (deep copy) of the specified <xref href=\"System.Windows.Freezable\"></xref> using base (non-animated) property values.\n  syntax:\n    content: protected override void CloneCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: The object to clone.\n  overload: System.Windows.Interop.D3DImage.CloneCore*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.CloneCurrentValue\n  commentId: M:System.Windows.Interop.D3DImage.CloneCurrentValue\n  id: CloneCurrentValue\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: CloneCurrentValue()\n  nameWithType: D3DImage.CloneCurrentValue()\n  fullName: D3DImage.CloneCurrentValue()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Creates a modifiable clone of this <xref href=\"System.Windows.Interop.D3DImage\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are copied.\n  remarks: \"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \\n  \\n For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.\"\n  syntax:\n    content: public System.Windows.Interop.D3DImage CloneCurrentValue ();\n    parameters: []\n    return:\n      type: System.Windows.Interop.D3DImage\n      description: A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`.\n  overload: System.Windows.Interop.D3DImage.CloneCurrentValue*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)\n  id: CloneCurrentValueCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: CloneCurrentValueCore(Freezable)\n  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)\n  fullName: D3DImage.CloneCurrentValueCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Makes the instance a modifiable clone (deep copy) of the specified <xref href=\"System.Windows.Freezable\"></xref> using current property values.\n  syntax:\n    content: protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: The <xref href=\"System.Windows.Freezable\"></xref> to be cloned.\n  overload: System.Windows.Interop.D3DImage.CloneCurrentValueCore*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.CopyBackBuffer\n  commentId: M:System.Windows.Interop.D3DImage.CopyBackBuffer\n  id: CopyBackBuffer\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: CopyBackBuffer()\n  nameWithType: D3DImage.CopyBackBuffer()\n  fullName: D3DImage.CopyBackBuffer()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Creates a software copy of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.\n  remarks: \"The <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method is called by clients such as the printing system and the <xref:System.Windows.Media.Imaging.RenderTargetBitmap> class.  \\n  \\n Optionally override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to implement custom logic and return a different <xref:System.Windows.Media.Imaging.BitmapSource>. For example, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource> if the default <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementation returns `null`.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      [System.Security.SecurityTreatAsSafe]\n\n      protected virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();\n    parameters: []\n    return:\n      type: System.Windows.Media.Imaging.BitmapSource\n      description: A <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that is a software copy of the current state of the back buffer; otherwise, `null` if the back buffer cannot be read.\n  overload: System.Windows.Interop.D3DImage.CopyBackBuffer*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  - type: System.Security.SecurityTreatAsSafeAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.CreateInstanceCore\n  commentId: M:System.Windows.Interop.D3DImage.CreateInstanceCore\n  id: CreateInstanceCore\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: CreateInstanceCore()\n  nameWithType: D3DImage.CreateInstanceCore()\n  fullName: D3DImage.CreateInstanceCore()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: When implemented in a derived class, creates a new instance of the <xref href=\"System.Windows.Interop.D3DImage\"></xref> derived class.\n  remarks: If you derive from the <xref:System.Windows.Interop.D3DImage> class, you must override the <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> method to enable correct cloning. The default implementation performs a `return new D3DImage()`, which will not be correct if the instance is a different class.\n  syntax:\n    content: protected override System.Windows.Freezable CreateInstanceCore ();\n    parameters: []\n    return:\n      type: System.Windows.Freezable\n      description: The new instance.\n  overload: System.Windows.Interop.D3DImage.CreateInstanceCore*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.Finalize\n  commentId: M:System.Windows.Interop.D3DImage.Finalize\n  id: Finalize\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: D3DImage.Finalize()\n  fullName: D3DImage.Finalize()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Frees resources and performs other cleanup operations before the <xref href=\"System.Windows.Interop.D3DImage\"></xref> is reclaimed by garbage collection.\n  remarks: \"This method overrides <xref:System.Object.Finalize%2A>. Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.  \\n  \\n For more information, see [Finalize Methods and Destructors](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      [System.Security.SecurityTreatAsSafe]\n\n      ~D3DImage ();\n    parameters: []\n  overload: System.Windows.Interop.D3DImage.Finalize*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  - type: System.Security.SecurityTreatAsSafeAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)\n  commentId: M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)\n  id: FreezeCore(System.Boolean)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: FreezeCore(Boolean)\n  nameWithType: D3DImage.FreezeCore(Boolean)\n  fullName: D3DImage.FreezeCore(Boolean)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Makes the <xref href=\"System.Windows.Interop.D3DImage\"></xref> unmodifiable or determines whether it can be made unmodifiable.\n  remarks: The <xref:System.Windows.Interop.D3DImage> class does not allow freezing because changes are always possible due to front buffer availability.\n  syntax:\n    content: protected override sealed bool FreezeCore (bool isChecking);\n    parameters:\n    - id: isChecking\n      type: System.Boolean\n      description: Has no effect.\n    return:\n      type: System.Boolean\n      description: '`false` in all cases.'\n  overload: System.Windows.Interop.D3DImage.FreezeCore*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)\n  id: GetAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: GetAsFrozenCore(Freezable)\n  nameWithType: D3DImage.GetAsFrozenCore(Freezable)\n  fullName: D3DImage.GetAsFrozenCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Makes the instance a frozen clone of the specified <xref href=\"System.Windows.Freezable\"></xref> using base (non-animated) property values.\n  syntax:\n    content: protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: The instance to copy.\n  overload: System.Windows.Interop.D3DImage.GetAsFrozenCore*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: GetCurrentValueAsFrozenCore(Freezable)\n  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)\n  fullName: D3DImage.GetCurrentValueAsFrozenCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Makes the current instance a frozen clone of the specified <xref href=\"System.Windows.Freezable\"></xref>. If the object has animated dependency properties, their current animated values are copied.\n  syntax:\n    content: protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: The <xref href=\"System.Windows.Freezable\"></xref> to copy and freeze.\n  overload: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.Height\n  commentId: P:System.Windows.Interop.D3DImage.Height\n  id: Height\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: Height\n  nameWithType: D3DImage.Height\n  fullName: D3DImage.Height\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Gets the height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.\n  remarks: The value of <xref:System.Windows.Interop.D3DImage.Height%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.\n  syntax:\n    content: public override sealed double Height { get; }\n    return:\n      type: System.Double\n      description: The height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units. A measure unit is 1/96th inch.\n  overload: System.Windows.Interop.D3DImage.Height*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable\n  commentId: P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable\n  id: IsFrontBufferAvailable\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: IsFrontBufferAvailable\n  nameWithType: D3DImage.IsFrontBufferAvailable\n  fullName: D3DImage.IsFrontBufferAvailable\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Gets a value that indicates whether a front buffer exists.\n  remarks: \"Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.  \\n  \\n<a name=\\\"dependencyPropertyInfo_IsFrontBufferAvailable\\\"></a>   \\n## Dependency Property Information  \\n  \\n|||  \\n|-|-|  \\n|Identifier field|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  \\n|Metadata properties set to `true`|None|\"\n  example:\n  - \"The following code example shows how to check the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> property when rendering the composition target. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]\"\n  syntax:\n    content: public bool IsFrontBufferAvailable { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if a front buffer exists; otherwise, `false`.'\n  overload: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged\n  commentId: E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged\n  id: IsFrontBufferAvailableChanged\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: IsFrontBufferAvailableChanged\n  nameWithType: D3DImage.IsFrontBufferAvailableChanged\n  fullName: D3DImage.IsFrontBufferAvailableChanged\n  type: Event\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Occurs when the <xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"></xref> property changes.\n  remarks: Handle the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> to be notified when the status of the front buffer changes. How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering. For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.\n  syntax:\n    content: public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;\n    return:\n      type: System.Windows.DependencyPropertyChangedEventHandler\n      description: ''\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty\n  commentId: F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty\n  id: IsFrontBufferAvailableProperty\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: IsFrontBufferAvailableProperty\n  nameWithType: D3DImage.IsFrontBufferAvailableProperty\n  fullName: D3DImage.IsFrontBufferAvailableProperty\n  type: Field\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Identifies the <xref href=\"System.Windows.Interop.D3DImage.IsFrontBufferAvailable\"></xref> dependency property.\n  syntax:\n    content: public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;\n    return:\n      type: System.Windows.DependencyProperty\n      description: ''\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.Lock\n  commentId: M:System.Windows.Interop.D3DImage.Lock\n  id: Lock\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: Lock()\n  nameWithType: D3DImage.Lock()\n  fullName: D3DImage.Lock()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Locks the <xref href=\"System.Windows.Interop.D3DImage\"></xref> and enables operations on the back buffer.\n  remarks: \"Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the back buffer by calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> and <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> methods. While the <xref:System.Windows.Interop.D3DImage> is locked, your application can also render to the Direct3D surface assigned to the back buffer.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Windows.Interop.D3DImage.Lock%2A> method blocks when the rendering system is reading the back buffer to update the front buffer. Use the <xref:System.Windows.Interop.D3DImage.TryLock%2A> method to avoid blocking indefinitely.\"\n  example:\n  - \"The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to enable updates to the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]\"\n  syntax:\n    content: public void Lock ();\n    parameters: []\n  overload: System.Windows.Interop.D3DImage.Lock*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The lock count equals <xref href=\"System.UInt32.MaxValue\"></xref>.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.Metadata\n  commentId: P:System.Windows.Interop.D3DImage.Metadata\n  id: Metadata\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: Metadata\n  nameWithType: D3DImage.Metadata\n  fullName: D3DImage.Metadata\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Gets the metadata associated with the image source.\n  syntax:\n    content: public override sealed System.Windows.Media.ImageMetadata Metadata { get; }\n    return:\n      type: System.Windows.Media.ImageMetadata\n      description: '`null` in all cases.'\n  overload: System.Windows.Interop.D3DImage.Metadata*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.PixelHeight\n  commentId: P:System.Windows.Interop.D3DImage.PixelHeight\n  id: PixelHeight\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: PixelHeight\n  nameWithType: D3DImage.PixelHeight\n  fullName: D3DImage.PixelHeight\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Gets the height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.\n  remarks: The value of <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.\n  example:\n  - \"The following code example shows how to use the <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]\"\n  syntax:\n    content: public int PixelHeight { get; }\n    return:\n      type: System.Int32\n      description: The height of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.\n  overload: System.Windows.Interop.D3DImage.PixelHeight*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.PixelWidth\n  commentId: P:System.Windows.Interop.D3DImage.PixelWidth\n  id: PixelWidth\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: PixelWidth\n  nameWithType: D3DImage.PixelWidth\n  fullName: D3DImage.PixelWidth\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Gets the width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.\n  remarks: The value of <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.\n  example:\n  - \"The following code example shows how to use the <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]\"\n  syntax:\n    content: public int PixelWidth { get; }\n    return:\n      type: System.Int32\n      description: The width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in pixels.\n  overload: System.Windows.Interop.D3DImage.PixelWidth*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\n  commentId: M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\n  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: SetBackBuffer(D3DResourceType, IntPtr)\n  nameWithType: D3DImage.SetBackBuffer(D3DResourceType, IntPtr)\n  fullName: D3DImage.SetBackBuffer(D3DResourceType, IntPtr)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Assigns a Direct3D surface as the source of the back buffer.\n  remarks: \"Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to the back buffer.  \\n  \\n> [!NOTE]\\n>  Performance depends greatly on the settings of the Direct3D surface. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  \\n  \\n Calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload is identical to calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`. When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> or call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  \\n  \\n The following list shows the required back buffer settings for the `IDirect3DSurface9` type.  \\n  \\n-   `D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`  \\n  \\n-   `D3DUSAGE_RENDERTARGET`  \\n  \\n-   `D3DPOOL_DEFAULT`  \\n  \\n Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.\"\n  example:\n  - \"The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]\"\n  syntax:\n    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);\n    parameters:\n    - id: backBufferType\n      type: System.Windows.Interop.D3DResourceType\n      description: The type of Direct3D surface. Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.\n    - id: backBuffer\n      type: System.IntPtr\n      description: The Direct3D surface to assign as the back buffer.\n  overload: System.Windows.Interop.D3DImage.SetBackBuffer*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Windows.Interop.D3DImage\"></xref> has not been locked by a call to the <xref href=\"System.Windows.Interop.D3DImage.Lock\"></xref> or <xref href=\"System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\"></xref> methods.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>backBufferType</code> is not a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The creation parameters for <code>backBuffer</code> do not meet the requirements for the <code>backBufferType</code>-or-The <code>backBuffer</code> device is not valid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)\n  commentId: M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)\n  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: SetBackBuffer(D3DResourceType, IntPtr, Boolean)\n  nameWithType: D3DImage.SetBackBuffer(D3DResourceType, IntPtr, Boolean)\n  fullName: D3DImage.SetBackBuffer(D3DResourceType, IntPtr, Boolean)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Assigns a Direct3D surface as the source of the back buffer.\n  remarks: \"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  \\n  \\n When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.  There may be situations where the user’s device becomes unavailable.  When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with `backBuffer` set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.  \\n  \\n The following list shows the required back buffer settings for the `IDirect3DSurface9` type.  \\n  \\n-   `D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`  \\n  \\n-   `D3DUSAGE_RENDERTARGET`  \\n  \\n-   `D3DPOOL_DEFAULT`  \\n  \\n Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);\n    parameters:\n    - id: backBufferType\n      type: System.Windows.Interop.D3DResourceType\n      description: The type of Direct3D surface. Must be a valid <xref href=\"System.Windows.Interop.D3DResourceType\"></xref>.\n    - id: backBuffer\n      type: System.IntPtr\n      description: The Direct3D surface to assign as the back buffer.\n    - id: enableSoftwareFallback\n      type: System.Boolean\n      description: '`true` to fall back on software rendering; otherwise, `false`.'\n  overload: System.Windows.Interop.D3DImage.SetBackBuffer*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\n  commentId: M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\n  id: TryLock(System.Windows.Duration)\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: TryLock(Duration)\n  nameWithType: D3DImage.TryLock(Duration)\n  fullName: D3DImage.TryLock(Duration)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Attempts to lock the <xref href=\"System.Windows.Interop.D3DImage\"></xref> and waits for the specified duration.\n  syntax:\n    content: public bool TryLock (System.Windows.Duration timeout);\n    parameters:\n    - id: timeout\n      type: System.Windows.Duration\n      description: The duration to wait for the lock to be acquired.\n    return:\n      type: System.Boolean\n      description: '`true` if the lock was acquired; otherwise, `false`.'\n  overload: System.Windows.Interop.D3DImage.TryLock*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> is set to <xref href=\"System.Windows.Duration.Automatic\"></xref>.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The lock count equals <xref href=\"System.UInt32.MaxValue\"></xref>.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.Unlock\n  commentId: M:System.Windows.Interop.D3DImage.Unlock\n  id: Unlock\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: Unlock()\n  nameWithType: D3DImage.Unlock()\n  fullName: D3DImage.Unlock()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Decrements the lock count for the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.\n  remarks: \"When the lock count for the <xref:System.Windows.Interop.D3DImage> reaches zero, the <xref:System.Windows.Interop.D3DImage> is fully unlocked. The <xref:System.Windows.Interop.D3DImage> is marked for rendering if the image has changed areas that were specified by previous calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.  \\n  \\n When the changes are committed and rendering occurs, additional calls to the <xref:System.Windows.Interop.D3DImage.Lock%2A> method block until the render thread has copied the contents of the back buffer to the front buffer. This synchronization avoids display artifacts, such as tearing.  \\n  \\n> [!NOTE]\\n>  Do not update the Direct3D surface while the <xref:System.Windows.Interop.D3DImage> is unlocked.\"\n  example:\n  - \"The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the updated back buffer to the front buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  \\n  \\n [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]\"\n  syntax:\n    content: public void Unlock ();\n    parameters: []\n  overload: System.Windows.Interop.D3DImage.Unlock*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Interop.D3DImage.Width\n  commentId: P:System.Windows.Interop.D3DImage.Width\n  id: Width\n  parent: System.Windows.Interop.D3DImage\n  langs:\n  - csharp\n  name: Width\n  nameWithType: D3DImage.Width\n  fullName: D3DImage.Width\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Interop\n  summary: Gets the width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>.\n  remarks: The value of <xref:System.Windows.Interop.D3DImage.Width%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.\n  syntax:\n    content: public override sealed double Width { get; }\n    return:\n      type: System.Double\n      description: The width of the <xref href=\"System.Windows.Interop.D3DImage\"></xref>, in measure units. A measure unit is 1/96th inch.\n  overload: System.Windows.Interop.D3DImage.Width*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\nreferences:\n- uid: System.Windows.Media.ImageSource\n  parent: System.Windows.Media\n  isExternal: false\n  name: ImageSource\n  nameWithType: ImageSource\n  fullName: System.Windows.Media.ImageSource\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.Windows.Interop.D3DImage.#ctor\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: D3DImage()\n  nameWithType: D3DImage.D3DImage()\n  fullName: D3DImage.D3DImage()\n- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: D3DImage(Double, Double)\n  nameWithType: D3DImage.D3DImage(Double, Double)\n  fullName: D3DImage.D3DImage(Double, Double)\n- uid: System.Double\n  parent: System\n  isExternal: false\n  name: Double\n  nameWithType: Double\n  fullName: System.Double\n- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: AddDirtyRect(Int32Rect)\n  nameWithType: D3DImage.AddDirtyRect(Int32Rect)\n  fullName: D3DImage.AddDirtyRect(Int32Rect)\n- uid: System.Windows.Int32Rect\n  parent: System.Windows\n  isExternal: false\n  name: Int32Rect\n  nameWithType: Int32Rect\n  fullName: System.Windows.Int32Rect\n- uid: System.Windows.Interop.D3DImage.Clone\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Clone()\n  nameWithType: D3DImage.Clone()\n  fullName: D3DImage.Clone()\n- uid: System.Windows.Interop.D3DImage\n  parent: System.Windows.Interop\n  isExternal: false\n  name: D3DImage\n  nameWithType: D3DImage\n  fullName: System.Windows.Interop.D3DImage\n- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CloneCore(Freezable)\n  nameWithType: D3DImage.CloneCore(Freezable)\n  fullName: D3DImage.CloneCore(Freezable)\n- uid: System.Windows.Freezable\n  parent: System.Windows\n  isExternal: false\n  name: Freezable\n  nameWithType: Freezable\n  fullName: System.Windows.Freezable\n- uid: System.Windows.Interop.D3DImage.CloneCurrentValue\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CloneCurrentValue()\n  nameWithType: D3DImage.CloneCurrentValue()\n  fullName: D3DImage.CloneCurrentValue()\n- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CloneCurrentValueCore(Freezable)\n  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)\n  fullName: D3DImage.CloneCurrentValueCore(Freezable)\n- uid: System.Windows.Interop.D3DImage.CopyBackBuffer\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CopyBackBuffer()\n  nameWithType: D3DImage.CopyBackBuffer()\n  fullName: D3DImage.CopyBackBuffer()\n- uid: System.Windows.Media.Imaging.BitmapSource\n  parent: System.Windows.Media.Imaging\n  isExternal: false\n  name: BitmapSource\n  nameWithType: BitmapSource\n  fullName: System.Windows.Media.Imaging.BitmapSource\n- uid: System.Windows.Interop.D3DImage.CreateInstanceCore\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CreateInstanceCore()\n  nameWithType: D3DImage.CreateInstanceCore()\n  fullName: D3DImage.CreateInstanceCore()\n- uid: System.Windows.Interop.D3DImage.Finalize\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Finalize()\n  nameWithType: D3DImage.Finalize()\n  fullName: D3DImage.Finalize()\n- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: FreezeCore(Boolean)\n  nameWithType: D3DImage.FreezeCore(Boolean)\n  fullName: D3DImage.FreezeCore(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: GetAsFrozenCore(Freezable)\n  nameWithType: D3DImage.GetAsFrozenCore(Freezable)\n  fullName: D3DImage.GetAsFrozenCore(Freezable)\n- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: GetCurrentValueAsFrozenCore(Freezable)\n  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)\n  fullName: D3DImage.GetCurrentValueAsFrozenCore(Freezable)\n- uid: System.Windows.Interop.D3DImage.Height\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Height\n  nameWithType: D3DImage.Height\n  fullName: D3DImage.Height\n- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: IsFrontBufferAvailable\n  nameWithType: D3DImage.IsFrontBufferAvailable\n  fullName: D3DImage.IsFrontBufferAvailable\n- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: IsFrontBufferAvailableChanged\n  nameWithType: D3DImage.IsFrontBufferAvailableChanged\n  fullName: D3DImage.IsFrontBufferAvailableChanged\n- uid: System.Windows.DependencyPropertyChangedEventHandler\n  parent: System.Windows\n  isExternal: false\n  name: DependencyPropertyChangedEventHandler\n  nameWithType: DependencyPropertyChangedEventHandler\n  fullName: System.Windows.DependencyPropertyChangedEventHandler\n- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: IsFrontBufferAvailableProperty\n  nameWithType: D3DImage.IsFrontBufferAvailableProperty\n  fullName: D3DImage.IsFrontBufferAvailableProperty\n- uid: System.Windows.DependencyProperty\n  parent: System.Windows\n  isExternal: false\n  name: DependencyProperty\n  nameWithType: DependencyProperty\n  fullName: System.Windows.DependencyProperty\n- uid: System.Windows.Interop.D3DImage.Lock\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Lock()\n  nameWithType: D3DImage.Lock()\n  fullName: D3DImage.Lock()\n- uid: System.Windows.Interop.D3DImage.Metadata\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Metadata\n  nameWithType: D3DImage.Metadata\n  fullName: D3DImage.Metadata\n- uid: System.Windows.Media.ImageMetadata\n  parent: System.Windows.Media\n  isExternal: false\n  name: ImageMetadata\n  nameWithType: ImageMetadata\n  fullName: System.Windows.Media.ImageMetadata\n- uid: System.Windows.Interop.D3DImage.PixelHeight\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: PixelHeight\n  nameWithType: D3DImage.PixelHeight\n  fullName: D3DImage.PixelHeight\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Windows.Interop.D3DImage.PixelWidth\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: PixelWidth\n  nameWithType: D3DImage.PixelWidth\n  fullName: D3DImage.PixelWidth\n- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: SetBackBuffer(D3DResourceType, IntPtr)\n  nameWithType: D3DImage.SetBackBuffer(D3DResourceType, IntPtr)\n  fullName: D3DImage.SetBackBuffer(D3DResourceType, IntPtr)\n- uid: System.Windows.Interop.D3DResourceType\n  parent: System.Windows.Interop\n  isExternal: false\n  name: D3DResourceType\n  nameWithType: D3DResourceType\n  fullName: System.Windows.Interop.D3DResourceType\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: SetBackBuffer(D3DResourceType, IntPtr, Boolean)\n  nameWithType: D3DImage.SetBackBuffer(D3DResourceType, IntPtr, Boolean)\n  fullName: D3DImage.SetBackBuffer(D3DResourceType, IntPtr, Boolean)\n- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: TryLock(Duration)\n  nameWithType: D3DImage.TryLock(Duration)\n  fullName: D3DImage.TryLock(Duration)\n- uid: System.Windows.Duration\n  parent: System.Windows\n  isExternal: false\n  name: Duration\n  nameWithType: Duration\n  fullName: System.Windows.Duration\n- uid: System.Windows.Interop.D3DImage.Unlock\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Unlock()\n  nameWithType: D3DImage.Unlock()\n  fullName: D3DImage.Unlock()\n- uid: System.Windows.Interop.D3DImage.Width\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Width\n  nameWithType: D3DImage.Width\n  fullName: D3DImage.Width\n- uid: System.Windows.Interop.D3DImage.#ctor*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: D3DImage\n  nameWithType: D3DImage.D3DImage\n  fullName: D3DImage.D3DImage\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.AddDirtyRect*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: AddDirtyRect\n  nameWithType: D3DImage.AddDirtyRect\n  fullName: D3DImage.AddDirtyRect\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.Clone*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Clone\n  nameWithType: D3DImage.Clone\n  fullName: D3DImage.Clone\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.CloneCore*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CloneCore\n  nameWithType: D3DImage.CloneCore\n  fullName: D3DImage.CloneCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.CloneCurrentValue*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CloneCurrentValue\n  nameWithType: D3DImage.CloneCurrentValue\n  fullName: D3DImage.CloneCurrentValue\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CloneCurrentValueCore\n  nameWithType: D3DImage.CloneCurrentValueCore\n  fullName: D3DImage.CloneCurrentValueCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.CopyBackBuffer*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CopyBackBuffer\n  nameWithType: D3DImage.CopyBackBuffer\n  fullName: D3DImage.CopyBackBuffer\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.CreateInstanceCore*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: CreateInstanceCore\n  nameWithType: D3DImage.CreateInstanceCore\n  fullName: D3DImage.CreateInstanceCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.Finalize*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Finalize\n  nameWithType: D3DImage.Finalize\n  fullName: D3DImage.Finalize\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.FreezeCore*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: FreezeCore\n  nameWithType: D3DImage.FreezeCore\n  fullName: D3DImage.FreezeCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: GetAsFrozenCore\n  nameWithType: D3DImage.GetAsFrozenCore\n  fullName: D3DImage.GetAsFrozenCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: GetCurrentValueAsFrozenCore\n  nameWithType: D3DImage.GetCurrentValueAsFrozenCore\n  fullName: D3DImage.GetCurrentValueAsFrozenCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.Height*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Height\n  nameWithType: D3DImage.Height\n  fullName: D3DImage.Height\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: IsFrontBufferAvailable\n  nameWithType: D3DImage.IsFrontBufferAvailable\n  fullName: D3DImage.IsFrontBufferAvailable\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.Lock*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Lock\n  nameWithType: D3DImage.Lock\n  fullName: D3DImage.Lock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.Metadata*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Metadata\n  nameWithType: D3DImage.Metadata\n  fullName: D3DImage.Metadata\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.PixelHeight*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: PixelHeight\n  nameWithType: D3DImage.PixelHeight\n  fullName: D3DImage.PixelHeight\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.PixelWidth*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: PixelWidth\n  nameWithType: D3DImage.PixelWidth\n  fullName: D3DImage.PixelWidth\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.SetBackBuffer*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: SetBackBuffer\n  nameWithType: D3DImage.SetBackBuffer\n  fullName: D3DImage.SetBackBuffer\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.TryLock*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: TryLock\n  nameWithType: D3DImage.TryLock\n  fullName: D3DImage.TryLock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.Unlock*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Unlock\n  nameWithType: D3DImage.Unlock\n  fullName: D3DImage.Unlock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.Interop.D3DImage.Width*\n  parent: System.Windows.Interop.D3DImage\n  isExternal: false\n  name: Width\n  nameWithType: D3DImage.Width\n  fullName: D3DImage.Width\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Interop/D3DImage.xml\n- uid: System.Windows.DependencyObject.Equals(System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: DependencyObject.Equals(Object)\n  fullName: DependencyObject.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Windows.DependencyObject.GetHashCode\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: DependencyObject.GetHashCode()\n  fullName: DependencyObject.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Windows.Media.ImageSource.ToString\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: ToString()\n  nameWithType: ImageSource.ToString()\n  fullName: ImageSource.ToString()\n- uid: System.Windows.Threading.DispatcherObject.CheckAccess\n  parent: System.Windows.Threading.DispatcherObject\n  isExternal: false\n  name: CheckAccess()\n  nameWithType: DispatcherObject.CheckAccess()\n  fullName: DispatcherObject.CheckAccess()\n- uid: System.Windows.Threading.DispatcherObject.Dispatcher\n  parent: System.Windows.Threading.DispatcherObject\n  isExternal: false\n  name: Dispatcher\n  nameWithType: DispatcherObject.Dispatcher\n  fullName: DispatcherObject.Dispatcher\n- uid: System.Windows.Threading.DispatcherObject.VerifyAccess\n  parent: System.Windows.Threading.DispatcherObject\n  isExternal: false\n  name: VerifyAccess()\n  nameWithType: DispatcherObject.VerifyAccess()\n  fullName: DispatcherObject.VerifyAccess()\n- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ClearValue(DependencyProperty)\n  nameWithType: DependencyObject.ClearValue(DependencyProperty)\n  fullName: DependencyObject.ClearValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ClearValue(DependencyPropertyKey)\n  nameWithType: DependencyObject.ClearValue(DependencyPropertyKey)\n  fullName: DependencyObject.ClearValue(DependencyPropertyKey)\n- uid: System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: CoerceValue(DependencyProperty)\n  nameWithType: DependencyObject.CoerceValue(DependencyProperty)\n  fullName: DependencyObject.CoerceValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.DependencyObjectType\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: DependencyObjectType\n  nameWithType: DependencyObject.DependencyObjectType\n  fullName: DependencyObject.DependencyObjectType\n- uid: System.Windows.DependencyObject.GetLocalValueEnumerator\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: GetLocalValueEnumerator()\n  nameWithType: DependencyObject.GetLocalValueEnumerator()\n  fullName: DependencyObject.GetLocalValueEnumerator()\n- uid: System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: GetValue(DependencyProperty)\n  nameWithType: DependencyObject.GetValue(DependencyProperty)\n  fullName: DependencyObject.GetValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: InvalidateProperty(DependencyProperty)\n  nameWithType: DependencyObject.InvalidateProperty(DependencyProperty)\n  fullName: DependencyObject.InvalidateProperty(DependencyProperty)\n- uid: System.Windows.DependencyObject.IsSealed\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: IsSealed\n  nameWithType: DependencyObject.IsSealed\n  fullName: DependencyObject.IsSealed\n- uid: System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)\n  nameWithType: Freezable.OnPropertyChanged(DependencyPropertyChangedEventArgs)\n  fullName: Freezable.OnPropertyChanged(DependencyPropertyChangedEventArgs)\n- uid: System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ReadLocalValue(DependencyProperty)\n  nameWithType: DependencyObject.ReadLocalValue(DependencyProperty)\n  fullName: DependencyObject.ReadLocalValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: SetCurrentValue(DependencyProperty, Object)\n  nameWithType: DependencyObject.SetCurrentValue(DependencyProperty, Object)\n  fullName: DependencyObject.SetCurrentValue(DependencyProperty, Object)\n- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: SetValue(DependencyProperty, Object)\n  nameWithType: DependencyObject.SetValue(DependencyProperty, Object)\n  fullName: DependencyObject.SetValue(DependencyProperty, Object)\n- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: SetValue(DependencyPropertyKey, Object)\n  nameWithType: DependencyObject.SetValue(DependencyPropertyKey, Object)\n  fullName: DependencyObject.SetValue(DependencyPropertyKey, Object)\n- uid: System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ShouldSerializeProperty(DependencyProperty)\n  nameWithType: DependencyObject.ShouldSerializeProperty(DependencyProperty)\n  fullName: DependencyObject.ShouldSerializeProperty(DependencyProperty)\n- uid: System.Windows.Freezable.CanFreeze\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: CanFreeze\n  nameWithType: Freezable.CanFreeze\n  fullName: Freezable.CanFreeze\n- uid: System.Windows.Freezable.Changed\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: Changed\n  nameWithType: Freezable.Changed\n  fullName: Freezable.Changed\n- uid: System.Windows.Freezable.CreateInstance\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: CreateInstance()\n  nameWithType: Freezable.CreateInstance()\n  fullName: Freezable.CreateInstance()\n- uid: System.Windows.Freezable.Freeze\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: Freeze()\n  nameWithType: Freezable.Freeze()\n  fullName: Freezable.Freeze()\n- uid: System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: Freeze(Freezable, Boolean)\n  nameWithType: Freezable.Freeze(Freezable, Boolean)\n  fullName: Freezable.Freeze(Freezable, Boolean)\n- uid: System.Windows.Freezable.GetAsFrozen\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: GetAsFrozen()\n  nameWithType: Freezable.GetAsFrozen()\n  fullName: Freezable.GetAsFrozen()\n- uid: System.Windows.Freezable.GetCurrentValueAsFrozen\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: GetCurrentValueAsFrozen()\n  nameWithType: Freezable.GetCurrentValueAsFrozen()\n  fullName: Freezable.GetCurrentValueAsFrozen()\n- uid: System.Windows.Freezable.IsFrozen\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: IsFrozen\n  nameWithType: Freezable.IsFrozen\n  fullName: Freezable.IsFrozen\n- uid: System.Windows.Freezable.OnChanged\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnChanged()\n  nameWithType: Freezable.OnChanged()\n  fullName: Freezable.OnChanged()\n- uid: System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnFreezablePropertyChanged(DependencyObject, DependencyObject)\n  nameWithType: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject)\n  fullName: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject)\n- uid: System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnFreezablePropertyChanged(DependencyObject, DependencyObject, DependencyProperty)\n  nameWithType: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject, DependencyProperty)\n  fullName: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject, DependencyProperty)\n- uid: System.Windows.Freezable.ReadPreamble\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: ReadPreamble()\n  nameWithType: Freezable.ReadPreamble()\n  fullName: Freezable.ReadPreamble()\n- uid: System.Windows.Freezable.WritePostscript\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: WritePostscript()\n  nameWithType: Freezable.WritePostscript()\n  fullName: Freezable.WritePostscript()\n- uid: System.Windows.Freezable.WritePreamble\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: WritePreamble()\n  nameWithType: Freezable.WritePreamble()\n  fullName: Freezable.WritePreamble()\n- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: ApplyAnimationClock(DependencyProperty, AnimationClock)\n  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock)\n  fullName: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock)\n- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)\n  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)\n  fullName: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)\n- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: BeginAnimation(DependencyProperty, AnimationTimeline)\n  nameWithType: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline)\n  fullName: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline)\n- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)\n  nameWithType: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)\n  fullName: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)\n- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: GetAnimationBaseValue(DependencyProperty)\n  nameWithType: Animatable.GetAnimationBaseValue(DependencyProperty)\n  fullName: Animatable.GetAnimationBaseValue(DependencyProperty)\n- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: HasAnimatedProperties\n  nameWithType: Animatable.HasAnimatedProperties\n  fullName: Animatable.HasAnimatedProperties\n- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: ShouldSerializeStoredWeakReference(DependencyObject)\n  nameWithType: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)\n  fullName: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)\n- uid: System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: PixelsToDIPs(Double, Int32)\n  nameWithType: ImageSource.PixelsToDIPs(Double, Int32)\n  fullName: ImageSource.PixelsToDIPs(Double, Int32)\n- uid: System.Windows.Media.ImageSource.ToString(System.IFormatProvider)\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: ToString(IFormatProvider)\n  nameWithType: ImageSource.ToString(IFormatProvider)\n  fullName: ImageSource.ToString(IFormatProvider)\n- uid: System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: IFormattable.ToString(String, IFormatProvider)\n  nameWithType: ImageSource.IFormattable.ToString(String, IFormatProvider)\n  fullName: ImageSource.IFormattable.ToString(String, IFormatProvider)\n"}