{"nodes":[{"content":"Represents a character encoding.","nodes":[{"pos":[0,32],"content":"Represents a character encoding.","nodes":[{"content":"Represents a character encoding.","pos":[0,32]}]}],"pos":[3955,3988],"yaml":true},{"content":"> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters. For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).  \n  \n Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays. If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \n  \n The .NET Framework provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:  \n  \n-   <xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters. This encoding only supports character values between U+0000 and U+007F. Code page 20127. Also available through the <xref:System.Text.Encoding.ASCII%2A> property.  \n  \n-   <xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding. This encoding supports all Unicode character values. Code page 65000. Also available through the <xref:System.Text.Encoding.UTF7%2A> property.  \n  \n-   <xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding. This encoding supports all Unicode character values. Code page 65001. Also available through the <xref:System.Text.Encoding.UTF8%2A> property.  \n  \n-   <xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding. Both little endian and big endian byte orders are supported. Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.  \n  \n-   <xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding. Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported. Also available through the <xref:System.Text.Encoding.UTF32%2A> property.  \n  \n The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode. Often one of the derived Unicode classes is the correct choice for your app.  \n  \n Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.  \n  \n The following table lists the encodings supported by the .NET Framework. It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName> properties. An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform. Note that code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> property corresponds to an international standard do not necessarily comply in full with that standard.  \n  \n|Code page|Name|Display name|.NET Framework support|  \n|---------------|----------|------------------|----------------------------|  \n|37|IBM037|IBM EBCDIC (US-Canada)||  \n|437|IBM437|OEM United States||  \n|500|IBM500|IBM EBCDIC (International)||  \n|708|ASMO-708|Arabic (ASMO 708)||  \n|720|DOS-720|Arabic (DOS)||  \n|737|ibm737|Greek (DOS)||  \n|775|ibm775|Baltic (DOS)||  \n|850|ibm850|Western European (DOS)||  \n|852|ibm852|Central European (DOS)||  \n|855|IBM855|OEM Cyrillic||  \n|857|ibm857|Turkish (DOS)||  \n|858|IBM00858|OEM Multilingual Latin I||  \n|860|IBM860|Portuguese (DOS)||  \n|861|ibm861|Icelandic (DOS)||  \n|862|DOS-862|Hebrew (DOS)||  \n|863|IBM863|French Canadian (DOS)||  \n|864|IBM864|Arabic (864)||  \n|865|IBM865|Nordic (DOS)||  \n|866|cp866|Cyrillic (DOS)||  \n|869|ibm869|Greek, Modern (DOS)||  \n|870|IBM870|IBM EBCDIC (Multilingual Latin-2)||  \n|874|windows-874|Thai (Windows)||  \n|875|cp875|IBM EBCDIC (Greek Modern)||  \n|932|shift_jis|Japanese (Shift-JIS)||  \n|936|gb2312|Chinese Simplified (GB2312)|✓|  \n|949|ks_c_5601-1987|Korean||  \n|950|big5|Chinese Traditional (Big5)||  \n|1026|IBM1026|IBM EBCDIC (Turkish Latin-5)||  \n|1047|IBM01047|IBM Latin-1||  \n|1140|IBM01140|IBM EBCDIC (US-Canada-Euro)||  \n|1141|IBM01141|IBM EBCDIC (Germany-Euro)||  \n|1142|IBM01142|IBM EBCDIC (Denmark-Norway-Euro)||  \n|1143|IBM01143|IBM EBCDIC (Finland-Sweden-Euro)||  \n|1144|IBM01144|IBM EBCDIC (Italy-Euro)||  \n|1145|IBM01145|IBM EBCDIC (Spain-Euro)||  \n|1146|IBM01146|IBM EBCDIC (UK-Euro)||  \n|1147|IBM01147|IBM EBCDIC (France-Euro)||  \n|1148|IBM01148|IBM EBCDIC (International-Euro)||  \n|1149|IBM01149|IBM EBCDIC (Icelandic-Euro)||  \n|1200|utf-16|Unicode|✓|  \n|1201|unicodeFFFE|Unicode (Big endian)|✓|  \n|1250|windows-1250|Central European (Windows)||  \n|1251|windows-1251|Cyrillic (Windows)||  \n|1252|Windows-1252|Western European (Windows)|✓|  \n|1253|windows-1253|Greek (Windows)||  \n|1254|windows-1254|Turkish (Windows)||  \n|1255|windows-1255|Hebrew (Windows)||  \n|1256|windows-1256|Arabic (Windows)||  \n|1257|windows-1257|Baltic (Windows)||  \n|1258|windows-1258|Vietnamese (Windows)||  \n|1361|Johab|Korean (Johab)||  \n|10000|macintosh|Western European (Mac)||  \n|10001|x-mac-japanese|Japanese (Mac)||  \n|10002|x-mac-chinesetrad|Chinese Traditional (Mac)||  \n|10003|x-mac-korean|Korean (Mac)|✓|  \n|10004|x-mac-arabic|Arabic (Mac)||  \n|10005|x-mac-hebrew|Hebrew (Mac)||  \n|10006|x-mac-greek|Greek (Mac)||  \n|10007|x-mac-cyrillic|Cyrillic (Mac)||  \n|10008|x-mac-chinesesimp|Chinese Simplified (Mac)|✓|  \n|10010|x-mac-romanian|Romanian (Mac)||  \n|10017|x-mac-ukrainian|Ukrainian (Mac)||  \n|10021|x-mac-thai|Thai (Mac)||  \n|10029|x-mac-ce|Central European (Mac)||  \n|10079|x-mac-icelandic|Icelandic (Mac)||  \n|10081|x-mac-turkish|Turkish (Mac)||  \n|10082|x-mac-croatian|Croatian (Mac)||  \n|12000|utf-32|Unicode (UTF-32)|✓|  \n|12001|utf-32BE|Unicode (UTF-32 Big endian)|✓|  \n|20000|x-Chinese-CNS|Chinese Traditional (CNS)||  \n|20001|x-cp20001|TCA Taiwan||  \n|20002|x-Chinese-Eten|Chinese Traditional (Eten)||  \n|20003|x-cp20003|IBM5550 Taiwan||  \n|20004|x-cp20004|TeleText Taiwan||  \n|20005|x-cp20005|Wang Taiwan||  \n|20105|x-IA5|Western European (IA5)||  \n|20106|x-IA5-German|German (IA5)||  \n|20107|x-IA5-Swedish|Swedish (IA5)||  \n|20108|x-IA5-Norwegian|Norwegian (IA5)||  \n|20127|us-ascii|US-ASCII|✓|  \n|20261|x-cp20261|T.61||  \n|20269|x-cp20269|ISO-6937||  \n|20273|IBM273|IBM EBCDIC (Germany)||  \n|20277|IBM277|IBM EBCDIC (Denmark-Norway)||  \n|20278|IBM278|IBM EBCDIC (Finland-Sweden)||  \n|20280|IBM280|IBM EBCDIC (Italy)||  \n|20284|IBM284|IBM EBCDIC (Spain)||  \n|20285|IBM285|IBM EBCDIC (UK)||  \n|20290|IBM290|IBM EBCDIC (Japanese katakana)||  \n|20297|IBM297|IBM EBCDIC (France)||  \n|20420|IBM420|IBM EBCDIC (Arabic)||  \n|20423|IBM423|IBM EBCDIC (Greek)||  \n|20424|IBM424|IBM EBCDIC (Hebrew)||  \n|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (Korean Extended)||  \n|20838|IBM-Thai|IBM EBCDIC (Thai)||  \n|20866|koi8-r|Cyrillic (KOI8-R)||  \n|20871|IBM871|IBM EBCDIC (Icelandic)||  \n|20880|IBM880|IBM EBCDIC (Cyrillic Russian)||  \n|20905|IBM905|IBM EBCDIC (Turkish)||  \n|20924|IBM00924|IBM Latin-1||  \n|20932|EUC-JP|Japanese (JIS 0208-1990 and 0212-1990)||  \n|20936|x-cp20936|Chinese Simplified (GB2312-80)|✓|  \n|20949|x-cp20949|Korean Wansung|✓|  \n|21025|cp1025|IBM EBCDIC (Cyrillic Serbian-Bulgarian)||  \n|21866|koi8-u|Cyrillic (KOI8-U)||  \n|28591|iso-8859-1|Western European (ISO)|✓|  \n|28592|iso-8859-2|Central European (ISO)||  \n|28593|iso-8859-3|Latin 3 (ISO)||  \n|28594|iso-8859-4|Baltic (ISO)||  \n|28595|iso-8859-5|Cyrillic (ISO)||  \n|28596|iso-8859-6|Arabic (ISO)||  \n|28597|iso-8859-7|Greek (ISO)||  \n|28598|iso-8859-8|Hebrew (ISO-Visual)|✓|  \n|28599|iso-8859-9|Turkish (ISO)||  \n|28603|iso-8859-13|Estonian (ISO)||  \n|28605|iso-8859-15|Latin 9 (ISO)||  \n|29001|x-Europa|Europa||  \n|38598|iso-8859-8-i|Hebrew (ISO-Logical)|✓|  \n|50220|iso-2022-jp|Japanese (JIS)|✓|  \n|50221|csISO2022JP|Japanese (JIS-Allow 1 byte Kana)|✓|  \n|50222|iso-2022-jp|Japanese (JIS-Allow 1 byte Kana - SO/SI)|✓|  \n|50225|iso-2022-kr|Korean (ISO)|✓|  \n|50227|x-cp50227|Chinese Simplified (ISO-2022)|✓|  \n|51932|euc-jp|Japanese (EUC)|✓|  \n|51936|EUC-CN|Chinese Simplified (EUC)|✓|  \n|51949|euc-kr|Korean (EUC)|✓|  \n|52936|hz-gb-2312|Chinese Simplified (HZ)|✓|  \n|54936|GB18030|Chinese Simplified (GB18030)|✓|  \n|57002|x-iscii-de|ISCII Devanagari|✓|  \n|57003|x-iscii-be|ISCII Bengali|✓|  \n|57004|x-iscii-ta|ISCII Tamil|✓|  \n|57005|x-iscii-te|ISCII Telugu|✓|  \n|57006|x-iscii-as|ISCII Assamese|✓|  \n|57007|x-iscii-or|ISCII Oriya|✓|  \n|57008|x-iscii-ka|ISCII Kannada|✓|  \n|57009|x-iscii-ma|ISCII Malayalam|✓|  \n|57010|x-iscii-gu|ISCII Gujarati|✓|  \n|57011|x-iscii-pa|ISCII Punjabi|✓|  \n|65000|utf-7|Unicode (UTF-7)|✓|  \n|65001|utf-8|Unicode (UTF-8)|✓|  \n  \n The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding. It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.  \n  \n [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]\n [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):  \n  \n-   UTF-16 big endian byte order: 00 41  \n  \n-   UTF-16 little endian byte order: 41 00  \n  \n-   UTF-32 big endian byte order: 00 00 00 41  \n  \n-   UTF-32 little endian byte order: 41 00 00 00  \n  \n It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.  \n  \n The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM). If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.  \n  \n For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).  \n  \n Note that the encoding classes allow errors to:  \n  \n-   Silently change to a \"?\" character.  \n  \n-   Use a \"best fit\" character.  \n  \n-   Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.  \n  \n You should throw an exception on any data stream error. An app either uses a \"throwonerror\" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes. Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements. For ANSI encodings, the best fit behavior is the default.","nodes":[{"pos":[2,412],"content":"[!NOTE]\n To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","leadings":["","> "],"nodes":[{"content":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","pos":[8,408],"nodes":[{"content":"To view the .NET Framework source code for this type, see the <bpt id=\"p1\">[</bpt>Reference Source<ept id=\"p1\">](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25)</ept>.","pos":[1,171],"source":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25)."},{"content":"You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id=\"p1\">[</bpt>instructions<ept id=\"p1\">](http://referencesource.microsoft.com/)</ept>.","pos":[172,400],"source":" You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/)."}]}]},{"pos":[419,851],"content":"Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters. For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).","nodes":[{"content":"Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.","pos":[0,93]},{"content":"In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.","pos":[94,208]},{"content":"For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph>, see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept>.","pos":[209,432],"source":" For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md)."}]},{"pos":[858,1200],"content":"Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays. If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.","nodes":[{"content":"Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays. If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.","pos":[0,342],"nodes":[{"content":"Note that <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.","pos":[0,137],"source":"Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays."},{"content":"If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id=\"ph1\">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.","pos":[138,342],"source":" If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>."}]}]},{"pos":[1207,1363],"content":"The .NET Framework provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:","nodes":[{"content":"The .NET Framework provides the following implementations of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class to support current Unicode encodings and other encodings:","pos":[0,156],"source":"The .NET Framework provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:"}]},{"pos":[1373,1629],"content":"<xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters. This encoding only supports character values between U+0000 and U+007F. Code page 20127. Also available through the <xref:System.Text.Encoding.ASCII%2A> property.","nodes":[{"content":"<xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters. This encoding only supports character values between U+0000 and U+007F. Code page 20127. Also available through the <xref:System.Text.Encoding.ASCII%2A> property.","pos":[0,256],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> encodes Unicode characters as single 7-bit ASCII characters.","pos":[0,93],"source":"<xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters."},{"content":"This encoding only supports character values between U+0000 and U+007F.","pos":[94,165]},{"content":"Code page 20127.","pos":[166,182]},{"content":"Also available through the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> property.","pos":[183,256],"source":" Also available through the <xref:System.Text.Encoding.ASCII%2A> property."}]}]},{"pos":[1639,1866],"content":"<xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding. This encoding supports all Unicode character values. Code page 65000. Also available through the <xref:System.Text.Encoding.UTF7%2A> property.","nodes":[{"content":"<xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding. This encoding supports all Unicode character values. Code page 65000. Also available through the <xref:System.Text.Encoding.UTF7%2A> property.","pos":[0,227],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF7Encoding&gt;</ph> encodes Unicode characters using the UTF-7 encoding.","pos":[0,84],"source":"<xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding."},{"content":"This encoding supports all Unicode character values.","pos":[85,137]},{"content":"Code page 65000.","pos":[138,154]},{"content":"Also available through the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.UTF7%2A&gt;</ph> property.","pos":[155,227],"source":" Also available through the <xref:System.Text.Encoding.UTF7%2A> property."}]}]},{"pos":[1876,2103],"content":"<xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding. This encoding supports all Unicode character values. Code page 65001. Also available through the <xref:System.Text.Encoding.UTF8%2A> property.","nodes":[{"content":"<xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding. This encoding supports all Unicode character values. Code page 65001. Also available through the <xref:System.Text.Encoding.UTF8%2A> property.","pos":[0,227],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encodes Unicode characters using the UTF-8 encoding.","pos":[0,84],"source":"<xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding."},{"content":"This encoding supports all Unicode character values.","pos":[85,137]},{"content":"Code page 65001.","pos":[138,154]},{"content":"Also available through the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> property.","pos":[155,227],"source":" Also available through the <xref:System.Text.Encoding.UTF8%2A> property."}]}]},{"pos":[2113,2403],"content":"<xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding. Both little endian and big endian byte orders are supported. Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.","nodes":[{"content":"<xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding. Both little endian and big endian byte orders are supported. Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.","pos":[0,290],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> encodes Unicode characters using the UTF-16 encoding.","pos":[0,88],"source":"<xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding."},{"content":"Both little endian and big endian byte orders are supported.","pos":[89,149]},{"content":"Also available through the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.Unicode%2A&gt;</ph> property and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A&gt;</ph> property.","pos":[150,290],"source":" Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property."}]}]},{"pos":[2413,2670],"content":"<xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding. Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported. Also available through the <xref:System.Text.Encoding.UTF32%2A> property.","nodes":[{"content":"<xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding. Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported. Also available through the <xref:System.Text.Encoding.UTF32%2A> property.","pos":[0,257],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> encodes Unicode characters using the UTF-32 encoding.","pos":[0,86],"source":"<xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding."},{"content":"Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.","pos":[87,183]},{"content":"Also available through the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.UTF32%2A&gt;</ph> property.","pos":[184,257],"source":" Also available through the <xref:System.Text.Encoding.UTF32%2A> property."}]}]},{"pos":[2677,2865],"content":"The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode. Often one of the derived Unicode classes is the correct choice for your app.","nodes":[{"content":"The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode. Often one of the derived Unicode classes is the correct choice for your app.","pos":[0,188],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class is primarily intended to convert between different encodings and Unicode.","pos":[0,111],"source":"The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode."},{"content":"Often one of the derived Unicode classes is the correct choice for your app.","pos":[112,188]}]}]},{"pos":[2872,3052],"content":"Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method to obtain other encodings, and call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get a list of all encodings.","pos":[0,180],"source":"Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings."}]},{"pos":[3059,3699],"content":"The following table lists the encodings supported by the .NET Framework. It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName> properties. An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform. Note that code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> property corresponds to an international standard do not necessarily comply in full with that standard.","nodes":[{"content":"The following table lists the encodings supported by the .NET Framework. It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName> properties. An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform. Note that code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> property corresponds to an international standard do not necessarily comply in full with that standard.","pos":[0,640],"nodes":[{"content":"The following table lists the encodings supported by the .NET Framework.","pos":[0,72]},{"content":"It lists each encoding's code page number and the values of the encoding's <ph id=\"ph1\">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName&gt;</ph> properties.","pos":[73,300],"source":" It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName> properties."},{"content":"An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform.","pos":[301,444]},{"content":"Note that code pages whose <ph id=\"ph1\">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName&gt;</ph> property corresponds to an international standard do not necessarily comply in full with that standard.","pos":[445,640],"source":" Note that code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> property corresponds to an international standard do not necessarily comply in full with that standard."}]}]},{"pos":[3706,3715],"content":"Code page","nodes":[{"content":"Code page","pos":[0,9]}]},{"pos":[3716,3720],"content":"Name","nodes":[{"content":"Name","pos":[0,4]}]},{"pos":[3721,3733],"content":"Display name","nodes":[{"content":"Display name","pos":[0,12]}]},{"pos":[3734,3756],"content":".NET Framework support","nodes":[{"content":".NET Framework support","pos":[0,22]}]},{"pos":[3840,3842],"content":"37","nodes":[{"content":"37","pos":[0,2]}]},{"pos":[3843,3849],"content":"IBM037","nodes":[{"content":"IBM037","pos":[0,6]}]},{"pos":[3850,3872],"content":"IBM EBCDIC (US-Canada)","nodes":[{"content":"IBM EBCDIC (US-Canada)","pos":[0,22]}]},{"pos":[3878,3881],"content":"437","nodes":[{"content":"437","pos":[0,3]}]},{"pos":[3882,3888],"content":"IBM437","nodes":[{"content":"IBM437","pos":[0,6]}]},{"pos":[3889,3906],"content":"OEM United States","nodes":[{"content":"OEM United States","pos":[0,17]}]},{"pos":[3912,3915],"content":"500","nodes":[{"content":"500","pos":[0,3]}]},{"pos":[3916,3922],"content":"IBM500","nodes":[{"content":"IBM500","pos":[0,6]}]},{"pos":[3923,3949],"content":"IBM EBCDIC (International)","nodes":[{"content":"IBM EBCDIC (International)","pos":[0,26]}]},{"pos":[3955,3958],"content":"708","nodes":[{"content":"708","pos":[0,3]}]},{"pos":[3959,3967],"content":"ASMO-708","nodes":[{"content":"ASMO-708","pos":[0,8]}]},{"pos":[3968,3985],"content":"Arabic (ASMO 708)","nodes":[{"content":"Arabic (ASMO 708)","pos":[0,17]}]},{"pos":[3991,3994],"content":"720","nodes":[{"content":"720","pos":[0,3]}]},{"pos":[3995,4002],"content":"DOS-720","nodes":[{"content":"DOS-720","pos":[0,7]}]},{"pos":[4003,4015],"content":"Arabic (DOS)","nodes":[{"content":"Arabic (DOS)","pos":[0,12]}]},{"pos":[4021,4024],"content":"737","nodes":[{"content":"737","pos":[0,3]}]},{"pos":[4025,4031],"content":"ibm737","nodes":[{"content":"ibm737","pos":[0,6]}]},{"pos":[4032,4043],"content":"Greek (DOS)","nodes":[{"content":"Greek (DOS)","pos":[0,11]}]},{"pos":[4049,4052],"content":"775","nodes":[{"content":"775","pos":[0,3]}]},{"pos":[4053,4059],"content":"ibm775","nodes":[{"content":"ibm775","pos":[0,6]}]},{"pos":[4060,4072],"content":"Baltic (DOS)","nodes":[{"content":"Baltic (DOS)","pos":[0,12]}]},{"pos":[4078,4081],"content":"850","nodes":[{"content":"850","pos":[0,3]}]},{"pos":[4082,4088],"content":"ibm850","nodes":[{"content":"ibm850","pos":[0,6]}]},{"pos":[4089,4111],"content":"Western European (DOS)","nodes":[{"content":"Western European (DOS)","pos":[0,22]}]},{"pos":[4117,4120],"content":"852","nodes":[{"content":"852","pos":[0,3]}]},{"pos":[4121,4127],"content":"ibm852","nodes":[{"content":"ibm852","pos":[0,6]}]},{"pos":[4128,4150],"content":"Central European (DOS)","nodes":[{"content":"Central European (DOS)","pos":[0,22]}]},{"pos":[4156,4159],"content":"855","nodes":[{"content":"855","pos":[0,3]}]},{"pos":[4160,4166],"content":"IBM855","nodes":[{"content":"IBM855","pos":[0,6]}]},{"pos":[4167,4179],"content":"OEM Cyrillic","nodes":[{"content":"OEM Cyrillic","pos":[0,12]}]},{"pos":[4185,4188],"content":"857","nodes":[{"content":"857","pos":[0,3]}]},{"pos":[4189,4195],"content":"ibm857","nodes":[{"content":"ibm857","pos":[0,6]}]},{"pos":[4196,4209],"content":"Turkish (DOS)","nodes":[{"content":"Turkish (DOS)","pos":[0,13]}]},{"pos":[4215,4218],"content":"858","nodes":[{"content":"858","pos":[0,3]}]},{"pos":[4219,4227],"content":"IBM00858","nodes":[{"content":"IBM00858","pos":[0,8]}]},{"pos":[4228,4252],"content":"OEM Multilingual Latin I","nodes":[{"content":"OEM Multilingual Latin I","pos":[0,24]}]},{"pos":[4258,4261],"content":"860","nodes":[{"content":"860","pos":[0,3]}]},{"pos":[4262,4268],"content":"IBM860","nodes":[{"content":"IBM860","pos":[0,6]}]},{"pos":[4269,4285],"content":"Portuguese (DOS)","nodes":[{"content":"Portuguese (DOS)","pos":[0,16]}]},{"pos":[4291,4294],"content":"861","nodes":[{"content":"861","pos":[0,3]}]},{"pos":[4295,4301],"content":"ibm861","nodes":[{"content":"ibm861","pos":[0,6]}]},{"pos":[4302,4317],"content":"Icelandic (DOS)","nodes":[{"content":"Icelandic (DOS)","pos":[0,15]}]},{"pos":[4323,4326],"content":"862","nodes":[{"content":"862","pos":[0,3]}]},{"pos":[4327,4334],"content":"DOS-862","nodes":[{"content":"DOS-862","pos":[0,7]}]},{"pos":[4335,4347],"content":"Hebrew (DOS)","nodes":[{"content":"Hebrew (DOS)","pos":[0,12]}]},{"pos":[4353,4356],"content":"863","nodes":[{"content":"863","pos":[0,3]}]},{"pos":[4357,4363],"content":"IBM863","nodes":[{"content":"IBM863","pos":[0,6]}]},{"pos":[4364,4385],"content":"French Canadian (DOS)","nodes":[{"content":"French Canadian (DOS)","pos":[0,21]}]},{"pos":[4391,4394],"content":"864","nodes":[{"content":"864","pos":[0,3]}]},{"pos":[4395,4401],"content":"IBM864","nodes":[{"content":"IBM864","pos":[0,6]}]},{"pos":[4402,4414],"content":"Arabic (864)","nodes":[{"content":"Arabic (864)","pos":[0,12]}]},{"pos":[4420,4423],"content":"865","nodes":[{"content":"865","pos":[0,3]}]},{"pos":[4424,4430],"content":"IBM865","nodes":[{"content":"IBM865","pos":[0,6]}]},{"pos":[4431,4443],"content":"Nordic (DOS)","nodes":[{"content":"Nordic (DOS)","pos":[0,12]}]},{"pos":[4449,4452],"content":"866","nodes":[{"content":"866","pos":[0,3]}]},{"pos":[4453,4458],"content":"cp866","nodes":[{"content":"cp866","pos":[0,5]}]},{"pos":[4459,4473],"content":"Cyrillic (DOS)","nodes":[{"content":"Cyrillic (DOS)","pos":[0,14]}]},{"pos":[4479,4482],"content":"869","nodes":[{"content":"869","pos":[0,3]}]},{"pos":[4483,4489],"content":"ibm869","nodes":[{"content":"ibm869","pos":[0,6]}]},{"pos":[4490,4509],"content":"Greek, Modern (DOS)","nodes":[{"content":"Greek, Modern (DOS)","pos":[0,19]}]},{"pos":[4515,4518],"content":"870","nodes":[{"content":"870","pos":[0,3]}]},{"pos":[4519,4525],"content":"IBM870","nodes":[{"content":"IBM870","pos":[0,6]}]},{"pos":[4526,4559],"content":"IBM EBCDIC (Multilingual Latin-2)","nodes":[{"content":"IBM EBCDIC (Multilingual Latin-2)","pos":[0,33]}]},{"pos":[4565,4568],"content":"874","nodes":[{"content":"874","pos":[0,3]}]},{"pos":[4569,4580],"content":"windows-874","nodes":[{"content":"windows-874","pos":[0,11]}]},{"pos":[4581,4595],"content":"Thai (Windows)","nodes":[{"content":"Thai (Windows)","pos":[0,14]}]},{"pos":[4601,4604],"content":"875","nodes":[{"content":"875","pos":[0,3]}]},{"pos":[4605,4610],"content":"cp875","nodes":[{"content":"cp875","pos":[0,5]}]},{"pos":[4611,4636],"content":"IBM EBCDIC (Greek Modern)","nodes":[{"content":"IBM EBCDIC (Greek Modern)","pos":[0,25]}]},{"pos":[4642,4645],"content":"932","nodes":[{"content":"932","pos":[0,3]}]},{"pos":[4646,4655],"content":"shift_jis","nodes":[{"content":"shift_jis","pos":[0,9]}]},{"pos":[4656,4676],"content":"Japanese (Shift-JIS)","nodes":[{"content":"Japanese (Shift-JIS)","pos":[0,20]}]},{"pos":[4682,4685],"content":"936","nodes":[{"content":"936","pos":[0,3]}]},{"pos":[4686,4692],"content":"gb2312","nodes":[{"content":"gb2312","pos":[0,6]}]},{"pos":[4693,4720],"content":"Chinese Simplified (GB2312)","nodes":[{"content":"Chinese Simplified (GB2312)","pos":[0,27]}]},{"pos":[4721,4722],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[4727,4730],"content":"949","nodes":[{"content":"949","pos":[0,3]}]},{"pos":[4731,4745],"content":"ks_c_5601-1987","nodes":[{"content":"ks_c_5601-1987","pos":[0,14]}]},{"pos":[4746,4752],"content":"Korean","nodes":[{"content":"Korean","pos":[0,6]}]},{"pos":[4758,4761],"content":"950","nodes":[{"content":"950","pos":[0,3]}]},{"pos":[4762,4766],"content":"big5","nodes":[{"content":"big5","pos":[0,4]}]},{"pos":[4767,4793],"content":"Chinese Traditional (Big5)","nodes":[{"content":"Chinese Traditional (Big5)","pos":[0,26]}]},{"pos":[4799,4803],"content":"1026","nodes":[{"content":"1026","pos":[0,4]}]},{"pos":[4804,4811],"content":"IBM1026","nodes":[{"content":"IBM1026","pos":[0,7]}]},{"pos":[4812,4840],"content":"IBM EBCDIC (Turkish Latin-5)","nodes":[{"content":"IBM EBCDIC (Turkish Latin-5)","pos":[0,28]}]},{"pos":[4846,4850],"content":"1047","nodes":[{"content":"1047","pos":[0,4]}]},{"pos":[4851,4859],"content":"IBM01047","nodes":[{"content":"IBM01047","pos":[0,8]}]},{"pos":[4860,4871],"content":"IBM Latin-1","nodes":[{"content":"IBM Latin-1","pos":[0,11]}]},{"pos":[4877,4881],"content":"1140","nodes":[{"content":"1140","pos":[0,4]}]},{"pos":[4882,4890],"content":"IBM01140","nodes":[{"content":"IBM01140","pos":[0,8]}]},{"pos":[4891,4918],"content":"IBM EBCDIC (US-Canada-Euro)","nodes":[{"content":"IBM EBCDIC (US-Canada-Euro)","pos":[0,27]}]},{"pos":[4924,4928],"content":"1141","nodes":[{"content":"1141","pos":[0,4]}]},{"pos":[4929,4937],"content":"IBM01141","nodes":[{"content":"IBM01141","pos":[0,8]}]},{"pos":[4938,4963],"content":"IBM EBCDIC (Germany-Euro)","nodes":[{"content":"IBM EBCDIC (Germany-Euro)","pos":[0,25]}]},{"pos":[4969,4973],"content":"1142","nodes":[{"content":"1142","pos":[0,4]}]},{"pos":[4974,4982],"content":"IBM01142","nodes":[{"content":"IBM01142","pos":[0,8]}]},{"pos":[4983,5015],"content":"IBM EBCDIC (Denmark-Norway-Euro)","nodes":[{"content":"IBM EBCDIC (Denmark-Norway-Euro)","pos":[0,32]}]},{"pos":[5021,5025],"content":"1143","nodes":[{"content":"1143","pos":[0,4]}]},{"pos":[5026,5034],"content":"IBM01143","nodes":[{"content":"IBM01143","pos":[0,8]}]},{"pos":[5035,5067],"content":"IBM EBCDIC (Finland-Sweden-Euro)","nodes":[{"content":"IBM EBCDIC (Finland-Sweden-Euro)","pos":[0,32]}]},{"pos":[5073,5077],"content":"1144","nodes":[{"content":"1144","pos":[0,4]}]},{"pos":[5078,5086],"content":"IBM01144","nodes":[{"content":"IBM01144","pos":[0,8]}]},{"pos":[5087,5110],"content":"IBM EBCDIC (Italy-Euro)","nodes":[{"content":"IBM EBCDIC (Italy-Euro)","pos":[0,23]}]},{"pos":[5116,5120],"content":"1145","nodes":[{"content":"1145","pos":[0,4]}]},{"pos":[5121,5129],"content":"IBM01145","nodes":[{"content":"IBM01145","pos":[0,8]}]},{"pos":[5130,5153],"content":"IBM EBCDIC (Spain-Euro)","nodes":[{"content":"IBM EBCDIC (Spain-Euro)","pos":[0,23]}]},{"pos":[5159,5163],"content":"1146","nodes":[{"content":"1146","pos":[0,4]}]},{"pos":[5164,5172],"content":"IBM01146","nodes":[{"content":"IBM01146","pos":[0,8]}]},{"pos":[5173,5193],"content":"IBM EBCDIC (UK-Euro)","nodes":[{"content":"IBM EBCDIC (UK-Euro)","pos":[0,20]}]},{"pos":[5199,5203],"content":"1147","nodes":[{"content":"1147","pos":[0,4]}]},{"pos":[5204,5212],"content":"IBM01147","nodes":[{"content":"IBM01147","pos":[0,8]}]},{"pos":[5213,5237],"content":"IBM EBCDIC (France-Euro)","nodes":[{"content":"IBM EBCDIC (France-Euro)","pos":[0,24]}]},{"pos":[5243,5247],"content":"1148","nodes":[{"content":"1148","pos":[0,4]}]},{"pos":[5248,5256],"content":"IBM01148","nodes":[{"content":"IBM01148","pos":[0,8]}]},{"pos":[5257,5288],"content":"IBM EBCDIC (International-Euro)","nodes":[{"content":"IBM EBCDIC (International-Euro)","pos":[0,31]}]},{"pos":[5294,5298],"content":"1149","nodes":[{"content":"1149","pos":[0,4]}]},{"pos":[5299,5307],"content":"IBM01149","nodes":[{"content":"IBM01149","pos":[0,8]}]},{"pos":[5308,5335],"content":"IBM EBCDIC (Icelandic-Euro)","nodes":[{"content":"IBM EBCDIC (Icelandic-Euro)","pos":[0,27]}]},{"pos":[5341,5345],"content":"1200","nodes":[{"content":"1200","pos":[0,4]}]},{"pos":[5346,5352],"content":"utf-16","nodes":[{"content":"utf-16","pos":[0,6]}]},{"pos":[5353,5360],"content":"Unicode","nodes":[{"content":"Unicode","pos":[0,7]}]},{"pos":[5361,5362],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[5367,5371],"content":"1201","nodes":[{"content":"1201","pos":[0,4]}]},{"pos":[5372,5383],"content":"unicodeFFFE","nodes":[{"content":"unicodeFFFE","pos":[0,11]}]},{"pos":[5384,5404],"content":"Unicode (Big endian)","nodes":[{"content":"Unicode (Big endian)","pos":[0,20]}]},{"pos":[5405,5406],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[5411,5415],"content":"1250","nodes":[{"content":"1250","pos":[0,4]}]},{"pos":[5416,5428],"content":"windows-1250","nodes":[{"content":"windows-1250","pos":[0,12]}]},{"pos":[5429,5455],"content":"Central European (Windows)","nodes":[{"content":"Central European (Windows)","pos":[0,26]}]},{"pos":[5461,5465],"content":"1251","nodes":[{"content":"1251","pos":[0,4]}]},{"pos":[5466,5478],"content":"windows-1251","nodes":[{"content":"windows-1251","pos":[0,12]}]},{"pos":[5479,5497],"content":"Cyrillic (Windows)","nodes":[{"content":"Cyrillic (Windows)","pos":[0,18]}]},{"pos":[5503,5507],"content":"1252","nodes":[{"content":"1252","pos":[0,4]}]},{"pos":[5508,5520],"content":"Windows-1252","nodes":[{"content":"Windows-1252","pos":[0,12]}]},{"pos":[5521,5547],"content":"Western European (Windows)","nodes":[{"content":"Western European (Windows)","pos":[0,26]}]},{"pos":[5548,5549],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[5554,5558],"content":"1253","nodes":[{"content":"1253","pos":[0,4]}]},{"pos":[5559,5571],"content":"windows-1253","nodes":[{"content":"windows-1253","pos":[0,12]}]},{"pos":[5572,5587],"content":"Greek (Windows)","nodes":[{"content":"Greek (Windows)","pos":[0,15]}]},{"pos":[5593,5597],"content":"1254","nodes":[{"content":"1254","pos":[0,4]}]},{"pos":[5598,5610],"content":"windows-1254","nodes":[{"content":"windows-1254","pos":[0,12]}]},{"pos":[5611,5628],"content":"Turkish (Windows)","nodes":[{"content":"Turkish (Windows)","pos":[0,17]}]},{"pos":[5634,5638],"content":"1255","nodes":[{"content":"1255","pos":[0,4]}]},{"pos":[5639,5651],"content":"windows-1255","nodes":[{"content":"windows-1255","pos":[0,12]}]},{"pos":[5652,5668],"content":"Hebrew (Windows)","nodes":[{"content":"Hebrew (Windows)","pos":[0,16]}]},{"pos":[5674,5678],"content":"1256","nodes":[{"content":"1256","pos":[0,4]}]},{"pos":[5679,5691],"content":"windows-1256","nodes":[{"content":"windows-1256","pos":[0,12]}]},{"pos":[5692,5708],"content":"Arabic (Windows)","nodes":[{"content":"Arabic (Windows)","pos":[0,16]}]},{"pos":[5714,5718],"content":"1257","nodes":[{"content":"1257","pos":[0,4]}]},{"pos":[5719,5731],"content":"windows-1257","nodes":[{"content":"windows-1257","pos":[0,12]}]},{"pos":[5732,5748],"content":"Baltic (Windows)","nodes":[{"content":"Baltic (Windows)","pos":[0,16]}]},{"pos":[5754,5758],"content":"1258","nodes":[{"content":"1258","pos":[0,4]}]},{"pos":[5759,5771],"content":"windows-1258","nodes":[{"content":"windows-1258","pos":[0,12]}]},{"pos":[5772,5792],"content":"Vietnamese (Windows)","nodes":[{"content":"Vietnamese (Windows)","pos":[0,20]}]},{"pos":[5798,5802],"content":"1361","nodes":[{"content":"1361","pos":[0,4]}]},{"pos":[5803,5808],"content":"Johab","nodes":[{"content":"Johab","pos":[0,5]}]},{"pos":[5809,5823],"content":"Korean (Johab)","nodes":[{"content":"Korean (Johab)","pos":[0,14]}]},{"pos":[5829,5834],"content":"10000","nodes":[{"content":"10000","pos":[0,5]}]},{"pos":[5835,5844],"content":"macintosh","nodes":[{"content":"macintosh","pos":[0,9]}]},{"pos":[5845,5867],"content":"Western European (Mac)","nodes":[{"content":"Western European (Mac)","pos":[0,22]}]},{"pos":[5873,5878],"content":"10001","nodes":[{"content":"10001","pos":[0,5]}]},{"pos":[5879,5893],"content":"x-mac-japanese","nodes":[{"content":"x-mac-japanese","pos":[0,14]}]},{"pos":[5894,5908],"content":"Japanese (Mac)","nodes":[{"content":"Japanese (Mac)","pos":[0,14]}]},{"pos":[5914,5919],"content":"10002","nodes":[{"content":"10002","pos":[0,5]}]},{"pos":[5920,5937],"content":"x-mac-chinesetrad","nodes":[{"content":"x-mac-chinesetrad","pos":[0,17]}]},{"pos":[5938,5963],"content":"Chinese Traditional (Mac)","nodes":[{"content":"Chinese Traditional (Mac)","pos":[0,25]}]},{"pos":[5969,5974],"content":"10003","nodes":[{"content":"10003","pos":[0,5]}]},{"pos":[5975,5987],"content":"x-mac-korean","nodes":[{"content":"x-mac-korean","pos":[0,12]}]},{"pos":[5988,6000],"content":"Korean (Mac)","nodes":[{"content":"Korean (Mac)","pos":[0,12]}]},{"pos":[6001,6002],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[6007,6012],"content":"10004","nodes":[{"content":"10004","pos":[0,5]}]},{"pos":[6013,6025],"content":"x-mac-arabic","nodes":[{"content":"x-mac-arabic","pos":[0,12]}]},{"pos":[6026,6038],"content":"Arabic (Mac)","nodes":[{"content":"Arabic (Mac)","pos":[0,12]}]},{"pos":[6044,6049],"content":"10005","nodes":[{"content":"10005","pos":[0,5]}]},{"pos":[6050,6062],"content":"x-mac-hebrew","nodes":[{"content":"x-mac-hebrew","pos":[0,12]}]},{"pos":[6063,6075],"content":"Hebrew (Mac)","nodes":[{"content":"Hebrew (Mac)","pos":[0,12]}]},{"pos":[6081,6086],"content":"10006","nodes":[{"content":"10006","pos":[0,5]}]},{"pos":[6087,6098],"content":"x-mac-greek","nodes":[{"content":"x-mac-greek","pos":[0,11]}]},{"pos":[6099,6110],"content":"Greek (Mac)","nodes":[{"content":"Greek (Mac)","pos":[0,11]}]},{"pos":[6116,6121],"content":"10007","nodes":[{"content":"10007","pos":[0,5]}]},{"pos":[6122,6136],"content":"x-mac-cyrillic","nodes":[{"content":"x-mac-cyrillic","pos":[0,14]}]},{"pos":[6137,6151],"content":"Cyrillic (Mac)","nodes":[{"content":"Cyrillic (Mac)","pos":[0,14]}]},{"pos":[6157,6162],"content":"10008","nodes":[{"content":"10008","pos":[0,5]}]},{"pos":[6163,6180],"content":"x-mac-chinesesimp","nodes":[{"content":"x-mac-chinesesimp","pos":[0,17]}]},{"pos":[6181,6205],"content":"Chinese Simplified (Mac)","nodes":[{"content":"Chinese Simplified (Mac)","pos":[0,24]}]},{"pos":[6206,6207],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[6212,6217],"content":"10010","nodes":[{"content":"10010","pos":[0,5]}]},{"pos":[6218,6232],"content":"x-mac-romanian","nodes":[{"content":"x-mac-romanian","pos":[0,14]}]},{"pos":[6233,6247],"content":"Romanian (Mac)","nodes":[{"content":"Romanian (Mac)","pos":[0,14]}]},{"pos":[6253,6258],"content":"10017","nodes":[{"content":"10017","pos":[0,5]}]},{"pos":[6259,6274],"content":"x-mac-ukrainian","nodes":[{"content":"x-mac-ukrainian","pos":[0,15]}]},{"pos":[6275,6290],"content":"Ukrainian (Mac)","nodes":[{"content":"Ukrainian (Mac)","pos":[0,15]}]},{"pos":[6296,6301],"content":"10021","nodes":[{"content":"10021","pos":[0,5]}]},{"pos":[6302,6312],"content":"x-mac-thai","nodes":[{"content":"x-mac-thai","pos":[0,10]}]},{"pos":[6313,6323],"content":"Thai (Mac)","nodes":[{"content":"Thai (Mac)","pos":[0,10]}]},{"pos":[6329,6334],"content":"10029","nodes":[{"content":"10029","pos":[0,5]}]},{"pos":[6335,6343],"content":"x-mac-ce","nodes":[{"content":"x-mac-ce","pos":[0,8]}]},{"pos":[6344,6366],"content":"Central European (Mac)","nodes":[{"content":"Central European (Mac)","pos":[0,22]}]},{"pos":[6372,6377],"content":"10079","nodes":[{"content":"10079","pos":[0,5]}]},{"pos":[6378,6393],"content":"x-mac-icelandic","nodes":[{"content":"x-mac-icelandic","pos":[0,15]}]},{"pos":[6394,6409],"content":"Icelandic (Mac)","nodes":[{"content":"Icelandic (Mac)","pos":[0,15]}]},{"pos":[6415,6420],"content":"10081","nodes":[{"content":"10081","pos":[0,5]}]},{"pos":[6421,6434],"content":"x-mac-turkish","nodes":[{"content":"x-mac-turkish","pos":[0,13]}]},{"pos":[6435,6448],"content":"Turkish (Mac)","nodes":[{"content":"Turkish (Mac)","pos":[0,13]}]},{"pos":[6454,6459],"content":"10082","nodes":[{"content":"10082","pos":[0,5]}]},{"pos":[6460,6474],"content":"x-mac-croatian","nodes":[{"content":"x-mac-croatian","pos":[0,14]}]},{"pos":[6475,6489],"content":"Croatian (Mac)","nodes":[{"content":"Croatian (Mac)","pos":[0,14]}]},{"pos":[6495,6500],"content":"12000","nodes":[{"content":"12000","pos":[0,5]}]},{"pos":[6501,6507],"content":"utf-32","nodes":[{"content":"utf-32","pos":[0,6]}]},{"pos":[6508,6524],"content":"Unicode (UTF-32)","nodes":[{"content":"Unicode (UTF-32)","pos":[0,16]}]},{"pos":[6525,6526],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[6531,6536],"content":"12001","nodes":[{"content":"12001","pos":[0,5]}]},{"pos":[6537,6545],"content":"utf-32BE","nodes":[{"content":"utf-32BE","pos":[0,8]}]},{"pos":[6546,6573],"content":"Unicode (UTF-32 Big endian)","nodes":[{"content":"Unicode (UTF-32 Big endian)","pos":[0,27]}]},{"pos":[6574,6575],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[6580,6585],"content":"20000","nodes":[{"content":"20000","pos":[0,5]}]},{"pos":[6586,6599],"content":"x-Chinese-CNS","nodes":[{"content":"x-Chinese-CNS","pos":[0,13]}]},{"pos":[6600,6625],"content":"Chinese Traditional (CNS)","nodes":[{"content":"Chinese Traditional (CNS)","pos":[0,25]}]},{"pos":[6631,6636],"content":"20001","nodes":[{"content":"20001","pos":[0,5]}]},{"pos":[6637,6646],"content":"x-cp20001","nodes":[{"content":"x-cp20001","pos":[0,9]}]},{"pos":[6647,6657],"content":"TCA Taiwan","nodes":[{"content":"TCA Taiwan","pos":[0,10]}]},{"pos":[6663,6668],"content":"20002","nodes":[{"content":"20002","pos":[0,5]}]},{"pos":[6669,6683],"content":"x-Chinese-Eten","nodes":[{"content":"x-Chinese-Eten","pos":[0,14]}]},{"pos":[6684,6710],"content":"Chinese Traditional (Eten)","nodes":[{"content":"Chinese Traditional (Eten)","pos":[0,26]}]},{"pos":[6716,6721],"content":"20003","nodes":[{"content":"20003","pos":[0,5]}]},{"pos":[6722,6731],"content":"x-cp20003","nodes":[{"content":"x-cp20003","pos":[0,9]}]},{"pos":[6732,6746],"content":"IBM5550 Taiwan","nodes":[{"content":"IBM5550 Taiwan","pos":[0,14]}]},{"pos":[6752,6757],"content":"20004","nodes":[{"content":"20004","pos":[0,5]}]},{"pos":[6758,6767],"content":"x-cp20004","nodes":[{"content":"x-cp20004","pos":[0,9]}]},{"pos":[6768,6783],"content":"TeleText Taiwan","nodes":[{"content":"TeleText Taiwan","pos":[0,15]}]},{"pos":[6789,6794],"content":"20005","nodes":[{"content":"20005","pos":[0,5]}]},{"pos":[6795,6804],"content":"x-cp20005","nodes":[{"content":"x-cp20005","pos":[0,9]}]},{"pos":[6805,6816],"content":"Wang Taiwan","nodes":[{"content":"Wang Taiwan","pos":[0,11]}]},{"pos":[6822,6827],"content":"20105","nodes":[{"content":"20105","pos":[0,5]}]},{"pos":[6828,6833],"content":"x-IA5","nodes":[{"content":"x-IA5","pos":[0,5]}]},{"pos":[6834,6856],"content":"Western European (IA5)","nodes":[{"content":"Western European (IA5)","pos":[0,22]}]},{"pos":[6862,6867],"content":"20106","nodes":[{"content":"20106","pos":[0,5]}]},{"pos":[6868,6880],"content":"x-IA5-German","nodes":[{"content":"x-IA5-German","pos":[0,12]}]},{"pos":[6881,6893],"content":"German (IA5)","nodes":[{"content":"German (IA5)","pos":[0,12]}]},{"pos":[6899,6904],"content":"20107","nodes":[{"content":"20107","pos":[0,5]}]},{"pos":[6905,6918],"content":"x-IA5-Swedish","nodes":[{"content":"x-IA5-Swedish","pos":[0,13]}]},{"pos":[6919,6932],"content":"Swedish (IA5)","nodes":[{"content":"Swedish (IA5)","pos":[0,13]}]},{"pos":[6938,6943],"content":"20108","nodes":[{"content":"20108","pos":[0,5]}]},{"pos":[6944,6959],"content":"x-IA5-Norwegian","nodes":[{"content":"x-IA5-Norwegian","pos":[0,15]}]},{"pos":[6960,6975],"content":"Norwegian (IA5)","nodes":[{"content":"Norwegian (IA5)","pos":[0,15]}]},{"pos":[6981,6986],"content":"20127","nodes":[{"content":"20127","pos":[0,5]}]},{"pos":[6987,6995],"content":"us-ascii","nodes":[{"content":"us-ascii","pos":[0,8]}]},{"pos":[6996,7004],"content":"US-ASCII","nodes":[{"content":"US-ASCII","pos":[0,8]}]},{"pos":[7005,7006],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[7011,7016],"content":"20261","nodes":[{"content":"20261","pos":[0,5]}]},{"pos":[7017,7026],"content":"x-cp20261","nodes":[{"content":"x-cp20261","pos":[0,9]}]},{"pos":[7027,7031],"content":"T.61","nodes":[{"content":"T.61","pos":[0,4]}]},{"pos":[7037,7042],"content":"20269","nodes":[{"content":"20269","pos":[0,5]}]},{"pos":[7043,7052],"content":"x-cp20269","nodes":[{"content":"x-cp20269","pos":[0,9]}]},{"pos":[7053,7061],"content":"ISO-6937","nodes":[{"content":"ISO-6937","pos":[0,8]}]},{"pos":[7067,7072],"content":"20273","nodes":[{"content":"20273","pos":[0,5]}]},{"pos":[7073,7079],"content":"IBM273","nodes":[{"content":"IBM273","pos":[0,6]}]},{"pos":[7080,7100],"content":"IBM EBCDIC (Germany)","nodes":[{"content":"IBM EBCDIC (Germany)","pos":[0,20]}]},{"pos":[7106,7111],"content":"20277","nodes":[{"content":"20277","pos":[0,5]}]},{"pos":[7112,7118],"content":"IBM277","nodes":[{"content":"IBM277","pos":[0,6]}]},{"pos":[7119,7146],"content":"IBM EBCDIC (Denmark-Norway)","nodes":[{"content":"IBM EBCDIC (Denmark-Norway)","pos":[0,27]}]},{"pos":[7152,7157],"content":"20278","nodes":[{"content":"20278","pos":[0,5]}]},{"pos":[7158,7164],"content":"IBM278","nodes":[{"content":"IBM278","pos":[0,6]}]},{"pos":[7165,7192],"content":"IBM EBCDIC (Finland-Sweden)","nodes":[{"content":"IBM EBCDIC (Finland-Sweden)","pos":[0,27]}]},{"pos":[7198,7203],"content":"20280","nodes":[{"content":"20280","pos":[0,5]}]},{"pos":[7204,7210],"content":"IBM280","nodes":[{"content":"IBM280","pos":[0,6]}]},{"pos":[7211,7229],"content":"IBM EBCDIC (Italy)","nodes":[{"content":"IBM EBCDIC (Italy)","pos":[0,18]}]},{"pos":[7235,7240],"content":"20284","nodes":[{"content":"20284","pos":[0,5]}]},{"pos":[7241,7247],"content":"IBM284","nodes":[{"content":"IBM284","pos":[0,6]}]},{"pos":[7248,7266],"content":"IBM EBCDIC (Spain)","nodes":[{"content":"IBM EBCDIC (Spain)","pos":[0,18]}]},{"pos":[7272,7277],"content":"20285","nodes":[{"content":"20285","pos":[0,5]}]},{"pos":[7278,7284],"content":"IBM285","nodes":[{"content":"IBM285","pos":[0,6]}]},{"pos":[7285,7300],"content":"IBM EBCDIC (UK)","nodes":[{"content":"IBM EBCDIC (UK)","pos":[0,15]}]},{"pos":[7306,7311],"content":"20290","nodes":[{"content":"20290","pos":[0,5]}]},{"pos":[7312,7318],"content":"IBM290","nodes":[{"content":"IBM290","pos":[0,6]}]},{"pos":[7319,7349],"content":"IBM EBCDIC (Japanese katakana)","nodes":[{"content":"IBM EBCDIC (Japanese katakana)","pos":[0,30]}]},{"pos":[7355,7360],"content":"20297","nodes":[{"content":"20297","pos":[0,5]}]},{"pos":[7361,7367],"content":"IBM297","nodes":[{"content":"IBM297","pos":[0,6]}]},{"pos":[7368,7387],"content":"IBM EBCDIC (France)","nodes":[{"content":"IBM EBCDIC (France)","pos":[0,19]}]},{"pos":[7393,7398],"content":"20420","nodes":[{"content":"20420","pos":[0,5]}]},{"pos":[7399,7405],"content":"IBM420","nodes":[{"content":"IBM420","pos":[0,6]}]},{"pos":[7406,7425],"content":"IBM EBCDIC (Arabic)","nodes":[{"content":"IBM EBCDIC (Arabic)","pos":[0,19]}]},{"pos":[7431,7436],"content":"20423","nodes":[{"content":"20423","pos":[0,5]}]},{"pos":[7437,7443],"content":"IBM423","nodes":[{"content":"IBM423","pos":[0,6]}]},{"pos":[7444,7462],"content":"IBM EBCDIC (Greek)","nodes":[{"content":"IBM EBCDIC (Greek)","pos":[0,18]}]},{"pos":[7468,7473],"content":"20424","nodes":[{"content":"20424","pos":[0,5]}]},{"pos":[7474,7480],"content":"IBM424","nodes":[{"content":"IBM424","pos":[0,6]}]},{"pos":[7481,7500],"content":"IBM EBCDIC (Hebrew)","nodes":[{"content":"IBM EBCDIC (Hebrew)","pos":[0,19]}]},{"pos":[7506,7511],"content":"20833","nodes":[{"content":"20833","pos":[0,5]}]},{"pos":[7512,7535],"content":"x-EBCDIC-KoreanExtended","nodes":[{"content":"x-EBCDIC-KoreanExtended","pos":[0,23]}]},{"pos":[7536,7564],"content":"IBM EBCDIC (Korean Extended)","nodes":[{"content":"IBM EBCDIC (Korean Extended)","pos":[0,28]}]},{"pos":[7570,7575],"content":"20838","nodes":[{"content":"20838","pos":[0,5]}]},{"pos":[7576,7584],"content":"IBM-Thai","nodes":[{"content":"IBM-Thai","pos":[0,8]}]},{"pos":[7585,7602],"content":"IBM EBCDIC (Thai)","nodes":[{"content":"IBM EBCDIC (Thai)","pos":[0,17]}]},{"pos":[7608,7613],"content":"20866","nodes":[{"content":"20866","pos":[0,5]}]},{"pos":[7614,7620],"content":"koi8-r","nodes":[{"content":"koi8-r","pos":[0,6]}]},{"pos":[7621,7638],"content":"Cyrillic (KOI8-R)","nodes":[{"content":"Cyrillic (KOI8-R)","pos":[0,17]}]},{"pos":[7644,7649],"content":"20871","nodes":[{"content":"20871","pos":[0,5]}]},{"pos":[7650,7656],"content":"IBM871","nodes":[{"content":"IBM871","pos":[0,6]}]},{"pos":[7657,7679],"content":"IBM EBCDIC (Icelandic)","nodes":[{"content":"IBM EBCDIC (Icelandic)","pos":[0,22]}]},{"pos":[7685,7690],"content":"20880","nodes":[{"content":"20880","pos":[0,5]}]},{"pos":[7691,7697],"content":"IBM880","nodes":[{"content":"IBM880","pos":[0,6]}]},{"pos":[7698,7727],"content":"IBM EBCDIC (Cyrillic Russian)","nodes":[{"content":"IBM EBCDIC (Cyrillic Russian)","pos":[0,29]}]},{"pos":[7733,7738],"content":"20905","nodes":[{"content":"20905","pos":[0,5]}]},{"pos":[7739,7745],"content":"IBM905","nodes":[{"content":"IBM905","pos":[0,6]}]},{"pos":[7746,7766],"content":"IBM EBCDIC (Turkish)","nodes":[{"content":"IBM EBCDIC (Turkish)","pos":[0,20]}]},{"pos":[7772,7777],"content":"20924","nodes":[{"content":"20924","pos":[0,5]}]},{"pos":[7778,7786],"content":"IBM00924","nodes":[{"content":"IBM00924","pos":[0,8]}]},{"pos":[7787,7798],"content":"IBM Latin-1","nodes":[{"content":"IBM Latin-1","pos":[0,11]}]},{"pos":[7804,7809],"content":"20932","nodes":[{"content":"20932","pos":[0,5]}]},{"pos":[7810,7816],"content":"EUC-JP","nodes":[{"content":"EUC-JP","pos":[0,6]}]},{"pos":[7817,7855],"content":"Japanese (JIS 0208-1990 and 0212-1990)","nodes":[{"content":"Japanese (JIS 0208-1990 and 0212-1990)","pos":[0,38]}]},{"pos":[7861,7866],"content":"20936","nodes":[{"content":"20936","pos":[0,5]}]},{"pos":[7867,7876],"content":"x-cp20936","nodes":[{"content":"x-cp20936","pos":[0,9]}]},{"pos":[7877,7907],"content":"Chinese Simplified (GB2312-80)","nodes":[{"content":"Chinese Simplified (GB2312-80)","pos":[0,30]}]},{"pos":[7908,7909],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[7914,7919],"content":"20949","nodes":[{"content":"20949","pos":[0,5]}]},{"pos":[7920,7929],"content":"x-cp20949","nodes":[{"content":"x-cp20949","pos":[0,9]}]},{"pos":[7930,7944],"content":"Korean Wansung","nodes":[{"content":"Korean Wansung","pos":[0,14]}]},{"pos":[7945,7946],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[7951,7956],"content":"21025","nodes":[{"content":"21025","pos":[0,5]}]},{"pos":[7957,7963],"content":"cp1025","nodes":[{"content":"cp1025","pos":[0,6]}]},{"pos":[7964,8003],"content":"IBM EBCDIC (Cyrillic Serbian-Bulgarian)","nodes":[{"content":"IBM EBCDIC (Cyrillic Serbian-Bulgarian)","pos":[0,39]}]},{"pos":[8009,8014],"content":"21866","nodes":[{"content":"21866","pos":[0,5]}]},{"pos":[8015,8021],"content":"koi8-u","nodes":[{"content":"koi8-u","pos":[0,6]}]},{"pos":[8022,8039],"content":"Cyrillic (KOI8-U)","nodes":[{"content":"Cyrillic (KOI8-U)","pos":[0,17]}]},{"pos":[8045,8050],"content":"28591","nodes":[{"content":"28591","pos":[0,5]}]},{"pos":[8051,8061],"content":"iso-8859-1","nodes":[{"content":"iso-8859-1","pos":[0,10]}]},{"pos":[8062,8084],"content":"Western European (ISO)","nodes":[{"content":"Western European (ISO)","pos":[0,22]}]},{"pos":[8085,8086],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8091,8096],"content":"28592","nodes":[{"content":"28592","pos":[0,5]}]},{"pos":[8097,8107],"content":"iso-8859-2","nodes":[{"content":"iso-8859-2","pos":[0,10]}]},{"pos":[8108,8130],"content":"Central European (ISO)","nodes":[{"content":"Central European (ISO)","pos":[0,22]}]},{"pos":[8136,8141],"content":"28593","nodes":[{"content":"28593","pos":[0,5]}]},{"pos":[8142,8152],"content":"iso-8859-3","nodes":[{"content":"iso-8859-3","pos":[0,10]}]},{"pos":[8153,8166],"content":"Latin 3 (ISO)","nodes":[{"content":"Latin 3 (ISO)","pos":[0,13]}]},{"pos":[8172,8177],"content":"28594","nodes":[{"content":"28594","pos":[0,5]}]},{"pos":[8178,8188],"content":"iso-8859-4","nodes":[{"content":"iso-8859-4","pos":[0,10]}]},{"pos":[8189,8201],"content":"Baltic (ISO)","nodes":[{"content":"Baltic (ISO)","pos":[0,12]}]},{"pos":[8207,8212],"content":"28595","nodes":[{"content":"28595","pos":[0,5]}]},{"pos":[8213,8223],"content":"iso-8859-5","nodes":[{"content":"iso-8859-5","pos":[0,10]}]},{"pos":[8224,8238],"content":"Cyrillic (ISO)","nodes":[{"content":"Cyrillic (ISO)","pos":[0,14]}]},{"pos":[8244,8249],"content":"28596","nodes":[{"content":"28596","pos":[0,5]}]},{"pos":[8250,8260],"content":"iso-8859-6","nodes":[{"content":"iso-8859-6","pos":[0,10]}]},{"pos":[8261,8273],"content":"Arabic (ISO)","nodes":[{"content":"Arabic (ISO)","pos":[0,12]}]},{"pos":[8279,8284],"content":"28597","nodes":[{"content":"28597","pos":[0,5]}]},{"pos":[8285,8295],"content":"iso-8859-7","nodes":[{"content":"iso-8859-7","pos":[0,10]}]},{"pos":[8296,8307],"content":"Greek (ISO)","nodes":[{"content":"Greek (ISO)","pos":[0,11]}]},{"pos":[8313,8318],"content":"28598","nodes":[{"content":"28598","pos":[0,5]}]},{"pos":[8319,8329],"content":"iso-8859-8","nodes":[{"content":"iso-8859-8","pos":[0,10]}]},{"pos":[8330,8349],"content":"Hebrew (ISO-Visual)","nodes":[{"content":"Hebrew (ISO-Visual)","pos":[0,19]}]},{"pos":[8350,8351],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8356,8361],"content":"28599","nodes":[{"content":"28599","pos":[0,5]}]},{"pos":[8362,8372],"content":"iso-8859-9","nodes":[{"content":"iso-8859-9","pos":[0,10]}]},{"pos":[8373,8386],"content":"Turkish (ISO)","nodes":[{"content":"Turkish (ISO)","pos":[0,13]}]},{"pos":[8392,8397],"content":"28603","nodes":[{"content":"28603","pos":[0,5]}]},{"pos":[8398,8409],"content":"iso-8859-13","nodes":[{"content":"iso-8859-13","pos":[0,11]}]},{"pos":[8410,8424],"content":"Estonian (ISO)","nodes":[{"content":"Estonian (ISO)","pos":[0,14]}]},{"pos":[8430,8435],"content":"28605","nodes":[{"content":"28605","pos":[0,5]}]},{"pos":[8436,8447],"content":"iso-8859-15","nodes":[{"content":"iso-8859-15","pos":[0,11]}]},{"pos":[8448,8461],"content":"Latin 9 (ISO)","nodes":[{"content":"Latin 9 (ISO)","pos":[0,13]}]},{"pos":[8467,8472],"content":"29001","nodes":[{"content":"29001","pos":[0,5]}]},{"pos":[8473,8481],"content":"x-Europa","nodes":[{"content":"x-Europa","pos":[0,8]}]},{"pos":[8482,8488],"content":"Europa","nodes":[{"content":"Europa","pos":[0,6]}]},{"pos":[8494,8499],"content":"38598","nodes":[{"content":"38598","pos":[0,5]}]},{"pos":[8500,8512],"content":"iso-8859-8-i","nodes":[{"content":"iso-8859-8-i","pos":[0,12]}]},{"pos":[8513,8533],"content":"Hebrew (ISO-Logical)","nodes":[{"content":"Hebrew (ISO-Logical)","pos":[0,20]}]},{"pos":[8534,8535],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8540,8545],"content":"50220","nodes":[{"content":"50220","pos":[0,5]}]},{"pos":[8546,8557],"content":"iso-2022-jp","nodes":[{"content":"iso-2022-jp","pos":[0,11]}]},{"pos":[8558,8572],"content":"Japanese (JIS)","nodes":[{"content":"Japanese (JIS)","pos":[0,14]}]},{"pos":[8573,8574],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8579,8584],"content":"50221","nodes":[{"content":"50221","pos":[0,5]}]},{"pos":[8585,8596],"content":"csISO2022JP","nodes":[{"content":"csISO2022JP","pos":[0,11]}]},{"pos":[8597,8629],"content":"Japanese (JIS-Allow 1 byte Kana)","nodes":[{"content":"Japanese (JIS-Allow 1 byte Kana)","pos":[0,32]}]},{"pos":[8630,8631],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8636,8641],"content":"50222","nodes":[{"content":"50222","pos":[0,5]}]},{"pos":[8642,8653],"content":"iso-2022-jp","nodes":[{"content":"iso-2022-jp","pos":[0,11]}]},{"pos":[8654,8694],"content":"Japanese (JIS-Allow 1 byte Kana - SO/SI)","nodes":[{"content":"Japanese (JIS-Allow 1 byte Kana - SO/SI)","pos":[0,40]}]},{"pos":[8695,8696],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8701,8706],"content":"50225","nodes":[{"content":"50225","pos":[0,5]}]},{"pos":[8707,8718],"content":"iso-2022-kr","nodes":[{"content":"iso-2022-kr","pos":[0,11]}]},{"pos":[8719,8731],"content":"Korean (ISO)","nodes":[{"content":"Korean (ISO)","pos":[0,12]}]},{"pos":[8732,8733],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8738,8743],"content":"50227","nodes":[{"content":"50227","pos":[0,5]}]},{"pos":[8744,8753],"content":"x-cp50227","nodes":[{"content":"x-cp50227","pos":[0,9]}]},{"pos":[8754,8783],"content":"Chinese Simplified (ISO-2022)","nodes":[{"content":"Chinese Simplified (ISO-2022)","pos":[0,29]}]},{"pos":[8784,8785],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8790,8795],"content":"51932","nodes":[{"content":"51932","pos":[0,5]}]},{"pos":[8796,8802],"content":"euc-jp","nodes":[{"content":"euc-jp","pos":[0,6]}]},{"pos":[8803,8817],"content":"Japanese (EUC)","nodes":[{"content":"Japanese (EUC)","pos":[0,14]}]},{"pos":[8818,8819],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8824,8829],"content":"51936","nodes":[{"content":"51936","pos":[0,5]}]},{"pos":[8830,8836],"content":"EUC-CN","nodes":[{"content":"EUC-CN","pos":[0,6]}]},{"pos":[8837,8861],"content":"Chinese Simplified (EUC)","nodes":[{"content":"Chinese Simplified (EUC)","pos":[0,24]}]},{"pos":[8862,8863],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8868,8873],"content":"51949","nodes":[{"content":"51949","pos":[0,5]}]},{"pos":[8874,8880],"content":"euc-kr","nodes":[{"content":"euc-kr","pos":[0,6]}]},{"pos":[8881,8893],"content":"Korean (EUC)","nodes":[{"content":"Korean (EUC)","pos":[0,12]}]},{"pos":[8894,8895],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8900,8905],"content":"52936","nodes":[{"content":"52936","pos":[0,5]}]},{"pos":[8906,8916],"content":"hz-gb-2312","nodes":[{"content":"hz-gb-2312","pos":[0,10]}]},{"pos":[8917,8940],"content":"Chinese Simplified (HZ)","nodes":[{"content":"Chinese Simplified (HZ)","pos":[0,23]}]},{"pos":[8941,8942],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8947,8952],"content":"54936","nodes":[{"content":"54936","pos":[0,5]}]},{"pos":[8953,8960],"content":"GB18030","nodes":[{"content":"GB18030","pos":[0,7]}]},{"pos":[8961,8989],"content":"Chinese Simplified (GB18030)","nodes":[{"content":"Chinese Simplified (GB18030)","pos":[0,28]}]},{"pos":[8990,8991],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[8996,9001],"content":"57002","nodes":[{"content":"57002","pos":[0,5]}]},{"pos":[9002,9012],"content":"x-iscii-de","nodes":[{"content":"x-iscii-de","pos":[0,10]}]},{"pos":[9013,9029],"content":"ISCII Devanagari","nodes":[{"content":"ISCII Devanagari","pos":[0,16]}]},{"pos":[9030,9031],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9036,9041],"content":"57003","nodes":[{"content":"57003","pos":[0,5]}]},{"pos":[9042,9052],"content":"x-iscii-be","nodes":[{"content":"x-iscii-be","pos":[0,10]}]},{"pos":[9053,9066],"content":"ISCII Bengali","nodes":[{"content":"ISCII Bengali","pos":[0,13]}]},{"pos":[9067,9068],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9073,9078],"content":"57004","nodes":[{"content":"57004","pos":[0,5]}]},{"pos":[9079,9089],"content":"x-iscii-ta","nodes":[{"content":"x-iscii-ta","pos":[0,10]}]},{"pos":[9090,9101],"content":"ISCII Tamil","nodes":[{"content":"ISCII Tamil","pos":[0,11]}]},{"pos":[9102,9103],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9108,9113],"content":"57005","nodes":[{"content":"57005","pos":[0,5]}]},{"pos":[9114,9124],"content":"x-iscii-te","nodes":[{"content":"x-iscii-te","pos":[0,10]}]},{"pos":[9125,9137],"content":"ISCII Telugu","nodes":[{"content":"ISCII Telugu","pos":[0,12]}]},{"pos":[9138,9139],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9144,9149],"content":"57006","nodes":[{"content":"57006","pos":[0,5]}]},{"pos":[9150,9160],"content":"x-iscii-as","nodes":[{"content":"x-iscii-as","pos":[0,10]}]},{"pos":[9161,9175],"content":"ISCII Assamese","nodes":[{"content":"ISCII Assamese","pos":[0,14]}]},{"pos":[9176,9177],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9182,9187],"content":"57007","nodes":[{"content":"57007","pos":[0,5]}]},{"pos":[9188,9198],"content":"x-iscii-or","nodes":[{"content":"x-iscii-or","pos":[0,10]}]},{"pos":[9199,9210],"content":"ISCII Oriya","nodes":[{"content":"ISCII Oriya","pos":[0,11]}]},{"pos":[9211,9212],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9217,9222],"content":"57008","nodes":[{"content":"57008","pos":[0,5]}]},{"pos":[9223,9233],"content":"x-iscii-ka","nodes":[{"content":"x-iscii-ka","pos":[0,10]}]},{"pos":[9234,9247],"content":"ISCII Kannada","nodes":[{"content":"ISCII Kannada","pos":[0,13]}]},{"pos":[9248,9249],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9254,9259],"content":"57009","nodes":[{"content":"57009","pos":[0,5]}]},{"pos":[9260,9270],"content":"x-iscii-ma","nodes":[{"content":"x-iscii-ma","pos":[0,10]}]},{"pos":[9271,9286],"content":"ISCII Malayalam","nodes":[{"content":"ISCII Malayalam","pos":[0,15]}]},{"pos":[9287,9288],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9293,9298],"content":"57010","nodes":[{"content":"57010","pos":[0,5]}]},{"pos":[9299,9309],"content":"x-iscii-gu","nodes":[{"content":"x-iscii-gu","pos":[0,10]}]},{"pos":[9310,9324],"content":"ISCII Gujarati","nodes":[{"content":"ISCII Gujarati","pos":[0,14]}]},{"pos":[9325,9326],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9331,9336],"content":"57011","nodes":[{"content":"57011","pos":[0,5]}]},{"pos":[9337,9347],"content":"x-iscii-pa","nodes":[{"content":"x-iscii-pa","pos":[0,10]}]},{"pos":[9348,9361],"content":"ISCII Punjabi","nodes":[{"content":"ISCII Punjabi","pos":[0,13]}]},{"pos":[9362,9363],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9368,9373],"content":"65000","nodes":[{"content":"65000","pos":[0,5]}]},{"pos":[9374,9379],"content":"utf-7","nodes":[{"content":"utf-7","pos":[0,5]}]},{"pos":[9380,9395],"content":"Unicode (UTF-7)","nodes":[{"content":"Unicode (UTF-7)","pos":[0,15]}]},{"pos":[9396,9397],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9402,9407],"content":"65001","nodes":[{"content":"65001","pos":[0,5]}]},{"pos":[9408,9413],"content":"utf-8","nodes":[{"content":"utf-8","pos":[0,5]}]},{"pos":[9414,9429],"content":"Unicode (UTF-8)","nodes":[{"content":"Unicode (UTF-8)","pos":[0,15]}]},{"pos":[9430,9431],"content":"✓","nodes":[{"content":"✓","pos":[0,1]}]},{"pos":[9439,9882],"content":"The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding. It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.","nodes":[{"content":"The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding. It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.","pos":[0,443],"nodes":[{"content":"The following example calls the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> methods to get the Greek (Windows) code page encoding.","pos":[0,207],"source":"The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding."},{"content":"It compares the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.","pos":[208,443],"source":" It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet."}]}]},{"pos":[9889,10152],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Text.Encoding#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Text.Encoding#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]\n [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]"},{"pos":[10159,10581],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[10588,10842],"content":"The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):","nodes":[{"content":"The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):","pos":[0,254],"nodes":[{"content":"The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).","pos":[0,162]},{"content":"For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):","pos":[163,254]}]}]},{"pos":[10852,10887],"content":"UTF-16 big endian byte order: 00 41","nodes":[{"content":"UTF-16 big endian byte order: 00 41","pos":[0,35]}]},{"pos":[10897,10935],"content":"UTF-16 little endian byte order: 41 00","nodes":[{"content":"UTF-16 little endian byte order: 41 00","pos":[0,38]}]},{"pos":[10945,10986],"content":"UTF-32 big endian byte order: 00 00 00 41","nodes":[{"content":"UTF-32 big endian byte order: 00 00 00 41","pos":[0,41]}]},{"pos":[10996,11040],"content":"UTF-32 little endian byte order: 41 00 00 00","nodes":[{"content":"UTF-32 little endian byte order: 41 00 00 00","pos":[0,44]}]},{"pos":[11047,11249],"content":"It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.","nodes":[{"content":"It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.","pos":[0,202],"nodes":[{"content":"It is generally more efficient to store Unicode characters using the native byte order.","pos":[0,87]},{"content":"For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.","pos":[88,202]}]}]},{"pos":[11256,11490],"content":"The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM). If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.","nodes":[{"content":"The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM). If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.","pos":[0,234],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetPreamble%2A&gt;</ph> method retrieves an array of bytes that includes the byte order mark (BOM).","pos":[0,122],"source":"The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM)."},{"content":"If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.","pos":[123,234]}]}]},{"pos":[11497,11655],"content":"For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id=\"p1\">[</bpt>Unicode home page<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.","source":"For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123)."},{"pos":[11662,11709],"content":"Note that the encoding classes allow errors to:","nodes":[{"content":"Note that the encoding classes allow errors to:","pos":[0,47]}]},{"pos":[11719,11754],"content":"Silently change to a \"?\" character.","nodes":[{"content":"Silently change to a \"?\" character.","pos":[0,35]}]},{"pos":[11764,11791],"content":"Use a \"best fit\" character.","nodes":[{"content":"Use a \"best fit\" character.","pos":[0,27]}]},{"pos":[11801,11991],"content":"Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.","nodes":[{"content":"Change to an application-specific behavior through use of the <ph id=\"ph1\">&lt;xref:System.Text.EncoderFallback&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.DecoderFallback&gt;</ph> classes with the U+FFFD Unicode replacement character.","pos":[0,190],"source":"Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character."}]},{"pos":[11998,12418],"content":"You should throw an exception on any data stream error. An app either uses a \"throwonerror\" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes. Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements. For ANSI encodings, the best fit behavior is the default.","nodes":[{"content":"You should throw an exception on any data stream error. An app either uses a \"throwonerror\" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes. Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements. For ANSI encodings, the best fit behavior is the default.","pos":[0,420],"nodes":[{"content":"You should throw an exception on any data stream error.","pos":[0,55]},{"content":"An app either uses a \"throwonerror\" flag when applicable or uses the <ph id=\"ph1\">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> classes.","pos":[56,225],"source":" An app either uses a \"throwonerror\" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes."},{"content":"Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.","pos":[226,362]},{"content":"For ANSI encodings, the best fit behavior is the default.","pos":[363,420]}]}]}],"pos":[3999,16625],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class.","nodes":[{"pos":[0,82],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class."}],"pos":[19500,19583],"yaml":true},{"content":"Derived classes override this constructor.","nodes":[{"pos":[0,42],"content":"Derived classes override this constructor.","nodes":[{"content":"Derived classes override this constructor.","pos":[0,42]}]}],"pos":[19594,19637],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class that corresponds to the specified code page.","nodes":[{"pos":[0,126],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> class that corresponds to the specified code page.","source":"Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class that corresponds to the specified code page."}],"pos":[21208,21335],"yaml":true},{"content":"Derived classes override this constructor.  \n  \n Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations. Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified. To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.","nodes":[{"pos":[0,42],"content":"Derived classes override this constructor.","nodes":[{"content":"Derived classes override this constructor.","pos":[0,42]}]},{"pos":[49,590],"content":"Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations. Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified. To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.","nodes":[{"content":"Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations. Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified. To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.","pos":[0,541],"nodes":[{"content":"Calls to this constructor from a derived class create an <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> object that uses best-fit fallback for both encoding and decoding operations.","pos":[0,162],"source":"Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations."},{"content":"Both the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.DecoderFallback%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.EncoderFallback%2A&gt;</ph> properties are read-only and cannot be modified.","pos":[163,318],"source":" Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified."},{"content":"To control the fallback strategy for a class derived from <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> constructor.","pos":[319,541],"source":" To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor."}]}]}],"pos":[21346,21941],"yaml":true,"extradata":"MT"},{"content":"The code page identifier of the preferred encoding.  \n  \n -or-  \n  \n 0, to use the default encoding.","nodes":[{"pos":[0,51],"content":"The code page identifier of the preferred encoding.","nodes":[{"content":"The code page identifier of the preferred encoding.","pos":[0,51]}]},{"pos":[58,62],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[69,100],"content":"0, to use the default encoding.","nodes":[{"content":"0, to use the default encoding.","pos":[0,31]}]}],"pos":[22078,22185],"yaml":true},{"content":"<code>codePage</code> is less than zero.","nodes":[{"pos":[0,40],"content":"<ph id=\"ph1\">&lt;code&gt;codePage&lt;/code&gt;</ph> is less than zero.","source":"<code>codePage</code> is less than zero."}],"pos":[22353,22394],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.","nodes":[{"pos":[0,185],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.","source":"Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies."}],"pos":[23993,24179],"yaml":true},{"content":"This constructor is `protected`; derived classes override it.  \n  \n You call this constructor from a derived class to control the fallback encoding and decoding strategies. The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.  \n  \n If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.","nodes":[{"pos":[0,61],"content":"This constructor is <ph id=\"ph1\">`protected`</ph>; derived classes override it.","source":"This constructor is `protected`; derived classes override it."},{"pos":[68,341],"content":"You call this constructor from a derived class to control the fallback encoding and decoding strategies. The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.","nodes":[{"content":"You call this constructor from a derived class to control the fallback encoding and decoding strategies. The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.","pos":[0,273],"nodes":[{"content":"You call this constructor from a derived class to control the fallback encoding and decoding strategies.","pos":[0,104]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.","pos":[105,273],"source":" The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created."}]}]},{"pos":[348,471],"content":"If either <ph id=\"ph1\">`encoderFallback`</ph> or <ph id=\"ph2\">`decoderFallback`</ph> is null, best-fit fallback is used as the corresponding fallback strategy.","source":"If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy."}],"pos":[24190,24668],"yaml":true,"extradata":"MT"},{"content":"The encoding code page identifier.","nodes":[{"pos":[0,34],"content":"The encoding code page identifier.","nodes":[{"content":"The encoding code page identifier.","pos":[0,34]}]}],"pos":[24895,24930],"yaml":true},{"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","nodes":[{"pos":[0,113],"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","nodes":[{"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","pos":[0,113]}]}],"pos":[25015,25129],"yaml":true},{"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","nodes":[{"pos":[0,117],"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","nodes":[{"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","pos":[0,117]}]}],"pos":[25214,25332],"yaml":true},{"content":"<code>codePage</code> is less than zero.","nodes":[{"pos":[0,40],"content":"<ph id=\"ph1\">&lt;code&gt;codePage&lt;/code&gt;</ph> is less than zero.","source":"<code>codePage</code> is less than zero."}],"pos":[25500,25541],"yaml":true},{"content":"Gets an encoding for the ASCII (7-bit) character set.","nodes":[{"pos":[0,53],"content":"Gets an encoding for the ASCII (7-bit) character set.","nodes":[{"content":"Gets an encoding for the ASCII (7-bit) character set.","pos":[0,53]}]}],"pos":[26659,26713],"yaml":true},{"content":"ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.  \n  \n When selecting the ASCII encoding for your app, consider the following:  \n  \n-   The ASCII encoding is usually appropriate for protocols that require ASCII.  \n  \n-   If you requires 8-bit encoding (which is sometimes incorrectly referred to as \"ASCII\"), the UTF-8 encoding is recommended over the ASCII encoding. For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable. Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.  \n  \n-   Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit. Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.  \n  \n The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \n  \n [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]\n [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]","nodes":[{"pos":[0,89],"content":"ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.","nodes":[{"content":"ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.","pos":[0,89]}]},{"pos":[96,167],"content":"When selecting the ASCII encoding for your app, consider the following:","nodes":[{"content":"When selecting the ASCII encoding for your app, consider the following:","pos":[0,71]}]},{"pos":[177,252],"content":"The ASCII encoding is usually appropriate for protocols that require ASCII.","nodes":[{"content":"The ASCII encoding is usually appropriate for protocols that require ASCII.","pos":[0,75]}]},{"pos":[262,715],"content":"If you requires 8-bit encoding (which is sometimes incorrectly referred to as \"ASCII\"), the UTF-8 encoding is recommended over the ASCII encoding. For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable. Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.","nodes":[{"content":"If you requires 8-bit encoding (which is sometimes incorrectly referred to as \"ASCII\"), the UTF-8 encoding is recommended over the ASCII encoding. For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable. Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.","pos":[0,453],"nodes":[{"content":"If you requires 8-bit encoding (which is sometimes incorrectly referred to as \"ASCII\"), the UTF-8 encoding is recommended over the ASCII encoding.","pos":[0,146]},{"content":"For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.","pos":[147,309]},{"content":"Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.","pos":[310,453]}]}]},{"pos":[725,914],"content":"Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit. Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.","nodes":[{"content":"Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit. Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.","pos":[0,189],"nodes":[{"content":"Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.","pos":[0,101]},{"content":"Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.","pos":[102,189]}]}]},{"pos":[921,1570],"content":"The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","nodes":[{"content":"The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","pos":[0,649],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.","pos":[0,131],"source":"The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app."},{"content":"It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character.","pos":[132,279]},{"content":"Instead, you can call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> method to instantiate an <ph id=\"ph2\">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object whose fallback is either an <ph id=\"ph3\">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id=\"ph4\">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.","pos":[280,649],"source":" Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates."}]}]},{"pos":[1577,1870],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Text.Encoding.ASCII#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Text.Encoding.ASCII#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]\n[!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]"}],"pos":[26724,28614],"yaml":true,"extradata":"MT"},{"content":"An  encoding for the ASCII (7-bit) character set.","nodes":[{"pos":[0,49],"content":"An  encoding for the ASCII (7-bit) character set.","nodes":[{"content":"An  encoding for the ASCII (7-bit) character set.","pos":[0,49]}]}],"pos":[29349,29399],"yaml":true},{"content":"Gets an encoding for the UTF-16 format that uses the big endian byte order.","nodes":[{"pos":[0,75],"content":"Gets an encoding for the UTF-16 format that uses the big endian byte order.","nodes":[{"content":"Gets an encoding for the UTF-16 format that uses the big endian byte order.","pos":[0,75]}]}],"pos":[30774,30850],"yaml":true},{"content":"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \n  \n [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]\n [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  \n  \n The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name \"unicodeFFFE\". Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name \"unicodeFFFE\" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.","nodes":[{"pos":[0,669],"content":"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","nodes":[{"content":"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","pos":[0,669],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.","pos":[0,131],"source":"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app."},{"content":"It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character.","pos":[132,279]},{"content":"Instead, you can call the <ph id=\"ph1\">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a big endian <ph id=\"ph2\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id=\"ph3\">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id=\"ph4\">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.","pos":[280,669],"source":" Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates."}]}]},{"pos":[676,1017],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Text.Encoding.BigEndianUnicode#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Text.Encoding.BigEndianUnicode#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]\n [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]"},{"pos":[1024,1451],"content":"The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name \"unicodeFFFE\". Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name \"unicodeFFFE\" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.","nodes":[{"content":"The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name \"unicodeFFFE\". Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name \"unicodeFFFE\" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.","pos":[0,427],"nodes":[{"content":"The returned <ph id=\"ph1\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object has <ph id=\"ph2\">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> properties, which yield the name \"unicodeFFFE\".","pos":[0,233],"source":"The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name \"unicodeFFFE\"."},{"content":"Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name \"unicodeFFFE\" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.","pos":[234,427]}]}]}],"pos":[30861,32326],"yaml":true,"extradata":"MT"},{"content":"An encoding object for the UTF-16 format that uses the big endian byte order.","nodes":[{"pos":[0,77],"content":"An encoding object for the UTF-16 format that uses the big endian byte order.","nodes":[{"content":"An encoding object for the UTF-16 format that uses the big endian byte order.","pos":[0,77]}]}],"pos":[33776,33854],"yaml":true},{"content":"When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.","nodes":[{"pos":[0,116],"content":"When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.","nodes":[{"content":"When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.","pos":[0,116]}]}],"pos":[35287,35404],"yaml":true},{"content":"If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.  \n  \n In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.","nodes":[{"pos":[0,435],"content":"If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.","nodes":[{"content":"If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.","pos":[0,435],"nodes":[{"content":"If you need an encoding for a body name, you should call <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property.","pos":[0,158],"source":"If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property."},{"content":"Often the method retrieves a different encoding from the test encoding furnished in the call.","pos":[159,252]},{"content":"Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <ph id=\"ph1\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph>.","pos":[253,435],"source":" Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>."}]}]},{"pos":[442,671],"content":"In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.","nodes":[{"content":"In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.","pos":[0,229],"nodes":[{"content":"In some cases, the value of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.","pos":[0,150],"source":"In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding."},{"content":"This doesn't mean that the implementation complies in full with that standard.","pos":[151,229]}]}]}],"pos":[35415,36091],"yaml":true,"extradata":"MT"},{"content":"A name for the current <xref href=\"System.Text.Encoding\"></xref> that can be used with mail agent body tags.  \n  \n -or-  \n  \n An empty string (\"\"), if the current <xref href=\"System.Text.Encoding\"></xref> cannot be used.","nodes":[{"pos":[0,108],"content":"A name for the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> that can be used with mail agent body tags.","source":"A name for the current <xref href=\"System.Text.Encoding\"></xref> that can be used with mail agent body tags."},{"pos":[115,119],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[126,220],"content":"An empty string (\"\"), if the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> cannot be used.","source":"An empty string (\"\"), if the current <xref href=\"System.Text.Encoding\"></xref> cannot be used."}],"pos":[36944,37177],"yaml":true},{"content":"When overridden in a derived class, creates a shallow copy of the current <xref href=\"System.Text.Encoding\"></xref> object.","nodes":[{"pos":[0,123],"content":"When overridden in a derived class, creates a shallow copy of the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"When overridden in a derived class, creates a shallow copy of the current <xref href=\"System.Text.Encoding\"></xref> object."}],"pos":[38309,38433],"yaml":true},{"content":"The clone is writable even if the original <xref:System.Text.Encoding> object is read-only. Therefore, the properties of the clone can be modified.  \n  \n A shallow copy of an object is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects. It refers to the original objects instead. In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.","nodes":[{"pos":[0,147],"content":"The clone is writable even if the original <xref:System.Text.Encoding> object is read-only. Therefore, the properties of the clone can be modified.","nodes":[{"content":"The clone is writable even if the original <xref:System.Text.Encoding> object is read-only. Therefore, the properties of the clone can be modified.","pos":[0,147],"nodes":[{"content":"The clone is writable even if the original <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> object is read-only.","pos":[0,91],"source":"The clone is writable even if the original <xref:System.Text.Encoding> object is read-only."},{"content":"Therefore, the properties of the clone can be modified.","pos":[92,147]}]}]},{"pos":[154,513],"content":"A shallow copy of an object is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects. It refers to the original objects instead. In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.","nodes":[{"content":"A shallow copy of an object is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects. It refers to the original objects instead. In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.","pos":[0,359],"nodes":[{"content":"A shallow copy of an object is a copy of the object only.","pos":[0,57]},{"content":"If the object contains references to other objects, the shallow copy does not create copies of the referred objects.","pos":[58,174]},{"content":"It refers to the original objects instead.","pos":[175,217]},{"content":"In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.","pos":[218,359]}]}]}],"pos":[38444,38962],"yaml":true,"extradata":"MT"},{"content":"A copy of the current <xref href=\"System.Text.Encoding\"></xref> object.","nodes":[{"pos":[0,71],"content":"A copy of the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"A copy of the current <xref href=\"System.Text.Encoding\"></xref> object."}],"pos":[39160,39232],"yaml":true},{"content":"When overridden in a derived class, gets the code page identifier of the current <xref href=\"System.Text.Encoding\"></xref>.","nodes":[{"pos":[0,123],"content":"When overridden in a derived class, gets the code page identifier of the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph>.","source":"When overridden in a derived class, gets the code page identifier of the current <xref href=\"System.Text.Encoding\"></xref>."}],"pos":[40634,40758],"yaml":true},{"content":"The code page identifier of the current <xref href=\"System.Text.Encoding\"></xref>.","nodes":[{"pos":[0,82],"content":"The code page identifier of the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph>.","source":"The code page identifier of the current <xref href=\"System.Text.Encoding\"></xref>."}],"pos":[41621,41704],"yaml":true},{"content":"Converts a range of bytes in a byte array from one encoding to another.","nodes":[{"pos":[0,71],"content":"Converts a range of bytes in a byte array from one encoding to another.","nodes":[{"content":"Converts a range of bytes in a byte array from one encoding to another.","pos":[0,71]}]}],"pos":[43401,43473],"yaml":true},{"content":"The encoding of the source array, <code>bytes</code>.","nodes":[{"pos":[0,53],"content":"The encoding of the source array, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The encoding of the source array, <code>bytes</code>."}],"pos":[43721,43775],"yaml":true},{"content":"The encoding of the output array.","nodes":[{"pos":[0,33],"content":"The encoding of the output array.","nodes":[{"content":"The encoding of the output array.","pos":[0,33]}]}],"pos":[43849,43883],"yaml":true},{"content":"The array of bytes to convert.","nodes":[{"pos":[0,30],"content":"The array of bytes to convert.","nodes":[{"content":"The array of bytes to convert.","pos":[0,30]}]}],"pos":[43944,43975],"yaml":true},{"content":"The index of the first element of <code>bytes</code> to convert.","nodes":[{"pos":[0,64],"content":"The index of the first element of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> to convert.","source":"The index of the first element of <code>bytes</code> to convert."}],"pos":[44035,44100],"yaml":true},{"content":"The number of bytes to convert.","nodes":[{"pos":[0,31],"content":"The number of bytes to convert.","nodes":[{"content":"The number of bytes to convert.","pos":[0,31]}]}],"pos":[44160,44192],"yaml":true},{"content":"An array of type <xref href=\"System.Byte\"></xref> containing the result of converting a range of bytes in <code>bytes</code> from <code>srcEncoding</code> to <code>dstEncoding</code>.","nodes":[{"pos":[0,183],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> containing the result of converting a range of bytes in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> from <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">srcEncoding</ph><ept id=\"p2\">&lt;/code&gt;</ept> to <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph4\">dstEncoding</ph><ept id=\"p3\">&lt;/code&gt;</ept>.","source":"An array of type <xref href=\"System.Byte\"></xref> containing the result of converting a range of bytes in <code>bytes</code> from <code>srcEncoding</code> to <code>dstEncoding</code>."}],"pos":[44249,44433],"yaml":true},{"content":"<code>srcEncoding</code> is `null`.  \n  \n -or-  \n  \n <code>dstEncoding</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;srcEncoding&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>srcEncoding</code> is `null`."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,88],"content":"<ph id=\"ph1\">&lt;code&gt;dstEncoding&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>dstEncoding</code> is `null`."},{"pos":[95,99],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[106,135],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[44591,44737],"yaml":true},{"content":"<code>index</code> and <code>count</code> do not specify a valid range in the byte array.","nodes":[{"pos":[0,89],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid range in the byte array.","source":"<code>index</code> and <code>count</code> do not specify a valid range in the byte array."}],"pos":[44851,44941],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n **srcEncoding.** <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,305],"content":"**srcEncoding.** <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>srcEncoding.<ept id=\"p1\">**</ept>","pos":[0,16],"source":"**srcEncoding.**"},{"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","pos":[17,143],"source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}]}],"pos":[45059,45375],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n **dstEncoding.** <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,305],"content":"**dstEncoding.** <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>dstEncoding.<ept id=\"p1\">**</ept>","pos":[0,16],"source":"**dstEncoding.**"},{"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","pos":[17,143],"source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}]}],"pos":[45493,45809],"yaml":true},{"content":"Converts an entire byte array from one encoding to another.","nodes":[{"pos":[0,59],"content":"Converts an entire byte array from one encoding to another.","nodes":[{"content":"Converts an entire byte array from one encoding to another.","pos":[0,59]}]}],"pos":[47446,47506],"yaml":true},{"content":"The encoding format of <code>bytes</code>.","nodes":[{"pos":[0,42],"content":"The encoding format of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The encoding format of <code>bytes</code>."}],"pos":[48602,48645],"yaml":true},{"content":"The target encoding format.","nodes":[{"pos":[0,27],"content":"The target encoding format.","nodes":[{"content":"The target encoding format.","pos":[0,27]}]}],"pos":[48719,48747],"yaml":true},{"content":"The bytes to convert.","nodes":[{"pos":[0,21],"content":"The bytes to convert.","nodes":[{"content":"The bytes to convert.","pos":[0,21]}]}],"pos":[48808,48830],"yaml":true},{"content":"An array of type <xref href=\"System.Byte\"></xref> containing the results of converting <code>bytes</code> from <code>srcEncoding</code> to <code>dstEncoding</code>.","nodes":[{"pos":[0,164],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> containing the results of converting <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> from <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">srcEncoding</ph><ept id=\"p2\">&lt;/code&gt;</ept> to <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph4\">dstEncoding</ph><ept id=\"p3\">&lt;/code&gt;</ept>.","source":"An array of type <xref href=\"System.Byte\"></xref> containing the results of converting <code>bytes</code> from <code>srcEncoding</code> to <code>dstEncoding</code>."}],"pos":[48887,49052],"yaml":true},{"content":"<code>srcEncoding</code> is `null`.  \n  \n -or-  \n  \n <code>dstEncoding</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;srcEncoding&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>srcEncoding</code> is `null`."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,88],"content":"<ph id=\"ph1\">&lt;code&gt;dstEncoding&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>dstEncoding</code> is `null`."},{"pos":[95,99],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[106,135],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[49210,49356],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n **srcEncoding.** <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,305],"content":"**srcEncoding.** <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>srcEncoding.<ept id=\"p1\">**</ept>","pos":[0,16],"source":"**srcEncoding.**"},{"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","pos":[17,143],"source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}]}],"pos":[49474,49790],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n **dstEncoding.** <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,305],"content":"**dstEncoding.** <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>dstEncoding.<ept id=\"p1\">**</ept>","pos":[0,16],"source":"**dstEncoding.**"},{"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","pos":[17,143],"source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}]}],"pos":[49908,50224],"yaml":true},{"content":"Gets or sets the <xref href=\"System.Text.DecoderFallback\"></xref> object for the current <xref href=\"System.Text.Encoding\"></xref> object.","nodes":[{"pos":[0,138],"content":"Gets or sets the <ph id=\"ph1\">&lt;xref href=\"System.Text.DecoderFallback\"&gt;&lt;/xref&gt;</ph> object for the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"Gets or sets the <xref href=\"System.Text.DecoderFallback\"></xref> object for the current <xref href=\"System.Text.Encoding\"></xref> object."}],"pos":[51656,51795],"yaml":true},{"content":"The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character. Any one of the following handler types is supported:  \n  \n-   A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.  \n  \n-   A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark (\"?\") character.  \n  \n-   An exception fallback handler, which throws an exception when bytes cannot be decoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.","nodes":[{"pos":[0,208],"content":"The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character. Any one of the following handler types is supported:","nodes":[{"content":"The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character. Any one of the following handler types is supported:","pos":[0,208],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.DecoderFallback&gt;</ph> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.","pos":[0,155],"source":"The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character."},{"content":"Any one of the following handler types is supported:","pos":[156,208]}]}]},{"pos":[218,332],"content":"A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.","nodes":[{"content":"A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.","pos":[0,114]}]},{"pos":[342,651],"content":"A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark (\"?\") character.","nodes":[{"content":"A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark (\"?\") character.","pos":[0,309],"nodes":[{"content":"A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.","pos":[0,118]},{"content":"The .NET Framework includes one replacement fallback handler, <ph id=\"ph1\">&lt;xref:System.Text.DecoderFallback&gt;</ph>, which by default replaces bytes that cannot be decoded with a question mark (\"?\") character.","pos":[119,309],"source":" The .NET Framework includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark (\"?\") character."}]}]},{"pos":[661,941],"content":"An exception fallback handler, which throws an exception when bytes cannot be decoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.","nodes":[{"content":"An exception fallback handler, which throws an exception when bytes cannot be decoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.","pos":[0,280],"nodes":[{"content":"An exception fallback handler, which throws an exception when bytes cannot be decoded.","pos":[0,86]},{"content":"The .NET Framework includes one exception fallback handler, <ph id=\"ph1\">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph>, which throws a <ph id=\"ph2\">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> when bytes cannot be decoded.","pos":[87,280],"source":" The .NET Framework includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded."}]}]}],"pos":[51806,52758],"yaml":true,"extradata":"MT"},{"content":"The decoder fallback object for the current <xref href=\"System.Text.Encoding\"></xref> object.","nodes":[{"pos":[0,93],"content":"The decoder fallback object for the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"The decoder fallback object for the current <xref href=\"System.Text.Encoding\"></xref> object."}],"pos":[52984,53078],"yaml":true},{"content":"The value in a set operation is `null`.","nodes":[{"pos":[0,39],"content":"The value in a set operation is <ph id=\"ph1\">`null`</ph>.","source":"The value in a set operation is `null`."}],"pos":[53244,53284],"yaml":true},{"content":"A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\"></xref> object is read-only.","nodes":[{"pos":[0,128],"content":"A value cannot be assigned in a set operation because the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object is read-only.","source":"A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\"></xref> object is read-only."}],"pos":[53394,53523],"yaml":true},{"content":"Gets an encoding for the operating system's current ANSI code page.","nodes":[{"pos":[0,67],"content":"Gets an encoding for the operating system's current ANSI code page.","nodes":[{"content":"Gets an encoding for the operating system's current ANSI code page.","pos":[0,67]}]}],"pos":[54837,54905],"yaml":true},{"content":"> [!WARNING]\n>  Different computers can use different encodings as the default, and the default encoding can even change on a single computer. Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly. In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page. For these two reasons, using the default encoding is generally not recommended. To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>, with a preamble. Another option is to use a higher-level protocol to ensure that the same format is used for encoding and decoding.  \n  \n The system ANSI code page defined by <xref:System.Text.Encoding.Default%2A> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII. Because all <xref:System.Text.Encoding.Default%2A> encodings lose data, you might use <xref:System.Text.Encoding.UTF8%2A> instead. UTF-8 is often identical in the U+00 to U+7F range, but can encode other characters without loss.","nodes":[{"pos":[2,849],"content":"[!WARNING]\n Different computers can use different encodings as the default, and the default encoding can even change on a single computer. Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly. In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page. For these two reasons, using the default encoding is generally not recommended. To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>, with a preamble. Another option is to use a higher-level protocol to ensure that the same format is used for encoding and decoding.","leadings":["","> "],"nodes":[{"content":" Different computers can use different encodings as the default, and the default encoding can even change on a single computer. Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly. In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page. For these two reasons, using the default encoding is generally not recommended. To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>, with a preamble. Another option is to use a higher-level protocol to ensure that the same format is used for encoding and decoding.","pos":[11,845],"nodes":[{"content":"Different computers can use different encodings as the default, and the default encoding can even change on a single computer.","pos":[1,127]},{"content":"Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly.","pos":[128,272]},{"content":"In addition, the encoding returned by the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property uses best-fit fallback to map unsupported characters to characters supported by the code page.","pos":[273,457],"source":" In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page."},{"content":"For these two reasons, using the default encoding is generally not recommended.","pos":[458,537]},{"content":"To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, with a preamble.","pos":[538,719],"source":" To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>, with a preamble."},{"content":"Another option is to use a higher-level protocol to ensure that the same format is used for encoding and decoding.","pos":[720,834]}]}]},{"pos":[856,1255],"content":"The system ANSI code page defined by <xref:System.Text.Encoding.Default%2A> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII. Because all <xref:System.Text.Encoding.Default%2A> encodings lose data, you might use <xref:System.Text.Encoding.UTF8%2A> instead. UTF-8 is often identical in the U+00 to U+7F range, but can encode other characters without loss.","nodes":[{"content":"The system ANSI code page defined by <xref:System.Text.Encoding.Default%2A> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII. Because all <xref:System.Text.Encoding.Default%2A> encodings lose data, you might use <xref:System.Text.Encoding.UTF8%2A> instead. UTF-8 is often identical in the U+00 to U+7F range, but can encode other characters without loss.","pos":[0,399],"nodes":[{"content":"The system ANSI code page defined by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII.","pos":[0,170],"source":"The system ANSI code page defined by <xref:System.Text.Encoding.Default%2A> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII."},{"content":"Because all <ph id=\"ph1\">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encodings lose data, you might use <ph id=\"ph2\">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> instead.","pos":[171,301],"source":" Because all <xref:System.Text.Encoding.Default%2A> encodings lose data, you might use <xref:System.Text.Encoding.UTF8%2A> instead."},{"content":"UTF-8 is often identical in the U+00 to U+7F range, but can encode other characters without loss.","pos":[302,399]}]}]}],"pos":[54916,56177],"yaml":true,"extradata":"MT"},{"content":"An encoding for the operating system's current ANSI code page.","nodes":[{"pos":[0,62],"content":"An encoding for the operating system's current ANSI code page.","nodes":[{"content":"An encoding for the operating system's current ANSI code page.","pos":[0,62]}]}],"pos":[56376,56439],"yaml":true},{"content":"Gets or sets the <xref href=\"System.Text.EncoderFallback\"></xref> object for the current <xref href=\"System.Text.Encoding\"></xref> object.","nodes":[{"pos":[0,138],"content":"Gets or sets the <ph id=\"ph1\">&lt;xref href=\"System.Text.EncoderFallback\"&gt;&lt;/xref&gt;</ph> object for the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"Gets or sets the <xref href=\"System.Text.EncoderFallback\"></xref> object for the current <xref href=\"System.Text.Encoding\"></xref> object."}],"pos":[57694,57833],"yaml":true},{"content":"The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence. Any one of the following handler types is supported:  \n  \n-   A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.  \n  \n-   A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark (\"?\") character.  \n  \n-   An exception fallback handler, which throws an exception when characters cannot be encoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.","nodes":[{"pos":[0,210],"content":"The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence. Any one of the following handler types is supported:","nodes":[{"content":"The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence. Any one of the following handler types is supported:","pos":[0,210],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.EncoderFallback&gt;</ph> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.","pos":[0,157],"source":"The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence."},{"content":"Any one of the following handler types is supported:","pos":[158,210]}]}]},{"pos":[220,339],"content":"A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.","nodes":[{"content":"A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.","pos":[0,119]}]},{"pos":[349,668],"content":"A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark (\"?\") character.","nodes":[{"content":"A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark (\"?\") character.","pos":[0,319],"nodes":[{"content":"A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.","pos":[0,123]},{"content":"The .NET Framework includes one replacement fallback handler, <ph id=\"ph1\">&lt;xref:System.Text.EncoderFallback&gt;</ph>, which by default replaces characters that cannot be encoded with a question mark (\"?\") character.","pos":[124,319],"source":" The .NET Framework includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark (\"?\") character."}]}]},{"pos":[678,969],"content":"An exception fallback handler, which throws an exception when characters cannot be encoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.","nodes":[{"content":"An exception fallback handler, which throws an exception when characters cannot be encoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.","pos":[0,291],"nodes":[{"content":"An exception fallback handler, which throws an exception when characters cannot be encoded.","pos":[0,91]},{"content":"The .NET Framework includes one exception fallback handler, <ph id=\"ph1\">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph>, which throws an <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> when characters cannot be decoded.","pos":[92,291],"source":" The .NET Framework includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded."}]}]}],"pos":[57844,58824],"yaml":true,"extradata":"MT"},{"content":"The encoder fallback object for the current <xref href=\"System.Text.Encoding\"></xref> object.","nodes":[{"pos":[0,93],"content":"The encoder fallback object for the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"The encoder fallback object for the current <xref href=\"System.Text.Encoding\"></xref> object."}],"pos":[59050,59144],"yaml":true},{"content":"The value in a set operation is `null`.","nodes":[{"pos":[0,39],"content":"The value in a set operation is <ph id=\"ph1\">`null`</ph>.","source":"The value in a set operation is `null`."}],"pos":[59310,59350],"yaml":true},{"content":"A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\"></xref> object is read-only.","nodes":[{"pos":[0,128],"content":"A value cannot be assigned in a set operation because the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object is read-only.","source":"A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\"></xref> object is read-only."}],"pos":[59460,59589],"yaml":true},{"content":"When overridden in a derived class, gets the human-readable description of the current encoding.","nodes":[{"pos":[0,96],"content":"When overridden in a derived class, gets the human-readable description of the current encoding.","nodes":[{"content":"When overridden in a derived class, gets the human-readable description of the current encoding.","pos":[0,96]}]}],"pos":[60958,61055],"yaml":true},{"content":"The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display. To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.","nodes":[{"pos":[0,230],"content":"The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display. To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.","nodes":[{"content":"The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display. To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.","pos":[0,230],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> property is intended for display.","pos":[0,81],"source":"The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display."},{"content":"To find a name that can be passed to the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method, use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property.","pos":[82,230],"source":" To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property."}]}]}],"pos":[61066,61297],"yaml":true,"extradata":"MT"},{"content":"The human-readable description of the current <xref href=\"System.Text.Encoding\"></xref>.","nodes":[{"pos":[0,88],"content":"The human-readable description of the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph>.","source":"The human-readable description of the current <xref href=\"System.Text.Encoding\"></xref>."}],"pos":[62154,62243],"yaml":true},{"content":"Determines whether the specified <xref href=\"System.Object\"></xref> is equal to the current instance.","nodes":[{"pos":[0,101],"content":"Determines whether the specified <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> is equal to the current instance.","source":"Determines whether the specified <xref href=\"System.Object\"></xref> is equal to the current instance."}],"pos":[63632,63734],"yaml":true},{"content":"Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal. In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET). Thus they are all considered equal to one another. One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.","nodes":[{"pos":[0,537],"content":"Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal. In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET). Thus they are all considered equal to one another. One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.","nodes":[{"content":"Two instances of <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> are considered equal if they correspond to the same code page and their <ph id=\"ph2\">`EncoderFallback`</ph> and <ph id=\"ph3\">`DecoderFallback`</ph> objects are equal.","pos":[0,175],"source":"Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal."},{"content":"In particular, derived code pages all have a code page of 0 and their fallbacks are normally <ph id=\"ph1\">`null`</ph> (<ph id=\"ph2\">`Nothing`</ph> in Visual Basic .NET).","pos":[176,309],"source":" In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET)."},{"content":"Thus they are all considered equal to one another.","pos":[310,360]},{"content":"One consequence is that when <ph id=\"ph1\">&lt;xref:System.Text.Encoding.Equals%2A&gt;</ph> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.","pos":[361,537],"source":" One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot."}]}],"pos":[63745,64283],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Object\"></xref> to compare with the current instance.","nodes":[{"pos":[0,76],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> to compare with the current instance.","source":"The <xref href=\"System.Object\"></xref> to compare with the current instance."}],"pos":[64998,65075],"yaml":true},{"content":"`true` if <code>value</code> is an instance of <xref href=\"System.Text.Encoding\"></xref> and is equal to the current instance; otherwise, `false`.","nodes":[{"pos":[0,146],"content":"<ph id=\"ph1\">`true`</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">value</ph><ept id=\"p1\">&lt;/code&gt;</ept> is an instance of <ph id=\"ph3\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> and is equal to the current instance; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if <code>value</code> is an instance of <xref href=\"System.Text.Encoding\"></xref> and is equal to the current instance; otherwise, `false`."}],"pos":[65133,65282],"yaml":true},{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.","nodes":[{"pos":[0,143],"content":"When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.","nodes":[{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.","pos":[0,143]}]}],"pos":[68008,68152],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \n  \n-   If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,467],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,467],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,176],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[177,277],"source":" To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[278,467],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[474,920],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,446],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,446],"source":" The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[927,1125],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1135,1416],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","pos":[0,281],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."}]}]},{"pos":[1426,1538],"content":"If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.","nodes":[{"content":"If your app handles string inputs, the string version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.","pos":[0,112],"source":"If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended."}]},{"pos":[1548,1931],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[1941,2136],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2146,2485],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[68163,70665],"yaml":true,"extradata":"MT"},{"content":"The character array containing the set of characters to encode.","nodes":[{"pos":[0,63],"content":"The character array containing the set of characters to encode.","nodes":[{"content":"The character array containing the set of characters to encode.","pos":[0,63]}]}],"pos":[71558,71622],"yaml":true},{"content":"The index of the first character to encode.","nodes":[{"pos":[0,43],"content":"The index of the first character to encode.","nodes":[{"content":"The index of the first character to encode.","pos":[0,43]}]}],"pos":[71682,71726],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[71786,71822],"yaml":true},{"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"pos":[0,66],"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"content":"The number of bytes produced by encoding the specified characters.","pos":[0,66]}]}],"pos":[71878,71945],"yaml":true},{"content":"<code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[72108,72138],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>."}],"pos":[72252,72428],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[72546,72845],"yaml":true},{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.","nodes":[{"pos":[0,140],"content":"When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.","nodes":[{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.","pos":[0,140]}]}],"pos":[74326,74467],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \n  \n-   If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, you should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,467],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,467],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,176],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[177,277],"source":" To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[278,467],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[474,920],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,446],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,446],"source":" The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[927,1125],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1135,1416],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","pos":[0,281],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."}]}]},{"pos":[1426,1550],"content":"If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.","nodes":[{"content":"If your app handles string inputs, you should use the string versions of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.","pos":[0,124],"source":"If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method."}]},{"pos":[1560,1943],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[1953,2149],"content":"If your app must convert a large amount of data, you should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, you should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,196],"nodes":[{"content":"If your app must convert a large amount of data, you should reuse the output buffer.","pos":[0,84]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[85,196],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2159,2498],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[74478,76993],"yaml":true,"extradata":"MT"},{"content":"The character array containing the characters to encode.","nodes":[{"pos":[0,56],"content":"The character array containing the characters to encode.","nodes":[{"content":"The character array containing the characters to encode.","pos":[0,56]}]}],"pos":[77823,77880],"yaml":true},{"content":"The number of bytes produced by encoding all the characters in the specified character array.","nodes":[{"pos":[0,93],"content":"The number of bytes produced by encoding all the characters in the specified character array.","nodes":[{"content":"The number of bytes produced by encoding all the characters in the specified character array.","pos":[0,93]}]}],"pos":[77936,78030],"yaml":true},{"content":"<code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[78193,78223],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[78341,78640],"yaml":true},{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.","nodes":[{"pos":[0,127],"content":"When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.","nodes":[{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.","pos":[0,127]}]}],"pos":[80121,80249],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \n  \n-   If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,467],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,467],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,176],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[177,277],"source":" To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[278,467],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[474,920],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,446],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,446],"source":" The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[927,1125],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1135,1416],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","pos":[0,281],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."}]}]},{"pos":[1426,1538],"content":"If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.","nodes":[{"content":"If your app handles string inputs, the string version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.","pos":[0,112],"source":"If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended."}]},{"pos":[1548,1931],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[1941,2136],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2146,2485],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[80260,82762],"yaml":true,"extradata":"MT"},{"content":"The string containing the set of characters to encode.","nodes":[{"pos":[0,54],"content":"The string containing the set of characters to encode.","nodes":[{"content":"The string containing the set of characters to encode.","pos":[0,54]}]}],"pos":[83591,83646],"yaml":true},{"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"pos":[0,66],"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"content":"The number of bytes produced by encoding the specified characters.","pos":[0,66]}]}],"pos":[83702,83769],"yaml":true},{"content":"<code>s</code> is `null`.","nodes":[{"pos":[0,25],"content":"<ph id=\"ph1\">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>s</code> is `null`."}],"pos":[83932,83958],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[84076,84375],"yaml":true},{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.","nodes":[{"pos":[0,152],"content":"When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.","nodes":[{"content":"When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.","pos":[0,152]}]}],"pos":[85910,86063],"yaml":true},{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some considerations for using these methods:  \n  \n-   Your app may need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \n  \n-   If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,480],"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,480],"nodes":[{"content":"To calculate the exact array size that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you should call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,189],"source":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[190,290],"source":" To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[291,480],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[487,1029],"content":"The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,542],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> method performs the actual encoding.","pos":[0,309],"source":"The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[310,542],"source":" The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[1036,1221],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some considerations for using these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some considerations for using these methods:","pos":[0,185],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some considerations for using these methods:","pos":[123,185]}]}]},{"pos":[1231,1510],"content":"Your app may need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","nodes":[{"content":"Your app may need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.","pos":[0,279],"nodes":[{"content":"Your app may need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,113]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[114,279],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."}]}]},{"pos":[1520,1643],"content":"If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.","nodes":[{"content":"If your app handles string inputs, you should use the string version of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.","pos":[0,123],"source":"If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method."}]},{"pos":[1653,1972],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,319],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,221],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[222,319]}]}]},{"pos":[1982,2177],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2187,2526],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[86074,88617],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first character to encode.","nodes":[{"pos":[0,43],"content":"A pointer to the first character to encode.","nodes":[{"content":"A pointer to the first character to encode.","pos":[0,43]}]}],"pos":[88919,88963],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[89023,89059],"yaml":true},{"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"pos":[0,66],"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"content":"The number of bytes produced by encoding the specified characters.","pos":[0,66]}]}],"pos":[89115,89182],"yaml":true},{"content":"<code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[89345,89375],"yaml":true},{"content":"<code>count</code> is less than zero.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>count</code> is less than zero."}],"pos":[89489,89527],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[89645,89944],"yaml":true},{"content":"When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.","nodes":[{"pos":[0,121],"content":"When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.","nodes":[{"content":"When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.","pos":[0,121]}]}],"pos":[91447,91569],"yaml":true},{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \n  \n-   If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,422],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[429,875],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,446],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,446],"source":" The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[882,1080],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1090,1759],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","pos":[0,669],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."},{"content":"(For example, a character sequence that includes surrogate pairs might end with a high surrogate.","pos":[282,379]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.","pos":[380,530],"source":" The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)","pos":[531,669],"source":" <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)"}]}]},{"pos":[1769,1893],"content":"If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.","nodes":[{"content":"If your app handles string inputs, you should call the string version of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.","pos":[0,124],"source":"If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method."}]},{"pos":[1903,2286],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[2296,2491],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2501,2840],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[91580,94437],"yaml":true,"extradata":"MT"},{"content":"The character array containing the characters to encode.","nodes":[{"pos":[0,56],"content":"The character array containing the characters to encode.","nodes":[{"content":"The character array containing the characters to encode.","pos":[0,56]}]}],"pos":[95266,95323],"yaml":true},{"content":"A byte array containing the results of encoding the specified set of characters.","nodes":[{"pos":[0,80],"content":"A byte array containing the results of encoding the specified set of characters.","nodes":[{"content":"A byte array containing the results of encoding the specified set of characters.","pos":[0,80]}]}],"pos":[95380,95461],"yaml":true},{"content":"<code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[95620,95650],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[95768,96067],"yaml":true},{"content":"When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.","nodes":[{"pos":[0,112],"content":"When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.","nodes":[{"content":"When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.","pos":[0,112]}]}],"pos":[97524,97637],"yaml":true},{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \n  \n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,422],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[429,900],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,471],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,471],"source":" The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[907,1105],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1115,1784],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","pos":[0,669],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."},{"content":"(For example, a character sequence that includes surrogate pairs might end with a high surrogate.","pos":[282,379]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.","pos":[380,530],"source":" The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)","pos":[531,669],"source":" <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)"}]}]},{"pos":[1794,1906],"content":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.","nodes":[{"content":"If your app handles string inputs, you should use the string version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.","pos":[0,112],"source":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>."}]},{"pos":[1916,2299],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[2309,2504],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2514,2853],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[97648,100518],"yaml":true,"extradata":"MT"},{"content":"The string containing the characters to encode.","nodes":[{"pos":[0,47],"content":"The string containing the characters to encode.","nodes":[{"content":"The string containing the characters to encode.","pos":[0,47]}]}],"pos":[101346,101394],"yaml":true},{"content":"A byte array containing the results of encoding the specified set of characters.","nodes":[{"pos":[0,80],"content":"A byte array containing the results of encoding the specified set of characters.","nodes":[{"content":"A byte array containing the results of encoding the specified set of characters.","pos":[0,80]}]}],"pos":[101451,101532],"yaml":true},{"content":"<code>s</code> is `null`.","nodes":[{"pos":[0,25],"content":"<ph id=\"ph1\">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>s</code> is `null`."}],"pos":[101691,101717],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[101835,102134],"yaml":true},{"content":"When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.","nodes":[{"pos":[0,124],"content":"When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.","nodes":[{"content":"When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.","pos":[0,124]}]}],"pos":[103711,103836],"yaml":true},{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \n  \n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,422],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[429,900],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,471],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,471],"source":" The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[907,1105],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1115,1784],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","pos":[0,669],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."},{"content":"(For example, a character sequence that includes surrogate pairs might end with a high surrogate.","pos":[282,379]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.","pos":[380,530],"source":" The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)","pos":[531,669],"source":" <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)"}]}]},{"pos":[1794,1906],"content":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.","nodes":[{"content":"If your app handles string inputs, you should use the string version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.","pos":[0,112],"source":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>."}]},{"pos":[1916,2299],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[2309,2504],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2514,2853],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[103847,106717],"yaml":true,"extradata":"MT"},{"content":"The character array containing the set of characters to encode.","nodes":[{"pos":[0,63],"content":"The character array containing the set of characters to encode.","nodes":[{"content":"The character array containing the set of characters to encode.","pos":[0,63]}]}],"pos":[107608,107672],"yaml":true},{"content":"The index of the first character to encode.","nodes":[{"pos":[0,43],"content":"The index of the first character to encode.","nodes":[{"content":"The index of the first character to encode.","pos":[0,43]}]}],"pos":[107732,107776],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[107836,107872],"yaml":true},{"content":"A byte array containing the results of encoding the specified set of characters.","nodes":[{"pos":[0,80],"content":"A byte array containing the results of encoding the specified set of characters.","nodes":[{"content":"A byte array containing the results of encoding the specified set of characters.","pos":[0,80]}]}],"pos":[107929,108010],"yaml":true},{"content":"<code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[108169,108199],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>."}],"pos":[108313,108489],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[108607,108906],"yaml":true},{"content":"When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.","nodes":[{"pos":[0,188],"content":"When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.","nodes":[{"content":"When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.","pos":[0,188]}]}],"pos":[111576,111765],"yaml":true},{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \n  \n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,469],"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,469],"nodes":[{"content":"To calculate the exact array size that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,178],"source":"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[179,279],"source":" To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[280,469],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[476,898],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[905,1351],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,446],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,446],"source":" The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[1358,1556],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1566,2235],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","pos":[0,669],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."},{"content":"(For example, a character sequence that includes surrogate pairs might end with a high surrogate.","pos":[282,379]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.","pos":[380,530],"source":" The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)","pos":[531,669],"source":" <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)"}]}]},{"pos":[2245,2357],"content":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.","nodes":[{"content":"If your app handles string inputs, you should use the string version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.","pos":[0,112],"source":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>."}]},{"pos":[2367,2750],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[2760,2955],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2965,3304],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[111776,115099],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first character to encode.","nodes":[{"pos":[0,43],"content":"A pointer to the first character to encode.","nodes":[{"content":"A pointer to the first character to encode.","pos":[0,43]}]}],"pos":[115429,115473],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[115537,115573],"yaml":true},{"content":"A pointer to the location at which to start writing the resulting sequence of bytes.","nodes":[{"pos":[0,84],"content":"A pointer to the location at which to start writing the resulting sequence of bytes.","nodes":[{"content":"A pointer to the location at which to start writing the resulting sequence of bytes.","pos":[0,84]}]}],"pos":[115633,115718],"yaml":true},{"content":"The maximum number of bytes to write.","nodes":[{"pos":[0,37],"content":"The maximum number of bytes to write.","nodes":[{"content":"The maximum number of bytes to write.","pos":[0,37]}]}],"pos":[115782,115820],"yaml":true},{"content":"The actual number of bytes written at the location indicated by the <code>bytes</code> parameter.","nodes":[{"pos":[0,97],"content":"The actual number of bytes written at the location indicated by the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The actual number of bytes written at the location indicated by the <code>bytes</code> parameter."}],"pos":[115876,115974],"yaml":true},{"content":"<code>chars</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[116133,116216],"yaml":true},{"content":"<code>charCount</code> or <code>byteCount</code> is less than zero.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.","source":"<code>charCount</code> or <code>byteCount</code> is less than zero."}],"pos":[116330,116398],"yaml":true},{"content":"<code>byteCount</code> is less than the resulting number of bytes.","nodes":[{"pos":[0,66],"content":"<ph id=\"ph1\">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than the resulting number of bytes.","source":"<code>byteCount</code> is less than the resulting number of bytes."}],"pos":[116492,116559],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[116677,116976],"yaml":true},{"content":"When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.","nodes":[{"pos":[0,129],"content":"When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.","nodes":[{"content":"When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.","pos":[0,129]}]}],"pos":[118725,118855],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \n  \n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,478],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,478],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,187],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[188,288],"source":" To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[289,478],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[485,907],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[914,1385],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,471],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,471],"source":" The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[1392,1590],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1600,2269],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","pos":[0,669],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."},{"content":"(For example, a character sequence that includes surrogate pairs might end with a high surrogate.","pos":[282,379]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.","pos":[380,530],"source":" The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)","pos":[531,669],"source":" <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)"}]}]},{"pos":[2279,2391],"content":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.","nodes":[{"content":"If your app handles string inputs, you should use the string version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.","pos":[0,112],"source":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>."}]},{"pos":[2401,2784],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[2794,2989],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2999,3338],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[118866,122223],"yaml":true,"extradata":"MT"},{"content":"The character array containing the set of characters to encode.","nodes":[{"pos":[0,63],"content":"The character array containing the set of characters to encode.","nodes":[{"content":"The character array containing the set of characters to encode.","pos":[0,63]}]}],"pos":[123149,123213],"yaml":true},{"content":"The index of the first character to encode.","nodes":[{"pos":[0,43],"content":"The index of the first character to encode.","nodes":[{"content":"The index of the first character to encode.","pos":[0,43]}]}],"pos":[123277,123321],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[123385,123421],"yaml":true},{"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"pos":[0,58],"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"content":"The byte array to contain the resulting sequence of bytes.","pos":[0,58]}]}],"pos":[123482,123541],"yaml":true},{"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"pos":[0,68],"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"content":"The index at which to start writing the resulting sequence of bytes.","pos":[0,68]}]}],"pos":[123605,123674],"yaml":true},{"content":"The actual number of bytes written into <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"The actual number of bytes written into <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The actual number of bytes written into <code>bytes</code>."}],"pos":[123730,123790],"yaml":true},{"content":"<code>chars</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[123949,124032],"yaml":true},{"content":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \n  \n -or-  \n  \n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \n  \n -or-  \n  \n <code>byteIndex</code> is not a valid index in <code>bytes</code>.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id=\"ph3\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is less than zero.","source":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero."},{"pos":[100,104],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[111,211],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>."},{"pos":[218,222],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[229,295],"content":"<ph id=\"ph1\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is not a valid index in <ph id=\"ph2\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>byteIndex</code> is not a valid index in <code>bytes</code>."}],"pos":[124146,124452],"yaml":true},{"content":"<code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.","nodes":[{"pos":[0,136],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> does not have enough capacity from <ph id=\"ph2\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting bytes.","source":"<code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes."}],"pos":[124546,124683],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[124801,125100],"yaml":true},{"content":"When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.","nodes":[{"pos":[0,120],"content":"When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.","nodes":[{"content":"When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.","pos":[0,120]}]}],"pos":[126803,126924],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \n  \n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \n  \n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \n  \n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,478],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,478],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,187],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[188,288],"source":" To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[289,478],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[485,907],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[914,1385],"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.","pos":[0,471],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,213],"source":"The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.","pos":[214,471],"source":" The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream."}]}]},{"pos":[1392,1590],"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1600,2269],"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)","pos":[0,669],"nodes":[{"content":"Your app might need to encode many input characters to a code page and process the characters using multiple calls.","pos":[0,115]},{"content":"In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> object being used.","pos":[116,281],"source":" In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used."},{"content":"(For example, a character sequence that includes surrogate pairs might end with a high surrogate.","pos":[282,379]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.","pos":[380,530],"source":" The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)","pos":[531,669],"source":" <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)"}]}]},{"pos":[2279,2391],"content":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.","nodes":[{"content":"If your app handles string inputs, you should use the string version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.","pos":[0,112],"source":"If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>."}]},{"pos":[2401,2784],"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,383],"nodes":[{"content":"The Unicode character buffer version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.","pos":[0,285],"source":"The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[286,383]}]}]},{"pos":[2794,2989],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.","pos":[0,195],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.","pos":[84,195],"source":" In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice."}]}]},{"pos":[2999,3338],"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.","pos":[0,339],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>."},{"content":"The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.","pos":[145,264]},{"content":"For continuous encoding of a stream, this method is often the best choice.","pos":[265,339]}]}]}],"pos":[126935,130292],"yaml":true,"extradata":"MT"},{"content":"The string containing the set of characters to encode.","nodes":[{"pos":[0,54],"content":"The string containing the set of characters to encode.","nodes":[{"content":"The string containing the set of characters to encode.","pos":[0,54]}]}],"pos":[131176,131231],"yaml":true},{"content":"The index of the first character to encode.","nodes":[{"pos":[0,43],"content":"The index of the first character to encode.","nodes":[{"content":"The index of the first character to encode.","pos":[0,43]}]}],"pos":[131295,131339],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[131403,131439],"yaml":true},{"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"pos":[0,58],"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"content":"The byte array to contain the resulting sequence of bytes.","pos":[0,58]}]}],"pos":[131500,131559],"yaml":true},{"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"pos":[0,68],"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"content":"The index at which to start writing the resulting sequence of bytes.","pos":[0,68]}]}],"pos":[131623,131692],"yaml":true},{"content":"The actual number of bytes written into <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"The actual number of bytes written into <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The actual number of bytes written into <code>bytes</code>."}],"pos":[131748,131808],"yaml":true},{"content":"<code>s</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,25],"content":"<ph id=\"ph1\">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>s</code> is `null`."},{"pos":[32,36],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[43,72],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[131967,132046],"yaml":true},{"content":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \n  \n -or-  \n  \n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \n  \n -or-  \n  \n <code>byteIndex</code> is not a valid index in <code>bytes</code>.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id=\"ph3\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is less than zero.","source":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero."},{"pos":[100,104],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[111,211],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>."},{"pos":[218,222],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[229,295],"content":"<ph id=\"ph1\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is not a valid index in <ph id=\"ph2\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>byteIndex</code> is not a valid index in <code>bytes</code>."}],"pos":[132160,132466],"yaml":true},{"content":"<code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.","nodes":[{"pos":[0,136],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> does not have enough capacity from <ph id=\"ph2\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting bytes.","source":"<code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes."}],"pos":[132560,132697],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[132815,133114],"yaml":true},{"content":"When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.","nodes":[{"pos":[0,135],"content":"When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.","nodes":[{"content":"When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.","pos":[0,135]}]}],"pos":[134595,134731],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method. To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method. The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.  \n  \n-   If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \n  \n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \n  \n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,567],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method. To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method. The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method. To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method. The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,567],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> to store the resulting characters, you should use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method.","pos":[0,231],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method."},{"content":"To calculate the maximum array size, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29&gt;</ph> method.","pos":[232,357],"source":" To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[358,567],"source":" The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[574,1078],"content":"The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","pos":[0,504],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the  <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> method performs the actual decoding.","pos":[0,251],"source":"The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.","pos":[252,504],"source":" The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream."}]}]},{"pos":[1085,1283],"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1293,1469],"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.","nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.","pos":[0,176],"nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.","pos":[0,111]},{"content":"In this case, you probably need to maintain state between calls.","pos":[112,176]}]}]},{"pos":[1479,1735],"content":"If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","nodes":[{"content":"If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","pos":[0,256],"nodes":[{"content":"If your app handles string outputs, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.","pos":[0,103],"source":"If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method."},{"content":"Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is to be preferred.","pos":[104,256],"source":" Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred."}]}]},{"pos":[1745,2046],"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,301],"nodes":[{"content":"The byte version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.","pos":[0,203],"source":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[204,301]}]}]},{"pos":[2056,2373],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","pos":[0,317],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.","pos":[84,317],"source":" In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice."}]}]},{"pos":[2383,2717],"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","pos":[0,334],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>."},{"content":"The conversion method converts as much data as possible and throws an exception if the output buffer is too small.","pos":[145,259]},{"content":"For continuous decoding of a stream, this method is often the best choice.","pos":[260,334]}]}]}],"pos":[134742,137478],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[138206,138265],"yaml":true},{"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"pos":[0,78],"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"content":"The number of characters produced by decoding the specified sequence of bytes.","pos":[0,78]}]}],"pos":[138321,138400],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[138563,138593],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[138711,139010],"yaml":true},{"content":"When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.","nodes":[{"pos":[0,152],"content":"When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.","nodes":[{"content":"When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.","pos":[0,152]}]}],"pos":[140545,140698],"yaml":true},{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.  \n  \n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \n  \n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \n  \n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,483],"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,483],"nodes":[{"content":"To calculate the exact array size that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,193],"source":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[194,293],"source":" To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[294,483],"source":" The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[490,928],"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","pos":[0,438],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.","pos":[0,210],"source":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.","pos":[211,438],"source":" The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream."}]}]},{"pos":[935,1133],"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1143,1319],"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.","nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.","pos":[0,176],"nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.","pos":[0,111]},{"content":"In this case, you probably need to maintain state between calls.","pos":[112,176]}]}]},{"pos":[1329,1595],"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","nodes":[{"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","pos":[0,266],"nodes":[{"content":"If your app handles string outputs, it is recommended to use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.","pos":[0,113],"source":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method."},{"content":"Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is to be preferred.","pos":[114,266],"source":" Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred."}]}]},{"pos":[1605,1906],"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,301],"nodes":[{"content":"The byte version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.","pos":[0,203],"source":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[204,301]}]}]},{"pos":[1916,2233],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","pos":[0,317],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.","pos":[84,317],"source":" In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice."}]}]},{"pos":[2243,2577],"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","pos":[0,334],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>."},{"content":"The conversion method converts as much data as possible and throws an exception if the output buffer is too small.","pos":[145,259]},{"content":"For continuous decoding of a stream, this method is often the best choice.","pos":[260,334]}]}]}],"pos":[140709,143305],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first byte to decode.","nodes":[{"pos":[0,38],"content":"A pointer to the first byte to decode.","nodes":[{"content":"A pointer to the first byte to decode.","pos":[0,38]}]}],"pos":[143607,143646],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[143706,143737],"yaml":true},{"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"pos":[0,78],"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"content":"The number of characters produced by decoding the specified sequence of bytes.","pos":[0,78]}]}],"pos":[143793,143872],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[144035,144065],"yaml":true},{"content":"<code>count</code> is less than zero.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>count</code> is less than zero."}],"pos":[144179,144217],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[144335,144634],"yaml":true},{"content":"When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.","nodes":[{"pos":[0,143],"content":"When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.","nodes":[{"content":"When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.","pos":[0,143]}]}],"pos":[146281,146425],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.  \n  \n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \n  \n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \n  \n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,481],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,481],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,191],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[192,291],"source":" To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[292,481],"source":" The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[488,926],"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","pos":[0,438],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.","pos":[0,210],"source":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.","pos":[211,438],"source":" The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream."}]}]},{"pos":[933,1131],"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1141,1317],"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.","nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.","pos":[0,176],"nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.","pos":[0,111]},{"content":"In this case, you probably need to maintain state between calls.","pos":[112,176]}]}]},{"pos":[1327,1593],"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","nodes":[{"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","pos":[0,266],"nodes":[{"content":"If your app handles string outputs, it is recommended to use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.","pos":[0,113],"source":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method."},{"content":"Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is to be preferred.","pos":[114,266],"source":" Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred."}]}]},{"pos":[1603,1904],"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,301],"nodes":[{"content":"The byte version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.","pos":[0,203],"source":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[204,301]}]}]},{"pos":[1914,2231],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","pos":[0,317],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.","pos":[84,317],"source":" In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice."}]}]},{"pos":[2241,2575],"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","pos":[0,334],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>."},{"content":"The conversion method converts as much data as possible and throws an exception if the output buffer is too small.","pos":[145,259]},{"content":"For continuous decoding of a stream, this method is often the best choice.","pos":[260,334]}]}]}],"pos":[146436,149030],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[150371,150430],"yaml":true},{"content":"The index of the first byte to decode.","nodes":[{"pos":[0,38],"content":"The index of the first byte to decode.","nodes":[{"content":"The index of the first byte to decode.","pos":[0,38]}]}],"pos":[150490,150529],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[150589,150620],"yaml":true},{"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"pos":[0,78],"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"content":"The number of characters produced by decoding the specified sequence of bytes.","pos":[0,78]}]}],"pos":[150676,150755],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[150918,150948],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>."}],"pos":[151062,151238],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[151356,151655],"yaml":true},{"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.","nodes":[{"pos":[0,129],"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.","nodes":[{"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.","pos":[0,129]}]}],"pos":[153358,153488],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \n  \n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call. [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \n  \n-   If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \n  \n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \n  \n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,481],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,481],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,191],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[192,291],"source":" To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[292,481],"source":" The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[488,949],"content":"[\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","nodes":[{"content":"[\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","pos":[0,461],"nodes":[{"content":"[<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt; gets characters from an input byte sequence.","pos":[0,133],"source":"[\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence."},{"content":"[<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt; is different than <ph id=\"ph3\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id=\"ph4\">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id=\"ph5\">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.","pos":[134,461],"source":" [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream."}]}]},{"pos":[956,1378],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[1385,1710],"content":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.","pos":[0,117],"source":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays."},{"content":"If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id=\"ph1\">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.","pos":[118,325],"source":" If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>."}]},{"pos":[1717,2180],"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","pos":[0,463],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.","pos":[0,210],"source":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.","pos":[211,463],"source":" The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream."}]}]},{"pos":[2187,2385],"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[2395,3107],"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call. [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call. [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","pos":[0,712],"nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.","pos":[0,111]},{"content":"In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.","pos":[112,245]},{"content":"(For example, part of an ISO-2022 shift sequence may end one [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call and continue at the beginning of the next [<ph id=\"ph3\">\\]</ph>, Int32, Int32, Char<ph id=\"ph4\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call.","pos":[246,487],"source":" (For example, part of an ISO-2022 shift sequence may end one [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A> call."},{"content":"[<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt; will call the fallback for those incomplete sequences, but <ph id=\"ph3\">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)","pos":[488,712],"source":" [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)"}]}]},{"pos":[3117,3373],"content":"If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","nodes":[{"content":"If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","pos":[0,256],"nodes":[{"content":"If your app handles string outputs, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.","pos":[0,103],"source":"If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended."},{"content":"Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is to be preferred.","pos":[104,256],"source":" Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred."}]}]},{"pos":[3383,3684],"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,301],"nodes":[{"content":"The byte version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.","pos":[0,203],"source":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[204,301]}]}]},{"pos":[3694,4011],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","pos":[0,317],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.","pos":[84,317],"source":" In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice."}]}]},{"pos":[4021,4355],"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","pos":[0,334],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>."},{"content":"The conversion method converts as much data as possible and throws an exception if the output buffer is too small.","pos":[145,259]},{"content":"For continuous decoding of a stream, this method is often the best choice.","pos":[260,334]}]}]}],"pos":[153499,157889],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[159263,159322],"yaml":true},{"content":"The index of the first byte to decode.","nodes":[{"pos":[0,38],"content":"The index of the first byte to decode.","nodes":[{"content":"The index of the first byte to decode.","pos":[0,38]}]}],"pos":[159386,159425],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[159489,159520],"yaml":true},{"content":"The character array to contain the resulting set of characters.","nodes":[{"pos":[0,63],"content":"The character array to contain the resulting set of characters.","nodes":[{"content":"The character array to contain the resulting set of characters.","pos":[0,63]}]}],"pos":[159581,159645],"yaml":true},{"content":"The index at which to start writing the resulting set of characters.","nodes":[{"pos":[0,68],"content":"The index at which to start writing the resulting set of characters.","nodes":[{"content":"The index at which to start writing the resulting set of characters.","pos":[0,68]}]}],"pos":[159709,159778],"yaml":true},{"content":"The actual number of characters written into <code>chars</code>.","nodes":[{"pos":[0,64],"content":"The actual number of characters written into <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The actual number of characters written into <code>chars</code>."}],"pos":[159834,159899],"yaml":true},{"content":"<code>bytes</code> is `null`.  \n  \n -or-  \n  \n <code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[160058,160141],"yaml":true},{"content":"<code>byteIndex</code> or <code>byteCount</code> or <code>charIndex</code> is less than zero.  \n  \n -or-  \n  \n <code>byteindex</code> and <code>byteCount</code> do not denote a valid range in <code>bytes</code>.  \n  \n -or-  \n  \n <code>charIndex</code> is not a valid index in <code>chars</code>.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;byteCount&lt;/code&gt;</ph> or <ph id=\"ph3\">&lt;code&gt;charIndex&lt;/code&gt;</ph> is less than zero.","source":"<code>byteIndex</code> or <code>byteCount</code> or <code>charIndex</code> is less than zero."},{"pos":[100,104],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[111,211],"content":"<ph id=\"ph1\">&lt;code&gt;byteindex&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;byteCount&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>byteindex</code> and <code>byteCount</code> do not denote a valid range in <code>bytes</code>."},{"pos":[218,222],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[229,295],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> is not a valid index in <ph id=\"ph2\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>charIndex</code> is not a valid index in <code>chars</code>."}],"pos":[160255,160561],"yaml":true},{"content":"<code>chars</code> does not have enough capacity from <code>charIndex</code> to the end of the array to accommodate the resulting characters.","nodes":[{"pos":[0,141],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> does not have enough capacity from <ph id=\"ph2\">&lt;code&gt;charIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting characters.","source":"<code>chars</code> does not have enough capacity from <code>charIndex</code> to the end of the array to accommodate the resulting characters."}],"pos":[160655,160797],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[160915,161214],"yaml":true},{"content":"When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.","nodes":[{"pos":[0,188],"content":"When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.","nodes":[{"content":"When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.","pos":[0,188]}]}],"pos":[162845,163034],"yaml":true},{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \n  \n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \n  \n-   If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \n  \n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \n  \n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,483],"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,483],"nodes":[{"content":"To calculate the exact array size that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,193],"source":"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[194,293],"source":" To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[294,483],"source":" The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[490,903],"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","nodes":[{"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","pos":[0,413],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> gets characters from an input byte sequence.","pos":[0,109],"source":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> is different than <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id=\"ph3\">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id=\"ph4\">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.","pos":[110,413],"source":" <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream."}]}]},{"pos":[910,1332],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[1339,1664],"content":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.","pos":[0,117],"source":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays."},{"content":"If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id=\"ph1\">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.","pos":[118,325],"source":" If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>."}]},{"pos":[1671,2134],"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","pos":[0,463],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.","pos":[0,210],"source":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.","pos":[211,463],"source":" The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream."}]}]},{"pos":[2141,2339],"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[2349,2989],"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","pos":[0,640],"nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.","pos":[0,111]},{"content":"In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.","pos":[112,245]},{"content":"(For example, part of an ISO-2022 shift sequence may end one <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.","pos":[246,439],"source":" (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> will call the fallback for those incomplete sequences, but <ph id=\"ph2\">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)","pos":[440,640],"source":" <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)"}]}]},{"pos":[2999,3255],"content":"If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","nodes":[{"content":"If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","pos":[0,256],"nodes":[{"content":"If your app handles string outputs, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.","pos":[0,103],"source":"If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended."},{"content":"Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is to be preferred.","pos":[104,256],"source":" Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred."}]}]},{"pos":[3265,3566],"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,301],"nodes":[{"content":"The byte version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.","pos":[0,203],"source":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[204,301]}]}]},{"pos":[3576,3893],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","pos":[0,317],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.","pos":[84,317],"source":" In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice."}]}]},{"pos":[3903,4237],"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","pos":[0,334],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>."},{"content":"The conversion method converts as much data as possible and throws an exception if the output buffer is too small.","pos":[145,259]},{"content":"For continuous decoding of a stream, this method is often the best choice.","pos":[260,334]}]}]}],"pos":[163045,167307],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first byte to decode.","nodes":[{"pos":[0,38],"content":"A pointer to the first byte to decode.","nodes":[{"content":"A pointer to the first byte to decode.","pos":[0,38]}]}],"pos":[167637,167676],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[167740,167771],"yaml":true},{"content":"A pointer to the location at which to start writing the resulting set of characters.","nodes":[{"pos":[0,84],"content":"A pointer to the location at which to start writing the resulting set of characters.","nodes":[{"content":"A pointer to the location at which to start writing the resulting set of characters.","pos":[0,84]}]}],"pos":[167831,167916],"yaml":true},{"content":"The maximum number of characters to write.","nodes":[{"pos":[0,42],"content":"The maximum number of characters to write.","nodes":[{"content":"The maximum number of characters to write.","pos":[0,42]}]}],"pos":[167980,168023],"yaml":true},{"content":"The actual number of characters written at the location indicated by the <code>chars</code> parameter.","nodes":[{"pos":[0,102],"content":"The actual number of characters written at the location indicated by the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The actual number of characters written at the location indicated by the <code>chars</code> parameter."}],"pos":[168079,168182],"yaml":true},{"content":"<code>bytes</code> is `null`.  \n  \n -or-  \n  \n <code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[168341,168424],"yaml":true},{"content":"<code>byteCount</code> or <code>charCount</code> is less than zero.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">&lt;code&gt;byteCount&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than zero.","source":"<code>byteCount</code> or <code>charCount</code> is less than zero."}],"pos":[168538,168606],"yaml":true},{"content":"<code>charCount</code> is less than the resulting number of characters.","nodes":[{"pos":[0,71],"content":"<ph id=\"ph1\">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than the resulting number of characters.","source":"<code>charCount</code> is less than the resulting number of characters."}],"pos":[168700,168772],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[168890,169189],"yaml":true},{"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.","nodes":[{"pos":[0,119],"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.","nodes":[{"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.","pos":[0,119]}]}],"pos":[170812,170932],"yaml":true},{"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \n  \n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \n  \n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \n  \n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \n  \n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,413],"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","nodes":[{"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","pos":[0,413],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> gets characters from an input byte sequence.","pos":[0,109],"source":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> is different than <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id=\"ph3\">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id=\"ph4\">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.","pos":[110,413],"source":" <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream."}]}]},{"pos":[420,842],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[849,1174],"content":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.","pos":[0,117],"source":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays."},{"content":"If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id=\"ph1\">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.","pos":[118,325],"source":" If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>."}]},{"pos":[1181,1644],"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","pos":[0,463],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.","pos":[0,210],"source":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.","pos":[211,463],"source":" The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream."}]}]},{"pos":[1651,1849],"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1859,2499],"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","pos":[0,640],"nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.","pos":[0,111]},{"content":"In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.","pos":[112,245]},{"content":"(For example, part of an ISO-2022 shift sequence may end one <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.","pos":[246,439],"source":" (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> will call the fallback for those incomplete sequences, but <ph id=\"ph2\">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)","pos":[440,640],"source":" <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)"}]}]},{"pos":[2509,2775],"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","nodes":[{"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","pos":[0,266],"nodes":[{"content":"If your app handles string outputs, it is recommended to use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.","pos":[0,113],"source":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method."},{"content":"Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is to be preferred.","pos":[114,266],"source":" Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred."}]}]},{"pos":[2785,3086],"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,301],"nodes":[{"content":"The byte version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.","pos":[0,203],"source":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[204,301]}]}]},{"pos":[3096,3413],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","pos":[0,317],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.","pos":[84,317],"source":" In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice."}]}]},{"pos":[3423,3757],"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","pos":[0,334],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>."},{"content":"The conversion method converts as much data as possible and throws an exception if the output buffer is too small.","pos":[145,259]},{"content":"For continuous decoding of a stream, this method is often the best choice.","pos":[260,334]}]}]}],"pos":[170943,174723],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[175501,175560],"yaml":true},{"content":"The index of the first byte to decode.","nodes":[{"pos":[0,38],"content":"The index of the first byte to decode.","nodes":[{"content":"The index of the first byte to decode.","pos":[0,38]}]}],"pos":[175620,175659],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[175719,175750],"yaml":true},{"content":"A character array containing the results of decoding the specified sequence of bytes.","nodes":[{"pos":[0,85],"content":"A character array containing the results of decoding the specified sequence of bytes.","nodes":[{"content":"A character array containing the results of decoding the specified sequence of bytes.","pos":[0,85]}]}],"pos":[175807,175893],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[176052,176082],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>."}],"pos":[176196,176372],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[176490,176789],"yaml":true},{"content":"When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.","nodes":[{"pos":[0,111],"content":"When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.","nodes":[{"content":"When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.","pos":[0,111]}]}],"pos":[178246,178358],"yaml":true},{"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \n  \n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \n  \n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \n  \n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \n  \n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \n  \n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \n  \n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \n  \n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"pos":[0,413],"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","nodes":[{"content":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.","pos":[0,413],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> gets characters from an input byte sequence.","pos":[0,109],"source":"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> is different than <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id=\"ph3\">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id=\"ph4\">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.","pos":[110,413],"source":" <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream."}]}]},{"pos":[420,842],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[849,1174],"content":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.","pos":[0,117],"source":"**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays."},{"content":"If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id=\"ph1\">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.","pos":[118,325],"source":" If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>."}]},{"pos":[1181,1644],"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","nodes":[{"content":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.","pos":[0,463],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.","pos":[0,210],"source":"The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id=\"ph2\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.","pos":[211,463],"source":" The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream."}]}]},{"pos":[1651,1849],"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","nodes":[{"content":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:","pos":[0,198],"nodes":[{"content":"Several versions of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.","pos":[0,122],"source":"Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported."},{"content":"The following are some programming considerations for use of these methods:","pos":[123,198]}]}]},{"pos":[1859,2499],"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)","pos":[0,640],"nodes":[{"content":"Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.","pos":[0,111]},{"content":"In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.","pos":[112,245]},{"content":"(For example, part of an ISO-2022 shift sequence may end one <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.","pos":[246,439],"source":" (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call."},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> will call the fallback for those incomplete sequences, but <ph id=\"ph2\">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)","pos":[440,640],"source":" <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)"}]}]},{"pos":[2509,2775],"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","nodes":[{"content":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.","pos":[0,266],"nodes":[{"content":"If your app handles string outputs, it is recommended to use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.","pos":[0,113],"source":"If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method."},{"content":"Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is to be preferred.","pos":[114,266],"source":" Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred."}]}]},{"pos":[2785,3086],"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","nodes":[{"content":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[0,301],"nodes":[{"content":"The byte version of <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.","pos":[0,203],"source":"The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers."},{"content":"Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.","pos":[204,301]}]}]},{"pos":[3096,3413],"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.","pos":[0,317],"nodes":[{"content":"If your app must convert a large amount of data, it should reuse the output buffer.","pos":[0,83]},{"content":"In this case, the [<ph id=\"ph1\">\\]</ph>, Int32, Int32, Char<ph id=\"ph2\">\\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.","pos":[84,317],"source":" In this case, the [\\], Int32, Int32, Char\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice."}]}]},{"pos":[3423,3757],"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","nodes":[{"content":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.","pos":[0,334],"nodes":[{"content":"Consider using the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.","pos":[0,144],"source":"Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>."},{"content":"The conversion method converts as much data as possible and throws an exception if the output buffer is too small.","pos":[145,259]},{"content":"For continuous decoding of a stream, this method is often the best choice.","pos":[260,334]}]}]}],"pos":[178369,182149],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[182876,182935],"yaml":true},{"content":"A character array containing the results of decoding the specified sequence of bytes.","nodes":[{"pos":[0,85],"content":"A character array containing the results of decoding the specified sequence of bytes.","nodes":[{"content":"A character array containing the results of decoding the specified sequence of bytes.","pos":[0,85]}]}],"pos":[182992,183078],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[183237,183267],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[183385,183684],"yaml":true},{"content":"When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.","nodes":[{"pos":[0,127],"content":"When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.","nodes":[{"content":"When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.","pos":[0,127]}]}],"pos":[185090,185218],"yaml":true},{"content":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class. However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","nodes":[{"pos":[0,768],"content":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class. However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","nodes":[{"content":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class. However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[0,768],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method of this class.","pos":[0,237],"source":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class."},{"content":"However, a <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it correctly decodes byte sequences that span blocks.","pos":[238,374],"source":" However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.","pos":[375,521],"source":" The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation."},{"content":"Therefore, <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[522,768],"source":" Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream."}]}]}],"pos":[185229,185998],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Text.Decoder\"></xref> that converts an encoded sequence of bytes into a sequence of characters.","nodes":[{"pos":[0,116],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Text.Decoder\"&gt;&lt;/xref&gt;</ph> that converts an encoded sequence of bytes into a sequence of characters.","source":"A <xref href=\"System.Text.Decoder\"></xref> that converts an encoded sequence of bytes into a sequence of characters."}],"pos":[186153,186270],"yaml":true},{"content":"When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.","nodes":[{"pos":[0,136],"content":"When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.","nodes":[{"content":"When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.","pos":[0,136]}]}],"pos":[187738,187875],"yaml":true},{"content":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class. However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","nodes":[{"pos":[0,917],"content":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class. However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","nodes":[{"content":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class. However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[0,917],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method of this class.","pos":[0,237],"source":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class."},{"content":"However, a <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it correctly encodes character sequences that span blocks.","pos":[238,379],"source":" However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.","pos":[380,536],"source":" The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation."},{"content":"For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.","pos":[537,670]},{"content":"Therefore, <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[671,917],"source":" Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream."}]}]}],"pos":[187886,188804],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Text.Encoder\"></xref> that converts a sequence of Unicode characters into an encoded sequence of bytes.","nodes":[{"pos":[0,124],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoder\"&gt;&lt;/xref&gt;</ph> that converts a sequence of Unicode characters into an encoded sequence of bytes.","source":"A <xref href=\"System.Text.Encoder\"></xref> that converts a sequence of Unicode characters into an encoded sequence of bytes."}],"pos":[188959,189084],"yaml":true},{"content":"Returns the encoding associated with the specified code page identifier.","nodes":[{"pos":[0,72],"content":"Returns the encoding associated with the specified code page identifier.","nodes":[{"content":"Returns the encoding associated with the specified code page identifier.","pos":[0,72]}]}],"pos":[190615,190688],"yaml":true},{"content":"The fallback handler depends on the encoding type of `codepage`. If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.  \n  \n The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings. For a list of code pages, see the <xref:System.Text.Encoding> class topic. Alternatively, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all encodings.  \n  \n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \n  \n To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value 0 for the `codepage` argument or, on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A> property. To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function. To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop.  \n  \n> [!NOTE]\n>  Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.  \n  \n> [!NOTE]\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \n  \n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"pos":[0,511],"content":"The fallback handler depends on the encoding type of `codepage`. If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.","nodes":[{"content":"The fallback handler depends on the encoding type of <ph id=\"ph1\">`codepage`</ph>.","pos":[0,64],"source":"The fallback handler depends on the encoding type of `codepage`."},{"content":"If <ph id=\"ph1\">`codepage`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.","pos":[65,176],"source":" If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used."},{"content":"Otherwise, a replacement fallback handler is used.","pos":[177,227]},{"content":"These fallback handlers may not be appropriate for your app.","pos":[228,288]},{"content":"To specify the fallback handler used by the encoding specified by <ph id=\"ph1\">`codepage`</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.","pos":[289,511],"source":" To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload."}]},{"pos":[518,959],"content":"The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings. For a list of code pages, see the <xref:System.Text.Encoding> class topic. Alternatively, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all encodings.","nodes":[{"content":"The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings. For a list of code pages, see the <xref:System.Text.Encoding> class topic. Alternatively, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all encodings.","pos":[0,441],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.","pos":[0,115],"source":"The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages."},{"content":"However, the .NET Framework natively supports some encodings.","pos":[116,177]},{"content":"For a list of code pages, see the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class topic.","pos":[178,252],"source":" For a list of code pages, see the <xref:System.Text.Encoding> class topic."},{"content":"Alternatively, you can call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get an array of <ph id=\"ph2\">&lt;xref:System.Text.EncodingInfo&gt;</ph> objects that contains information about all encodings.","pos":[253,441],"source":" Alternatively, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all encodings."}]}]},{"pos":[966,1269],"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.","nodes":[{"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id=\"ph2\">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.","pos":[0,303],"source":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object."}]},{"pos":[1276,1952],"content":"To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value 0 for the `codepage` argument or, on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A> property. To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function. To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop.","nodes":[{"content":"To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value 0 for the <ph id=\"ph1\">`codepage`</ph> argument or, on the full .NET Framework on the Windows desktop, retrieve the value of the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property.","pos":[0,310],"source":"To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value 0 for the `codepage` argument or, on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A> property."},{"content":"To determine the default code pages used on the system, use the Windows <bpt id=\"p1\">[</bpt>GetSystemDefaultLangID<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx)</ept> function.","pos":[311,482],"source":" To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function."},{"content":"To determine the current ANSI code page, call the Windows <bpt id=\"p1\">[</bpt>GetACP<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the full .NET Framework on the Windows desktop.","pos":[483,676],"source":" To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop."}]},{"pos":[1960,2206],"content":"[!NOTE]\n Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.","leadings":["","> "],"nodes":[{"content":" Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.","pos":[8,244],"nodes":[{"content":"Some unsupported code pages cause the exception <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause <ph id=\"ph2\">&lt;xref:System.NotSupportedException&gt;</ph>.","pos":[1,152],"source":" Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>."},{"content":"Therefore, your code must catch all exceptions indicated in the Exceptions section.","pos":[153,236]}]}]},{"pos":[2214,2617],"content":"[!NOTE]\n The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","leadings":["","> "],"nodes":[{"content":" The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[8,401],"nodes":[{"content":"The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.","pos":[1,130]},{"content":"For this reason, encoding and decoding data using the default code page returned by <ph id=\"ph1\">`Encoding.GetEncoding(0)`</ph> is not recommended.","pos":[131,260],"source":" For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended."},{"content":"For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[261,393]}]}]},{"pos":[2624,2927],"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","pos":[0,303],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.","pos":[0,91],"source":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings."},{"content":"You should use the constructors of derived classes to get an instance with different settings.","pos":[92,186]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.","pos":[187,303],"source":" For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection."}]}]}],"pos":[190699,193643],"yaml":true,"extradata":"MT"},{"content":"The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.  \n  \n -or-  \n  \n 0 (zero), to use the default encoding.","nodes":[{"pos":[0,190],"content":"The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.","nodes":[{"content":"The code page identifier of the preferred encoding.","pos":[0,51]},{"content":"Possible values are listed in the Code Page column of the table that appears in the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> class topic.","pos":[52,190],"source":" Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic."}]},{"pos":[197,201],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[208,246],"content":"0 (zero), to use the default encoding.","nodes":[{"content":"0 (zero), to use the default encoding.","pos":[0,38]}]}],"pos":[194380,194635],"yaml":true},{"content":"The encoding that is associated with the specified code page.","nodes":[{"pos":[0,61],"content":"The encoding that is associated with the specified code page.","nodes":[{"content":"The encoding that is associated with the specified code page.","pos":[0,61]}]}],"pos":[194699,194761],"yaml":true},{"content":"<code>codepage</code> is less than zero or greater than 65535.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;codepage&lt;/code&gt;</ph> is less than zero or greater than 65535.","source":"<code>codepage</code> is less than zero or greater than 65535."}],"pos":[194935,194998],"yaml":true},{"content":"<code>codepage</code> is not supported by the underlying platform.","nodes":[{"pos":[0,66],"content":"<ph id=\"ph1\">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.","source":"<code>codepage</code> is not supported by the underlying platform."}],"pos":[195092,195159],"yaml":true},{"content":"<code>codepage</code> is not supported by the underlying platform.","nodes":[{"pos":[0,66],"content":"<ph id=\"ph1\">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.","source":"<code>codepage</code> is not supported by the underlying platform."}],"pos":[195261,195328],"yaml":true},{"content":"Returns the encoding associated with the specified code page name.","nodes":[{"pos":[0,66],"content":"Returns the encoding associated with the specified code page name.","nodes":[{"content":"Returns the encoding associated with the specified code page name.","pos":[0,66]}]}],"pos":[196700,196767],"yaml":true},{"content":"The fallback handler depends on the encoding type of `name`. If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.  \n  \n The `GetEncoding` method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.  \n  \n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.String%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \n  \n> [!NOTE]\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \n  \n For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.  \n  \n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"pos":[0,500],"content":"The fallback handler depends on the encoding type of `name`. If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.","nodes":[{"content":"The fallback handler depends on the encoding type of <ph id=\"ph1\">`name`</ph>.","pos":[0,60],"source":"The fallback handler depends on the encoding type of `name`."},{"content":"If <ph id=\"ph1\">`name`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.","pos":[61,168],"source":" If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used."},{"content":"Otherwise, a replacement fallback handler is used.","pos":[169,219]},{"content":"These fallback handlers may not be appropriate for your app.","pos":[220,280]},{"content":"To specify the fallback handler used by the encoding specified by <ph id=\"ph1\">`name`</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.","pos":[281,500],"source":" To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload."}]},{"pos":[507,655],"content":"The `GetEncoding` method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.","nodes":[{"content":"The <ph id=\"ph1\">`GetEncoding`</ph> method relies on the underlying platform to support most code pages.","pos":[0,86],"source":"The `GetEncoding` method relies on the underlying platform to support most code pages."},{"content":"However, the .NET Framework natively supports some encodings.","pos":[87,148]}]},{"pos":[662,966],"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.String%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.","nodes":[{"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id=\"ph2\">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.","pos":[0,304],"source":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.String%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object."}]},{"pos":[974,1247],"content":"[!NOTE]\n The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","leadings":["","> "],"nodes":[{"content":" The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[8,271],"nodes":[{"content":"The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.","pos":[1,130]},{"content":"For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[131,263]}]}]},{"pos":[1254,1478],"content":"For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.","nodes":[{"content":"For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.","pos":[0,224],"nodes":[{"content":"For a list of code pages, see the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class topic.","pos":[0,74],"source":"For a list of code pages, see the <xref:System.Text.Encoding> class topic."},{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method in the full .NET Framework on the Windows desktop to get a list of all encodings.","pos":[75,224],"source":" You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings."}]}]},{"pos":[1485,1788],"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","pos":[0,303],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.","pos":[0,91],"source":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings."},{"content":"You should use the constructors of derived classes to get an instance with different settings.","pos":[92,186]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.","pos":[187,303],"source":" For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection."}]}]}],"pos":[196778,198580],"yaml":true,"extradata":"MT"},{"content":"The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.","nodes":[{"pos":[0,274],"content":"The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.","nodes":[{"content":"The code page name of the preferred encoding.","pos":[0,45]},{"content":"Any value returned by the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.WebName\"&gt;&lt;/xref&gt;</ph> property is valid.","pos":[46,140],"source":" Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid."},{"content":"Possible values are listed in the Name column of the table that appears in the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> class topic.","pos":[141,274],"source":" Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic."}]}],"pos":[199313,199588],"yaml":true},{"content":"The encoding  associated with the specified code page.","nodes":[{"pos":[0,54],"content":"The encoding  associated with the specified code page.","nodes":[{"content":"The encoding  associated with the specified code page.","pos":[0,54]}]}],"pos":[199652,199707],"yaml":true},{"content":"<code>name</code> is not a valid code page name.  \n  \n -or-  \n  \n The code page indicated by <code>name</code> is not supported by the underlying platform.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is not a valid code page name.","source":"<code>name</code> is not a valid code page name."},{"pos":[55,59],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[66,155],"content":"The code page indicated by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not supported by the underlying platform.","source":"The code page indicated by <code>name</code> is not supported by the underlying platform."}],"pos":[199861,200023],"yaml":true},{"content":"Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","nodes":[{"pos":[0,189],"content":"Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","nodes":[{"content":"Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","pos":[0,189],"nodes":[{"content":"Returns the encoding associated with the specified code page identifier.","pos":[0,72]},{"content":"Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","pos":[73,189]}]}]}],"pos":[201762,201952],"yaml":true},{"content":"> [!NOTE]\n>  Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.  \n  \n The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.  \n  \n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \n  \n> [!NOTE]\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \n  \n For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.  \n  \n To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=fullName> property. To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function. To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop.  \n  \n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"pos":[2,248],"content":"[!NOTE]\n Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.","leadings":["","> "],"nodes":[{"content":" Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.","pos":[8,244],"nodes":[{"content":"Some unsupported code pages cause the exception <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause <ph id=\"ph2\">&lt;xref:System.NotSupportedException&gt;</ph>.","pos":[1,152],"source":" Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>."},{"content":"Therefore, your code must catch all exceptions indicated in the Exceptions section.","pos":[153,236]}]}]},{"pos":[255,432],"content":"The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.","nodes":[{"content":"The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.","pos":[0,177],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.","pos":[0,115],"source":"The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages."},{"content":"However, the .NET Framework natively supports some encodings.","pos":[116,177]}]}]},{"pos":[439,802],"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.","nodes":[{"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id=\"ph2\">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.","pos":[0,363],"source":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object."}]},{"pos":[810,1213],"content":"[!NOTE]\n The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","leadings":["","> "],"nodes":[{"content":" The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[8,401],"nodes":[{"content":"The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.","pos":[1,130]},{"content":"For this reason, encoding and decoding data using the default code page returned by <ph id=\"ph1\">`Encoding.GetEncoding(0)`</ph> is not recommended.","pos":[131,260],"source":" For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended."},{"content":"For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[261,393]}]}]},{"pos":[1220,1444],"content":"For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.","nodes":[{"content":"For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.","pos":[0,224],"nodes":[{"content":"For a list of code pages, see the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class topic.","pos":[0,74],"source":"For a list of code pages, see the <xref:System.Text.Encoding> class topic."},{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method in the full .NET Framework on the Windows desktop to get a list of all encodings.","pos":[75,224],"source":" You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings."}]}]},{"pos":[1451,2179],"content":"To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=fullName> property. To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function. To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop.","nodes":[{"content":"To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value of 0 for the <ph id=\"ph1\">`codepage`</ph> argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=fullName&gt;</ph> property.","pos":[0,362],"source":"To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=fullName> property."},{"content":"To determine the default code pages used on the system, use the Windows <bpt id=\"p1\">[</bpt>GetSystemDefaultLangID<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx)</ept> function.","pos":[363,534],"source":" To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function."},{"content":"To determine the current ANSI code page, call the Windows <bpt id=\"p1\">[</bpt>GetACP<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the full .NET Framework on the Windows desktop.","pos":[535,728],"source":" To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop."}]},{"pos":[2186,2489],"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","pos":[0,303],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.","pos":[0,91],"source":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings."},{"content":"You should use the constructors of derived classes to get an instance with different settings.","pos":[92,186]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.","pos":[187,303],"source":" For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection."}]}]}],"pos":[201963,204469],"yaml":true,"extradata":"MT"},{"content":"The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.  \n  \n -or-  \n  \n 0 (zero), to use the default encoding.","nodes":[{"pos":[0,190],"content":"The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.","nodes":[{"content":"The code page identifier of the preferred encoding.","pos":[0,51]},{"content":"Possible values are listed in the Code Page column of the table that appears in the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> class topic.","pos":[52,190],"source":" Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic."}]},{"pos":[197,201],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[208,246],"content":"0 (zero), to use the default encoding.","nodes":[{"content":"0 (zero), to use the default encoding.","pos":[0,38]}]}],"pos":[205319,205574],"yaml":true},{"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","nodes":[{"pos":[0,113],"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","nodes":[{"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","pos":[0,113]}]}],"pos":[205659,205773],"yaml":true},{"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","nodes":[{"pos":[0,117],"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","nodes":[{"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","pos":[0,117]}]}],"pos":[205858,205976],"yaml":true},{"content":"The encoding that is associated with the specified code page.","nodes":[{"pos":[0,61],"content":"The encoding that is associated with the specified code page.","nodes":[{"content":"The encoding that is associated with the specified code page.","pos":[0,61]}]}],"pos":[206040,206102],"yaml":true},{"content":"<code>codepage</code> is less than zero or greater than 65535.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;codepage&lt;/code&gt;</ph> is less than zero or greater than 65535.","source":"<code>codepage</code> is less than zero or greater than 65535."}],"pos":[206276,206339],"yaml":true},{"content":"<code>codepage</code> is not supported by the underlying platform.","nodes":[{"pos":[0,66],"content":"<ph id=\"ph1\">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.","source":"<code>codepage</code> is not supported by the underlying platform."}],"pos":[206433,206500],"yaml":true},{"content":"<code>codepage</code> is not supported by the underlying platform.","nodes":[{"pos":[0,66],"content":"<ph id=\"ph1\">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.","source":"<code>codepage</code> is not supported by the underlying platform."}],"pos":[206602,206669],"yaml":true},{"content":"Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","nodes":[{"pos":[0,183],"content":"Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","nodes":[{"content":"Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","pos":[0,183],"nodes":[{"content":"Returns the encoding associated with the specified code page name.","pos":[0,66]},{"content":"Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.","pos":[67,183]}]}]}],"pos":[208294,208478],"yaml":true},{"content":"The `GetEncoding` method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.  \n  \n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \n  \n> [!NOTE]\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \n  \n For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method on the full .NET Framework on the Windows desktop to get a list of all encodings.  \n  \n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"pos":[0,148],"content":"The `GetEncoding` method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.","nodes":[{"content":"The <ph id=\"ph1\">`GetEncoding`</ph> method relies on the underlying platform to support most code pages.","pos":[0,86],"source":"The `GetEncoding` method relies on the underlying platform to support most code pages."},{"content":"However, the .NET Framework natively supports some encodings.","pos":[87,148]}]},{"pos":[155,458],"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.","nodes":[{"content":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id=\"ph2\">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.","pos":[0,303],"source":"In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object."}]},{"pos":[466,739],"content":"[!NOTE]\n The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","leadings":["","> "],"nodes":[{"content":" The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[8,271],"nodes":[{"content":"The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.","pos":[1,130]},{"content":"For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.","pos":[131,263]}]}]},{"pos":[746,970],"content":"For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method on the full .NET Framework on the Windows desktop to get a list of all encodings.","nodes":[{"content":"For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method on the full .NET Framework on the Windows desktop to get a list of all encodings.","pos":[0,224],"nodes":[{"content":"For a list of code pages, see the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class topic.","pos":[0,74],"source":"For a list of code pages, see the <xref:System.Text.Encoding> class topic."},{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method on the full .NET Framework on the Windows desktop to get a list of all encodings.","pos":[75,224],"source":" You can call the <xref:System.Text.Encoding.GetEncodings%2A> method on the full .NET Framework on the Windows desktop to get a list of all encodings."}]}]},{"pos":[977,1280],"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","nodes":[{"content":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.","pos":[0,303],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.","pos":[0,91],"source":"<xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings."},{"content":"You should use the constructors of derived classes to get an instance with different settings.","pos":[92,186]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.","pos":[187,303],"source":" For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection."}]}]}],"pos":[208489,209781],"yaml":true,"extradata":"MT"},{"content":"The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.","nodes":[{"pos":[0,274],"content":"The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.","nodes":[{"content":"The code page name of the preferred encoding.","pos":[0,45]},{"content":"Any value returned by the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.WebName\"&gt;&lt;/xref&gt;</ph> property is valid.","pos":[46,140],"source":" Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid."},{"content":"Possible values are listed in the Name column of the table that appears in the <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> class topic.","pos":[141,274],"source":" Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic."}]}],"pos":[210627,210902],"yaml":true},{"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","nodes":[{"pos":[0,113],"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","nodes":[{"content":"An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.","pos":[0,113]}]}],"pos":[210987,211101],"yaml":true},{"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","nodes":[{"pos":[0,117],"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","nodes":[{"content":"An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.","pos":[0,117]}]}],"pos":[211186,211304],"yaml":true},{"content":"The encoding that is associated with the specified code page.","nodes":[{"pos":[0,61],"content":"The encoding that is associated with the specified code page.","nodes":[{"content":"The encoding that is associated with the specified code page.","pos":[0,61]}]}],"pos":[211368,211430],"yaml":true},{"content":"<code>name</code> is not a valid code page name.  \n  \n -or-  \n  \n The code page indicated by <code>name</code> is not supported by the underlying platform.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is not a valid code page name.","source":"<code>name</code> is not a valid code page name."},{"pos":[55,59],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[66,155],"content":"The code page indicated by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not supported by the underlying platform.","source":"The code page indicated by <code>name</code> is not supported by the underlying platform."}],"pos":[211584,211746],"yaml":true},{"content":"Returns an array that contains all encodings.","nodes":[{"pos":[0,45],"content":"Returns an array that contains all encodings.","nodes":[{"content":"Returns an array that contains all encodings.","pos":[0,45]}]}],"pos":[213019,213065],"yaml":true},{"content":"This method returns a list of supported encodings, uniquely distinguished by code page. For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.  \n  \n> [!NOTE]\n>  The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.  \n  \n Encodings 50220 and 50222 are both associated with the name \"iso-2022-jp\", but they are not identical. Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters. The display name for encoding 50222 is \"Japanese (JIS-Allow 1 byte Kana - SO/SI)\" to distinguish it from encoding 50220, which has the display name \"Japanese (JIS)\".  \n  \n If you request the encoding name \"iso-2022-jp\", the .NET Framework returns encoding 50220. However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.  \n  \n To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.  \n  \n <xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box. However, many non-Unicode encodings are either incomplete and translate many characters to \"?\", or have subtly different behavior on different platforms. Consider using UTF-8 or UTF-16 as the default.","nodes":[{"pos":[0,184],"content":"This method returns a list of supported encodings, uniquely distinguished by code page. For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.","nodes":[{"content":"This method returns a list of supported encodings, uniquely distinguished by code page. For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.","pos":[0,184],"nodes":[{"content":"This method returns a list of supported encodings, uniquely distinguished by code page.","pos":[0,87]},{"content":"For a table that lists the supported encodings, see the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class topic.","pos":[88,184],"source":" For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic."}]}]},{"pos":[192,510],"content":"[!NOTE]\n The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.","leadings":["","> "],"nodes":[{"content":"The list of supported encodings returned by the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method does not include any additional encodings made available by any <ph id=\"ph2\">&lt;xref:System.Text.EncodingProvider&gt;</ph> implementations that were registered by calls to the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method.","pos":[9,316],"source":" The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method."}]},{"pos":[517,975],"content":"Encodings 50220 and 50222 are both associated with the name \"iso-2022-jp\", but they are not identical. Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters. The display name for encoding 50222 is \"Japanese (JIS-Allow 1 byte Kana - SO/SI)\" to distinguish it from encoding 50220, which has the display name \"Japanese (JIS)\".","nodes":[{"content":"Encodings 50220 and 50222 are both associated with the name \"iso-2022-jp\", but they are not identical. Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters. The display name for encoding 50222 is \"Japanese (JIS-Allow 1 byte Kana - SO/SI)\" to distinguish it from encoding 50220, which has the display name \"Japanese (JIS)\".","pos":[0,458],"nodes":[{"content":"Encodings 50220 and 50222 are both associated with the name \"iso-2022-jp\", but they are not identical.","pos":[0,102]},{"content":"Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.","pos":[103,292]},{"content":"The display name for encoding 50222 is \"Japanese (JIS-Allow 1 byte Kana - SO/SI)\" to distinguish it from encoding 50220, which has the display name \"Japanese (JIS)\".","pos":[293,458]}]}]},{"pos":[982,1201],"content":"If you request the encoding name \"iso-2022-jp\", the .NET Framework returns encoding 50220. However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.","nodes":[{"content":"If you request the encoding name \"iso-2022-jp\", the .NET Framework returns encoding 50220. However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.","pos":[0,219],"nodes":[{"content":"If you request the encoding name \"iso-2022-jp\", the .NET Framework returns encoding 50220.","pos":[0,90]},{"content":"However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.","pos":[91,219]}]}]},{"pos":[1208,1305],"content":"To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.","nodes":[{"content":"To get a specific encoding, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method.","pos":[0,97],"source":"To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method."}]},{"pos":[1312,1653],"content":"<xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box. However, many non-Unicode encodings are either incomplete and translate many characters to \"?\", or have subtly different behavior on different platforms. Consider using UTF-8 or UTF-16 as the default.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> is sometimes used to present the user with a list of encodings in a File <bpt id=\"p1\">**</bpt>Save as<ept id=\"p1\">**</ept> dialog box.","pos":[0,140],"source":"<xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box."},{"content":"However, many non-Unicode encodings are either incomplete and translate many characters to \"?\", or have subtly different behavior on different platforms.","pos":[141,294]},{"content":"Consider using UTF-8 or UTF-16 as the default.","pos":[295,341]}]}],"pos":[213076,214753],"yaml":true,"extradata":"MT"},{"content":"An array that contains all encodings.","nodes":[{"pos":[0,37],"content":"An array that contains all encodings.","nodes":[{"content":"An array that contains all encodings.","pos":[0,37]}]}],"pos":[215459,215497],"yaml":true},{"content":"Returns the hash code for the current instance.","nodes":[{"pos":[0,47],"content":"Returns the hash code for the current instance.","nodes":[{"content":"Returns the hash code for the current instance.","pos":[0,47]}]}],"pos":[216669,216717],"yaml":true},{"content":"The hash code for the current instance.","nodes":[{"pos":[0,39],"content":"The hash code for the current instance.","nodes":[{"content":"The hash code for the current instance.","pos":[0,39]}]}],"pos":[216851,216891],"yaml":true},{"content":"When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"pos":[0,131],"content":"When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"content":"When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.","pos":[0,131]}]}],"pos":[218447,218579],"yaml":true},{"content":"The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters. Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.  \n  \n To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character. For example, this can happen for ISO-2022-JP. For more information, see the blog entry \"[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)\" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  \n  \n In most cases, this method retrieves reasonable values for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.  \n  \n When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.  \n  \n Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation. Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII. You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.  \n  \n> [!NOTE]\n>  `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.","nodes":[{"pos":[0,419],"content":"The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters. Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.","nodes":[{"content":"The <ph id=\"ph1\">`charCount`</ph> parameter actually specifies the number of <ph id=\"ph2\">&lt;xref:System.Char&gt;</ph> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters.","pos":[0,217],"source":"The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters."},{"content":"Consequently, most Unicode characters can be represented by one <ph id=\"ph1\">&lt;xref:System.Char&gt;</ph> object, but a Unicode character represented by a surrogate pair, for example, requires two <ph id=\"ph2\">&lt;xref:System.Char&gt;</ph> objects.","pos":[218,419],"source":" Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects."}]},{"pos":[426,902],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,476],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,186],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[187,286],"source":" To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[287,476],"source":" The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[909,1582],"content":"<xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character. For example, this can happen for ISO-2022-JP. For more information, see the blog entry \"[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)\" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.","pos":[0,165],"source":"<xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>."},{"content":"If a fallback is chosen with a potentially large string, <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.","pos":[166,399],"source":" If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character."},{"content":"For example, this can happen for ISO-2022-JP.","pos":[400,445]},{"content":"For more information, see the blog entry \"<bpt id=\"p1\">[</bpt>What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=153702)</ept>\"","pos":[446,608],"source":" For more information, see the blog entry \"[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)\""},{"content":"(http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).","pos":[609,673]}]},{"pos":[1589,1990],"content":"In most cases, this method retrieves reasonable values for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.","nodes":[{"content":"In most cases, this method retrieves reasonable values for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.","pos":[0,401],"nodes":[{"content":"In most cases, this method retrieves reasonable values for small strings.","pos":[0,73]},{"content":"For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.","pos":[74,231]},{"content":"You might also want to consider a different approach using <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph>.","pos":[232,401],"source":" You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>."}]}]},{"pos":[1997,2250],"content":"When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.","nodes":[{"content":"When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.","pos":[0,253],"nodes":[{"content":"When using <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.","pos":[0,143],"source":"When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer."},{"content":"If the output buffer is constrained in size, you might use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.Convert%2A&gt;</ph> method.","pos":[144,253],"source":" If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method."}]}]},{"pos":[2257,2613],"content":"Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation. Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII. You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.","nodes":[{"content":"Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation. Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII. You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.","pos":[0,356],"nodes":[{"content":"Note that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> considers potential leftover surrogates from a previous decoder operation.","pos":[0,131],"source":"Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation."},{"content":"Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.","pos":[132,245]},{"content":"You should use the <ph id=\"ph1\">&lt;xref:System.Text.ASCIIEncoding.IsSingleByte%2A&gt;</ph> property if this information is necessary.","pos":[246,356],"source":" You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary."}]}]},{"pos":[2621,2714],"content":"[!NOTE]\n `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id=\"ph2\">`N* GetMaxByteCount(1)`</ph>.","pos":[8,91],"source":" `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`."}]}],"pos":[218590,221322],"yaml":true,"extradata":"MT"},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[222160,222196],"yaml":true},{"content":"The maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"pos":[0,84],"content":"The maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"content":"The maximum number of bytes produced by encoding the specified number of characters.","pos":[0,84]}]}],"pos":[222252,222337],"yaml":true},{"content":"<code>charCount</code> is less than zero.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than zero.","source":"<code>charCount</code> is less than zero."}],"pos":[222515,222557],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[222675,222974],"yaml":true},{"content":"When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"pos":[0,131],"content":"When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"content":"When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.","pos":[0,131]}]}],"pos":[224467,224599],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.  \n  \n In most cases, this method retrieves reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName>.  \n  \n <xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>. If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.  \n  \n When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method.  \n  \n Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation. For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.  \n  \n> [!NOTE]\n>  `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.","nodes":[{"pos":[0,481],"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,481],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,191],"source":"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, use the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[192,291],"source":" To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[292,481],"source":" The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[488,781],"content":"<xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.","nodes":[{"content":"<xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.","pos":[0,293],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id=\"ph2\">&lt;xref:System.Text.DecoderFallback&gt;</ph>.","pos":[0,165],"source":"<xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>."},{"content":"If a fallback is chosen with a potentially large string, <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves large values.","pos":[166,293],"source":" If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values."}]}]},{"pos":[788,1190],"content":"In most cases, this method retrieves reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName>.","nodes":[{"content":"In most cases, this method retrieves reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName>.","pos":[0,402],"nodes":[{"content":"In most cases, this method retrieves reasonable numbers for small strings.","pos":[0,74]},{"content":"For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.","pos":[75,232]},{"content":"You might also want to consider a different approach using <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph>.","pos":[233,402],"source":" You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName>."}]}]},{"pos":[1197,1451],"content":"<xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>. If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.","nodes":[{"content":"<xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>. If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.","pos":[0,254],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.","pos":[0,106],"source":"<xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>."},{"content":"If you needs a similar function to use with <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>, you should use <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>.","pos":[107,254],"source":" If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>."}]}]},{"pos":[1458,1735],"content":"When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method.","nodes":[{"content":"When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method.","pos":[0,277],"nodes":[{"content":"When using <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.","pos":[0,143],"source":"When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer."},{"content":"If the output buffer is constrained in size, you might use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method.","pos":[144,277],"source":" If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method."}]}]},{"pos":[1742,1979],"content":"Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation. For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.","nodes":[{"content":"Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation. For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.","pos":[0,237],"nodes":[{"content":"Note that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> considers the worst case for leftover bytes from a previous encoder operation.","pos":[0,135],"source":"Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation."},{"content":"For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.","pos":[136,237]}]}]},{"pos":[1987,2080],"content":"[!NOTE]\n `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id=\"ph2\">`N* GetMaxCharCount(1)`</ph>.","pos":[8,91],"source":" `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`."}]}],"pos":[224610,226706],"yaml":true,"extradata":"MT"},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[227442,227473],"yaml":true},{"content":"The maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"pos":[0,84],"content":"The maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"content":"The maximum number of characters produced by decoding the specified number of bytes.","pos":[0,84]}]}],"pos":[227529,227614],"yaml":true},{"content":"<code>byteCount</code> is less than zero.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.","source":"<code>byteCount</code> is less than zero."}],"pos":[227792,227834],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[227952,228251],"yaml":true},{"content":"When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.","nodes":[{"pos":[0,97],"content":"When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.","nodes":[{"content":"When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.","pos":[0,97]}]}],"pos":[229663,229761],"yaml":true},{"content":"Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.  \n  \n The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):  \n  \n-   UTF-8: EF BB BF  \n  \n-   UTF-16 big endian byte order: FE FF  \n  \n-   UTF-16 little endian byte order: FF FE  \n  \n-   UTF-32 big endian byte order: 00 00 FE FF  \n  \n-   UTF-32 little endian byte order: FF FE 00 00  \n  \n You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data. Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.  \n  \n For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.  \n  \n There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.  \n  \n For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).  \n  \n> [!CAUTION]\n>  To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. However, most encodings do not provide a preamble. To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.","nodes":[{"pos":[0,339],"content":"Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.","nodes":[{"content":"Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.","pos":[0,339],"nodes":[{"content":"Optionally, the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.","pos":[0,179],"source":"Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process."},{"content":"If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.","pos":[180,339]}]}]},{"pos":[346,422],"content":"The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):","nodes":[{"content":"The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):","pos":[0,76]}]},{"pos":[432,447],"content":"UTF-8: EF BB BF","nodes":[{"content":"UTF-8: EF BB BF","pos":[0,15]}]},{"pos":[457,492],"content":"UTF-16 big endian byte order: FE FF","nodes":[{"content":"UTF-16 big endian byte order: FE FF","pos":[0,35]}]},{"pos":[502,540],"content":"UTF-16 little endian byte order: FF FE","nodes":[{"content":"UTF-16 little endian byte order: FF FE","pos":[0,38]}]},{"pos":[550,591],"content":"UTF-32 big endian byte order: 00 00 FE FF","nodes":[{"content":"UTF-32 big endian byte order: 00 00 FE FF","pos":[0,41]}]},{"pos":[601,645],"content":"UTF-32 little endian byte order: FF FE 00 00","nodes":[{"content":"UTF-32 little endian byte order: FF FE 00 00","pos":[0,44]}]},{"pos":[652,1088],"content":"You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data. Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.","nodes":[{"content":"You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data. Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.","pos":[0,436],"nodes":[{"content":"You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.","pos":[0,323],"source":"You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data."},{"content":"Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.","pos":[324,436]}]}]},{"pos":[1095,1327],"content":"For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.","nodes":[{"content":"For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.","pos":[0,232],"nodes":[{"content":"For standards that provide an encoding type, a BOM is somewhat redundant.","pos":[0,73]},{"content":"However, it can be used to help a server send the correct encoding header.","pos":[74,148]},{"content":"Alternatively, it can be used as a fallback in case the encoding is otherwise lost.","pos":[149,232]}]}]},{"pos":[1334,1708],"content":"There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.","nodes":[{"content":"There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.","pos":[0,374],"nodes":[{"content":"There are some disadvantages to using a BOM.","pos":[0,44]},{"content":"For example, knowing how to limit the database fields that use a BOM can be difficult.","pos":[45,131]},{"content":"Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.","pos":[132,290]},{"content":"In spite of the few disadvantages, however, the use of a BOM is highly recommended.","pos":[291,374]}]}]},{"pos":[1715,1873],"content":"For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id=\"p1\">[</bpt>Unicode home page<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.","source":"For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123)."},{"pos":[1881,2271],"content":"[!CAUTION]\n To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. However, most encodings do not provide a preamble. To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.","leadings":["","> "],"nodes":[{"content":" To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. However, most encodings do not provide a preamble. To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.","pos":[11,388],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.","pos":[1,104]},{"content":"However, most encodings do not provide a preamble.","pos":[105,155]},{"content":"To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding&gt;</ph>, with a preamble.","pos":[156,377],"source":" To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble."}]}]}],"pos":[229772,232069],"yaml":true,"extradata":"MT"},{"content":"A byte array containing a sequence of bytes that specifies the encoding used.  \n  \n -or-  \n  \n A byte array of length zero, if a preamble is not required.","nodes":[{"pos":[0,77],"content":"A byte array containing a sequence of bytes that specifies the encoding used.","nodes":[{"content":"A byte array containing a sequence of bytes that specifies the encoding used.","pos":[0,77]}]},{"pos":[84,88],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[95,154],"content":"A byte array of length zero, if a preamble is not required.","nodes":[{"content":"A byte array of length zero, if a preamble is not required.","pos":[0,59]}]}],"pos":[232820,232981],"yaml":true},{"content":"When overridden in a derived class, decodes all the bytes in the specified byte array into a string.","nodes":[{"pos":[0,100],"content":"When overridden in a derived class, decodes all the bytes in the specified byte array into a string.","nodes":[{"content":"When overridden in a derived class, decodes all the bytes in the specified byte array into a string.","pos":[0,100]}]}],"pos":[234507,234608],"yaml":true},{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.  \n  \n See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.  \n  \n Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object. For more information, see the \"Choosing a Fallback Strategy\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic.","nodes":[{"pos":[0,324],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.","pos":[0,324],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class."}]},{"pos":[331,502],"content":"See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.","nodes":[{"content":"See the Remarks section of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> reference topic for a discussion of decoding techniques and considerations.","pos":[0,171],"source":"See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations."}]},{"pos":[509,916],"content":"Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object. For more information, see the \"Choosing a Fallback Strategy\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic.","nodes":[{"content":"Note that the precise behavior of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id=\"ph2\">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id=\"ph3\">&lt;xref:System.Text.Encoding&gt;</ph> object.","pos":[0,231],"source":"Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object."},{"content":"For more information, see the \"Choosing a Fallback Strategy\" section of the <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> topic.","pos":[232,407],"source":" For more information, see the \"Choosing a Fallback Strategy\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic."}]}],"pos":[234619,235544],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[237224,237283],"yaml":true},{"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"pos":[0,79],"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"content":"A string that contains the results of decoding the specified sequence of bytes.","pos":[0,79]}]}],"pos":[237340,237420],"yaml":true},{"content":"The byte array contains invalid Unicode code points.","nodes":[{"pos":[0,52],"content":"The byte array contains invalid Unicode code points.","nodes":[{"content":"The byte array contains invalid Unicode code points.","pos":[0,52]}]}],"pos":[237572,237625],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[237727,237757],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[237875,238174],"yaml":true},{"content":"When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.","nodes":[{"pos":[0,118],"content":"When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.","nodes":[{"content":"When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.","pos":[0,118]}]}],"pos":[239571,239690],"yaml":true},{"content":"The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array. Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.  \n  \n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.  \n  \n See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.  \n  \n Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object. For more information, see the \"Choosing a Fallback Strategy\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic.","nodes":[{"pos":[0,282],"content":"The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array. Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.","nodes":[{"content":"The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array. Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.","pos":[0,282],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is designed to optimize performance when you have a native pointer to a byte array.","pos":[0,135],"source":"The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array."},{"content":"Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.","pos":[136,282]}]}]},{"pos":[289,613],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.","pos":[0,324],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class."}]},{"pos":[620,791],"content":"See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.","nodes":[{"content":"See the Remarks section of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> reference topic for a discussion of decoding techniques and considerations.","pos":[0,171],"source":"See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations."}]},{"pos":[798,1205],"content":"Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object. For more information, see the \"Choosing a Fallback Strategy\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic.","nodes":[{"content":"Note that the precise behavior of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id=\"ph2\">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id=\"ph3\">&lt;xref:System.Text.Encoding&gt;</ph> object.","pos":[0,231],"source":"Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object."},{"content":"For more information, see the \"Choosing a Fallback Strategy\" section of the <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> topic.","pos":[232,407],"source":" For more information, see the \"Choosing a Fallback Strategy\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic."}]}],"pos":[239701,240917],"yaml":true,"extradata":"MT"},{"content":"A pointer to a byte array.","nodes":[{"pos":[0,26],"content":"A pointer to a byte array.","nodes":[{"content":"A pointer to a byte array.","pos":[0,26]}]}],"pos":[241215,241242],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[241306,241337],"yaml":true},{"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"pos":[0,79],"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"content":"A string that contains the results of decoding the specified sequence of bytes.","pos":[0,79]}]}],"pos":[241394,241474],"yaml":true},{"content":"<code>bytes</code> is a null pointer.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is a null pointer.","source":"<code>bytes</code> is a null pointer."}],"pos":[241634,241672],"yaml":true},{"content":"<code>byteCount</code> is less than zero.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.","source":"<code>byteCount</code> is less than zero."}],"pos":[241786,241828],"yaml":true},{"content":"A   fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,147],"content":"A   fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)","source":"A   fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)"},{"pos":[154,159],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[166,292],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[241946,242249],"yaml":true},{"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.","nodes":[{"pos":[0,108],"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.","nodes":[{"content":"When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.","pos":[0,108]}]}],"pos":[243744,243853],"yaml":true},{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \n  \n See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.","nodes":[{"pos":[0,422],"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.","nodes":[{"content":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.","pos":[0,422],"source":"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class."}]},{"pos":[429,600],"content":"See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.","nodes":[{"content":"See the Remarks section of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> reference topic for a discussion of decoding techniques and considerations.","pos":[0,171],"source":"See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations."}]}],"pos":[243864,244469],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[246209,246268],"yaml":true},{"content":"The index of the first byte to decode.","nodes":[{"pos":[0,38],"content":"The index of the first byte to decode.","nodes":[{"content":"The index of the first byte to decode.","pos":[0,38]}]}],"pos":[246328,246367],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[246427,246458],"yaml":true},{"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"pos":[0,79],"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"content":"A string that contains the results of decoding the specified sequence of bytes.","pos":[0,79]}]}],"pos":[246515,246595],"yaml":true},{"content":"The byte array contains invalid Unicode code points.","nodes":[{"pos":[0,52],"content":"The byte array contains invalid Unicode code points.","nodes":[{"content":"The byte array contains invalid Unicode code points.","pos":[0,52]}]}],"pos":[246747,246800],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[246902,246932],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>."}],"pos":[247046,247222],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[247340,247639],"yaml":true},{"content":"When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.","nodes":[{"pos":[0,118],"content":"When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.","nodes":[{"content":"When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.","pos":[0,118]}]}],"pos":[249016,249135],"yaml":true},{"content":"If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding.  \n  \n In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.  \n  \n Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an e-mail application, for example. However, use of the property to define the encoding is not recommended.","nodes":[{"pos":[0,337],"content":"If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding.","nodes":[{"content":"If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding.","pos":[0,337],"nodes":[{"content":"If you need an encoding for a header name, you should call the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method with the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property.","pos":[0,173],"source":"If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property."},{"content":"Often the method retrieves a different encoding from the test encoding furnished in the call.","pos":[174,267]},{"content":"Generally only e-mail applications need to retrieve such an encoding.","pos":[268,337]}]}]},{"pos":[344,573],"content":"In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.","nodes":[{"content":"In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.","pos":[0,229],"nodes":[{"content":"In some cases, the value of the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.","pos":[0,150],"source":"In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding."},{"content":"This doesn't mean that the implementation complies in full with that standard.","pos":[151,229]}]}]},{"pos":[580,896],"content":"Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an e-mail application, for example. However, use of the property to define the encoding is not recommended.","nodes":[{"content":"Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an e-mail application, for example. However, use of the property to define the encoding is not recommended.","pos":[0,316],"nodes":[{"content":"Note that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns the name to use to describe an encoding.","pos":[0,97],"source":"Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for an e-mail application, for example.","pos":[98,244],"source":" The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an e-mail application, for example."},{"content":"However, use of the property to define the encoding is not recommended.","pos":[245,316]}]}]}],"pos":[249146,250049],"yaml":true,"extradata":"MT"},{"content":"A name for the current <xref href=\"System.Text.Encoding\"></xref> to use with mail agent header tags.  \n  \n -or-  \n  \n An empty string (\"\"), if the current <xref href=\"System.Text.Encoding\"></xref> cannot be used.","nodes":[{"pos":[0,100],"content":"A name for the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> to use with mail agent header tags.","source":"A name for the current <xref href=\"System.Text.Encoding\"></xref> to use with mail agent header tags."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,212],"content":"An empty string (\"\"), if the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> cannot be used.","source":"An empty string (\"\"), if the current <xref href=\"System.Text.Encoding\"></xref> cannot be used."}],"pos":[250904,251129],"yaml":true},{"content":"Gets a value indicating whether the current encoding is always normalized, using the default normalization form.","nodes":[{"pos":[0,112],"content":"Gets a value indicating whether the current encoding is always normalized, using the default normalization form.","nodes":[{"content":"Gets a value indicating whether the current encoding is always normalized, using the default normalization form.","pos":[0,112]}]}],"pos":[252316,252429],"yaml":true},{"content":"The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.","nodes":[{"pos":[0,203],"content":"The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.","nodes":[{"content":"The default normalization form is <ph id=\"ph1\">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.","pos":[0,203],"source":"The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible."}]}],"pos":[252440,252644],"yaml":true,"extradata":"MT"},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> is always normalized; otherwise, `false`. The default is `false`.","nodes":[{"pos":[0,129],"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> is always normalized; otherwise, `false`. The default is `false`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> is always normalized; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,105],"source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> is always normalized; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`false`</ph>.","pos":[106,129],"source":" The default is `false`."}]}],"pos":[252846,252978],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.","nodes":[{"pos":[0,150],"content":"When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.","pos":[0,150]}]}],"pos":[254392,254543],"yaml":true},{"content":"The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.","nodes":[{"pos":[0,203],"content":"The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.","nodes":[{"content":"The default normalization form is <ph id=\"ph1\">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.","pos":[0,203],"source":"The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible."}]}],"pos":[254554,254758],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Text.NormalizationForm\"></xref> values.","nodes":[{"pos":[0,69],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Text.NormalizationForm\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Text.NormalizationForm\"></xref> values."}],"pos":[255017,255087],"yaml":true},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> object is always normalized using the specified <xref href=\"System.Text.NormalizationForm\"></xref> value; otherwise, `false`. The default is `false`.","nodes":[{"pos":[0,213],"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> object is always normalized using the specified <xref href=\"System.Text.NormalizationForm\"></xref> value; otherwise, `false`. The default is `false`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> object is always normalized using the specified <ph id=\"ph3\">&lt;xref href=\"System.Text.NormalizationForm\"&gt;&lt;/xref&gt;</ph> value; otherwise, <ph id=\"ph4\">`false`</ph>.","pos":[0,189],"source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> object is always normalized using the specified <xref href=\"System.Text.NormalizationForm\"></xref> value; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`false`</ph>.","pos":[190,213],"source":" The default is `false`."}]}],"pos":[255145,255361],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.","nodes":[{"pos":[0,143],"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.","pos":[0,143]}]}],"pos":[256615,256759],"yaml":true},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by browser clients for displaying content; otherwise, `false`.","nodes":[{"pos":[0,138],"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> can be used by browser clients for displaying content; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by browser clients for displaying content; otherwise, `false`."}],"pos":[257436,257577],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.","nodes":[{"pos":[0,139],"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.","pos":[0,139]}]}],"pos":[258736,258876],"yaml":true},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by browser clients for saving content; otherwise, `false`.","nodes":[{"pos":[0,134],"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> can be used by browser clients for saving content; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by browser clients for saving content; otherwise, `false`."}],"pos":[259550,259687],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.","nodes":[{"pos":[0,149],"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.","pos":[0,149]}]}],"pos":[260867,261017],"yaml":true},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by mail and news clients for displaying content; otherwise, `false`.","nodes":[{"pos":[0,144],"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> can be used by mail and news clients for displaying content; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by mail and news clients for displaying content; otherwise, `false`."}],"pos":[261695,261842],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.","nodes":[{"pos":[0,145],"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.","pos":[0,145]}]}],"pos":[263008,263154],"yaml":true},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by mail and news clients for saving content; otherwise, `false`.","nodes":[{"pos":[0,140],"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> can be used by mail and news clients for saving content; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by mail and news clients for saving content; otherwise, `false`."}],"pos":[263829,263972],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the current encoding is read-only.","nodes":[{"pos":[0,102],"content":"When overridden in a derived class, gets a value indicating whether the current encoding is read-only.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the current encoding is read-only.","pos":[0,102]}]}],"pos":[265111,265214],"yaml":true},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> is read-only; otherwise, `false`. The default is `true`.","nodes":[{"pos":[0,120],"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> is read-only; otherwise, `false`. The default is `true`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> is read-only; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,97],"source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> is read-only; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`true`</ph>.","pos":[98,120],"source":" The default is `true`."}]}],"pos":[265394,265517],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.","nodes":[{"pos":[0,118],"content":"When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.","pos":[0,118]}]}],"pos":[266764,266883],"yaml":true},{"content":"For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.  \n  \n> [!CAUTION]\n>  You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>. An assumption of how an Encoding will proceed may still be wrong. For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName>, but Encoding.GetMaxByteCount(1) returns 2. This is because the method considers potential leftover surrogates from a previous decoder operation.","nodes":[{"pos":[0,106],"content":"For a single-byte encoding, for example, <ph id=\"ph1\">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>, this property retrieves <ph id=\"ph2\">`true`</ph>.","source":"For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`."},{"pos":[114,576],"content":"[!CAUTION]\n You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>. An assumption of how an Encoding will proceed may still be wrong. For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName>, but Encoding.GetMaxByteCount(1) returns 2. This is because the method considers potential leftover surrogates from a previous decoder operation.","leadings":["","> "],"nodes":[{"content":" You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>. An assumption of how an Encoding will proceed may still be wrong. For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName>, but Encoding.GetMaxByteCount(1) returns 2. This is because the method considers potential leftover surrogates from a previous decoder operation.","pos":[11,460],"nodes":[{"content":"You should be careful in what your application does with the value for <ph id=\"ph1\">&lt;xref:System.Text.Encoding.IsSingleByte%2A&gt;</ph>.","pos":[1,116],"source":" You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>."},{"content":"An assumption of how an Encoding will proceed may still be wrong.","pos":[117,182]},{"content":"For example, Windows-1252 has a value of <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">&lt;xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName&gt;</ph>, but Encoding.GetMaxByteCount(1) returns 2.","pos":[183,347],"source":" For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName>, but Encoding.GetMaxByteCount(1) returns 2."},{"content":"This is because the method considers potential leftover surrogates from a previous decoder operation.","pos":[348,449]}]}]}],"pos":[266894,267476],"yaml":true,"extradata":"MT"},{"content":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> uses single-byte code points; otherwise, `false`.","nodes":[{"pos":[0,113],"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph> uses single-byte code points; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current <xref href=\"System.Text.Encoding\"></xref> uses single-byte code points; otherwise, `false`."}],"pos":[268202,268318],"yaml":true},{"content":"Registers an encoding provider.","nodes":[{"pos":[0,31],"content":"Registers an encoding provider.","nodes":[{"content":"Registers an encoding provider.","pos":[0,31]}]}],"pos":[269917,269949],"yaml":true},{"content":"The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them. Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName> overload.  \n  \n [!INCLUDE[net_v46](~/includes/net-v46-md.md)] includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. By default, [!INCLUDE[net_v46](~/includes/net-v46-md.md)] only supports the Unicode encodings, ASCII, and code page 28591.  \n  \n If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider. Subsequent calls are ignored.  \n  \n If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations. Any previously registered providers are ignored.","nodes":[{"pos":[0,414],"content":"The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them. Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName> overload.","nodes":[{"content":"The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them. Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName> overload.","pos":[0,414],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method allows you to register a class derived from <ph id=\"ph2\">&lt;xref:System.Text.EncodingProvider&gt;</ph> that makes character encodings available on a platform that does not otherwise support them.","pos":[0,231],"source":"The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them."},{"content":"Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName&gt;</ph> overload.","pos":[232,414],"source":" Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName> overload."}]}]},{"pos":[421,818],"content":"[!INCLUDE[net_v46](~/includes/net-v46-md.md)] includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. By default, [!INCLUDE[net_v46](~/includes/net-v46-md.md)] only supports the Unicode encodings, ASCII, and code page 28591.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> includes one encoding provider, <ph id=\"ph2\">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, that makes the encodings available that are present in the full .NET Framework but are not available in <ph id=\"ph3\">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>.","pos":[0,274],"source":"[!INCLUDE[net_v46](~/includes/net-v46-md.md)] includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]."},{"content":"By default, <ph id=\"ph1\">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> only supports the Unicode encodings, ASCII, and code page 28591.","pos":[275,397],"source":" By default, [!INCLUDE[net_v46](~/includes/net-v46-md.md)] only supports the Unicode encodings, ASCII, and code page 28591."}]},{"pos":[825,1024],"content":"If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider. Subsequent calls are ignored.","nodes":[{"content":"If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider. Subsequent calls are ignored.","pos":[0,199],"nodes":[{"content":"If the same encoding provider is used in multiple calls to the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method, only the first method call registers the provider.","pos":[0,169],"source":"If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider."},{"content":"Subsequent calls are ignored.","pos":[170,199]}]}]},{"pos":[1031,1296],"content":"If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations. Any previously registered providers are ignored.","nodes":[{"content":"If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations. Any previously registered providers are ignored.","pos":[0,265],"nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.","pos":[0,216],"source":"If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations."},{"content":"Any previously registered providers are ignored.","pos":[217,265]}]}]}],"pos":[269960,271265],"yaml":true,"extradata":"MT"},{"content":"A subclass of <xref href=\"System.Text.EncodingProvider\"></xref> that provides access to additional character encodings.","nodes":[{"pos":[0,119],"content":"A subclass of <ph id=\"ph1\">&lt;xref href=\"System.Text.EncodingProvider\"&gt;&lt;/xref&gt;</ph> that provides access to additional character encodings.","source":"A subclass of <xref href=\"System.Text.EncodingProvider\"></xref> that provides access to additional character encodings."}],"pos":[271511,271631],"yaml":true},{"content":"<code>provider</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;provider&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>provider</code> is `null`."}],"pos":[271798,271831],"yaml":true},{"content":"Gets an encoding for the UTF-16 format using the little endian byte order.","nodes":[{"pos":[0,74],"content":"Gets an encoding for the UTF-16 format using the little endian byte order.","nodes":[{"content":"Gets an encoding for the UTF-16 format using the little endian byte order.","pos":[0,74]}]}],"pos":[273027,273102],"yaml":true},{"content":"For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).  \n  \n The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \n  \n [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]\n [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]","nodes":[{"pos":[0,216],"content":"For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept>.","source":"For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md)."},{"pos":[223,895],"content":"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","nodes":[{"content":"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","pos":[0,672],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.","pos":[0,131],"source":"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app."},{"content":"It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character.","pos":[132,279]},{"content":"Instead, you can call the <ph id=\"ph1\">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a little endian <ph id=\"ph2\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id=\"ph3\">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id=\"ph4\">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.","pos":[280,672],"source":" Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates."}]}]},{"pos":[902,1189],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Text.Encoding.Unicode#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Text.Encoding.Unicode#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]\n [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]"}],"pos":[273113,274312],"yaml":true,"extradata":"MT"},{"content":"An encoding for the UTF-16 format using the little endian byte order.","nodes":[{"pos":[0,69],"content":"An encoding for the UTF-16 format using the little endian byte order.","nodes":[{"content":"An encoding for the UTF-16 format using the little endian byte order.","pos":[0,69]}]}],"pos":[275133,275203],"yaml":true},{"content":"Gets an encoding for the UTF-32 format using the little endian byte order.","nodes":[{"pos":[0,74],"content":"Gets an encoding for the UTF-32 format using the little endian byte order.","nodes":[{"content":"Gets an encoding for the UTF-32 format using the little endian byte order.","pos":[0,74]}]}],"pos":[276634,276709],"yaml":true},{"content":"The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE). Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \n  \n [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]\n [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  \n  \n For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.  \n  \n For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).","nodes":[{"pos":[0,663],"content":"The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE). Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","nodes":[{"content":"The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE). Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","pos":[0,663],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.","pos":[0,129],"source":"The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app."},{"content":"It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).","pos":[130,288]},{"content":"Instead, you can call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object whose fallback is either an <ph id=\"ph3\">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id=\"ph4\">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.","pos":[289,663],"source":" Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates."}]}]},{"pos":[670,965],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Text.Encoding.UTF32#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Text.Encoding.UTF32#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]\n [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]"},{"pos":[972,1066],"content":"For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.","nodes":[{"content":"For a discussion of little endian byte order, see the <ph id=\"ph1\">&lt;xref:System.Text.Encoding&gt;</ph> class topic.","pos":[0,94],"source":"For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic."}]},{"pos":[1073,1289],"content":"For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept>.","source":"For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md)."}],"pos":[276720,278019],"yaml":true,"extradata":"MT"},{"content":"An  encoding object for the UTF-32 format using the little endian byte order.","nodes":[{"pos":[0,77],"content":"An  encoding object for the UTF-32 format using the little endian byte order.","nodes":[{"content":"An  encoding object for the UTF-32 format using the little endian byte order.","pos":[0,77]}]}],"pos":[278838,278916],"yaml":true},{"content":"Gets an encoding for the UTF-7 format.","nodes":[{"pos":[0,38],"content":"Gets an encoding for the UTF-7 format.","nodes":[{"content":"Gets an encoding for the UTF-7 format.","pos":[0,38]}]}],"pos":[280219,280258],"yaml":true},{"content":"UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications. Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.","nodes":[{"pos":[0,285],"content":"UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications. Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.","nodes":[{"content":"UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications. Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.","pos":[0,285],"nodes":[{"content":"UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.","pos":[0,140]},{"content":"Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.","pos":[141,285]}]}]}],"pos":[280269,280555],"yaml":true,"extradata":"MT"},{"content":"An encoding for the UTF-7 format.","nodes":[{"pos":[0,33],"content":"An encoding for the UTF-7 format.","nodes":[{"content":"An encoding for the UTF-7 format.","pos":[0,33]}]}],"pos":[281373,281407],"yaml":true},{"content":"Gets an encoding for the UTF-8 format.","nodes":[{"pos":[0,38],"content":"Gets an encoding for the UTF-8 format.","nodes":[{"content":"Gets an encoding for the UTF-8 format.","pos":[0,38]}]}],"pos":[282709,282748],"yaml":true},{"content":"This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters. For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).  \n  \n The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.  \n  \n-   It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM). To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.  \n  \n-   It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \n  \n     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]\n     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]","nodes":[{"pos":[0,474],"content":"This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters. For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).","nodes":[{"content":"This property returns a <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.","pos":[0,247],"source":"This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters."},{"content":"For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept>.","pos":[248,474],"source":" For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md)."}]},{"pos":[481,611],"content":"The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.","pos":[0,130],"source":"The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app."}]},{"pos":[621,859],"content":"It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM). To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.","nodes":[{"content":"It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM). To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.","pos":[0,238],"nodes":[{"content":"It returns a <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that provides a Unicode byte order mark (BOM).","pos":[0,98],"source":"It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM)."},{"content":"To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding.%23ctor%2A&gt;</ph> constructor.","pos":[99,238],"source":" To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor."}]}]},{"pos":[869,1424],"content":"It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","nodes":[{"content":"It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark (\"?\") character. Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.","pos":[0,555],"nodes":[{"content":"It returns a <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark (\"?\") character.","pos":[0,199],"source":"It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark (\"?\") character."},{"content":"Instead, you can call the <ph id=\"ph1\">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a <ph id=\"ph2\">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object whose fallback is either an <ph id=\"ph3\">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id=\"ph4\">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.","pos":[200,555],"source":" Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates."}]}]},{"pos":[1435,1728],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Text.Encoding.UTF8#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Text.Encoding.UTF8#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]\n [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]"}],"pos":[282759,284501],"yaml":true,"extradata":"MT"},{"content":"An encoding for the UTF-8 format.","nodes":[{"pos":[0,33],"content":"An encoding for the UTF-8 format.","nodes":[{"content":"An encoding for the UTF-8 format.","pos":[0,33]}]}],"pos":[285579,285613],"yaml":true},{"content":"When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.","nodes":[{"pos":[0,138],"content":"When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.","nodes":[{"content":"When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.","pos":[0,138]}]}],"pos":[287053,287192],"yaml":true},{"content":"The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.  \n  \n Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding. When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for e-mail headers. However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.  \n  \n For more information on the IANA, go to [www.iana.org](http://www.iana.org/).  \n  \n The <xref:System.Text.Encoding.WebName%2A?displayProperty=fullName> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName>. Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName> for more information.","nodes":[{"pos":[0,120],"content":"The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property is the same as the <ph id=\"ph2\">&lt;xref:System.Text.EncodingInfo.Name%2A&gt;</ph> property.","pos":[0,120],"source":"The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property."}]},{"pos":[127,551],"content":"Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding. When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for e-mail headers. However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.","nodes":[{"content":"Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding. When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for e-mail headers. However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.","pos":[0,424],"nodes":[{"content":"Note that <ph id=\"ph1\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns an IANA-registered name for the encoding.","pos":[0,98],"source":"Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding."},{"content":"When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.","pos":[99,219]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for e-mail headers.","pos":[220,346],"source":" The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for e-mail headers."},{"content":"However, most apps should use <ph id=\"ph1\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead.","pos":[347,424],"source":" However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead."}]}]},{"pos":[558,635],"content":"For more information on the IANA, go to <bpt id=\"p1\">[</bpt>www.iana.org<ept id=\"p1\">](http://www.iana.org/)</ept>.","source":"For more information on the IANA, go to [www.iana.org](http://www.iana.org/)."},{"pos":[642,1024],"content":"The <xref:System.Text.Encoding.WebName%2A?displayProperty=fullName> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName>. Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName> for more information.","nodes":[{"content":"The <xref:System.Text.Encoding.WebName%2A?displayProperty=fullName> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName>. Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName> for more information.","pos":[0,382],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoding.WebName%2A?displayProperty=fullName&gt;</ph> is the same as the <ph id=\"ph2\">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName&gt;</ph> returned by <ph id=\"ph3\">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName&gt;</ph>.","pos":[0,233],"source":"The <xref:System.Text.Encoding.WebName%2A?displayProperty=fullName> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName>."},{"content":"Some of the web names are duplicates; see the remarks for <ph id=\"ph1\">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName&gt;</ph> for more information.","pos":[234,382],"source":" Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName> for more information."}]}]}],"pos":[287203,288236],"yaml":true,"extradata":"MT"},{"content":"The IANA name for the current <xref href=\"System.Text.Encoding\"></xref>.","nodes":[{"pos":[0,72],"content":"The IANA name for the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph>.","source":"The IANA name for the current <xref href=\"System.Text.Encoding\"></xref>."}],"pos":[289624,289697],"yaml":true},{"content":"When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.","nodes":[{"pos":[0,134],"content":"When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.","nodes":[{"content":"When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.","pos":[0,134]}]}],"pos":[291163,291298],"yaml":true},{"content":"This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families. For globalization, using one of the Unicode encodings is recommended instead. It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.","nodes":[{"pos":[0,363],"content":"This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families. For globalization, using one of the Unicode encodings is recommended instead. It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.","nodes":[{"content":"This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families. For globalization, using one of the Unicode encodings is recommended instead. It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.","pos":[0,363],"nodes":[{"content":"This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.","pos":[0,131]},{"content":"For globalization, using one of the Unicode encodings is recommended instead.","pos":[132,209]},{"content":"It is also recommended to use <ph id=\"ph1\">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead of <ph id=\"ph2\">&lt;xref:System.Text.Encoding.WindowsCodePage%2A&gt;</ph> to identify the code page.","pos":[210,363],"source":" It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page."}]}]}],"pos":[291309,291673],"yaml":true,"extradata":"MT"},{"content":"The Windows operating system code page that most closely corresponds to the current <xref href=\"System.Text.Encoding\"></xref>.","nodes":[{"pos":[0,126],"content":"The Windows operating system code page that most closely corresponds to the current <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding\"&gt;&lt;/xref&gt;</ph>.","source":"The Windows operating system code page that most closely corresponds to the current <xref href=\"System.Text.Encoding\"></xref>."}],"pos":[292360,292487],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Text.Encoding\n  commentId: T:System.Text.Encoding\n  id: Encoding\n  children:\n  - System.Text.Encoding.#ctor\n  - System.Text.Encoding.#ctor(System.Int32)\n  - System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  - System.Text.Encoding.ASCII\n  - System.Text.Encoding.BigEndianUnicode\n  - System.Text.Encoding.BodyName\n  - System.Text.Encoding.Clone\n  - System.Text.Encoding.CodePage\n  - System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)\n  - System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\n  - System.Text.Encoding.DecoderFallback\n  - System.Text.Encoding.Default\n  - System.Text.Encoding.EncoderFallback\n  - System.Text.Encoding.EncodingName\n  - System.Text.Encoding.Equals(System.Object)\n  - System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)\n  - System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  - System.Text.Encoding.GetByteCount(System.Char[])\n  - System.Text.Encoding.GetByteCount(System.String)\n  - System.Text.Encoding.GetByteCount(System.Char*,System.Int32)\n  - System.Text.Encoding.GetBytes(System.Char[])\n  - System.Text.Encoding.GetBytes(System.String)\n  - System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)\n  - System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)\n  - System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  - System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  - System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  - System.Text.Encoding.GetCharCount(System.Byte[])\n  - System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)\n  - System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  - System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  - System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  - System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\n  - System.Text.Encoding.GetChars(System.Byte[])\n  - System.Text.Encoding.GetDecoder\n  - System.Text.Encoding.GetEncoder\n  - System.Text.Encoding.GetEncoding(System.Int32)\n  - System.Text.Encoding.GetEncoding(System.String)\n  - System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  - System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  - System.Text.Encoding.GetEncodings\n  - System.Text.Encoding.GetHashCode\n  - System.Text.Encoding.GetMaxByteCount(System.Int32)\n  - System.Text.Encoding.GetMaxCharCount(System.Int32)\n  - System.Text.Encoding.GetPreamble\n  - System.Text.Encoding.GetString(System.Byte[])\n  - System.Text.Encoding.GetString(System.Byte*,System.Int32)\n  - System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  - System.Text.Encoding.HeaderName\n  - System.Text.Encoding.IsAlwaysNormalized\n  - System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)\n  - System.Text.Encoding.IsBrowserDisplay\n  - System.Text.Encoding.IsBrowserSave\n  - System.Text.Encoding.IsMailNewsDisplay\n  - System.Text.Encoding.IsMailNewsSave\n  - System.Text.Encoding.IsReadOnly\n  - System.Text.Encoding.IsSingleByte\n  - System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\n  - System.Text.Encoding.Unicode\n  - System.Text.Encoding.UTF32\n  - System.Text.Encoding.UTF7\n  - System.Text.Encoding.UTF8\n  - System.Text.Encoding.WebName\n  - System.Text.Encoding.WindowsCodePage\n  langs:\n  - csharp\n  name: Encoding\n  nameWithType: Encoding\n  fullName: System.Text.Encoding\n  type: Class\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Represents a character encoding.\n  remarks: \"> [!NOTE]\\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \\n  \\n Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters. For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).  \\n  \\n Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays. If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \\n  \\n The .NET Framework provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:  \\n  \\n-   <xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters. This encoding only supports character values between U+0000 and U+007F. Code page 20127. Also available through the <xref:System.Text.Encoding.ASCII%2A> property.  \\n  \\n-   <xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding. This encoding supports all Unicode character values. Code page 65000. Also available through the <xref:System.Text.Encoding.UTF7%2A> property.  \\n  \\n-   <xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding. This encoding supports all Unicode character values. Code page 65001. Also available through the <xref:System.Text.Encoding.UTF8%2A> property.  \\n  \\n-   <xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding. Both little endian and big endian byte orders are supported. Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.  \\n  \\n-   <xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding. Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported. Also available through the <xref:System.Text.Encoding.UTF32%2A> property.  \\n  \\n The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode. Often one of the derived Unicode classes is the correct choice for your app.  \\n  \\n Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.  \\n  \\n The following table lists the encodings supported by the .NET Framework. It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName> properties. An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform. Note that code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> property corresponds to an international standard do not necessarily comply in full with that standard.  \\n  \\n|Code page|Name|Display name|.NET Framework support|  \\n|---------------|----------|------------------|----------------------------|  \\n|37|IBM037|IBM EBCDIC (US-Canada)||  \\n|437|IBM437|OEM United States||  \\n|500|IBM500|IBM EBCDIC (International)||  \\n|708|ASMO-708|Arabic (ASMO 708)||  \\n|720|DOS-720|Arabic (DOS)||  \\n|737|ibm737|Greek (DOS)||  \\n|775|ibm775|Baltic (DOS)||  \\n|850|ibm850|Western European (DOS)||  \\n|852|ibm852|Central European (DOS)||  \\n|855|IBM855|OEM Cyrillic||  \\n|857|ibm857|Turkish (DOS)||  \\n|858|IBM00858|OEM Multilingual Latin I||  \\n|860|IBM860|Portuguese (DOS)||  \\n|861|ibm861|Icelandic (DOS)||  \\n|862|DOS-862|Hebrew (DOS)||  \\n|863|IBM863|French Canadian (DOS)||  \\n|864|IBM864|Arabic (864)||  \\n|865|IBM865|Nordic (DOS)||  \\n|866|cp866|Cyrillic (DOS)||  \\n|869|ibm869|Greek, Modern (DOS)||  \\n|870|IBM870|IBM EBCDIC (Multilingual Latin-2)||  \\n|874|windows-874|Thai (Windows)||  \\n|875|cp875|IBM EBCDIC (Greek Modern)||  \\n|932|shift_jis|Japanese (Shift-JIS)||  \\n|936|gb2312|Chinese Simplified (GB2312)|✓|  \\n|949|ks_c_5601-1987|Korean||  \\n|950|big5|Chinese Traditional (Big5)||  \\n|1026|IBM1026|IBM EBCDIC (Turkish Latin-5)||  \\n|1047|IBM01047|IBM Latin-1||  \\n|1140|IBM01140|IBM EBCDIC (US-Canada-Euro)||  \\n|1141|IBM01141|IBM EBCDIC (Germany-Euro)||  \\n|1142|IBM01142|IBM EBCDIC (Denmark-Norway-Euro)||  \\n|1143|IBM01143|IBM EBCDIC (Finland-Sweden-Euro)||  \\n|1144|IBM01144|IBM EBCDIC (Italy-Euro)||  \\n|1145|IBM01145|IBM EBCDIC (Spain-Euro)||  \\n|1146|IBM01146|IBM EBCDIC (UK-Euro)||  \\n|1147|IBM01147|IBM EBCDIC (France-Euro)||  \\n|1148|IBM01148|IBM EBCDIC (International-Euro)||  \\n|1149|IBM01149|IBM EBCDIC (Icelandic-Euro)||  \\n|1200|utf-16|Unicode|✓|  \\n|1201|unicodeFFFE|Unicode (Big endian)|✓|  \\n|1250|windows-1250|Central European (Windows)||  \\n|1251|windows-1251|Cyrillic (Windows)||  \\n|1252|Windows-1252|Western European (Windows)|✓|  \\n|1253|windows-1253|Greek (Windows)||  \\n|1254|windows-1254|Turkish (Windows)||  \\n|1255|windows-1255|Hebrew (Windows)||  \\n|1256|windows-1256|Arabic (Windows)||  \\n|1257|windows-1257|Baltic (Windows)||  \\n|1258|windows-1258|Vietnamese (Windows)||  \\n|1361|Johab|Korean (Johab)||  \\n|10000|macintosh|Western European (Mac)||  \\n|10001|x-mac-japanese|Japanese (Mac)||  \\n|10002|x-mac-chinesetrad|Chinese Traditional (Mac)||  \\n|10003|x-mac-korean|Korean (Mac)|✓|  \\n|10004|x-mac-arabic|Arabic (Mac)||  \\n|10005|x-mac-hebrew|Hebrew (Mac)||  \\n|10006|x-mac-greek|Greek (Mac)||  \\n|10007|x-mac-cyrillic|Cyrillic (Mac)||  \\n|10008|x-mac-chinesesimp|Chinese Simplified (Mac)|✓|  \\n|10010|x-mac-romanian|Romanian (Mac)||  \\n|10017|x-mac-ukrainian|Ukrainian (Mac)||  \\n|10021|x-mac-thai|Thai (Mac)||  \\n|10029|x-mac-ce|Central European (Mac)||  \\n|10079|x-mac-icelandic|Icelandic (Mac)||  \\n|10081|x-mac-turkish|Turkish (Mac)||  \\n|10082|x-mac-croatian|Croatian (Mac)||  \\n|12000|utf-32|Unicode (UTF-32)|✓|  \\n|12001|utf-32BE|Unicode (UTF-32 Big endian)|✓|  \\n|20000|x-Chinese-CNS|Chinese Traditional (CNS)||  \\n|20001|x-cp20001|TCA Taiwan||  \\n|20002|x-Chinese-Eten|Chinese Traditional (Eten)||  \\n|20003|x-cp20003|IBM5550 Taiwan||  \\n|20004|x-cp20004|TeleText Taiwan||  \\n|20005|x-cp20005|Wang Taiwan||  \\n|20105|x-IA5|Western European (IA5)||  \\n|20106|x-IA5-German|German (IA5)||  \\n|20107|x-IA5-Swedish|Swedish (IA5)||  \\n|20108|x-IA5-Norwegian|Norwegian (IA5)||  \\n|20127|us-ascii|US-ASCII|✓|  \\n|20261|x-cp20261|T.61||  \\n|20269|x-cp20269|ISO-6937||  \\n|20273|IBM273|IBM EBCDIC (Germany)||  \\n|20277|IBM277|IBM EBCDIC (Denmark-Norway)||  \\n|20278|IBM278|IBM EBCDIC (Finland-Sweden)||  \\n|20280|IBM280|IBM EBCDIC (Italy)||  \\n|20284|IBM284|IBM EBCDIC (Spain)||  \\n|20285|IBM285|IBM EBCDIC (UK)||  \\n|20290|IBM290|IBM EBCDIC (Japanese katakana)||  \\n|20297|IBM297|IBM EBCDIC (France)||  \\n|20420|IBM420|IBM EBCDIC (Arabic)||  \\n|20423|IBM423|IBM EBCDIC (Greek)||  \\n|20424|IBM424|IBM EBCDIC (Hebrew)||  \\n|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (Korean Extended)||  \\n|20838|IBM-Thai|IBM EBCDIC (Thai)||  \\n|20866|koi8-r|Cyrillic (KOI8-R)||  \\n|20871|IBM871|IBM EBCDIC (Icelandic)||  \\n|20880|IBM880|IBM EBCDIC (Cyrillic Russian)||  \\n|20905|IBM905|IBM EBCDIC (Turkish)||  \\n|20924|IBM00924|IBM Latin-1||  \\n|20932|EUC-JP|Japanese (JIS 0208-1990 and 0212-1990)||  \\n|20936|x-cp20936|Chinese Simplified (GB2312-80)|✓|  \\n|20949|x-cp20949|Korean Wansung|✓|  \\n|21025|cp1025|IBM EBCDIC (Cyrillic Serbian-Bulgarian)||  \\n|21866|koi8-u|Cyrillic (KOI8-U)||  \\n|28591|iso-8859-1|Western European (ISO)|✓|  \\n|28592|iso-8859-2|Central European (ISO)||  \\n|28593|iso-8859-3|Latin 3 (ISO)||  \\n|28594|iso-8859-4|Baltic (ISO)||  \\n|28595|iso-8859-5|Cyrillic (ISO)||  \\n|28596|iso-8859-6|Arabic (ISO)||  \\n|28597|iso-8859-7|Greek (ISO)||  \\n|28598|iso-8859-8|Hebrew (ISO-Visual)|✓|  \\n|28599|iso-8859-9|Turkish (ISO)||  \\n|28603|iso-8859-13|Estonian (ISO)||  \\n|28605|iso-8859-15|Latin 9 (ISO)||  \\n|29001|x-Europa|Europa||  \\n|38598|iso-8859-8-i|Hebrew (ISO-Logical)|✓|  \\n|50220|iso-2022-jp|Japanese (JIS)|✓|  \\n|50221|csISO2022JP|Japanese (JIS-Allow 1 byte Kana)|✓|  \\n|50222|iso-2022-jp|Japanese (JIS-Allow 1 byte Kana - SO/SI)|✓|  \\n|50225|iso-2022-kr|Korean (ISO)|✓|  \\n|50227|x-cp50227|Chinese Simplified (ISO-2022)|✓|  \\n|51932|euc-jp|Japanese (EUC)|✓|  \\n|51936|EUC-CN|Chinese Simplified (EUC)|✓|  \\n|51949|euc-kr|Korean (EUC)|✓|  \\n|52936|hz-gb-2312|Chinese Simplified (HZ)|✓|  \\n|54936|GB18030|Chinese Simplified (GB18030)|✓|  \\n|57002|x-iscii-de|ISCII Devanagari|✓|  \\n|57003|x-iscii-be|ISCII Bengali|✓|  \\n|57004|x-iscii-ta|ISCII Tamil|✓|  \\n|57005|x-iscii-te|ISCII Telugu|✓|  \\n|57006|x-iscii-as|ISCII Assamese|✓|  \\n|57007|x-iscii-or|ISCII Oriya|✓|  \\n|57008|x-iscii-ka|ISCII Kannada|✓|  \\n|57009|x-iscii-ma|ISCII Malayalam|✓|  \\n|57010|x-iscii-gu|ISCII Gujarati|✓|  \\n|57011|x-iscii-pa|ISCII Punjabi|✓|  \\n|65000|utf-7|Unicode (UTF-7)|✓|  \\n|65001|utf-8|Unicode (UTF-8)|✓|  \\n  \\n The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding. It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.  \\n  \\n [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]\\n [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):  \\n  \\n-   UTF-16 big endian byte order: 00 41  \\n  \\n-   UTF-16 little endian byte order: 41 00  \\n  \\n-   UTF-32 big endian byte order: 00 00 00 41  \\n  \\n-   UTF-32 little endian byte order: 41 00 00 00  \\n  \\n It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.  \\n  \\n The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM). If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.  \\n  \\n For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).  \\n  \\n Note that the encoding classes allow errors to:  \\n  \\n-   Silently change to a \\\"?\\\" character.  \\n  \\n-   Use a \\\"best fit\\\" character.  \\n  \\n-   Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.  \\n  \\n You should throw an exception on any data stream error. An app either uses a \\\"throwonerror\\\" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes. Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements. For ANSI encodings, the best fit behavior is the default.\"\n  example:\n  - \"The following example converts a string from one encoding to another.  \\n  \\n> [!NOTE]\\n>  The byte[] array is the only type in this example that contains the encoded data. The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.  \\n  \\n [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]\\n [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract class Encoding : ICloneable\n  inheritance:\n  - System.Object\n  derivedClasses:\n  - System.Text.ASCIIEncoding\n  - System.Text.UnicodeEncoding\n  - System.Text.UTF32Encoding\n  - System.Text.UTF7Encoding\n  - System.Text.UTF8Encoding\n  implements:\n  - System.ICloneable\n  inheritedMembers:\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.#ctor\n  commentId: M:System.Text.Encoding.#ctor\n  id: '#ctor'\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Encoding()\n  nameWithType: Encoding.Encoding()\n  fullName: Encoding.Encoding()\n  type: Constructor\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class.\n  remarks: Derived classes override this constructor.\n  syntax:\n    content: protected Encoding ();\n    parameters: []\n  overload: System.Text.Encoding.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.#ctor(System.Int32)\n  commentId: M:System.Text.Encoding.#ctor(System.Int32)\n  id: '#ctor(System.Int32)'\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Encoding(Int32)\n  nameWithType: Encoding.Encoding(Int32)\n  fullName: Encoding.Encoding(Int32)\n  type: Constructor\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class that corresponds to the specified code page.\n  remarks: \"Derived classes override this constructor.  \\n  \\n Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations. Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified. To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.\"\n  syntax:\n    content: protected Encoding (int codePage);\n    parameters:\n    - id: codePage\n      type: System.Int32\n      description: \"The code page identifier of the preferred encoding.  \\n  \\n -or-  \\n  \\n 0, to use the default encoding.\"\n  overload: System.Text.Encoding.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>codePage</code> is less than zero.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  commentId: M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  id: '#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)'\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Encoding(Int32, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.Encoding(Int32, EncoderFallback, DecoderFallback)\n  fullName: Encoding.Encoding(Int32, EncoderFallback, DecoderFallback)\n  type: Constructor\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Initializes a new instance of the <xref href=\"System.Text.Encoding\"></xref> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.\n  remarks: \"This constructor is `protected`; derived classes override it.  \\n  \\n You call this constructor from a derived class to control the fallback encoding and decoding strategies. The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.  \\n  \\n If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.\"\n  syntax:\n    content: protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);\n    parameters:\n    - id: codePage\n      type: System.Int32\n      description: The encoding code page identifier.\n    - id: encoderFallback\n      type: System.Text.EncoderFallback\n      description: An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.\n    - id: decoderFallback\n      type: System.Text.DecoderFallback\n      description: An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.\n  overload: System.Text.Encoding.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>codePage</code> is less than zero.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.ASCII\n  commentId: P:System.Text.Encoding.ASCII\n  id: ASCII\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: ASCII\n  nameWithType: Encoding.ASCII\n  fullName: Encoding.ASCII\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets an encoding for the ASCII (7-bit) character set.\n  remarks: \"ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.  \\n  \\n When selecting the ASCII encoding for your app, consider the following:  \\n  \\n-   The ASCII encoding is usually appropriate for protocols that require ASCII.  \\n  \\n-   If you requires 8-bit encoding (which is sometimes incorrectly referred to as \\\"ASCII\\\"), the UTF-8 encoding is recommended over the ASCII encoding. For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable. Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.  \\n  \\n-   Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit. Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.  \\n  \\n The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\\\"?\\\") character. Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \\n  \\n [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]\\n [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]\"\n  example:\n  - \"The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.  \\n  \\n [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]\\n [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]\\n [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding ASCII { get; }\n    return:\n      type: System.Text.Encoding\n      description: An  encoding for the ASCII (7-bit) character set.\n  overload: System.Text.Encoding.ASCII*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.BigEndianUnicode\n  commentId: P:System.Text.Encoding.BigEndianUnicode\n  id: BigEndianUnicode\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: BigEndianUnicode\n  nameWithType: Encoding.BigEndianUnicode\n  fullName: Encoding.BigEndianUnicode\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets an encoding for the UTF-16 format that uses the big endian byte order.\n  remarks: \"The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\\\"?\\\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \\n  \\n [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]\\n [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  \\n  \\n The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name \\\"unicodeFFFE\\\". Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name \\\"unicodeFFFE\\\" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.\"\n  example:\n  - \"The following example reads a text file with a UTF-16 encoding using the big endian byte order.  \\n  \\n [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]\\n [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]\\n [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  \\n  \\n The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding BigEndianUnicode { get; }\n    return:\n      type: System.Text.Encoding\n      description: An encoding object for the UTF-16 format that uses the big endian byte order.\n  overload: System.Text.Encoding.BigEndianUnicode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.BodyName\n  commentId: P:System.Text.Encoding.BodyName\n  id: BodyName\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: BodyName\n  nameWithType: Encoding.BodyName\n  fullName: Encoding.BodyName\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.\n  remarks: \"If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.  \\n  \\n In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.\"\n  example:\n  - \"The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>. It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.  \\n  \\n [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]\\n [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]\"\n  syntax:\n    content: public virtual string BodyName { get; }\n    return:\n      type: System.String\n      description: \"A name for the current <xref href=\\\"System.Text.Encoding\\\"></xref> that can be used with mail agent body tags.  \\n  \\n -or-  \\n  \\n An empty string (\\\"\\\"), if the current <xref href=\\\"System.Text.Encoding\\\"></xref> cannot be used.\"\n  overload: System.Text.Encoding.BodyName*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.Clone\n  commentId: M:System.Text.Encoding.Clone\n  id: Clone\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Clone()\n  nameWithType: Encoding.Clone()\n  fullName: Encoding.Clone()\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, creates a shallow copy of the current <xref href=\"System.Text.Encoding\"></xref> object.\n  remarks: \"The clone is writable even if the original <xref:System.Text.Encoding> object is read-only. Therefore, the properties of the clone can be modified.  \\n  \\n A shallow copy of an object is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects. It refers to the original objects instead. In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public virtual object Clone ();\n    parameters: []\n    return:\n      type: System.Object\n      description: A copy of the current <xref href=\"System.Text.Encoding\"></xref> object.\n  overload: System.Text.Encoding.Clone*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.CodePage\n  commentId: P:System.Text.Encoding.CodePage\n  id: CodePage\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: CodePage\n  nameWithType: Encoding.CodePage\n  fullName: Encoding.CodePage\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets the code page identifier of the current <xref href=\"System.Text.Encoding\"></xref>.\n  remarks: ''\n  example:\n  - \"The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>. It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.  \\n  \\n [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]\\n [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]\"\n  syntax:\n    content: public virtual int CodePage { get; }\n    return:\n      type: System.Int32\n      description: The code page identifier of the current <xref href=\"System.Text.Encoding\"></xref>.\n  overload: System.Text.Encoding.CodePage*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)\n  id: Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Convert(Encoding, Encoding, Byte[], Int32, Int32)\n  nameWithType: Encoding.Convert(Encoding, Encoding, Byte[], Int32, Int32)\n  fullName: Encoding.Convert(Encoding, Encoding, Byte[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Converts a range of bytes in a byte array from one encoding to another.\n  syntax:\n    content: public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);\n    parameters:\n    - id: srcEncoding\n      type: System.Text.Encoding\n      description: The encoding of the source array, <code>bytes</code>.\n    - id: dstEncoding\n      type: System.Text.Encoding\n      description: The encoding of the output array.\n    - id: bytes\n      type: System.Byte[]\n      description: The array of bytes to convert.\n    - id: index\n      type: System.Int32\n      description: The index of the first element of <code>bytes</code> to convert.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to convert.\n    return:\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> containing the result of converting a range of bytes in <code>bytes</code> from <code>srcEncoding</code> to <code>dstEncoding</code>.\n  overload: System.Text.Encoding.Convert*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>srcEncoding</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>dstEncoding</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>index</code> and <code>count</code> do not specify a valid range in the byte array.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n **srcEncoding.** <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n **dstEncoding.** <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\n  commentId: M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\n  id: Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Convert(Encoding, Encoding, Byte[])\n  nameWithType: Encoding.Convert(Encoding, Encoding, Byte[])\n  fullName: Encoding.Convert(Encoding, Encoding, Byte[])\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Converts an entire byte array from one encoding to another.\n  remarks: ''\n  example:\n  - \"The following example converts a Unicode-encoded string to an ASCII-encoded string. Because the ASCII encoding object returned by the <xref:System.Text.Encoding.ASCII%2A> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.  \\n  \\n [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]\\n [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]\"\n  syntax:\n    content: public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);\n    parameters:\n    - id: srcEncoding\n      type: System.Text.Encoding\n      description: The encoding format of <code>bytes</code>.\n    - id: dstEncoding\n      type: System.Text.Encoding\n      description: The target encoding format.\n    - id: bytes\n      type: System.Byte[]\n      description: The bytes to convert.\n    return:\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> containing the results of converting <code>bytes</code> from <code>srcEncoding</code> to <code>dstEncoding</code>.\n  overload: System.Text.Encoding.Convert*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>srcEncoding</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>dstEncoding</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n **srcEncoding.** <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n **dstEncoding.** <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.DecoderFallback\n  commentId: P:System.Text.Encoding.DecoderFallback\n  id: DecoderFallback\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: DecoderFallback\n  nameWithType: Encoding.DecoderFallback\n  fullName: Encoding.DecoderFallback\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets or sets the <xref href=\"System.Text.DecoderFallback\"></xref> object for the current <xref href=\"System.Text.Encoding\"></xref> object.\n  remarks: \"The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character. Any one of the following handler types is supported:  \\n  \\n-   A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.  \\n  \\n-   A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark (\\\"?\\\") character.  \\n  \\n-   An exception fallback handler, which throws an exception when bytes cannot be decoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public System.Text.DecoderFallback DecoderFallback { get; set; }\n    return:\n      type: System.Text.DecoderFallback\n      description: The decoder fallback object for the current <xref href=\"System.Text.Encoding\"></xref> object.\n  overload: System.Text.Encoding.DecoderFallback*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The value in a set operation is `null`.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\"></xref> object is read-only.\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.Default\n  commentId: P:System.Text.Encoding.Default\n  id: Default\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Default\n  nameWithType: Encoding.Default\n  fullName: Encoding.Default\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets an encoding for the operating system's current ANSI code page.\n  remarks: \"> [!WARNING]\\n>  Different computers can use different encodings as the default, and the default encoding can even change on a single computer. Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly. In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page. For these two reasons, using the default encoding is generally not recommended. To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>, with a preamble. Another option is to use a higher-level protocol to ensure that the same format is used for encoding and decoding.  \\n  \\n The system ANSI code page defined by <xref:System.Text.Encoding.Default%2A> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII. Because all <xref:System.Text.Encoding.Default%2A> encodings lose data, you might use <xref:System.Text.Encoding.UTF8%2A> instead. UTF-8 is often identical in the U+00 to U+7F range, but can encode other characters without loss.\"\n  syntax:\n    content: >-\n      [get: System.Security.SecuritySafeCritical]\n\n      public static System.Text.Encoding Default { get; }\n    return:\n      type: System.Text.Encoding\n      description: An encoding for the operating system's current ANSI code page.\n  overload: System.Text.Encoding.Default*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Security.SecuritySafeCritical'\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.EncoderFallback\n  commentId: P:System.Text.Encoding.EncoderFallback\n  id: EncoderFallback\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: EncoderFallback\n  nameWithType: Encoding.EncoderFallback\n  fullName: Encoding.EncoderFallback\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets or sets the <xref href=\"System.Text.EncoderFallback\"></xref> object for the current <xref href=\"System.Text.Encoding\"></xref> object.\n  remarks: \"The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence. Any one of the following handler types is supported:  \\n  \\n-   A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.  \\n  \\n-   A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark (\\\"?\\\") character.  \\n  \\n-   An exception fallback handler, which throws an exception when characters cannot be encoded. The .NET Framework includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public System.Text.EncoderFallback EncoderFallback { get; set; }\n    return:\n      type: System.Text.EncoderFallback\n      description: The encoder fallback object for the current <xref href=\"System.Text.Encoding\"></xref> object.\n  overload: System.Text.Encoding.EncoderFallback*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The value in a set operation is `null`.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\"></xref> object is read-only.\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.EncodingName\n  commentId: P:System.Text.Encoding.EncodingName\n  id: EncodingName\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: EncodingName\n  nameWithType: Encoding.EncodingName\n  fullName: Encoding.EncodingName\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets the human-readable description of the current encoding.\n  remarks: The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display. To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.\n  example:\n  - \"The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>. It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.  \\n  \\n [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]\\n [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]\"\n  syntax:\n    content: public virtual string EncodingName { get; }\n    return:\n      type: System.String\n      description: The human-readable description of the current <xref href=\"System.Text.Encoding\"></xref>.\n  overload: System.Text.Encoding.EncodingName*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.Equals(System.Object)\n  commentId: M:System.Text.Encoding.Equals(System.Object)\n  id: Equals(System.Object)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Equals(Object)\n  nameWithType: Encoding.Equals(Object)\n  fullName: Encoding.Equals(Object)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Determines whether the specified <xref href=\"System.Object\"></xref> is equal to the current instance.\n  remarks: Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal. In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET). Thus they are all considered equal to one another. One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.\n  example:\n  - \"The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.  \\n  \\n [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]\\n [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]\"\n  syntax:\n    content: public override bool Equals (object value);\n    parameters:\n    - id: value\n      type: System.Object\n      description: The <xref href=\"System.Object\"></xref> to compare with the current instance.\n    return:\n      type: System.Boolean\n      description: '`true` if <code>value</code> is an instance of <xref href=\"System.Text.Encoding\"></xref> and is equal to the current instance; otherwise, `false`.'\n  overload: System.Text.Encoding.Equals*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)\n  id: GetByteCount(System.String,System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetByteCount(String, Int32, Int32)\n  nameWithType: Encoding.GetByteCount(String, Int32, Int32)\n  fullName: Encoding.GetByteCount(String, Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  namespace: System.Text\n  syntax:\n    content: public int GetByteCount (string s, int index, int count);\n    parameters:\n    - id: s\n      type: System.String\n      description: ''\n    - id: index\n      type: System.Int32\n      description: ''\n    - id: count\n      type: System.Int32\n      description: ''\n    return:\n      type: System.Int32\n      description: ''\n  overload: System.Text.Encoding.GetByteCount*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  id: GetByteCount(System.Char[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetByteCount(Char[], Int32, Int32)\n  nameWithType: Encoding.GetByteCount(Char[], Int32, Int32)\n  fullName: Encoding.GetByteCount(Char[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \\n  \\n-   If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]\"\n  syntax:\n    content: public abstract int GetByteCount (char[] chars, int index, int count);\n    parameters:\n    - id: chars\n      type: System.Char[]\n      description: The character array containing the set of characters to encode.\n    - id: index\n      type: System.Int32\n      description: The index of the first character to encode.\n    - id: count\n      type: System.Int32\n      description: The number of characters to encode.\n    return:\n      type: System.Int32\n      description: The number of bytes produced by encoding the specified characters.\n  overload: System.Text.Encoding.GetByteCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>chars</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetByteCount(System.Char[])\n  commentId: M:System.Text.Encoding.GetByteCount(System.Char[])\n  id: GetByteCount(System.Char[])\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetByteCount(Char[])\n  nameWithType: Encoding.GetByteCount(Char[])\n  fullName: Encoding.GetByteCount(Char[])\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \\n  \\n-   If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, you should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]\"\n  syntax:\n    content: public virtual int GetByteCount (char[] chars);\n    parameters:\n    - id: chars\n      type: System.Char[]\n      description: The character array containing the characters to encode.\n    return:\n      type: System.Int32\n      description: The number of bytes produced by encoding all the characters in the specified character array.\n  overload: System.Text.Encoding.GetByteCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>chars</code> is `null`.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetByteCount(System.String)\n  commentId: M:System.Text.Encoding.GetByteCount(System.String)\n  id: GetByteCount(System.String)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetByteCount(String)\n  nameWithType: Encoding.GetByteCount(String)\n  fullName: Encoding.GetByteCount(String)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \\n  \\n-   If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]\"\n  syntax:\n    content: public virtual int GetByteCount (string s);\n    parameters:\n    - id: s\n      type: System.String\n      description: The string containing the set of characters to encode.\n    return:\n      type: System.Int32\n      description: The number of bytes produced by encoding the specified characters.\n  overload: System.Text.Encoding.GetByteCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>s</code> is `null`.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetByteCount(System.Char*,System.Int32)\n  commentId: M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)\n  id: GetByteCount(System.Char*,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetByteCount(Char*, Int32)\n  nameWithType: Encoding.GetByteCount(Char*, Int32)\n  fullName: Encoding.GetByteCount(Char*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.\n  remarks: \"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some considerations for using these methods:  \\n  \\n-   Your app may need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.  \\n  \\n-   If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      [System.Security.SecurityCritical]\n\n      public virtual int GetByteCount (char* chars, int count);\n    parameters:\n    - id: chars\n      type: System.Char*\n      description: A pointer to the first character to encode.\n    - id: count\n      type: System.Int32\n      description: The number of characters to encode.\n    return:\n      type: System.Int32\n      description: The number of bytes produced by encoding the specified characters.\n  overload: System.Text.Encoding.GetByteCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>chars</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>count</code> is less than zero.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetBytes(System.Char[])\n  commentId: M:System.Text.Encoding.GetBytes(System.Char[])\n  id: GetBytes(System.Char[])\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetBytes(Char[])\n  nameWithType: Encoding.GetBytes(Char[])\n  fullName: Encoding.GetBytes(Char[])\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.\n  remarks: \"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \\n  \\n-   If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]\"\n  syntax:\n    content: public virtual byte[] GetBytes (char[] chars);\n    parameters:\n    - id: chars\n      type: System.Char[]\n      description: The character array containing the characters to encode.\n    return:\n      type: System.Byte[]\n      description: A byte array containing the results of encoding the specified set of characters.\n  overload: System.Text.Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>chars</code> is `null`.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetBytes(System.String)\n  commentId: M:System.Text.Encoding.GetBytes(System.String)\n  id: GetBytes(System.String)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetBytes(String)\n  nameWithType: Encoding.GetBytes(String)\n  fullName: Encoding.GetBytes(String)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.\n  remarks: \"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \\n  \\n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]\"\n  syntax:\n    content: public virtual byte[] GetBytes (string s);\n    parameters:\n    - id: s\n      type: System.String\n      description: The string containing the characters to encode.\n    return:\n      type: System.Byte[]\n      description: A byte array containing the results of encoding the specified set of characters.\n  overload: System.Text.Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>s</code> is `null`.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)\n  id: GetBytes(System.Char[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetBytes(Char[], Int32, Int32)\n  nameWithType: Encoding.GetBytes(Char[], Int32, Int32)\n  fullName: Encoding.GetBytes(Char[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.\n  remarks: \"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \\n  \\n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]\"\n  syntax:\n    content: public virtual byte[] GetBytes (char[] chars, int index, int count);\n    parameters:\n    - id: chars\n      type: System.Char[]\n      description: The character array containing the set of characters to encode.\n    - id: index\n      type: System.Int32\n      description: The index of the first character to encode.\n    - id: count\n      type: System.Int32\n      description: The number of characters to encode.\n    return:\n      type: System.Byte[]\n      description: A byte array containing the results of encoding the specified set of characters.\n  overload: System.Text.Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>chars</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)\n  id: GetBytes(System.String,System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetBytes(String, Int32, Int32)\n  nameWithType: Encoding.GetBytes(String, Int32, Int32)\n  fullName: Encoding.GetBytes(String, Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  namespace: System.Text\n  syntax:\n    content: public byte[] GetBytes (string s, int index, int count);\n    parameters:\n    - id: s\n      type: System.String\n      description: ''\n    - id: index\n      type: System.Int32\n      description: ''\n    - id: count\n      type: System.Int32\n      description: ''\n    return:\n      type: System.Byte[]\n      description: ''\n  overload: System.Text.Encoding.GetBytes*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  commentId: M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  id: GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetBytes(Char*, Int32, Byte*, Int32)\n  nameWithType: Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n  fullName: Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.\n  remarks: \"To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \\n  \\n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      [System.Security.SecurityCritical]\n\n      public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);\n    parameters:\n    - id: chars\n      type: System.Char*\n      description: A pointer to the first character to encode.\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    - id: bytes\n      type: System.Byte*\n      description: A pointer to the location at which to start writing the resulting sequence of bytes.\n    - id: byteCount\n      type: System.Int32\n      description: The maximum number of bytes to write.\n    return:\n      type: System.Int32\n      description: The actual number of bytes written at the location indicated by the <code>bytes</code> parameter.\n  overload: System.Text.Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>chars</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>charCount</code> or <code>byteCount</code> is less than zero.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>byteCount</code> is less than the resulting number of bytes.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  commentId: M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  id: GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  nameWithType: Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  fullName: Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \\n  \\n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]\"\n  syntax:\n    content: public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);\n    parameters:\n    - id: chars\n      type: System.Char[]\n      description: The character array containing the set of characters to encode.\n    - id: charIndex\n      type: System.Int32\n      description: The index of the first character to encode.\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array to contain the resulting sequence of bytes.\n    - id: byteIndex\n      type: System.Int32\n      description: The index at which to start writing the resulting sequence of bytes.\n    return:\n      type: System.Int32\n      description: The actual number of bytes written into <code>bytes</code>.\n  overload: System.Text.Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>chars</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \\n  \\n -or-  \\n  \\n <code>byteIndex</code> is not a valid index in <code>bytes</code>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  commentId: M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  id: GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetBytes(String, Int32, Int32, Byte[], Int32)\n  nameWithType: Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n  fullName: Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding. The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method, which handles multiple conversions on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)  \\n  \\n-   If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.  \\n  \\n-   The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetByteCount%2A>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]\"\n  syntax:\n    content: public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);\n    parameters:\n    - id: s\n      type: System.String\n      description: The string containing the set of characters to encode.\n    - id: charIndex\n      type: System.Int32\n      description: The index of the first character to encode.\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array to contain the resulting sequence of bytes.\n    - id: byteIndex\n      type: System.Int32\n      description: The index at which to start writing the resulting sequence of bytes.\n    return:\n      type: System.Int32\n      description: The actual number of bytes written into <code>bytes</code>.\n  overload: System.Text.Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>s</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \\n  \\n -or-  \\n  \\n <code>byteIndex</code> is not a valid index in <code>bytes</code>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetCharCount(System.Byte[])\n  commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])\n  id: GetCharCount(System.Byte[])\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetCharCount(Byte[])\n  nameWithType: Encoding.GetCharCount(Byte[])\n  fullName: Encoding.GetCharCount(Byte[])\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method. To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method. The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.  \\n  \\n-   If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \\n  \\n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]\\n [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]\"\n  syntax:\n    content: public virtual int GetCharCount (byte[] bytes);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    return:\n      type: System.Int32\n      description: The number of characters produced by decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetCharCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)\n  commentId: M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)\n  id: GetCharCount(System.Byte*,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetCharCount(Byte*, Int32)\n  nameWithType: Encoding.GetCharCount(Byte*, Int32)\n  fullName: Encoding.GetCharCount(Byte*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.\n  remarks: \"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.  \\n  \\n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \\n  \\n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      [System.Security.SecurityCritical]\n\n      public virtual int GetCharCount (byte* bytes, int count);\n    parameters:\n    - id: bytes\n      type: System.Byte*\n      description: A pointer to the first byte to decode.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.Int32\n      description: The number of characters produced by decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetCharCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>count</code> is less than zero.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  id: GetCharCount(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetCharCount(Byte[], Int32, Int32)\n  nameWithType: Encoding.GetCharCount(Byte[], Int32, Int32)\n  fullName: Encoding.GetCharCount(Byte[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.  \\n  \\n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \\n  \\n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example converts a string from one encoding to another.  \\n  \\n [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]\\n [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  \\n  \\n The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]\\n [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]\"\n  syntax:\n    content: public abstract int GetCharCount (byte[] bytes, int index, int count);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    - id: index\n      type: System.Int32\n      description: The index of the first byte to decode.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.Int32\n      description: The number of characters produced by decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetCharCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.\"\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  commentId: M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  id: GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetChars(Byte[], Int32, Int32, Char[], Int32)\n  nameWithType: Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n  fullName: Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \\n  \\n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%2A> call. [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \\n  \\n-   If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \\n  \\n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example converts a string from one encoding to another.  \\n  \\n [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]\\n [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  \\n  \\n The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]\\n [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]\"\n  syntax:\n    content: public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    - id: byteIndex\n      type: System.Int32\n      description: The index of the first byte to decode.\n    - id: byteCount\n      type: System.Int32\n      description: The number of bytes to decode.\n    - id: chars\n      type: System.Char[]\n      description: The character array to contain the resulting set of characters.\n    - id: charIndex\n      type: System.Int32\n      description: The index at which to start writing the resulting set of characters.\n    return:\n      type: System.Int32\n      description: The actual number of characters written into <code>chars</code>.\n  overload: System.Text.Encoding.GetChars*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>bytes</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>chars</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>byteIndex</code> or <code>byteCount</code> or <code>charIndex</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>byteindex</code> and <code>byteCount</code> do not denote a valid range in <code>bytes</code>.  \\n  \\n -or-  \\n  \\n <code>charIndex</code> is not a valid index in <code>chars</code>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>chars</code> does not have enough capacity from <code>charIndex</code> to the end of the array to accommodate the resulting characters.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  commentId: M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  id: GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetChars(Byte*, Int32, Char*, Int32)\n  nameWithType: Encoding.GetChars(Byte*, Int32, Char*, Int32)\n  fullName: Encoding.GetChars(Byte*, Int32, Char*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.\n  remarks: \"To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \\n  \\n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \\n  \\n-   If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \\n  \\n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      [System.Security.SecurityCritical]\n\n      public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);\n    parameters:\n    - id: bytes\n      type: System.Byte*\n      description: A pointer to the first byte to decode.\n    - id: byteCount\n      type: System.Int32\n      description: The number of bytes to decode.\n    - id: chars\n      type: System.Char*\n      description: A pointer to the location at which to start writing the resulting set of characters.\n    - id: charCount\n      type: System.Int32\n      description: The maximum number of characters to write.\n    return:\n      type: System.Int32\n      description: The actual number of characters written at the location indicated by the <code>chars</code> parameter.\n  overload: System.Text.Encoding.GetChars*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>bytes</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>chars</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>byteCount</code> or <code>charCount</code> is less than zero.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>charCount</code> is less than the resulting number of characters.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\n  id: GetChars(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetChars(Byte[], Int32, Int32)\n  nameWithType: Encoding.GetChars(Byte[], Int32, Int32)\n  fullName: Encoding.GetChars(Byte[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.\n  remarks: \"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \\n  \\n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \\n  \\n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \\n  \\n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]\\n [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]\"\n  syntax:\n    content: public virtual char[] GetChars (byte[] bytes, int index, int count);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    - id: index\n      type: System.Int32\n      description: The index of the first byte to decode.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.Char[]\n      description: A character array containing the results of decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetChars*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.\"\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetChars(System.Byte[])\n  commentId: M:System.Text.Encoding.GetChars(System.Byte[])\n  id: GetChars(System.Byte[])\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetChars(Byte[])\n  nameWithType: Encoding.GetChars(Byte[])\n  fullName: Encoding.GetChars(Byte[])\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.\n  remarks: \"<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> gets characters from an input byte sequence. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n **Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  \\n  \\n The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding. The <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method, which handles multiple passes on a single input stream.  \\n  \\n Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported. The following are some programming considerations for use of these methods:  \\n  \\n-   Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call. <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)  \\n  \\n-   If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.  \\n  \\n-   The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.  \\n  \\n-   If your app must convert a large amount of data, it should reuse the output buffer. In this case, the [\\\\], Int32, Int32, Char\\\\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.  \\n  \\n-   Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method instead of <xref:System.Text.Encoding.GetCharCount%2A>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.\"\n  example:\n  - \"The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]\\n [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]\"\n  syntax:\n    content: public virtual char[] GetChars (byte[] bytes);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    return:\n      type: System.Char[]\n      description: A character array containing the results of decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetChars*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetDecoder\n  commentId: M:System.Text.Encoding.GetDecoder\n  id: GetDecoder\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetDecoder()\n  nameWithType: Encoding.GetDecoder()\n  fullName: Encoding.GetDecoder()\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.\n  remarks: The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class. However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.\n  syntax:\n    content: public virtual System.Text.Decoder GetDecoder ();\n    parameters: []\n    return:\n      type: System.Text.Decoder\n      description: A <xref href=\"System.Text.Decoder\"></xref> that converts an encoded sequence of bytes into a sequence of characters.\n  overload: System.Text.Encoding.GetDecoder*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetEncoder\n  commentId: M:System.Text.Encoding.GetEncoder\n  id: GetEncoder\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetEncoder()\n  nameWithType: Encoding.GetEncoder()\n  fullName: Encoding.GetEncoder()\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.\n  remarks: The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class. However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.\n  syntax:\n    content: public virtual System.Text.Encoder GetEncoder ();\n    parameters: []\n    return:\n      type: System.Text.Encoder\n      description: A <xref href=\"System.Text.Encoder\"></xref> that converts a sequence of Unicode characters into an encoded sequence of bytes.\n  overload: System.Text.Encoding.GetEncoder*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetEncoding(System.Int32)\n  commentId: M:System.Text.Encoding.GetEncoding(System.Int32)\n  id: GetEncoding(System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetEncoding(Int32)\n  nameWithType: Encoding.GetEncoding(Int32)\n  fullName: Encoding.GetEncoding(Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Returns the encoding associated with the specified code page identifier.\n  remarks: \"The fallback handler depends on the encoding type of `codepage`. If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.  \\n  \\n The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings. For a list of code pages, see the <xref:System.Text.Encoding> class topic. Alternatively, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all encodings.  \\n  \\n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \\n  \\n To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value 0 for the `codepage` argument or, on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A> property. To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function. To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop.  \\n  \\n> [!NOTE]\\n>  Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.  \\n  \\n> [!NOTE]\\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \\n  \\n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.\"\n  example:\n  - \"The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.  \\n  \\n [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]\\n [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding GetEncoding (int codepage);\n    parameters:\n    - id: codepage\n      type: System.Int32\n      description: \"The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\\\"System.Text.Encoding\\\"></xref> class topic.  \\n  \\n -or-  \\n  \\n 0 (zero), to use the default encoding.\"\n    return:\n      type: System.Text.Encoding\n      description: The encoding that is associated with the specified code page.\n  overload: System.Text.Encoding.GetEncoding*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>codepage</code> is less than zero or greater than 65535.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>codepage</code> is not supported by the underlying platform.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: <code>codepage</code> is not supported by the underlying platform.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetEncoding(System.String)\n  commentId: M:System.Text.Encoding.GetEncoding(System.String)\n  id: GetEncoding(System.String)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetEncoding(String)\n  nameWithType: Encoding.GetEncoding(String)\n  fullName: Encoding.GetEncoding(String)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Returns the encoding associated with the specified code page name.\n  remarks: \"The fallback handler depends on the encoding type of `name`. If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.  \\n  \\n The `GetEncoding` method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.  \\n  \\n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.String%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \\n  \\n> [!NOTE]\\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \\n  \\n For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.  \\n  \\n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.\"\n  example:\n  - \"The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.  \\n  \\n [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]\\n [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding GetEncoding (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.\n    return:\n      type: System.Text.Encoding\n      description: The encoding  associated with the specified code page.\n  overload: System.Text.Encoding.GetEncoding*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is not a valid code page name.  \\n  \\n -or-  \\n  \\n The code page indicated by <code>name</code> is not supported by the underlying platform.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  commentId: M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  id: GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetEncoding(Int32, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)\n  fullName: Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.\n  remarks: \"> [!NOTE]\\n>  Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>. Therefore, your code must catch all exceptions indicated in the Exceptions section.  \\n  \\n The <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.  \\n  \\n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \\n  \\n> [!NOTE]\\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \\n  \\n For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method in the full .NET Framework on the Windows desktop to get a list of all encodings.  \\n  \\n To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=fullName> property. To determine the default code pages used on the system, use the Windows [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) function. To determine the current ANSI code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the full .NET Framework on the Windows desktop.  \\n  \\n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.\"\n  example:\n  - \"The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=fullName> method.  \\n  \\n [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]\\n [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]\\n [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);\n    parameters:\n    - id: codepage\n      type: System.Int32\n      description: \"The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\\\"System.Text.Encoding\\\"></xref> class topic.  \\n  \\n -or-  \\n  \\n 0 (zero), to use the default encoding.\"\n    - id: encoderFallback\n      type: System.Text.EncoderFallback\n      description: An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.\n    - id: decoderFallback\n      type: System.Text.DecoderFallback\n      description: An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.\n    return:\n      type: System.Text.Encoding\n      description: The encoding that is associated with the specified code page.\n  overload: System.Text.Encoding.GetEncoding*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>codepage</code> is less than zero or greater than 65535.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>codepage</code> is not supported by the underlying platform.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: <code>codepage</code> is not supported by the underlying platform.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  commentId: M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  id: GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetEncoding(String, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)\n  fullName: Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.\n  remarks: \"The `GetEncoding` method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.  \\n  \\n In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.  \\n  \\n> [!NOTE]\\n>  The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.  \\n  \\n For a list of code pages, see the <xref:System.Text.Encoding> class topic. You can call the <xref:System.Text.Encoding.GetEncodings%2A> method on the full .NET Framework on the Windows desktop to get a list of all encodings.  \\n  \\n <xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.\"\n  example:\n  - \"The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=fullName> method.  \\n  \\n [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]\\n [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]\\n [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);\n    parameters:\n    - id: name\n      type: System.String\n      description: The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\"></xref> class topic.\n    - id: encoderFallback\n      type: System.Text.EncoderFallback\n      description: An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.\n    - id: decoderFallback\n      type: System.Text.DecoderFallback\n      description: An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.\n    return:\n      type: System.Text.Encoding\n      description: The encoding that is associated with the specified code page.\n  overload: System.Text.Encoding.GetEncoding*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is not a valid code page name.  \\n  \\n -or-  \\n  \\n The code page indicated by <code>name</code> is not supported by the underlying platform.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetEncodings\n  commentId: M:System.Text.Encoding.GetEncodings\n  id: GetEncodings\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetEncodings()\n  nameWithType: Encoding.GetEncodings()\n  fullName: Encoding.GetEncodings()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Returns an array that contains all encodings.\n  remarks: \"This method returns a list of supported encodings, uniquely distinguished by code page. For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.  \\n  \\n> [!NOTE]\\n>  The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.  \\n  \\n Encodings 50220 and 50222 are both associated with the name \\\"iso-2022-jp\\\", but they are not identical. Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters. The display name for encoding 50222 is \\\"Japanese (JIS-Allow 1 byte Kana - SO/SI)\\\" to distinguish it from encoding 50220, which has the display name \\\"Japanese (JIS)\\\".  \\n  \\n If you request the encoding name \\\"iso-2022-jp\\\", the .NET Framework returns encoding 50220. However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.  \\n  \\n To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.  \\n  \\n <xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box. However, many non-Unicode encodings are either incomplete and translate many characters to \\\"?\\\", or have subtly different behavior on different platforms. Consider using UTF-8 or UTF-16 as the default.\"\n  example:\n  - \"The following example checks the values of the Boolean properties of each encoding.  \\n  \\n [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]\\n [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]\\n [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]\"\n  syntax:\n    content: public static System.Text.EncodingInfo[] GetEncodings ();\n    parameters: []\n    return:\n      type: System.Text.EncodingInfo[]\n      description: An array that contains all encodings.\n  overload: System.Text.Encoding.GetEncodings*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetHashCode\n  commentId: M:System.Text.Encoding.GetHashCode\n  id: GetHashCode\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetHashCode()\n  nameWithType: Encoding.GetHashCode()\n  fullName: Encoding.GetHashCode()\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Returns the hash code for the current instance.\n  syntax:\n    content: public override int GetHashCode ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: The hash code for the current instance.\n  overload: System.Text.Encoding.GetHashCode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetMaxByteCount(System.Int32)\n  commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)\n  id: GetMaxByteCount(System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetMaxByteCount(Int32)\n  nameWithType: Encoding.GetMaxByteCount(Int32)\n  fullName: Encoding.GetMaxByteCount(Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.\n  remarks: \"The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters. Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.  \\n  \\n To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character. For example, this can happen for ISO-2022-JP. For more information, see the blog entry \\\"[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)\\\" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  \\n  \\n In most cases, this method retrieves reasonable values for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.  \\n  \\n When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.  \\n  \\n Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation. Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII. You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.  \\n  \\n> [!NOTE]\\n>  `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]\"\n  syntax:\n    content: public abstract int GetMaxByteCount (int charCount);\n    parameters:\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    return:\n      type: System.Int32\n      description: The maximum number of bytes produced by encoding the specified number of characters.\n  overload: System.Text.Encoding.GetMaxByteCount*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>charCount</code> is less than zero.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetMaxCharCount(System.Int32)\n  commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)\n  id: GetMaxCharCount(System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetMaxCharCount(Int32)\n  nameWithType: Encoding.GetMaxCharCount(Int32)\n  fullName: Encoding.GetMaxCharCount(Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method. To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.  \\n  \\n In most cases, this method retrieves reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small. You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName>.  \\n  \\n <xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>. If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.  \\n  \\n When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> method.  \\n  \\n Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation. For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.  \\n  \\n> [!NOTE]\\n>  `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.\"\n  example:\n  - \"The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]\\n [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]\"\n  syntax:\n    content: public abstract int GetMaxCharCount (int byteCount);\n    parameters:\n    - id: byteCount\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.Int32\n      description: The maximum number of characters produced by decoding the specified number of bytes.\n  overload: System.Text.Encoding.GetMaxCharCount*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>byteCount</code> is less than zero.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetPreamble\n  commentId: M:System.Text.Encoding.GetPreamble\n  id: GetPreamble\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetPreamble()\n  nameWithType: Encoding.GetPreamble()\n  fullName: Encoding.GetPreamble()\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.\n  remarks: \"Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.  \\n  \\n The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):  \\n  \\n-   UTF-8: EF BB BF  \\n  \\n-   UTF-16 big endian byte order: FE FF  \\n  \\n-   UTF-16 little endian byte order: FF FE  \\n  \\n-   UTF-32 big endian byte order: 00 00 FE FF  \\n  \\n-   UTF-32 little endian byte order: FF FE 00 00  \\n  \\n You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data. Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.  \\n  \\n For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.  \\n  \\n There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.  \\n  \\n For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).  \\n  \\n> [!CAUTION]\\n>  To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. However, most encodings do not provide a preamble. To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.\"\n  example:\n  - \"The following example determines the byte order of the encoding based on the preamble.  \\n  \\n [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]\\n [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]\"\n  syntax:\n    content: public virtual byte[] GetPreamble ();\n    parameters: []\n    return:\n      type: System.Byte[]\n      description: \"A byte array containing a sequence of bytes that specifies the encoding used.  \\n  \\n -or-  \\n  \\n A byte array of length zero, if a preamble is not required.\"\n  overload: System.Text.Encoding.GetPreamble*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetString(System.Byte[])\n  commentId: M:System.Text.Encoding.GetString(System.Byte[])\n  id: GetString(System.Byte[])\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetString(Byte[])\n  nameWithType: Encoding.GetString(Byte[])\n  fullName: Encoding.GetString(Byte[])\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, decodes all the bytes in the specified byte array into a string.\n  remarks: \"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.  \\n  \\n See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.  \\n  \\n Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object. For more information, see the \\\"Choosing a Fallback Strategy\\\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic.\"\n  example:\n  - \"The following example reads a UTF-8 encoded string from a binary file represented by a <xref:System.IO.FileStream> object. For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> method to perform the decoding. For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=fullName> method to perform the decoding.  \\n  \\n [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]\\n [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  \\n  \\n The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.  \\n  \\n```  \\n  \\nThis is a UTF-8-encoded file that contains primarily Latin text, although it   \\ndoes list the first twelve letters of the Russian (Cyrillic) alphabet:  \\n  \\nА б в г д е ё ж з и й к  \\n  \\nThe goal is to save this file, then open and decode it as a binary stream.  \\n  \\n```\"\n  syntax:\n    content: public virtual string GetString (byte[] bytes);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    return:\n      type: System.String\n      description: A string that contains the results of decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetString*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The byte array contains invalid Unicode code points.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetString(System.Byte*,System.Int32)\n  commentId: M:System.Text.Encoding.GetString(System.Byte*,System.Int32)\n  id: GetString(System.Byte*,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetString(Byte*, Int32)\n  nameWithType: Encoding.GetString(Byte*, Int32)\n  fullName: Encoding.GetString(Byte*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.\n  remarks: \"The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array. Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.  \\n  \\n If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.  \\n  \\n See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.  \\n  \\n Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object. For more information, see the \\\"Choosing a Fallback Strategy\\\" section of the [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) topic.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      [System.Security.SecurityCritical]\n\n      public string GetString (byte* bytes, int byteCount);\n    parameters:\n    - id: bytes\n      type: System.Byte*\n      description: A pointer to a byte array.\n    - id: byteCount\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.String\n      description: A string that contains the results of decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetString*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is a null pointer.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>byteCount</code> is less than zero.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A   fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  commentId: M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  id: GetString(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: GetString(Byte[], Int32, Int32)\n  nameWithType: Encoding.GetString(Byte[], Int32, Int32)\n  fullName: Encoding.GetString(Byte[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.\n  remarks: \"If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  \\n  \\n See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> reference topic for a discussion of decoding techniques and considerations.\"\n  example:\n  - \"The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref:System.IO.FileStream> object. For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to perform the decoding. For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=fullName> method to perform the decoding.  \\n  \\n [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]\\n [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  \\n  \\n The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.  \\n  \\n```  \\n  \\nThis is a UTF-8-encoded file that contains primarily Latin text, although it   \\ndoes list the first twelve letters of the Russian (Cyrillic) alphabet:  \\n  \\nА б в г д е ё ж з и й к  \\n  \\nThe goal is to save this file, then open and decode it as a binary stream.  \\n  \\n```\"\n  syntax:\n    content: public virtual string GetString (byte[] bytes, int index, int count);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    - id: index\n      type: System.Int32\n      description: The index of the first byte to decode.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.String\n      description: A string that contains the results of decoding the specified sequence of bytes.\n  overload: System.Text.Encoding.GetString*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The byte array contains invalid Unicode code points.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.\"\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.HeaderName\n  commentId: P:System.Text.Encoding.HeaderName\n  id: HeaderName\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: HeaderName\n  nameWithType: Encoding.HeaderName\n  fullName: Encoding.HeaderName\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.\n  remarks: \"If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding.  \\n  \\n In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.  \\n  \\n Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an e-mail application, for example. However, use of the property to define the encoding is not recommended.\"\n  example:\n  - \"The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>. It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.  \\n  \\n [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]\\n [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]\"\n  syntax:\n    content: public virtual string HeaderName { get; }\n    return:\n      type: System.String\n      description: \"A name for the current <xref href=\\\"System.Text.Encoding\\\"></xref> to use with mail agent header tags.  \\n  \\n -or-  \\n  \\n An empty string (\\\"\\\"), if the current <xref href=\\\"System.Text.Encoding\\\"></xref> cannot be used.\"\n  overload: System.Text.Encoding.HeaderName*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsAlwaysNormalized\n  commentId: M:System.Text.Encoding.IsAlwaysNormalized\n  id: IsAlwaysNormalized\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsAlwaysNormalized()\n  nameWithType: Encoding.IsAlwaysNormalized()\n  fullName: Encoding.IsAlwaysNormalized()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets a value indicating whether the current encoding is always normalized, using the default normalization form.\n  remarks: The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public bool IsAlwaysNormalized ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> is always normalized; otherwise, `false`. The default is `false`.'\n  overload: System.Text.Encoding.IsAlwaysNormalized*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)\n  commentId: M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)\n  id: IsAlwaysNormalized(System.Text.NormalizationForm)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsAlwaysNormalized(NormalizationForm)\n  nameWithType: Encoding.IsAlwaysNormalized(NormalizationForm)\n  fullName: Encoding.IsAlwaysNormalized(NormalizationForm)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.\n  remarks: The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);\n    parameters:\n    - id: form\n      type: System.Text.NormalizationForm\n      description: One of the <xref href=\"System.Text.NormalizationForm\"></xref> values.\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> object is always normalized using the specified <xref href=\"System.Text.NormalizationForm\"></xref> value; otherwise, `false`. The default is `false`.'\n  overload: System.Text.Encoding.IsAlwaysNormalized*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsBrowserDisplay\n  commentId: P:System.Text.Encoding.IsBrowserDisplay\n  id: IsBrowserDisplay\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsBrowserDisplay\n  nameWithType: Encoding.IsBrowserDisplay\n  fullName: Encoding.IsBrowserDisplay\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.\n  remarks: ''\n  example:\n  - \"The following example checks the values of the Boolean properties of each encoding.  \\n  \\n [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]\\n [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]\\n [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]\"\n  syntax:\n    content: public virtual bool IsBrowserDisplay { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by browser clients for displaying content; otherwise, `false`.'\n  overload: System.Text.Encoding.IsBrowserDisplay*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsBrowserSave\n  commentId: P:System.Text.Encoding.IsBrowserSave\n  id: IsBrowserSave\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsBrowserSave\n  nameWithType: Encoding.IsBrowserSave\n  fullName: Encoding.IsBrowserSave\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.\n  remarks: ''\n  example:\n  - \"The following example checks the values of the Boolean properties of each encoding.  \\n  \\n [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]\\n [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]\\n [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]\"\n  syntax:\n    content: public virtual bool IsBrowserSave { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by browser clients for saving content; otherwise, `false`.'\n  overload: System.Text.Encoding.IsBrowserSave*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsMailNewsDisplay\n  commentId: P:System.Text.Encoding.IsMailNewsDisplay\n  id: IsMailNewsDisplay\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsMailNewsDisplay\n  nameWithType: Encoding.IsMailNewsDisplay\n  fullName: Encoding.IsMailNewsDisplay\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.\n  remarks: ''\n  example:\n  - \"The following example checks the values of the Boolean properties of each encoding.  \\n  \\n [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]\\n [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]\\n [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]\"\n  syntax:\n    content: public virtual bool IsMailNewsDisplay { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by mail and news clients for displaying content; otherwise, `false`.'\n  overload: System.Text.Encoding.IsMailNewsDisplay*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsMailNewsSave\n  commentId: P:System.Text.Encoding.IsMailNewsSave\n  id: IsMailNewsSave\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsMailNewsSave\n  nameWithType: Encoding.IsMailNewsSave\n  fullName: Encoding.IsMailNewsSave\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.\n  remarks: ''\n  example:\n  - \"The following example checks the values of the Boolean properties of each encoding.  \\n  \\n [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]\\n [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]\\n [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]\"\n  syntax:\n    content: public virtual bool IsMailNewsSave { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> can be used by mail and news clients for saving content; otherwise, `false`.'\n  overload: System.Text.Encoding.IsMailNewsSave*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsReadOnly\n  commentId: P:System.Text.Encoding.IsReadOnly\n  id: IsReadOnly\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsReadOnly\n  nameWithType: Encoding.IsReadOnly\n  fullName: Encoding.IsReadOnly\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a value indicating whether the current encoding is read-only.\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public bool IsReadOnly { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> is read-only; otherwise, `false`. The default is `true`.'\n  overload: System.Text.Encoding.IsReadOnly*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.IsSingleByte\n  commentId: P:System.Text.Encoding.IsSingleByte\n  id: IsSingleByte\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: IsSingleByte\n  nameWithType: Encoding.IsSingleByte\n  fullName: Encoding.IsSingleByte\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.\n  remarks: \"For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.  \\n  \\n> [!CAUTION]\\n>  You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>. An assumption of how an Encoding will proceed may still be wrong. For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName>, but Encoding.GetMaxByteCount(1) returns 2. This is because the method considers potential leftover surrogates from a previous decoder operation.\"\n  example:\n  - \"The following example checks the values of the Boolean properties of each encoding.  \\n  \\n [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]\\n [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]\\n [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public virtual bool IsSingleByte { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Text.Encoding\"></xref> uses single-byte code points; otherwise, `false`.'\n  overload: System.Text.Encoding.IsSingleByte*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\n  commentId: M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\n  id: RegisterProvider(System.Text.EncodingProvider)\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: RegisterProvider(EncodingProvider)\n  nameWithType: Encoding.RegisterProvider(EncodingProvider)\n  fullName: Encoding.RegisterProvider(EncodingProvider)\n  type: Method\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Registers an encoding provider.\n  remarks: \"The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them. Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName> overload.  \\n  \\n [!INCLUDE[net_v46](~/includes/net-v46-md.md)] includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. By default, [!INCLUDE[net_v46](~/includes/net-v46-md.md)] only supports the Unicode encodings, ASCII, and code page 28591.  \\n  \\n If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider. Subsequent calls are ignored.  \\n  \\n If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations. Any previously registered providers are ignored.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void RegisterProvider (System.Text.EncodingProvider provider);\n    parameters:\n    - id: provider\n      type: System.Text.EncodingProvider\n      description: A subclass of <xref href=\"System.Text.EncodingProvider\"></xref> that provides access to additional character encodings.\n  overload: System.Text.Encoding.RegisterProvider*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>provider</code> is `null`.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.Unicode\n  commentId: P:System.Text.Encoding.Unicode\n  id: Unicode\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: Unicode\n  nameWithType: Encoding.Unicode\n  fullName: Encoding.Unicode\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets an encoding for the UTF-16 format using the little endian byte order.\n  remarks: \"For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).  \\n  \\n The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\\\"?\\\") character. Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \\n  \\n [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]\\n [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]\"\n  example:\n  - \"The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding Unicode { get; }\n    return:\n      type: System.Text.Encoding\n      description: An encoding for the UTF-16 format using the little endian byte order.\n  overload: System.Text.Encoding.Unicode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.UTF32\n  commentId: P:System.Text.Encoding.UTF32\n  id: UTF32\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: UTF32\n  nameWithType: Encoding.UTF32\n  fullName: Encoding.UTF32\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets an encoding for the UTF-32 format using the little endian byte order.\n  remarks: \"The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE). Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \\n  \\n [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]\\n [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  \\n  \\n For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.  \\n  \\n For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).\"\n  example:\n  - \"The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding UTF32 { get; }\n    return:\n      type: System.Text.Encoding\n      description: An  encoding object for the UTF-32 format using the little endian byte order.\n  overload: System.Text.Encoding.UTF32*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.UTF7\n  commentId: P:System.Text.Encoding.UTF7\n  id: UTF7\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: UTF7\n  nameWithType: Encoding.UTF7\n  fullName: Encoding.UTF7\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets an encoding for the UTF-7 format.\n  remarks: UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications. Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.\n  example:\n  - \"The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]\"\n  syntax:\n    content: public static System.Text.Encoding UTF7 { get; }\n    return:\n      type: System.Text.Encoding\n      description: An encoding for the UTF-7 format.\n  overload: System.Text.Encoding.UTF7*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.UTF8\n  commentId: P:System.Text.Encoding.UTF8\n  id: UTF8\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: UTF8\n  nameWithType: Encoding.UTF8\n  fullName: Encoding.UTF8\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: Gets an encoding for the UTF-8 format.\n  remarks: \"This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters. For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).  \\n  \\n The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.  \\n  \\n-   It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM). To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.  \\n  \\n-   It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark (\\\"?\\\") character. Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.  \\n  \\n     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]\\n     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]\"\n  example:\n  - \"The following example defines an array that consists of the following characters:  \\n  \\n-   LATIN SMALL LETTER Z (U+007A)  \\n  \\n-   LATIN SMALL LETTER A (U+0061)  \\n  \\n-   COMBINING BREVE (U+0306)  \\n  \\n-   LATIN SMALL LETTER AE WITH ACUTE (U+01FD)  \\n  \\n-   GREEK SMALL LETTER BETA (U+03B2)  \\n  \\n-   A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).  \\n  \\n It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array. It then encodes the characters and displays the resulting UTF-8-encoded bytes.  \\n  \\n [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]\\n [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]\"\n  syntax:\n    content: public static System.Text.Encoding UTF8 { get; }\n    return:\n      type: System.Text.Encoding\n      description: An encoding for the UTF-8 format.\n  overload: System.Text.Encoding.UTF8*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.WebName\n  commentId: P:System.Text.Encoding.WebName\n  id: WebName\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: WebName\n  nameWithType: Encoding.WebName\n  fullName: Encoding.WebName\n  type: Property\n  assemblies:\n  - System.Text.Encoding\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.\n  remarks: \"The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.  \\n  \\n Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding. When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard. The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for e-mail headers. However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.  \\n  \\n For more information on the IANA, go to [www.iana.org](http://www.iana.org/).  \\n  \\n The <xref:System.Text.Encoding.WebName%2A?displayProperty=fullName> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName>. Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName> for more information.\"\n  example:\n  - \"The following example includes the <xref:System.Text.Encoding.WebName%2A> in an HTML header.  \\n  \\n [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]\\n [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]\\n [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  \\n  \\n The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>. It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.  \\n  \\n [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]\\n [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]\\n [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]\"\n  syntax:\n    content: public virtual string WebName { get; }\n    return:\n      type: System.String\n      description: The IANA name for the current <xref href=\"System.Text.Encoding\"></xref>.\n  overload: System.Text.Encoding.WebName*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.Encoding.WindowsCodePage\n  commentId: P:System.Text.Encoding.WindowsCodePage\n  id: WindowsCodePage\n  parent: System.Text.Encoding\n  langs:\n  - csharp\n  name: WindowsCodePage\n  nameWithType: Encoding.WindowsCodePage\n  fullName: Encoding.WindowsCodePage\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Text\n  summary: When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.\n  remarks: This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families. For globalization, using one of the Unicode encodings is recommended instead. It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.\n  example:\n  - \"The following example determines the Windows code page that most closely corresponds to each encoding.  \\n  \\n [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]\\n [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]\\n [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]\"\n  syntax:\n    content: public virtual int WindowsCodePage { get; }\n    return:\n      type: System.Int32\n      description: The Windows operating system code page that most closely corresponds to the current <xref href=\"System.Text.Encoding\"></xref>.\n  overload: System.Text.Encoding.WindowsCodePage*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.Text.DecoderFallbackException\n  parent: System.Text\n  isExternal: false\n  name: DecoderFallbackException\n  nameWithType: DecoderFallbackException\n  fullName: System.Text.DecoderFallbackException\n- uid: System.Text.EncoderFallbackException\n  parent: System.Text\n  isExternal: false\n  name: EncoderFallbackException\n  nameWithType: EncoderFallbackException\n  fullName: System.Text.EncoderFallbackException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.Text.Encoding.#ctor\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Encoding()\n  nameWithType: Encoding.Encoding()\n  fullName: Encoding.Encoding()\n- uid: System.Text.Encoding.#ctor(System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Encoding(Int32)\n  nameWithType: Encoding.Encoding(Int32)\n  fullName: Encoding.Encoding(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Encoding(Int32, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.Encoding(Int32, EncoderFallback, DecoderFallback)\n  fullName: Encoding.Encoding(Int32, EncoderFallback, DecoderFallback)\n- uid: System.Text.EncoderFallback\n  parent: System.Text\n  isExternal: false\n  name: EncoderFallback\n  nameWithType: EncoderFallback\n  fullName: System.Text.EncoderFallback\n- uid: System.Text.DecoderFallback\n  parent: System.Text\n  isExternal: false\n  name: DecoderFallback\n  nameWithType: DecoderFallback\n  fullName: System.Text.DecoderFallback\n- uid: System.Text.Encoding.ASCII\n  parent: System.Text.Encoding\n  isExternal: false\n  name: ASCII\n  nameWithType: Encoding.ASCII\n  fullName: Encoding.ASCII\n- uid: System.Text.Encoding\n  parent: System.Text\n  isExternal: false\n  name: Encoding\n  nameWithType: Encoding\n  fullName: System.Text.Encoding\n- uid: System.Text.Encoding.BigEndianUnicode\n  parent: System.Text.Encoding\n  isExternal: false\n  name: BigEndianUnicode\n  nameWithType: Encoding.BigEndianUnicode\n  fullName: Encoding.BigEndianUnicode\n- uid: System.Text.Encoding.BodyName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: BodyName\n  nameWithType: Encoding.BodyName\n  fullName: Encoding.BodyName\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Text.Encoding.Clone\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Clone()\n  nameWithType: Encoding.Clone()\n  fullName: Encoding.Clone()\n- uid: System.Text.Encoding.CodePage\n  parent: System.Text.Encoding\n  isExternal: false\n  name: CodePage\n  nameWithType: Encoding.CodePage\n  fullName: Encoding.CodePage\n- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Convert(Encoding, Encoding, Byte[], Int32, Int32)\n  nameWithType: Encoding.Convert(Encoding, Encoding, Byte[], Int32, Int32)\n  fullName: Encoding.Convert(Encoding, Encoding, Byte[], Int32, Int32)\n- uid: System.Byte\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte\n- uid: System.Byte[]\n  parent: System\n  isExternal: false\n  name: Byte[]\n  nameWithType: Byte[]\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: System.Byte\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Convert(Encoding, Encoding, Byte[])\n  nameWithType: Encoding.Convert(Encoding, Encoding, Byte[])\n  fullName: Encoding.Convert(Encoding, Encoding, Byte[])\n- uid: System.Text.Encoding.DecoderFallback\n  parent: System.Text.Encoding\n  isExternal: false\n  name: DecoderFallback\n  nameWithType: Encoding.DecoderFallback\n  fullName: Encoding.DecoderFallback\n- uid: System.Text.Encoding.Default\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Default\n  nameWithType: Encoding.Default\n  fullName: Encoding.Default\n- uid: System.Text.Encoding.EncoderFallback\n  parent: System.Text.Encoding\n  isExternal: false\n  name: EncoderFallback\n  nameWithType: Encoding.EncoderFallback\n  fullName: Encoding.EncoderFallback\n- uid: System.Text.Encoding.EncodingName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: EncodingName\n  nameWithType: Encoding.EncodingName\n  fullName: Encoding.EncodingName\n- uid: System.Text.Encoding.Equals(System.Object)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Encoding.Equals(Object)\n  fullName: Encoding.Equals(Object)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount(String, Int32, Int32)\n  nameWithType: Encoding.GetByteCount(String, Int32, Int32)\n  fullName: Encoding.GetByteCount(String, Int32, Int32)\n- uid: System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount(Char[], Int32, Int32)\n  nameWithType: Encoding.GetByteCount(Char[], Int32, Int32)\n  fullName: Encoding.GetByteCount(Char[], Int32, Int32)\n- uid: System.Char\n  name: Char\n  nameWithType: Char\n  fullName: System.Char\n- uid: System.Char[]\n  parent: System\n  isExternal: false\n  name: Char[]\n  nameWithType: Char[]\n  fullName: System.Char[]\n  spec.csharp:\n  - uid: System.Char\n    name: Char\n    nameWithType: Char\n    fullName: System.Char\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Text.Encoding.GetByteCount(System.Char[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount(Char[])\n  nameWithType: Encoding.GetByteCount(Char[])\n  fullName: Encoding.GetByteCount(Char[])\n- uid: System.Text.Encoding.GetByteCount(System.String)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount(String)\n  nameWithType: Encoding.GetByteCount(String)\n  fullName: Encoding.GetByteCount(String)\n- uid: System.Text.Encoding.GetByteCount(System.Char*,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount(Char*, Int32)\n  nameWithType: Encoding.GetByteCount(Char*, Int32)\n  fullName: Encoding.GetByteCount(Char*, Int32)\n- uid: System.Char*\n  parent: System\n  isExternal: false\n  name: Char*\n  nameWithType: Char*\n  fullName: System.Char*\n  spec.csharp:\n  - uid: System.Char\n    name: Char\n    nameWithType: Char\n    fullName: System.Char\n  - name: '*'\n    nameWithType: '*'\n    fullName: '*'\n- uid: System.Text.Encoding.GetBytes(System.Char[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(Char[])\n  nameWithType: Encoding.GetBytes(Char[])\n  fullName: Encoding.GetBytes(Char[])\n- uid: System.Text.Encoding.GetBytes(System.String)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(String)\n  nameWithType: Encoding.GetBytes(String)\n  fullName: Encoding.GetBytes(String)\n- uid: System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(Char[], Int32, Int32)\n  nameWithType: Encoding.GetBytes(Char[], Int32, Int32)\n  fullName: Encoding.GetBytes(Char[], Int32, Int32)\n- uid: System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(String, Int32, Int32)\n  nameWithType: Encoding.GetBytes(String, Int32, Int32)\n  fullName: Encoding.GetBytes(String, Int32, Int32)\n- uid: System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(Char*, Int32, Byte*, Int32)\n  nameWithType: Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n  fullName: Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n- uid: System.Byte*\n  parent: System\n  isExternal: false\n  name: Byte*\n  nameWithType: Byte*\n  fullName: System.Byte*\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: System.Byte\n  - name: '*'\n    nameWithType: '*'\n    fullName: '*'\n- uid: System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  nameWithType: Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  fullName: Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n- uid: System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(String, Int32, Int32, Byte[], Int32)\n  nameWithType: Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n  fullName: Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n- uid: System.Text.Encoding.GetCharCount(System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetCharCount(Byte[])\n  nameWithType: Encoding.GetCharCount(Byte[])\n  fullName: Encoding.GetCharCount(Byte[])\n- uid: System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetCharCount(Byte*, Int32)\n  nameWithType: Encoding.GetCharCount(Byte*, Int32)\n  fullName: Encoding.GetCharCount(Byte*, Int32)\n- uid: System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetCharCount(Byte[], Int32, Int32)\n  nameWithType: Encoding.GetCharCount(Byte[], Int32, Int32)\n  fullName: Encoding.GetCharCount(Byte[], Int32, Int32)\n- uid: System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetChars(Byte[], Int32, Int32, Char[], Int32)\n  nameWithType: Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n  fullName: Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n- uid: System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetChars(Byte*, Int32, Char*, Int32)\n  nameWithType: Encoding.GetChars(Byte*, Int32, Char*, Int32)\n  fullName: Encoding.GetChars(Byte*, Int32, Char*, Int32)\n- uid: System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetChars(Byte[], Int32, Int32)\n  nameWithType: Encoding.GetChars(Byte[], Int32, Int32)\n  fullName: Encoding.GetChars(Byte[], Int32, Int32)\n- uid: System.Text.Encoding.GetChars(System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetChars(Byte[])\n  nameWithType: Encoding.GetChars(Byte[])\n  fullName: Encoding.GetChars(Byte[])\n- uid: System.Text.Encoding.GetDecoder\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetDecoder()\n  nameWithType: Encoding.GetDecoder()\n  fullName: Encoding.GetDecoder()\n- uid: System.Text.Decoder\n  parent: System.Text\n  isExternal: false\n  name: Decoder\n  nameWithType: Decoder\n  fullName: System.Text.Decoder\n- uid: System.Text.Encoding.GetEncoder\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoder()\n  nameWithType: Encoding.GetEncoder()\n  fullName: Encoding.GetEncoder()\n- uid: System.Text.Encoder\n  parent: System.Text\n  isExternal: false\n  name: Encoder\n  nameWithType: Encoder\n  fullName: System.Text.Encoder\n- uid: System.Text.Encoding.GetEncoding(System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(Int32)\n  nameWithType: Encoding.GetEncoding(Int32)\n  fullName: Encoding.GetEncoding(Int32)\n- uid: System.Text.Encoding.GetEncoding(System.String)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(String)\n  nameWithType: Encoding.GetEncoding(String)\n  fullName: Encoding.GetEncoding(String)\n- uid: System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(Int32, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)\n  fullName: Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)\n- uid: System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(String, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)\n  fullName: Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)\n- uid: System.Text.Encoding.GetEncodings\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncodings()\n  nameWithType: Encoding.GetEncodings()\n  fullName: Encoding.GetEncodings()\n- uid: System.Text.EncodingInfo\n  name: EncodingInfo\n  nameWithType: EncodingInfo\n  fullName: System.Text.EncodingInfo\n- uid: System.Text.EncodingInfo[]\n  parent: System.Text\n  isExternal: false\n  name: EncodingInfo[]\n  nameWithType: EncodingInfo[]\n  fullName: System.Text.EncodingInfo[]\n  spec.csharp:\n  - uid: System.Text.EncodingInfo\n    name: EncodingInfo\n    nameWithType: EncodingInfo\n    fullName: System.Text.EncodingInfo\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Text.Encoding.GetHashCode\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Encoding.GetHashCode()\n  fullName: Encoding.GetHashCode()\n- uid: System.Text.Encoding.GetMaxByteCount(System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetMaxByteCount(Int32)\n  nameWithType: Encoding.GetMaxByteCount(Int32)\n  fullName: Encoding.GetMaxByteCount(Int32)\n- uid: System.Text.Encoding.GetMaxCharCount(System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetMaxCharCount(Int32)\n  nameWithType: Encoding.GetMaxCharCount(Int32)\n  fullName: Encoding.GetMaxCharCount(Int32)\n- uid: System.Text.Encoding.GetPreamble\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetPreamble()\n  nameWithType: Encoding.GetPreamble()\n  fullName: Encoding.GetPreamble()\n- uid: System.Text.Encoding.GetString(System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetString(Byte[])\n  nameWithType: Encoding.GetString(Byte[])\n  fullName: Encoding.GetString(Byte[])\n- uid: System.Text.Encoding.GetString(System.Byte*,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetString(Byte*, Int32)\n  nameWithType: Encoding.GetString(Byte*, Int32)\n  fullName: Encoding.GetString(Byte*, Int32)\n- uid: System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetString(Byte[], Int32, Int32)\n  nameWithType: Encoding.GetString(Byte[], Int32, Int32)\n  fullName: Encoding.GetString(Byte[], Int32, Int32)\n- uid: System.Text.Encoding.HeaderName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: HeaderName\n  nameWithType: Encoding.HeaderName\n  fullName: Encoding.HeaderName\n- uid: System.Text.Encoding.IsAlwaysNormalized\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsAlwaysNormalized()\n  nameWithType: Encoding.IsAlwaysNormalized()\n  fullName: Encoding.IsAlwaysNormalized()\n- uid: System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsAlwaysNormalized(NormalizationForm)\n  nameWithType: Encoding.IsAlwaysNormalized(NormalizationForm)\n  fullName: Encoding.IsAlwaysNormalized(NormalizationForm)\n- uid: System.Text.NormalizationForm\n  parent: System.Text\n  isExternal: false\n  name: NormalizationForm\n  nameWithType: NormalizationForm\n  fullName: System.Text.NormalizationForm\n- uid: System.Text.Encoding.IsBrowserDisplay\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsBrowserDisplay\n  nameWithType: Encoding.IsBrowserDisplay\n  fullName: Encoding.IsBrowserDisplay\n- uid: System.Text.Encoding.IsBrowserSave\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsBrowserSave\n  nameWithType: Encoding.IsBrowserSave\n  fullName: Encoding.IsBrowserSave\n- uid: System.Text.Encoding.IsMailNewsDisplay\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsMailNewsDisplay\n  nameWithType: Encoding.IsMailNewsDisplay\n  fullName: Encoding.IsMailNewsDisplay\n- uid: System.Text.Encoding.IsMailNewsSave\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsMailNewsSave\n  nameWithType: Encoding.IsMailNewsSave\n  fullName: Encoding.IsMailNewsSave\n- uid: System.Text.Encoding.IsReadOnly\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsReadOnly\n  nameWithType: Encoding.IsReadOnly\n  fullName: Encoding.IsReadOnly\n- uid: System.Text.Encoding.IsSingleByte\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsSingleByte\n  nameWithType: Encoding.IsSingleByte\n  fullName: Encoding.IsSingleByte\n- uid: System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: RegisterProvider(EncodingProvider)\n  nameWithType: Encoding.RegisterProvider(EncodingProvider)\n  fullName: Encoding.RegisterProvider(EncodingProvider)\n- uid: System.Text.EncodingProvider\n  parent: System.Text\n  isExternal: false\n  name: EncodingProvider\n  nameWithType: EncodingProvider\n  fullName: System.Text.EncodingProvider\n- uid: System.Text.Encoding.Unicode\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Unicode\n  nameWithType: Encoding.Unicode\n  fullName: Encoding.Unicode\n- uid: System.Text.Encoding.UTF32\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF32\n  nameWithType: Encoding.UTF32\n  fullName: Encoding.UTF32\n- uid: System.Text.Encoding.UTF7\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF7\n  nameWithType: Encoding.UTF7\n  fullName: Encoding.UTF7\n- uid: System.Text.Encoding.UTF8\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF8\n  nameWithType: Encoding.UTF8\n  fullName: Encoding.UTF8\n- uid: System.Text.Encoding.WebName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: WebName\n  nameWithType: Encoding.WebName\n  fullName: Encoding.WebName\n- uid: System.Text.Encoding.WindowsCodePage\n  parent: System.Text.Encoding\n  isExternal: false\n  name: WindowsCodePage\n  nameWithType: Encoding.WindowsCodePage\n  fullName: Encoding.WindowsCodePage\n- uid: System.Text.Encoding.#ctor*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Encoding\n  nameWithType: Encoding.Encoding\n  fullName: Encoding.Encoding\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.ASCII*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: ASCII\n  nameWithType: Encoding.ASCII\n  fullName: Encoding.ASCII\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.BigEndianUnicode*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: BigEndianUnicode\n  nameWithType: Encoding.BigEndianUnicode\n  fullName: Encoding.BigEndianUnicode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.BodyName*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: BodyName\n  nameWithType: Encoding.BodyName\n  fullName: Encoding.BodyName\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.Clone*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Clone\n  nameWithType: Encoding.Clone\n  fullName: Encoding.Clone\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.CodePage*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: CodePage\n  nameWithType: Encoding.CodePage\n  fullName: Encoding.CodePage\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.Convert*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Convert\n  nameWithType: Encoding.Convert\n  fullName: Encoding.Convert\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.DecoderFallback*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: DecoderFallback\n  nameWithType: Encoding.DecoderFallback\n  fullName: Encoding.DecoderFallback\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.Default*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Default\n  nameWithType: Encoding.Default\n  fullName: Encoding.Default\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.EncoderFallback*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: EncoderFallback\n  nameWithType: Encoding.EncoderFallback\n  fullName: Encoding.EncoderFallback\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.EncodingName*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: EncodingName\n  nameWithType: Encoding.EncodingName\n  fullName: Encoding.EncodingName\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.Equals*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Equals\n  nameWithType: Encoding.Equals\n  fullName: Encoding.Equals\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetByteCount*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount\n  nameWithType: Encoding.GetByteCount\n  fullName: Encoding.GetByteCount\n  monikers:\n  - netcore-2.0\n  - netcore-1.0\n  - netcore-1.1\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetBytes*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes\n  nameWithType: Encoding.GetBytes\n  fullName: Encoding.GetBytes\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetCharCount*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetCharCount\n  nameWithType: Encoding.GetCharCount\n  fullName: Encoding.GetCharCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetChars*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetChars\n  nameWithType: Encoding.GetChars\n  fullName: Encoding.GetChars\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetDecoder*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetDecoder\n  nameWithType: Encoding.GetDecoder\n  fullName: Encoding.GetDecoder\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetEncoder*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoder\n  nameWithType: Encoding.GetEncoder\n  fullName: Encoding.GetEncoder\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetEncoding*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding\n  nameWithType: Encoding.GetEncoding\n  fullName: Encoding.GetEncoding\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetEncodings*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncodings\n  nameWithType: Encoding.GetEncodings\n  fullName: Encoding.GetEncodings\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetHashCode*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetHashCode\n  nameWithType: Encoding.GetHashCode\n  fullName: Encoding.GetHashCode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetMaxByteCount*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetMaxByteCount\n  nameWithType: Encoding.GetMaxByteCount\n  fullName: Encoding.GetMaxByteCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetMaxCharCount*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetMaxCharCount\n  nameWithType: Encoding.GetMaxCharCount\n  fullName: Encoding.GetMaxCharCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetPreamble*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetPreamble\n  nameWithType: Encoding.GetPreamble\n  fullName: Encoding.GetPreamble\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.GetString*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetString\n  nameWithType: Encoding.GetString\n  fullName: Encoding.GetString\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.HeaderName*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: HeaderName\n  nameWithType: Encoding.HeaderName\n  fullName: Encoding.HeaderName\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.IsAlwaysNormalized*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsAlwaysNormalized\n  nameWithType: Encoding.IsAlwaysNormalized\n  fullName: Encoding.IsAlwaysNormalized\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.IsBrowserDisplay*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsBrowserDisplay\n  nameWithType: Encoding.IsBrowserDisplay\n  fullName: Encoding.IsBrowserDisplay\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.IsBrowserSave*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsBrowserSave\n  nameWithType: Encoding.IsBrowserSave\n  fullName: Encoding.IsBrowserSave\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.IsMailNewsDisplay*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsMailNewsDisplay\n  nameWithType: Encoding.IsMailNewsDisplay\n  fullName: Encoding.IsMailNewsDisplay\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.IsMailNewsSave*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsMailNewsSave\n  nameWithType: Encoding.IsMailNewsSave\n  fullName: Encoding.IsMailNewsSave\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.IsReadOnly*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsReadOnly\n  nameWithType: Encoding.IsReadOnly\n  fullName: Encoding.IsReadOnly\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.IsSingleByte*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsSingleByte\n  nameWithType: Encoding.IsSingleByte\n  fullName: Encoding.IsSingleByte\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.RegisterProvider*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: RegisterProvider\n  nameWithType: Encoding.RegisterProvider\n  fullName: Encoding.RegisterProvider\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.Unicode*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Unicode\n  nameWithType: Encoding.Unicode\n  fullName: Encoding.Unicode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.UTF32*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF32\n  nameWithType: Encoding.UTF32\n  fullName: Encoding.UTF32\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.UTF7*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF7\n  nameWithType: Encoding.UTF7\n  fullName: Encoding.UTF7\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.UTF8*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF8\n  nameWithType: Encoding.UTF8\n  fullName: Encoding.UTF8\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.WebName*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: WebName\n  nameWithType: Encoding.WebName\n  fullName: Encoding.WebName\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Text.Encoding.WindowsCodePage*\n  parent: System.Text.Encoding\n  isExternal: false\n  name: WindowsCodePage\n  nameWithType: Encoding.WindowsCodePage\n  fullName: Encoding.WindowsCodePage\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/Encoding.xml\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.ICloneable\n  parent: System\n  isExternal: false\n  name: ICloneable\n  nameWithType: ICloneable\n  fullName: System.ICloneable\n"}