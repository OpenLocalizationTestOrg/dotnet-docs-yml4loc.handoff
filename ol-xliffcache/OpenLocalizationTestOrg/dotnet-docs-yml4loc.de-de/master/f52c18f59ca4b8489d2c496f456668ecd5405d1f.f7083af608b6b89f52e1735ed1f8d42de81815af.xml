{"nodes":[{"content":"Defines the interface that a channel must implement to be on the receiving side of a request-reply communication between messaging endpoints.","nodes":[{"pos":[0,141],"content":"Defines the interface that a channel must implement to be on the receiving side of a request-reply communication between messaging endpoints.","nodes":[{"content":"Defines the interface that a channel must implement to be on the receiving side of a request-reply communication between messaging endpoints.","pos":[0,141]}]}],"pos":[1588,1730],"yaml":true},{"content":"The <xref:System.ServiceModel.Channels.IReplyChannel> interface includes synchronous and asynchronous variants of a <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method return an <xref:System.ServiceModel.Channels.RequestContext> that can be used to construct replies to received requests.  \n  \n The contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.  \n  \n An <xref:System.ServiceModel.Channels.IReplyChannel> is not necessarily bound to a single sender. Other channels and channel interfaces provide correlation between the sender and the reply channel, but the base contract makes no such restriction.  \n  \n The pull model is used with an <xref:System.ServiceModel.Channels.IReplyChannel> to receive messages. This model consists of calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (or one of its variants) and then waiting for a message to arrive.","nodes":[{"pos":[0,311],"content":"The <xref:System.ServiceModel.Channels.IReplyChannel> interface includes synchronous and asynchronous variants of a <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method return an <xref:System.ServiceModel.Channels.RequestContext> that can be used to construct replies to received requests.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph> interface includes synchronous and asynchronous variants of a <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> method return an <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.RequestContext&gt;</ph> that can be used to construct replies to received requests.","pos":[0,311],"source":"The <xref:System.ServiceModel.Channels.IReplyChannel> interface includes synchronous and asynchronous variants of a <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method return an <xref:System.ServiceModel.Channels.RequestContext> that can be used to construct replies to received requests."}]},{"pos":[318,442],"content":"The contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.","nodes":[{"content":"The contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.","pos":[0,124]}]},{"pos":[449,695],"content":"An <xref:System.ServiceModel.Channels.IReplyChannel> is not necessarily bound to a single sender. Other channels and channel interfaces provide correlation between the sender and the reply channel, but the base contract makes no such restriction.","nodes":[{"content":"An <xref:System.ServiceModel.Channels.IReplyChannel> is not necessarily bound to a single sender. Other channels and channel interfaces provide correlation between the sender and the reply channel, but the base contract makes no such restriction.","pos":[0,246],"nodes":[{"content":"An <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph> is not necessarily bound to a single sender.","pos":[0,97],"source":"An <xref:System.ServiceModel.Channels.IReplyChannel> is not necessarily bound to a single sender."},{"content":"Other channels and channel interfaces provide correlation between the sender and the reply channel, but the base contract makes no such restriction.","pos":[98,246]}]}]},{"pos":[702,969],"content":"The pull model is used with an <xref:System.ServiceModel.Channels.IReplyChannel> to receive messages. This model consists of calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (or one of its variants) and then waiting for a message to arrive.","nodes":[{"content":"The pull model is used with an <xref:System.ServiceModel.Channels.IReplyChannel> to receive messages. This model consists of calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (or one of its variants) and then waiting for a message to arrive.","pos":[0,267],"nodes":[{"content":"The pull model is used with an <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph> to receive messages.","pos":[0,101],"source":"The pull model is used with an <xref:System.ServiceModel.Channels.IReplyChannel> to receive messages."},{"content":"This model consists of calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> (or one of its variants) and then waiting for a message to arrive.","pos":[102,267],"source":" This model consists of calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (or one of its variants) and then waiting for a message to arrive."}]}]}],"pos":[1741,2719],"yaml":true,"extradata":"MT"},{"content":"Begins an asynchronous operation to receive an available request with a default timeout.","nodes":[{"pos":[0,88],"content":"Begins an asynchronous operation to receive an available request with a default timeout.","nodes":[{"content":"Begins an asynchronous operation to receive an available request with a default timeout.","pos":[0,88]}]}],"pos":[4173,4262],"yaml":true},{"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronously. The default timeout is 1 minute. If a receive timeout is set on the binding used to configure the connection, then that value is used. Use <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> if you want to specify an explicit timeout with the call that overrides these other values.  \n  \n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"pos":[0,609],"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronously. The default timeout is 1 minute. If a receive timeout is set on the binding used to configure the connection, then that value is used. Use <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> if you want to specify an explicit timeout with the call that overrides these other values.","nodes":[{"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronously. The default timeout is 1 minute. If a receive timeout is set on the binding used to configure the connection, then that value is used. Use <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> if you want to specify an explicit timeout with the call that overrides these other values.","pos":[0,609],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29&gt;</ph> method implements the standard pattern for invoking <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest&gt;</ph> asynchronously.","pos":[0,248],"source":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronously."},{"content":"The default timeout is 1 minute.","pos":[249,281]},{"content":"If a receive timeout is set on the binding used to configure the connection, then that value is used.","pos":[282,383]},{"content":"Use <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> if you want to specify an explicit timeout with the call that overrides these other values.","pos":[384,609],"source":" Use <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> if you want to specify an explicit timeout with the call that overrides these other values."}]}]},{"pos":[616,954],"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","pos":[0,338],"nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> is thrown.","pos":[0,169],"source":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown."},{"content":"The maximum message size is set by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A&gt;</ph> property.","pos":[170,304],"source":" The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property."},{"content":"The default value is 65536 bytes.","pos":[305,338]}]}]}],"pos":[4273,5232],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.","nodes":[{"pos":[0,149],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous receive that a request operation completes.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes."}],"pos":[5653,5803],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"pos":[0,137],"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","pos":[0,137]}]}],"pos":[5864,6002],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous reception of the request.","nodes":[{"pos":[0,103],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous reception of the request.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous reception of the request."}],"pos":[6065,6169],"yaml":true},{"content":"Begins an asynchronous operation to receive an available request with a specified timeout.","nodes":[{"pos":[0,90],"content":"Begins an asynchronous operation to receive an available request with a specified timeout.","nodes":[{"content":"Begins an asynchronous operation to receive an available request with a specified timeout.","pos":[0,90]}]}],"pos":[7570,7661],"yaml":true},{"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29>asynchronously. The timeout set on this method overrides a receive timeout set on the binding that is used to configure the connection.  \n  \n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"pos":[0,406],"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29>asynchronously. The timeout set on this method overrides a receive timeout set on the binding that is used to configure the connection.","nodes":[{"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29>asynchronously. The timeout set on this method overrides a receive timeout set on the binding that is used to configure the connection.","pos":[0,406],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method implements the standard pattern for invoking <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29&gt;</ph>asynchronously.","pos":[0,286],"source":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29>asynchronously."},{"content":"The timeout set on this method overrides a receive timeout set on the binding that is used to configure the connection.","pos":[287,406]}]}]},{"pos":[413,751],"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","pos":[0,338],"nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> is thrown.","pos":[0,169],"source":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown."},{"content":"The maximum message size is set by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A&gt;</ph> property.","pos":[170,304],"source":" The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property."},{"content":"The default value is 65536 bytes.","pos":[305,338]}]}]}],"pos":[7672,8428],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for the reception of an available request.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies the interval of time to wait for the reception of an available request.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for the reception of an available request."}],"pos":[8861,8989],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.","nodes":[{"pos":[0,149],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous receive that a request operation completes.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes."}],"pos":[9060,9210],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"pos":[0,137],"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","pos":[0,137]}]}],"pos":[9271,9409],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous reception of the request.","nodes":[{"pos":[0,103],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous reception of the request.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous reception of the request."}],"pos":[9472,9576],"yaml":true},{"content":"Begins an asynchronous operation to receive a request message that has a specified time out and state object associated with it.","nodes":[{"pos":[0,128],"content":"Begins an asynchronous operation to receive a request message that has a specified time out and state object associated with it.","nodes":[{"content":"Begins an asynchronous operation to receive a request message that has a specified time out and state object associated with it.","pos":[0,128]}]}],"pos":[10995,11124],"yaml":true},{"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you need the application processing to continue without waiting. Use one of the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> methods when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.  \n  \n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.","nodes":[{"pos":[0,545],"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you need the application processing to continue without waiting. Use one of the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> methods when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.","nodes":[{"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you need the application processing to continue without waiting. Use one of the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> methods when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.","pos":[0,545],"nodes":[{"content":"Use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method when you need the application processing to continue without waiting.","pos":[0,230],"source":"Use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you need the application processing to continue without waiting."},{"content":"Use one of the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29&gt;</ph> methods when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.","pos":[231,545],"source":" Use one of the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> methods when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded."}]}]},{"pos":[552,772],"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.","nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.","pos":[0,220],"nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation.","pos":[0,110]},{"content":"The operation is not complete until either a message becomes available in the channel or the time out occurs.","pos":[111,220]}]}]}],"pos":[11135,11912],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive request operation has to complete before timing out and returning `false`.","nodes":[{"pos":[0,151],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies how long the receive request operation has to complete before timing out and returning <ph id=\"ph2\">`false`</ph>.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive request operation has to complete before timing out and returning `false`."}],"pos":[12348,12500],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.","nodes":[{"pos":[0,149],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous receive that a request operation completes.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes."}],"pos":[12571,12721],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"pos":[0,137],"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","pos":[0,137]}]}],"pos":[12782,12920],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive request operation.","nodes":[{"pos":[0,104],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous receive request operation.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive request operation."}],"pos":[12983,13088],"yaml":true},{"content":"Begins an asynchronous request operation that has a specified time out and state object associated with it.","nodes":[{"pos":[0,107],"content":"Begins an asynchronous request operation that has a specified time out and state object associated with it.","nodes":[{"content":"Begins an asynchronous request operation that has a specified time out and state object associated with it.","pos":[0,107]}]}],"pos":[14492,14600],"yaml":true},{"content":"Use the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue. The thread is blocked up to the specified `timeout`.  \n  \n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a request message becomes available in the channel or the time out occurs.","nodes":[{"pos":[0,285],"content":"Use the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue. The thread is blocked up to the specified `timeout`.","nodes":[{"content":"Use the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29&gt;</ph> method when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue.","pos":[0,232],"source":"Use the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue."},{"content":"The thread is blocked up to the specified <ph id=\"ph1\">`timeout`</ph>.","pos":[233,285],"source":" The thread is blocked up to the specified `timeout`."}]},{"pos":[292,520],"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a request message becomes available in the channel or the time out occurs.","nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a request message becomes available in the channel or the time out occurs.","pos":[0,228],"nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation.","pos":[0,110]},{"content":"The operation is not complete until either a request message becomes available in the channel or the time out occurs.","pos":[111,228]}]}]}],"pos":[14611,15136],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for the reception of an available request.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies the interval of time to wait for the reception of an available request.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for the reception of an available request."}],"pos":[15571,15699],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.","nodes":[{"pos":[0,149],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous receive that a request operation completes.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes."}],"pos":[15770,15920],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"pos":[0,137],"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.","pos":[0,137]}]}],"pos":[15981,16119],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous operation to wait for a request message to arrive.","nodes":[{"pos":[0,128],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous operation to wait for a request message to arrive.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous operation to wait for a request message to arrive."}],"pos":[16182,16311],"yaml":true},{"content":"Completes an asynchronous operation to receive an available request.","nodes":[{"pos":[0,68],"content":"Completes an asynchronous operation to receive an available request.","nodes":[{"content":"Completes an asynchronous operation to receive an available request.","pos":[0,68]}]}],"pos":[17550,17619],"yaml":true},{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"pos":[0,338],"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","pos":[0,338],"nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> is thrown.","pos":[0,169],"source":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown."},{"content":"The maximum message size is set by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A&gt;</ph> property.","pos":[170,304],"source":" The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property."},{"content":"The default value is 65536 bytes.","pos":[305,338]}]}]}],"pos":[17630,17969],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> method.","nodes":[{"pos":[0,156],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"&gt;&lt;/xref&gt;</ph> method.","source":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> method."}],"pos":[18399,18556],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct a reply to the request.","nodes":[{"pos":[0,110],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.RequestContext\"&gt;&lt;/xref&gt;</ph> used to construct a reply to the request.","source":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct a reply to the request."}],"pos":[18643,18754],"yaml":true},{"content":"Completes the specified asynchronous operation to receive a request message.","nodes":[{"pos":[0,76],"content":"Completes the specified asynchronous operation to receive a request message.","nodes":[{"content":"Completes the specified asynchronous operation to receive a request message.","pos":[0,76]}]}],"pos":[20192,20269],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,217],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[20734,20952],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> received.","nodes":[{"pos":[0,78],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.RequestContext\"&gt;&lt;/xref&gt;</ph> received.","source":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> received."}],"pos":[21045,21124],"yaml":true},{"content":"`true` if a request message is received before the specified interval of time elapses; otherwise `false`.","nodes":[{"pos":[0,105],"content":"<ph id=\"ph1\">`true`</ph> if a request message is received before the specified interval of time elapses; otherwise <ph id=\"ph2\">`false`</ph>.","source":"`true` if a request message is received before the specified interval of time elapses; otherwise `false`."}],"pos":[21182,21290],"yaml":true},{"content":"Completes the specified asynchronous wait-for-a-request message operation.","nodes":[{"pos":[0,74],"content":"Completes the specified asynchronous wait-for-a-request message operation.","nodes":[{"content":"Completes the specified asynchronous wait-for-a-request message operation.","pos":[0,74]}]}],"pos":[22530,22605],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that identifies the <xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> operation to finish, and from which to retrieve an end result.","nodes":[{"pos":[0,263],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that identifies the <ph id=\"ph2\">&lt;xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> operation to finish, and from which to retrieve an end result.","source":"The <xref href=\"System.IAsyncResult\"></xref> that identifies the <xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> operation to finish, and from which to retrieve an end result."}],"pos":[23012,23276],"yaml":true},{"content":"`true` if a request is received before the specified interval of time elapses; otherwise `false`.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">`true`</ph> if a request is received before the specified interval of time elapses; otherwise <ph id=\"ph2\">`false`</ph>.","source":"`true` if a request is received before the specified interval of time elapses; otherwise `false`."}],"pos":[23334,23434],"yaml":true},{"content":"Gets the address on which this reply channel receives messages.","nodes":[{"pos":[0,63],"content":"Gets the address on which this reply channel receives messages.","nodes":[{"content":"Gets the address on which this reply channel receives messages.","pos":[0,63]}]}],"pos":[24538,24602],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.EndpointAddress\"></xref> on which this reply channel receives messages.","nodes":[{"pos":[0,107],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.EndpointAddress\"&gt;&lt;/xref&gt;</ph> on which this reply channel receives messages.","source":"The <xref href=\"System.ServiceModel.EndpointAddress\"></xref> on which this reply channel receives messages."}],"pos":[25016,25124],"yaml":true},{"content":"Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.","nodes":[{"pos":[0,132],"content":"Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.","nodes":[{"content":"Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.","pos":[0,132],"nodes":[{"content":"Returns the context of the request received, if one is available.","pos":[0,65]},{"content":"If a context is not available, waits until there is one available.","pos":[66,132]}]}]}],"pos":[26239,26372],"yaml":true},{"content":"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.  \n  \n <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.  \n  \n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"pos":[0,129],"content":"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.RequestContext&gt;</ph> encapsulates the request message and a mechanism for replying to that message.","pos":[0,129],"source":"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message."}]},{"pos":[136,363],"content":"<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.","nodes":[{"content":"<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.","pos":[0,227],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> can be called multiple times or concurrently.","pos":[0,113],"source":"<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently."},{"content":"Only one <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> call completes per request received.","pos":[114,227],"source":" Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received."}]}]},{"pos":[370,708],"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","pos":[0,338],"nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> is thrown.","pos":[0,169],"source":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown."},{"content":"The maximum message size is set by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A&gt;</ph> property.","pos":[170,304],"source":" The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property."},{"content":"The default value is 65536 bytes.","pos":[305,338]}]}]}],"pos":[26383,27098],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct replies.","nodes":[{"pos":[0,95],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.RequestContext\"&gt;&lt;/xref&gt;</ph> used to construct replies.","source":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct replies."}],"pos":[27528,27624],"yaml":true},{"content":"Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.","nodes":[{"pos":[0,132],"content":"Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.","nodes":[{"content":"Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.","pos":[0,132],"nodes":[{"content":"Returns the context of the request received, if one is available.","pos":[0,65]},{"content":"If a context is not available, waits until there is one available.","pos":[66,132]}]}]}],"pos":[28816,28949],"yaml":true},{"content":"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.  \n  \n <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.  \n  \n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"pos":[0,129],"content":"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.RequestContext&gt;</ph> encapsulates the request message and a mechanism for replying to that message.","pos":[0,129],"source":"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message."}]},{"pos":[136,363],"content":"<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.","nodes":[{"content":"<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.","pos":[0,227],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> can be called multiple times or concurrently.","pos":[0,113],"source":"<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently."},{"content":"Only one <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> call completes per request received.","pos":[114,227],"source":" Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received."}]}]},{"pos":[370,708],"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.","pos":[0,338],"nodes":[{"content":"If the request message received is larger that the maximum message size allowed by the binding being used, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> is thrown.","pos":[0,169],"source":"If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown."},{"content":"The maximum message size is set by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A&gt;</ph> property.","pos":[170,304],"source":" The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property."},{"content":"The default value is 65536 bytes.","pos":[305,338]}]}]}],"pos":[28960,29675],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive of a request operation has to complete before timing out and returning `false`.","nodes":[{"pos":[0,156],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies how long the receive of a request operation has to complete before timing out and returning <ph id=\"ph2\">`false`</ph>.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive of a request operation has to complete before timing out and returning `false`."}],"pos":[30096,30253],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct replies.","nodes":[{"pos":[0,95],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.RequestContext\"&gt;&lt;/xref&gt;</ph> used to construct replies.","source":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct replies."}],"pos":[30340,30436],"yaml":true},{"content":"Returns a value that indicates whether a request is received before a specified interval of time elapses.","nodes":[{"pos":[0,105],"content":"Returns a value that indicates whether a request is received before a specified interval of time elapses.","nodes":[{"content":"Returns a value that indicates whether a request is received before a specified interval of time elapses.","pos":[0,105]}]}],"pos":[31829,31935],"yaml":true},{"content":"Use <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.","nodes":[{"pos":[0,544],"content":"Use <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.","nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue.","pos":[0,261],"source":"Use <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue."},{"content":"The thread is blocked up to the specified <ph id=\"ph1\">`timeout`</ph>.","pos":[262,314],"source":" The thread is blocked up to the specified `timeout`."},{"content":"If you need the application processing to continue without waiting, use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method.","pos":[315,544],"source":" If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method."}]}],"pos":[31946,32491],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive of a request operation has to complete before timing out and returning `false`.","nodes":[{"pos":[0,156],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies how long the receive of a request operation has to complete before timing out and returning <ph id=\"ph2\">`false`</ph>.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive of a request operation has to complete before timing out and returning `false`."}],"pos":[32933,33090],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> received.","nodes":[{"pos":[0,78],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.RequestContext\"&gt;&lt;/xref&gt;</ph> received.","source":"The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> received."}],"pos":[33183,33262],"yaml":true},{"content":"`true` if a request message is received before the specified interval of time elapses; otherwise `false`.","nodes":[{"pos":[0,105],"content":"<ph id=\"ph1\">`true`</ph> if a request message is received before the specified interval of time elapses; otherwise <ph id=\"ph2\">`false`</ph>.","source":"`true` if a request message is received before the specified interval of time elapses; otherwise `false`."}],"pos":[33320,33428],"yaml":true},{"content":"Returns a value that indicates whether a request message is received before a specified interval of time elapses.","nodes":[{"pos":[0,113],"content":"Returns a value that indicates whether a request message is received before a specified interval of time elapses.","nodes":[{"content":"Returns a value that indicates whether a request message is received before a specified interval of time elapses.","pos":[0,113]}]}],"pos":[34623,34737],"yaml":true},{"content":"Calling <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> does not result in a request message being received or processed in any way.  \n  \n The <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> normally for this, the user must create the transaction, and then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and hope the message arrives before the transaction times out, which may not be possible.  \n  \n Instead, the user can call <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> and specify the time out (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and be confident that they can get the message back before the transaction expires.  \n  \n Use <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.","nodes":[{"pos":[0,170],"content":"Calling <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> does not result in a request message being received or processed in any way.","nodes":[{"content":"Calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29&gt;</ph> does not result in a request message being received or processed in any way.","pos":[0,170],"source":"Calling <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> does not result in a request message being received or processed in any way."}]},{"pos":[177,737],"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> normally for this, the user must create the transaction, and then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and hope the message arrives before the transaction times out, which may not be possible.","nodes":[{"content":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> normally for this, the user must create the transaction, and then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and hope the message arrives before the transaction times out, which may not be possible.","pos":[0,560],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction.","pos":[0,247],"source":"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction."},{"content":"When using just <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> normally for this, the user must create the transaction, and then call <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> and hope the message arrives before the transaction times out, which may not be possible.","pos":[248,560],"source":" When using just <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> normally for this, the user must create the transaction, and then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and hope the message arrives before the transaction times out, which may not be possible."}]}]},{"pos":[744,1114],"content":"Instead, the user can call <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> and specify the time out (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and be confident that they can get the message back before the transaction expires.","nodes":[{"content":"Instead, the user can call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29&gt;</ph> and specify the time out (even infinite), then when a message arrives they can open the transaction, call <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> and be confident that they can get the message back before the transaction expires.","pos":[0,370],"source":"Instead, the user can call <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> and specify the time out (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and be confident that they can get the message back before the transaction expires."}]},{"pos":[1121,1602],"content":"Use <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.","nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.","pos":[0,201],"source":"Use <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue."},{"content":"The thread is blocked up to the specified <ph id=\"ph1\">`timeout`</ph>.","pos":[202,254],"source":" The thread is blocked up to the specified `timeout`."},{"content":"If you need the application processing to continue without waiting, use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method.","pos":[255,481],"source":" If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method."}]}],"pos":[34748,36359],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long a request operation has to complete before timing out and returning `false`.","nodes":[{"pos":[0,141],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies how long a request operation has to complete before timing out and returning <ph id=\"ph2\">`false`</ph>.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long a request operation has to complete before timing out and returning `false`."}],"pos":[36741,36883],"yaml":true},{"content":"`true` if a request is received before the specified interval of time elapses; otherwise `false`.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">`true`</ph> if a request is received before the specified interval of time elapses; otherwise <ph id=\"ph2\">`false`</ph>.","source":"`true` if a request is received before the specified interval of time elapses; otherwise `false`."}],"pos":[36941,37041],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.ServiceModel.Channels.IReplyChannel\n  commentId: T:System.ServiceModel.Channels.IReplyChannel\n  id: IReplyChannel\n  children:\n  - System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)\n  - System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)\n  - System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)\n  - System.ServiceModel.Channels.IReplyChannel.LocalAddress\n  - System.ServiceModel.Channels.IReplyChannel.ReceiveRequest\n  - System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)\n  - System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)\n  - System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)\n  langs:\n  - csharp\n  name: IReplyChannel\n  nameWithType: IReplyChannel\n  fullName: System.ServiceModel.Channels.IReplyChannel\n  type: Interface\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Defines the interface that a channel must implement to be on the receiving side of a request-reply communication between messaging endpoints.\n  remarks: \"The <xref:System.ServiceModel.Channels.IReplyChannel> interface includes synchronous and asynchronous variants of a <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method return an <xref:System.ServiceModel.Channels.RequestContext> that can be used to construct replies to received requests.  \\n  \\n The contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.  \\n  \\n An <xref:System.ServiceModel.Channels.IReplyChannel> is not necessarily bound to a single sender. Other channels and channel interfaces provide correlation between the sender and the reply channel, but the base contract makes no such restriction.  \\n  \\n The pull model is used with an <xref:System.ServiceModel.Channels.IReplyChannel> to receive messages. This model consists of calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (or one of its variants) and then waiting for a message to arrive.\"\n  syntax:\n    content: 'public interface IReplyChannel : System.ServiceModel.Channels.IChannel'\n  derivedClasses:\n  - System.ServiceModel.Channels.IReplySessionChannel\n  implements:\n  - System.ServiceModel.Channels.IChannel\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)\n  id: BeginReceiveRequest(System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: BeginReceiveRequest(AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginReceiveRequest(AsyncCallback, Object)\n  fullName: IReplyChannel.BeginReceiveRequest(AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous operation to receive an available request with a default timeout.\n  remarks: \"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronously. The default timeout is 1 minute. If a receive timeout is set on the binding used to configure the connection, then that value is used. Use <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> if you want to specify an explicit timeout with the call that overrides these other values.  \\n  \\n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#1)]\"\n  syntax:\n    content: public IAsyncResult BeginReceiveRequest (AsyncCallback callback, object state);\n    parameters:\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous reception of the request.\n  overload: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  id: BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: BeginReceiveRequest(TimeSpan, AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginReceiveRequest(TimeSpan, AsyncCallback, Object)\n  fullName: IReplyChannel.BeginReceiveRequest(TimeSpan, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous operation to receive an available request with a specified timeout.\n  remarks: \"The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29>asynchronously. The timeout set on this method overrides a receive timeout set on the binding that is used to configure the connection.  \\n  \\n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#2)]\"\n  syntax:\n    content: public IAsyncResult BeginReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for the reception of an available request.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous reception of the request.\n  overload: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  id: BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: BeginTryReceiveRequest(TimeSpan, AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginTryReceiveRequest(TimeSpan, AsyncCallback, Object)\n  fullName: IReplyChannel.BeginTryReceiveRequest(TimeSpan, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous operation to receive a request message that has a specified time out and state object associated with it.\n  remarks: \"Use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you need the application processing to continue without waiting. Use one of the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> methods when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.  \\n  \\n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#5)]\"\n  syntax:\n    content: public IAsyncResult BeginTryReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive request operation has to complete before timing out and returning `false`.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive request operation.\n  overload: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  id: BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: BeginWaitForRequest(TimeSpan, AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginWaitForRequest(TimeSpan, AsyncCallback, Object)\n  fullName: IReplyChannel.BeginWaitForRequest(TimeSpan, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous request operation that has a specified time out and state object associated with it.\n  remarks: \"Use the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue. The thread is blocked up to the specified `timeout`.  \\n  \\n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a request message becomes available in the channel or the time out occurs.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#10)]\"\n  syntax:\n    content: public IAsyncResult BeginWaitForRequest (TimeSpan timeout, AsyncCallback callback, object state);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for the reception of an available request.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous receive that a request operation completes.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous operation to wait for a request message to arrive.\n  overload: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)\n  id: EndReceiveRequest(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: EndReceiveRequest(IAsyncResult)\n  nameWithType: IReplyChannel.EndReceiveRequest(IAsyncResult)\n  fullName: IReplyChannel.EndReceiveRequest(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Completes an asynchronous operation to receive an available request.\n  remarks: If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#3)]\"\n  syntax:\n    content: public System.ServiceModel.Channels.RequestContext EndReceiveRequest (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> method.\n    return:\n      type: System.ServiceModel.Channels.RequestContext\n      description: The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct a reply to the request.\n  overload: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)\n  id: EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: EndTryReceiveRequest(IAsyncResult, RequestContext)\n  nameWithType: IReplyChannel.EndTryReceiveRequest(IAsyncResult, RequestContext)\n  fullName: IReplyChannel.EndTryReceiveRequest(IAsyncResult, RequestContext)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Completes the specified asynchronous operation to receive a request message.\n  remarks: ''\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#6)]\"\n  syntax:\n    content: public bool EndTryReceiveRequest (IAsyncResult result, out System.ServiceModel.Channels.RequestContext context);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> method.\n    - id: context\n      type: System.ServiceModel.Channels.RequestContext\n      description: The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> received.\n    return:\n      type: System.Boolean\n      description: '`true` if a request message is received before the specified interval of time elapses; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)\n  id: EndWaitForRequest(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: EndWaitForRequest(IAsyncResult)\n  nameWithType: IReplyChannel.EndWaitForRequest(IAsyncResult)\n  fullName: IReplyChannel.EndWaitForRequest(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Completes the specified asynchronous wait-for-a-request message operation.\n  remarks: ''\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#11)]\"\n  syntax:\n    content: public bool EndWaitForRequest (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that identifies the <xref href=\"System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> operation to finish, and from which to retrieve an end result.\n    return:\n      type: System.Boolean\n      description: '`true` if a request is received before the specified interval of time elapses; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.LocalAddress\n  commentId: P:System.ServiceModel.Channels.IReplyChannel.LocalAddress\n  id: LocalAddress\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: LocalAddress\n  nameWithType: IReplyChannel.LocalAddress\n  fullName: IReplyChannel.LocalAddress\n  type: Property\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Gets the address on which this reply channel receives messages.\n  remarks: ''\n  example:\n  - \"The following code illustrates how to implement this property:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#0)]\"\n  syntax:\n    content: public System.ServiceModel.EndpointAddress LocalAddress { get; }\n    return:\n      type: System.ServiceModel.EndpointAddress\n      description: The <xref href=\"System.ServiceModel.EndpointAddress\"></xref> on which this reply channel receives messages.\n  overload: System.ServiceModel.Channels.IReplyChannel.LocalAddress*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest\n  id: ReceiveRequest\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: ReceiveRequest()\n  nameWithType: IReplyChannel.ReceiveRequest()\n  fullName: IReplyChannel.ReceiveRequest()\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.\n  remarks: \"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.  \\n  \\n <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.  \\n  \\n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#7)]\"\n  syntax:\n    content: public System.ServiceModel.Channels.RequestContext ReceiveRequest ();\n    parameters: []\n    return:\n      type: System.ServiceModel.Channels.RequestContext\n      description: The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct replies.\n  overload: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)\n  id: ReceiveRequest(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: ReceiveRequest(TimeSpan)\n  nameWithType: IReplyChannel.ReceiveRequest(TimeSpan)\n  fullName: IReplyChannel.ReceiveRequest(TimeSpan)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Returns the context of the request received, if one is available. If a context is not available, waits until there is one available.\n  remarks: \"<xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.  \\n  \\n <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.  \\n  \\n If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown. The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property. The default value is 65536 bytes.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#8)]\"\n  syntax:\n    content: public System.ServiceModel.Channels.RequestContext ReceiveRequest (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive of a request operation has to complete before timing out and returning `false`.\n    return:\n      type: System.ServiceModel.Channels.RequestContext\n      description: The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> used to construct replies.\n  overload: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)\n  id: TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: TryReceiveRequest(TimeSpan, RequestContext)\n  nameWithType: IReplyChannel.TryReceiveRequest(TimeSpan, RequestContext)\n  fullName: IReplyChannel.TryReceiveRequest(TimeSpan, RequestContext)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Returns a value that indicates whether a request is received before a specified interval of time elapses.\n  remarks: Use <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#4)]\"\n  syntax:\n    content: public bool TryReceiveRequest (TimeSpan timeout, out System.ServiceModel.Channels.RequestContext context);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive of a request operation has to complete before timing out and returning `false`.\n    - id: context\n      type: System.ServiceModel.Channels.RequestContext\n      description: The <xref href=\"System.ServiceModel.Channels.RequestContext\"></xref> received.\n    return:\n      type: System.Boolean\n      description: '`true` if a request message is received before the specified interval of time elapses; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)\n  commentId: M:System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)\n  id: WaitForRequest(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  langs:\n  - csharp\n  name: WaitForRequest(TimeSpan)\n  nameWithType: IReplyChannel.WaitForRequest(TimeSpan)\n  fullName: IReplyChannel.WaitForRequest(TimeSpan)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Returns a value that indicates whether a request message is received before a specified interval of time elapses.\n  remarks: \"Calling <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> does not result in a request message being received or processed in any way.  \\n  \\n The <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> normally for this, the user must create the transaction, and then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and hope the message arrives before the transaction times out, which may not be possible.  \\n  \\n Instead, the user can call <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> and specify the time out (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and be confident that they can get the message back before the transaction expires.  \\n  \\n Use <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#9)]\"\n  syntax:\n    content: public bool WaitForRequest (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies how long a request operation has to complete before timing out and returning `false`.\n    return:\n      type: System.Boolean\n      description: '`true` if a request is received before the specified interval of time elapses; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IReplyChannel.WaitForRequest*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\nreferences:\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: BeginReceiveRequest(AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginReceiveRequest(AsyncCallback, Object)\n  fullName: IReplyChannel.BeginReceiveRequest(AsyncCallback, Object)\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: false\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.AsyncCallback\n  parent: System\n  isExternal: false\n  name: AsyncCallback\n  nameWithType: AsyncCallback\n  fullName: System.AsyncCallback\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: BeginReceiveRequest(TimeSpan, AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginReceiveRequest(TimeSpan, AsyncCallback, Object)\n  fullName: IReplyChannel.BeginReceiveRequest(TimeSpan, AsyncCallback, Object)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: BeginTryReceiveRequest(TimeSpan, AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginTryReceiveRequest(TimeSpan, AsyncCallback, Object)\n  fullName: IReplyChannel.BeginTryReceiveRequest(TimeSpan, AsyncCallback, Object)\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: BeginWaitForRequest(TimeSpan, AsyncCallback, Object)\n  nameWithType: IReplyChannel.BeginWaitForRequest(TimeSpan, AsyncCallback, Object)\n  fullName: IReplyChannel.BeginWaitForRequest(TimeSpan, AsyncCallback, Object)\n- uid: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: EndReceiveRequest(IAsyncResult)\n  nameWithType: IReplyChannel.EndReceiveRequest(IAsyncResult)\n  fullName: IReplyChannel.EndReceiveRequest(IAsyncResult)\n- uid: System.ServiceModel.Channels.RequestContext\n  parent: System.ServiceModel.Channels\n  isExternal: false\n  name: RequestContext\n  nameWithType: RequestContext\n  fullName: System.ServiceModel.Channels.RequestContext\n- uid: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: EndTryReceiveRequest(IAsyncResult, RequestContext)\n  nameWithType: IReplyChannel.EndTryReceiveRequest(IAsyncResult, RequestContext)\n  fullName: IReplyChannel.EndTryReceiveRequest(IAsyncResult, RequestContext)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: EndWaitForRequest(IAsyncResult)\n  nameWithType: IReplyChannel.EndWaitForRequest(IAsyncResult)\n  fullName: IReplyChannel.EndWaitForRequest(IAsyncResult)\n- uid: System.ServiceModel.Channels.IReplyChannel.LocalAddress\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: LocalAddress\n  nameWithType: IReplyChannel.LocalAddress\n  fullName: IReplyChannel.LocalAddress\n- uid: System.ServiceModel.EndpointAddress\n  parent: System.ServiceModel\n  isExternal: false\n  name: EndpointAddress\n  nameWithType: EndpointAddress\n  fullName: System.ServiceModel.EndpointAddress\n- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: ReceiveRequest()\n  nameWithType: IReplyChannel.ReceiveRequest()\n  fullName: IReplyChannel.ReceiveRequest()\n- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: ReceiveRequest(TimeSpan)\n  nameWithType: IReplyChannel.ReceiveRequest(TimeSpan)\n  fullName: IReplyChannel.ReceiveRequest(TimeSpan)\n- uid: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: TryReceiveRequest(TimeSpan, RequestContext)\n  nameWithType: IReplyChannel.TryReceiveRequest(TimeSpan, RequestContext)\n  fullName: IReplyChannel.TryReceiveRequest(TimeSpan, RequestContext)\n- uid: System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: WaitForRequest(TimeSpan)\n  nameWithType: IReplyChannel.WaitForRequest(TimeSpan)\n  fullName: IReplyChannel.WaitForRequest(TimeSpan)\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: BeginReceiveRequest\n  nameWithType: IReplyChannel.BeginReceiveRequest\n  fullName: IReplyChannel.BeginReceiveRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: BeginTryReceiveRequest\n  nameWithType: IReplyChannel.BeginTryReceiveRequest\n  fullName: IReplyChannel.BeginTryReceiveRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: BeginWaitForRequest\n  nameWithType: IReplyChannel.BeginWaitForRequest\n  fullName: IReplyChannel.BeginWaitForRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: EndReceiveRequest\n  nameWithType: IReplyChannel.EndReceiveRequest\n  fullName: IReplyChannel.EndReceiveRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: EndTryReceiveRequest\n  nameWithType: IReplyChannel.EndTryReceiveRequest\n  fullName: IReplyChannel.EndTryReceiveRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: EndWaitForRequest\n  nameWithType: IReplyChannel.EndWaitForRequest\n  fullName: IReplyChannel.EndWaitForRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.LocalAddress*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: LocalAddress\n  nameWithType: IReplyChannel.LocalAddress\n  fullName: IReplyChannel.LocalAddress\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: ReceiveRequest\n  nameWithType: IReplyChannel.ReceiveRequest\n  fullName: IReplyChannel.ReceiveRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: TryReceiveRequest\n  nameWithType: IReplyChannel.TryReceiveRequest\n  fullName: IReplyChannel.TryReceiveRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IReplyChannel.WaitForRequest*\n  parent: System.ServiceModel.Channels.IReplyChannel\n  isExternal: false\n  name: WaitForRequest\n  nameWithType: IReplyChannel.WaitForRequest\n  fullName: IReplyChannel.WaitForRequest\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IReplyChannel.xml\n- uid: System.ServiceModel.Channels.IChannel\n  parent: System.ServiceModel.Channels\n  isExternal: false\n  name: IChannel\n  nameWithType: IChannel\n  fullName: System.ServiceModel.Channels.IChannel\n"}