{"nodes":[{"content":"Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.","nodes":[{"pos":[0,157],"content":"Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.","nodes":[{"content":"Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.","pos":[0,157]}]}],"pos":[582,740],"yaml":true},{"content":"> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Pseudo-random numbers are chosen with equal probability from a finite set of numbers. The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes. The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm. For more information, see D. E. Knuth. *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*. Addison-Wesley, Reading, MA, third edition, 1997.  \n  \n To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=fullName>.  \n  \n In this topic:  \n  \n [Instantiating the random number generator](#Instantiate)   \n [Avoiding multiple instantiations](#Multiple)   \n [The System.Random class and thread safety](#ThreadSafety)   \n [Generating different types of random numbers](#Functionality)   \n [Substituting your own algorithm](#Overriding)   \n [How do you use System.Random to…](#Operations)   \n [Retrieve the same sequence of random values](#Same)  \n [Retrieve unique sequences of random values](#Unique)  \n [Retrieve integers in a specified range](#Range)  \n [Retrieve integers with a specified number of digits](#Digits)  \n [Retrieve floating-point values in a specified range](#Floats)  \n [Generate random Boolean values](#Boolean)  \n [Generate random 64-bit integers](#Long)  \n [Retrieve bytes in a specified range](#Bytes)  \n [Retrieve an element from an array or collection at random](#Array)  \n [Retrieve a unique element from an array or collection](#UniqueArray)  \n  \n<a name=\"Instantiate\"></a>   \n## Instantiating the random number generator  \n You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.  You can supply the seed value either explicitly or implicitly:  \n  \n-   The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.  \n  \n-   The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value. This is the most common way of instantiating the random number generator.  \n  \n If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers. This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers. However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.  \n  \n To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>. The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value. However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers. The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers. On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.  \n  \n [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]\n [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]\n [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  \n  \n To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.  \n  \n<a name=\"Multiple\"></a>   \n## Avoiding multiple instantiations  \n Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers. In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.  \n  \n Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.  \n  \n However, the <xref:System.Random> class isn't thread safe. If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.  \n  \n<a name=\"ThreadSafety\"></a>   \n## The System.Random class and thread safety  \n Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app. However, <xref:System.Random> objects are not thread safe. If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time. If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.  \n  \n The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner. Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.  \n  \n [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]\n [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]\n [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  \n  \n The example ensures thread-safety in the following ways:  \n  \n-   The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.  \n  \n-   A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.  \n  \n-   A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.  \n  \n-   The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0. If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.  \n  \n-   Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object. If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> method to cancel the thread.  \n  \n The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.  \n  \n [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]\n [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  \n  \n It differs from the first example in the following ways:  \n  \n-   The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.  \n  \n-   The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method is used to ensure that the main thread doesn't complete before all tasks have finished. There is no need for the <xref:System.Threading.CountdownEvent> object.  \n  \n-   The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method. In the previous example, it is handled by each thread.  \n  \n<a name=\"Functionality\"></a>   \n## Generating different types of random numbers  \n The random number generator provides methods that let you generate the following kinds of random numbers:  \n  \n-   A series of <xref:System.Byte> values. You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method. The following example generates 20 bytes.  \n  \n     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]\n     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]\n     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  \n  \n-   A single integer. You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=fullName> – 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method. In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.  \n  \n     The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10. Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method. In other words, the largest integer that the method can return is one less than this value.  \n  \n     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]\n     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]\n     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  \n  \n-   A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method. The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978. The following example generates 10 random floating-point numbers.  \n  \n     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]\n     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]\n     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  \n  \n> [!IMPORTANT]\n>  The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number. However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value. This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.  \n  \n You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray). For these and other common tasks, see the [How do you use System.Random to…](#Operations) section.  \n  \n<a name=\"Overriding\"></a>   \n## Substituting your own algorithm  \n You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm. To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm. You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method. You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.  \n  \n For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.  \n  \n<a name=\"Operations\"></a>   \n## How do you use System.Random to…  \n The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.  \n  \n<a name=\"Same\"></a>   \n### Retrieve the same sequence of random values  \n Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing. Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes. Using the same sequence of random number in games allows you to replay previous games.  \n  \n You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. The seed value provides a starting value for the pseudo-random number generation algorithm. The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value. It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.  Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.  \n  \n [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]\n [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]\n [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  \n  \n<a name=\"Unique\"></a>   \n### Retrieve unique sequences of random numbers  \n Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values. You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor. Most developers call the parameterless constructor, which uses the system clock. The following example uses this approach to instantiate two <xref:System.Random> instances. Each instance displays a series of 10 random integers.  \n  \n [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]\n [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]\n [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  \n  \n However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds. Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values. To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method call, and compile and run the example again.  \n  \n To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones. However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic. Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.  \n  \n<a name=\"Range\"></a>   \n### Retrieve integers in a specified range  \n You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return. The upper bound is an exclusive, not an inclusive, value. That is, it isn't included in the range of values returned by the method. The following example uses this method to generate random integers between -10 and 10. Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.  \n  \n [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]\n [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]\n [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  \n  \n<a name=\"Digits\"></a>   \n### Retrieve integers with a specified number of digits  \n You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits. For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.  \n  \n [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]\n [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]\n [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  \n  \n<a name=\"Floats\"></a>   \n### Retrieve floating-point values in a specified range  \n The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1. However, you'll often want to generate random values in some other range.  \n  \n If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method. The following example does this to generate 10 random numbers between -1 and 0.  \n  \n [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]\n [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]\n [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  \n  \n To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound. The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. In also displays the distribution of the random values generated by the method.  \n  \n [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]\n [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]\n [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  \n  \n To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:  \n  \n```  \nRandom.NextDouble() * (maxValue – minValue) + minValue  \n```  \n  \n The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.  \n  \n [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]\n [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]\n [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  \n  \n<a name=\"Boolean\"></a>   \n### Generate random Boolean values  \n The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values. However, you can define your own class or method to do that. The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`. The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable. The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=fullName> method. Note that 2 is used as the argument to specify the upper bound of the random number. Since this is an exclusive value, the method call returns either 0 or 1.  \n  \n [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]\n [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]\n [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  \n  \n Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method. In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call. In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.  The following example provides an implementation.  \n  \n [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]\n [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]\n [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  \n  \n<a name=\"Long\"></a>   \n### Generate random 64-bit integers  \n The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers. However, in some cases, you might want to work with 64-bit integers. You can do this as follows:  \n  \n1.  Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.  \n  \n2.  Multiply that value by <xref:System.Int64.MaxValue?displayProperty=fullName>.  \n  \n The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups. It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.  \n  \n [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]\n [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]\n [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  \n  \n An alternative technique that uses bit manipulation does not generate truly random numbers. This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together. This technique has two limitations:  \n  \n1.  Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.  This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.  \n  \n2.  More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.  \n  \n<a name=\"Bytes\"></a>   \n### Retrieve bytes in a specified range  \n The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not. The following example implements a `NextBytes` method that lets you specify the range of the returned bytes. It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.  \n  \n [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]\n [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]\n [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  \n  \n The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array. Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.  \n  \n<a name=\"Array\"></a>   \n### Retrieve an element from an array or collection at random  \n Random numbers often serve as indexes to retrieve values from arrays or collections. To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument. For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=fullName> method. The following example randomly retrieves the name of a city in the United States from an array of cities.  \n  \n [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]\n [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]\n [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  \n  \n<a name=\"UniqueArray\"></a>   \n### Retrieve a unique element from an array or collection  \n A random number generator can always return duplicate values. As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows. If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.  \n  \n There are a number of techniques to handle this scenario. One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers. The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is used to sort the first array by using the values in the parallel array.  \n  \n For example, if you're developing a Solitaire game, you want to ensure that each card is used only once. Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck. Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.  \n  \n The following example illustrates this approach. It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards. The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.  The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is then called to sort the `deck` array based on the values in the `order` array.  \n  \n [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]\n [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]\n [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]","nodes":[{"pos":[2,405],"content":"[!NOTE]\n To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","leadings":["","> "],"nodes":[{"content":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","pos":[8,401],"nodes":[{"content":"To view the .NET Framework source code for this type, see the <bpt id=\"p1\">[</bpt>Reference Source<ept id=\"p1\">](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca)</ept>.","pos":[1,164],"source":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca)."},{"content":"You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id=\"p1\">[</bpt>instructions<ept id=\"p1\">](http://referencesource.microsoft.com/)</ept>.","pos":[165,393],"source":" You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/)."}]}]},{"pos":[412,976],"content":"Pseudo-random numbers are chosen with equal probability from a finite set of numbers. The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes. The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm. For more information, see D. E. Knuth. *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*. Addison-Wesley, Reading, MA, third edition, 1997.","nodes":[{"content":"Pseudo-random numbers are chosen with equal probability from a finite set of numbers.","pos":[0,85]},{"content":"The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.","pos":[86,244]},{"content":"The current implementation of the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.","pos":[245,404],"source":" The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm."},{"content":"For more information, see D. E.","pos":[405,436]},{"content":"Knuth.","pos":[437,443]},{"content":"<bpt id=\"p1\">*</bpt>The Art of Computer Programming, Volume 2: Seminumerical Algorithms<ept id=\"p1\">*</ept>.","pos":[444,514],"source":"*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*."},{"content":"Addison-Wesley, Reading, MA, third edition, 1997.","pos":[515,564]}]},{"pos":[983,1278],"content":"To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=fullName>.","nodes":[{"content":"To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class or derive a class from <ph id=\"ph2\">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=fullName&gt;</ph>.","pos":[0,295],"source":"To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=fullName>."}]},{"pos":[1285,1299],"content":"In this topic:","nodes":[{"content":"In this topic:","pos":[0,14]}]},{"pos":[1306,2227],"content":"[Instantiating the random number generator](#Instantiate)   \n [Avoiding multiple instantiations](#Multiple)   \n [The System.Random class and thread safety](#ThreadSafety)   \n [Generating different types of random numbers](#Functionality)   \n [Substituting your own algorithm](#Overriding)   \n [How do you use System.Random to…](#Operations)   \n [Retrieve the same sequence of random values](#Same)  \n [Retrieve unique sequences of random values](#Unique)  \n [Retrieve integers in a specified range](#Range)  \n [Retrieve integers with a specified number of digits](#Digits)  \n [Retrieve floating-point values in a specified range](#Floats)  \n [Generate random Boolean values](#Boolean)  \n [Generate random 64-bit integers](#Long)  \n [Retrieve bytes in a specified range](#Bytes)  \n [Retrieve an element from an array or collection at random](#Array)  \n [Retrieve a unique element from an array or collection](#UniqueArray)","nodes":[{"content":"<bpt id=\"p1\">[</bpt>Instantiating the random number generator<ept id=\"p1\">](#Instantiate)</ept><ph id=\"ph1\"> </ph>","pos":[0,58],"source":"[Instantiating the random number generator](#Instantiate) "},{"content":"<bpt id=\"p1\"> [</bpt>Avoiding multiple instantiations<ept id=\"p1\">](#Multiple)</ept><ph id=\"ph1\"> </ph>","pos":[61,108],"source":" [Avoiding multiple instantiations](#Multiple) "},{"content":"<bpt id=\"p1\"> [</bpt>The System.Random class and thread safety<ept id=\"p1\">](#ThreadSafety)</ept><ph id=\"ph1\"> </ph>","pos":[111,171],"source":" [The System.Random class and thread safety](#ThreadSafety) "},{"content":"<bpt id=\"p1\"> [</bpt>Generating different types of random numbers<ept id=\"p1\">](#Functionality)</ept><ph id=\"ph1\"> </ph>","pos":[174,238],"source":" [Generating different types of random numbers](#Functionality) "},{"content":"<bpt id=\"p1\"> [</bpt>Substituting your own algorithm<ept id=\"p1\">](#Overriding)</ept><ph id=\"ph1\"> </ph>","pos":[241,289],"source":" [Substituting your own algorithm](#Overriding) "},{"content":"<bpt id=\"p1\"> [</bpt>How do you use System.Random to…<ept id=\"p1\">](#Operations)</ept><ph id=\"ph1\"> </ph>","pos":[292,341],"source":" [How do you use System.Random to…](#Operations) "},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve the same sequence of random values<ept id=\"p1\">](#Same)</ept>","pos":[344,397],"source":" [Retrieve the same sequence of random values](#Same)"},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve unique sequences of random values<ept id=\"p1\">](#Unique)</ept>","pos":[400,454],"source":" [Retrieve unique sequences of random values](#Unique)"},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve integers in a specified range<ept id=\"p1\">](#Range)</ept>","pos":[457,506],"source":" [Retrieve integers in a specified range](#Range)"},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve integers with a specified number of digits<ept id=\"p1\">](#Digits)</ept>","pos":[509,572],"source":" [Retrieve integers with a specified number of digits](#Digits)"},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve floating-point values in a specified range<ept id=\"p1\">](#Floats)</ept>","pos":[575,638],"source":" [Retrieve floating-point values in a specified range](#Floats)"},{"content":"<bpt id=\"p1\"> [</bpt>Generate random Boolean values<ept id=\"p1\">](#Boolean)</ept>","pos":[641,684],"source":" [Generate random Boolean values](#Boolean)"},{"content":"<bpt id=\"p1\"> [</bpt>Generate random 64-bit integers<ept id=\"p1\">](#Long)</ept>","pos":[687,728],"source":" [Generate random 64-bit integers](#Long)"},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve bytes in a specified range<ept id=\"p1\">](#Bytes)</ept>","pos":[731,777],"source":" [Retrieve bytes in a specified range](#Bytes)"},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve an element from an array or collection at random<ept id=\"p1\">](#Array)</ept>","pos":[780,848],"source":" [Retrieve an element from an array or collection at random](#Array)"},{"content":"<bpt id=\"p1\"> [</bpt>Retrieve a unique element from an array or collection<ept id=\"p1\">](#UniqueArray)</ept>","pos":[851,921],"source":" [Retrieve a unique element from an array or collection](#UniqueArray)"}]},{"pos":[2266,2307],"content":"Instantiating the random number generator","linkify":"Instantiating the random number generator","nodes":[{"content":"Instantiating the random number generator","pos":[0,41]}]},{"pos":[2311,2569],"content":"You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.  You can supply the seed value either explicitly or implicitly:","nodes":[{"content":"You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.  You can supply the seed value either explicitly or implicitly:","pos":[0,258],"nodes":[{"content":"You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%2A&gt;</ph> class constructor.","pos":[0,194],"source":"You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor."},{"content":"You can supply the seed value either explicitly or implicitly:","pos":[196,258]}]}]},{"pos":[2579,2686],"content":"The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor uses an explicit seed value that you supply.","pos":[0,107],"source":"The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply."}]},{"pos":[2696,2861],"content":"The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value. This is the most common way of instantiating the random number generator.","nodes":[{"content":"The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value. This is the most common way of instantiating the random number generator.","pos":[0,165],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to provide a seed value.","pos":[0,91],"source":"The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value."},{"content":"This is the most common way of instantiating the random number generator.","pos":[92,165]}]}]},{"pos":[2868,3350],"content":"If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers. This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers. However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.","nodes":[{"content":"If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers. This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers. However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.","pos":[0,482],"nodes":[{"content":"If the same seed is used for separate <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects, they will generate the same series of random numbers.","pos":[0,121],"source":"If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers."},{"content":"This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.","pos":[122,263]},{"content":"However, note that <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.","pos":[264,482],"source":" However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values."}]}]},{"pos":[3357,4360],"content":"To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>. The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value. However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers. The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers. On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.","nodes":[{"content":"To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>. The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value. However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers. The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers. On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.","pos":[0,1003],"nodes":[{"content":"To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph>.","pos":[0,178],"source":"To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>."},{"content":"The parameterized <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor can take an <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> value based on the number of ticks in the current time, whereas the parameterless <ph id=\"ph3\">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to generate its seed value.","pos":[179,460],"source":" The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value."},{"content":"However, because the clock has finite resolution, using the parameterless constructor to create different <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects in close succession creates random number generators that produce identical sequences of random numbers.","pos":[461,700],"source":" However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers."},{"content":"The following example illustrates how two <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects that are instantiated in close succession generate an identical series of random numbers.","pos":[701,861],"source":" The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers."},{"content":"On most Windows systems, <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects created within 15 milliseconds of one another are likely to have identical seed values.","pos":[862,1003],"source":" On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values."}]}]},{"pos":[4367,4701],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#1<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#1<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#1<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)</ept><ept id=\"p5\">]</ept>","leadings":[""," "," "],"source":"[!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]\n[!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]\n[!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]"},{"pos":[4708,4803],"content":"To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.","nodes":[{"content":"To avoid this problem, create a single <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object instead of multiple objects.","pos":[0,95],"source":"To avoid this problem, create a single <xref:System.Random> object instead of multiple objects."}]},{"pos":[4839,4871],"content":"Avoiding multiple instantiations","linkify":"Avoiding multiple instantiations","nodes":[{"content":"Avoiding multiple instantiations","pos":[0,32]}]},{"pos":[4875,5234],"content":"Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers. In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.","nodes":[{"content":"Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers. In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.","pos":[0,359],"nodes":[{"content":"Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.","pos":[0,173]},{"content":"In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.","pos":[174,359]}]}]},{"pos":[5241,5569],"content":"Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.","nodes":[{"content":"Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object to generate many random numbers over time, instead of creating new <ph id=\"ph2\">&lt;xref:System.Random&gt;</ph> objects to generate one random number.","pos":[0,328],"source":"Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number."}]},{"pos":[5576,5751],"content":"However, the <xref:System.Random> class isn't thread safe. If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.","nodes":[{"content":"However, the <xref:System.Random> class isn't thread safe. If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.","pos":[0,175],"nodes":[{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class isn't thread safe.","pos":[0,58],"source":"However, the <xref:System.Random> class isn't thread safe."},{"content":"If you call <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> methods from multiple threads, follow the guidelines discussed in the next section.","pos":[59,175],"source":" If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section."}]}]},{"pos":[5791,5832],"content":"The System.Random class and thread safety","linkify":"The System.Random class and thread safety","nodes":[{"content":"The System.Random class and thread safety","pos":[0,41]}]},{"pos":[5836,6417],"content":"Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app. However, <xref:System.Random> objects are not thread safe. If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time. If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.","nodes":[{"content":"Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app. However, <xref:System.Random> objects are not thread safe. If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time. If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.","pos":[0,581],"nodes":[{"content":"Instead of instantiating individual <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects, we recommend that you create a single <ph id=\"ph2\">&lt;xref:System.Random&gt;</ph> instance to generate all the random numbers needed by your app.","pos":[0,188],"source":"Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app."},{"content":"However, <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects are not thread safe.","pos":[189,247],"source":" However, <xref:System.Random> objects are not thread safe."},{"content":"If your app calls <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.","pos":[248,436],"source":" If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time."},{"content":"If you don't ensure that the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.","pos":[437,581],"source":" If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0."}]}]},{"pos":[6424,6941],"content":"The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner. Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.","nodes":[{"content":"The following example uses the C# <bpt id=\"p1\">[</bpt>lock Statement<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> and the Visual Basic <bpt id=\"p2\">[</bpt>SyncLock statement<ept id=\"p2\">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.","pos":[0,325],"source":"The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner."},{"content":"Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.","pos":[326,517]}]},{"pos":[6948,7300],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#3<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#3<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#3<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]\n [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]\n [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]"},{"pos":[7307,7363],"content":"The example ensures thread-safety in the following ways:","nodes":[{"content":"The example ensures thread-safety in the following ways:","pos":[0,56]}]},{"pos":[7373,7550],"content":"The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.","pos":[0,177],"source":"The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread."}]},{"pos":[7560,7749],"content":"A lock (the <ph id=\"ph1\">`lock`</ph> statement in C# and the <ph id=\"ph2\">`SyncLock`</ph> statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.","source":"A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads."},{"pos":[7759,7912],"content":"A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.","nodes":[{"content":"A semaphore (the <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object) is used to ensure that the main thread blocks until all other threads complete execution.","pos":[0,153],"source":"A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution."}]},{"pos":[7922,8238],"content":"The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0. If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.","nodes":[{"content":"The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0. If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.","pos":[0,316],"nodes":[{"content":"The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.","pos":[0,166]},{"content":"If corruption is detected, the example uses the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object to signal that all threads should be canceled.","pos":[167,316],"source":" If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled."}]}]},{"pos":[8248,8551],"content":"Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object. If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> method to cancel the thread.","nodes":[{"content":"Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object. If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> method to cancel the thread.","pos":[0,303],"nodes":[{"content":"Before generating each random number, each thread checks the state of the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken&gt;</ph> object.","pos":[0,123],"source":"Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object."},{"content":"If cancellation is requested, the example calls the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName&gt;</ph> method to cancel the thread.","pos":[124,303],"source":" If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> method to cancel the thread."}]}]},{"pos":[8558,8745],"content":"The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.","nodes":[{"content":"The following example is identical to the first, except that it uses a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and a lambda expression instead of <ph id=\"ph2\">&lt;xref:System.Threading.Thread&gt;</ph> objects.","pos":[0,187],"source":"The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects."}]},{"pos":[8752,8989],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Random#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Random#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]\n[!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]"},{"pos":[8996,9052],"content":"It differs from the first example in the following ways:","nodes":[{"content":"It differs from the first example in the following ways:","pos":[0,56]}]},{"pos":[9062,9259],"content":"The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.","nodes":[{"content":"The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <ph id=\"ph1\">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute.","pos":[0,197],"source":"The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute."}]},{"pos":[9269,9517],"content":"The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method is used to ensure that the main thread doesn't complete before all tasks have finished. There is no need for the <xref:System.Threading.CountdownEvent> object.","nodes":[{"content":"The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method is used to ensure that the main thread doesn't complete before all tasks have finished. There is no need for the <xref:System.Threading.CountdownEvent> object.","pos":[0,248],"nodes":[{"content":"The static <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName&gt;</ph> method is used to ensure that the main thread doesn't complete before all tasks have finished.","pos":[0,176],"source":"The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method is used to ensure that the main thread doesn't complete before all tasks have finished."},{"content":"There is no need for the <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.","pos":[177,248],"source":" There is no need for the <xref:System.Threading.CountdownEvent> object."}]}]},{"pos":[9527,9729],"content":"The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method. In the previous example, it is handled by each thread.","nodes":[{"content":"The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method. In the previous example, it is handled by each thread.","pos":[0,202],"nodes":[{"content":"The exception that results from task cancellation is surfaced in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName&gt;</ph> method.","pos":[0,147],"source":"The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method."},{"content":"In the previous example, it is handled by each thread.","pos":[148,202]}]}]},{"pos":[9770,9814],"content":"Generating different types of random numbers","linkify":"Generating different types of random numbers","nodes":[{"content":"Generating different types of random numbers","pos":[0,44]}]},{"pos":[9818,9923],"content":"The random number generator provides methods that let you generate the following kinds of random numbers:","nodes":[{"content":"The random number generator provides methods that let you generate the following kinds of random numbers:","pos":[0,105]}]},{"pos":[9933,10190],"content":"A series of <xref:System.Byte> values. You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method. The following example generates 20 bytes.","nodes":[{"content":"A series of <xref:System.Byte> values. You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method. The following example generates 20 bytes.","pos":[0,257],"nodes":[{"content":"A series of <ph id=\"ph1\">&lt;xref:System.Byte&gt;</ph> values.","pos":[0,38],"source":"A series of <xref:System.Byte> values."},{"content":"You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <ph id=\"ph1\">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method.","pos":[39,215],"source":" You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method."},{"content":"The following example generates 20 bytes.","pos":[216,257]}]}]},{"pos":[10201,10552],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#5<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#5<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)</ept><ept id=\"p3\">]</ept>  <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#5<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)</ept><ept id=\"p5\">]</ept>","leadings":["","    ","    "],"source":"[!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]\n [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]\n [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]"},{"pos":[10562,11144],"content":"A single integer. You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=fullName> – 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method. In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.","nodes":[{"content":"A single integer. You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=fullName> – 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method. In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.","pos":[0,582],"nodes":[{"content":"A single integer.","pos":[0,17]},{"content":"You can choose whether you want an integer from 0 to a maximum value (<ph id=\"ph1\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph> – 1) by calling the <ph id=\"ph2\">&lt;xref:System.Random.Next&gt;</ph> method, an integer between 0 and a specific value by calling the <ph id=\"ph3\">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> method, or an integer within a range of values by calling the <ph id=\"ph4\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method.","pos":[18,425],"source":" You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=fullName> – 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method."},{"content":"In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.","pos":[426,582]}]}]},{"pos":[11155,11528],"content":"The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10. Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method. In other words, the largest integer that the method can return is one less than this value.","nodes":[{"content":"The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10. Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method. In other words, the largest integer that the method can return is one less than this value.","pos":[0,373],"nodes":[{"content":"The following example calls the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to generate 10 random numbers between -10 and 10.","pos":[0,147],"source":"The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10."},{"content":"Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.","pos":[148,281]},{"content":"In other words, the largest integer that the method can return is one less than this value.","pos":[282,373]}]}]},{"pos":[11539,11881],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#6<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#6<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)</ept><ept id=\"p3\">]</ept>  <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#6<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)</ept><ept id=\"p5\">]</ept>","leadings":["","    ","    "],"source":"[!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]\n [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]\n [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]"},{"pos":[11891,12196],"content":"A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method. The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978. The following example generates 10 random floating-point numbers.","nodes":[{"content":"A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method. The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978. The following example generates 10 random floating-point numbers.","pos":[0,305],"nodes":[{"content":"A single floating-point value from 0.0 to less than 1.0 by calling the <ph id=\"ph1\">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.","pos":[0,113],"source":"A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method."},{"content":"The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.","pos":[114,239]},{"content":"The following example generates 10 random floating-point numbers.","pos":[240,305]}]}]},{"pos":[12207,12567],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#7<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#7<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)</ept><ept id=\"p3\">]</ept>  <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#7<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)</ept><ept id=\"p5\">]</ept>","leadings":["","    ","    "],"source":"[!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]\n [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]\n [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]"},{"pos":[12575,12957],"content":"[!IMPORTANT]\n The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number. However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value. This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.","leadings":["","> "],"nodes":[{"content":" The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number. However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value. This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.","pos":[13,380],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method allows you to specify the range of the returned random number.","pos":[1,133],"source":" The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number."},{"content":"However, the <ph id=\"ph1\">`maxValue`</ph> parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.","pos":[134,259],"source":" However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value."},{"content":"This means that the method call <ph id=\"ph1\">`Next(0, 100)`</ph> returns a value between 0 and 99, and not between 0 and 100.","pos":[260,367],"source":" This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100."}]}]},{"pos":[12964,13396],"content":"You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray). For these and other common tasks, see the [How do you use System.Random to…](#Operations) section.","nodes":[{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class for such tasks as generating <bpt id=\"p1\">[</bpt>random T:System.Boolean values<ept id=\"p1\">](#Boolean)</ept>, generating <bpt id=\"p2\">[</bpt>random floating point values with a range other than 0 to 1<ept id=\"p2\">](#Floats)</ept>, generating <bpt id=\"p3\">[</bpt>random 64-bit integers<ept id=\"p3\">](#Long)</ept>, and <bpt id=\"p4\">[</bpt>randomly retrieving a unique element from an array or collection<ept id=\"p4\">](#UniqueArray)</ept>.","pos":[0,333],"source":"You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray)."},{"content":"For these and other common tasks, see the <bpt id=\"p1\">[</bpt>How do you use System.Random to…<ept id=\"p1\">](#Operations)</ept>","pos":[334,423],"source":" For these and other common tasks, see the [How do you use System.Random to…](#Operations)"},{"content":"section.","pos":[424,432]}]},{"pos":[13434,13465],"content":"Substituting your own algorithm","linkify":"Substituting your own algorithm","nodes":[{"content":"Substituting your own algorithm","pos":[0,31]}]},{"pos":[13469,14137],"content":"You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm. To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm. You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method. You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.","nodes":[{"content":"You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm. To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm. You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method. You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.","pos":[0,668],"nodes":[{"content":"You can implement your own random number generator by inheriting from the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class and supplying your random number generation algorithm.","pos":[0,155],"source":"You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm."},{"content":"To supply your own algorithm, you must override the <ph id=\"ph1\">&lt;xref:System.Random.Sample%2A&gt;</ph> method, which implements the random number generation algorithm.","pos":[156,303],"source":" To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm."},{"content":"You should also override the <ph id=\"ph1\">&lt;xref:System.Random.Next&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Random.NextBytes%2A&gt;</ph> methods to ensure that they call your overridden <ph id=\"ph4\">&lt;xref:System.Random.Sample%2A&gt;</ph> method.","pos":[304,545],"source":" You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method."},{"content":"You don't have to override the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods.","pos":[546,668],"source":" You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods."}]}]},{"pos":[14144,14319],"content":"For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.","nodes":[{"content":"For an example that derives from the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class and modifies its default pseudo-random number generator, see the <ph id=\"ph2\">&lt;xref:System.Random.Sample%2A&gt;</ph> reference page.","pos":[0,175],"source":"For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page."}]},{"pos":[14357,14389],"content":"How do you use System.Random to…","linkify":"How do you use System.Random to…","nodes":[{"content":"How do you use System.Random to…","pos":[0,32]}]},{"pos":[14393,14518],"content":"The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.","nodes":[{"content":"The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.","pos":[0,125]}]},{"pos":[14551,14594],"content":"Retrieve the same sequence of random values","linkify":"Retrieve the same sequence of random values","nodes":[{"content":"Retrieve the same sequence of random values","pos":[0,43]}]},{"pos":[14598,14904],"content":"Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing. Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes. Using the same sequence of random number in games allows you to replay previous games.","nodes":[{"content":"Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing. Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes. Using the same sequence of random number in games allows you to replay previous games.","pos":[0,306],"nodes":[{"content":"Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.","pos":[0,114]},{"content":"Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.","pos":[115,219]},{"content":"Using the same sequence of random number in games allows you to replay previous games.","pos":[220,306]}]}]},{"pos":[14911,15592],"content":"You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. The seed value provides a starting value for the pseudo-random number generation algorithm. The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value. It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.  Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.","nodes":[{"content":"You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. The seed value provides a starting value for the pseudo-random number generation algorithm. The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value. It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.  Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.","pos":[0,681],"nodes":[{"content":"You can generate the same sequence of random numbers by providing the same seed value to the <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.","pos":[0,152],"source":"You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor."},{"content":"The seed value provides a starting value for the pseudo-random number generation algorithm.","pos":[153,244]},{"content":"The following example uses 100100 as an arbitrary seed value to instantiate the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object, displays 20 random floating-point values, and persists the seed value.","pos":[245,424],"source":" The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value."},{"content":"It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.","pos":[425,556]},{"content":"Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.","pos":[558,681]}]}]},{"pos":[15599,15933],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#12<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#12<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#12<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]\n [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]\n [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]"},{"pos":[15968,16011],"content":"Retrieve unique sequences of random numbers","linkify":"Retrieve unique sequences of random numbers","nodes":[{"content":"Retrieve unique sequences of random numbers","pos":[0,43]}]},{"pos":[16015,16593],"content":"Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values. You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor. Most developers call the parameterless constructor, which uses the system clock. The following example uses this approach to instantiate two <xref:System.Random> instances. Each instance displays a series of 10 random integers.","nodes":[{"content":"Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values. You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor. Most developers call the parameterless constructor, which uses the system clock. The following example uses this approach to instantiate two <xref:System.Random> instances. Each instance displays a series of 10 random integers.","pos":[0,578],"nodes":[{"content":"Providing different seed values to instances of the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class causes each random number generator to produce a different sequence of values.","pos":[0,157],"source":"Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values."},{"content":"You can provide a seed value either explicitly by calling the <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor, or implicitly by calling the <ph id=\"ph2\">&lt;xref:System.Random.%23ctor&gt;</ph> constructor.","pos":[158,350],"source":" You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor."},{"content":"Most developers call the parameterless constructor, which uses the system clock.","pos":[351,431]},{"content":"The following example uses this approach to instantiate two <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> instances.","pos":[432,523],"source":" The following example uses this approach to instantiate two <xref:System.Random> instances."},{"content":"Each instance displays a series of 10 random integers.","pos":[524,578]}]}]},{"pos":[16600,16937],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#13<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#13<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#13<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]\n [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]\n [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]"},{"pos":[16944,17467],"content":"However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds. Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values. To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method call, and compile and run the example again.","nodes":[{"content":"However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds. Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values. To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method call, and compile and run the example again.","pos":[0,523],"nodes":[{"content":"However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.","pos":[0,141]},{"content":"Therefore, if your code calls the <ph id=\"ph1\">&lt;xref:System.Random.%23ctor&gt;</ph> overload to instantiate two <ph id=\"ph2\">&lt;xref:System.Random&gt;</ph> objects in succession, you might inadvertently be providing the objects with identical seed values.","pos":[142,353],"source":" Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values."},{"content":"To see this in the previous example, comment out the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt;</ph> method call, and compile and run the example again.","pos":[354,523],"source":" To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method call, and compile and run the example again."}]}]},{"pos":[17474,18074],"content":"To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones. However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic. Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.","nodes":[{"content":"To prevent this from happening, we recommend that you instantiate a single <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object rather than multiple ones.","pos":[0,129],"source":"To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones."},{"content":"However, since <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> isn't thread safe, you must use some synchronization device if you access a <ph id=\"ph2\">&lt;xref:System.Random&gt;</ph> instance from multiple threads; for more information, see <bpt id=\"p1\">[</bpt>The Random class and thread safety<ept id=\"p1\">](#ThreadSafety)</ept> earlier in this topic.","pos":[130,395],"source":" However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic."},{"content":"Alternately, you can use a delay mechanism, such as the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.","pos":[396,600],"source":" Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart."}]},{"pos":[18108,18146],"content":"Retrieve integers in a specified range","linkify":"Retrieve integers in a specified range","nodes":[{"content":"Retrieve integers in a specified range","pos":[0,38]}]},{"pos":[18150,18752],"content":"You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return. The upper bound is an exclusive, not an inclusive, value. That is, it isn't included in the range of values returned by the method. The following example uses this method to generate random integers between -10 and 10. Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.","nodes":[{"content":"You can retrieve integers in a specified range by calling the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.","pos":[0,251],"source":"You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return."},{"content":"The upper bound is an exclusive, not an inclusive, value.","pos":[252,309]},{"content":"That is, it isn't included in the range of values returned by the method.","pos":[310,383]},{"content":"The following example uses this method to generate random integers between -10 and 10.","pos":[384,470]},{"content":"Note that it specifies 11, which is one greater than the desired value, as the value of the <ph id=\"ph1\">`maxValue`</ph> argument in the method call.","pos":[471,602],"source":" Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call."}]},{"pos":[18759,19096],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#15<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#15<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#15<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]\n [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]\n [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]"},{"pos":[19131,19182],"content":"Retrieve integers with a specified number of digits","linkify":"Retrieve integers with a specified number of digits","nodes":[{"content":"Retrieve integers with a specified number of digits","pos":[0,51]}]},{"pos":[19186,19598],"content":"You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits. For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.","nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to retrieve numbers with a specified number of digits.","pos":[0,137],"source":"You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits."},{"content":"For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method with a <ph id=\"ph2\">`minValue`</ph> value of 1000 and a <ph id=\"ph3\">`maxValue`</ph> value of 10000, as the following example shows.","pos":[138,412],"source":" For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows."}]},{"pos":[19605,19942],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#16<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#16<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#16<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]\n [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]\n [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]"},{"pos":[19977,20028],"content":"Retrieve floating-point values in a specified range","linkify":"Retrieve floating-point values in a specified range","nodes":[{"content":"Retrieve floating-point values in a specified range","pos":[0,51]}]},{"pos":[20032,20222],"content":"The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1. However, you'll often want to generate random values in some other range.","nodes":[{"content":"The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1. However, you'll often want to generate random values in some other range.","pos":[0,190],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method returns random floating-point values that range from 0 to less than 1.","pos":[0,116],"source":"The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1."},{"content":"However, you'll often want to generate random values in some other range.","pos":[117,190]}]}]},{"pos":[20229,20521],"content":"If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method. The following example does this to generate 10 random numbers between -1 and 0.","nodes":[{"content":"If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method. The following example does this to generate 10 random numbers between -1 and 0.","pos":[0,292],"nodes":[{"content":"If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <ph id=\"ph1\">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.","pos":[0,212],"source":"If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method."},{"content":"The following example does this to generate 10 random numbers between -1 and 0.","pos":[213,292]}]}]},{"pos":[20528,20883],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#17<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#17<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#17<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]\n [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]\n [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]"},{"pos":[20890,21374],"content":"To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound. The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. In also displays the distribution of the random values generated by the method.","nodes":[{"content":"To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound. The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. In also displays the distribution of the random values generated by the method.","pos":[0,484],"nodes":[{"content":"To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.","pos":[0,243]},{"content":"The following example does this to generate 20 million random floating-point numbers that range from 0 to <ph id=\"ph1\">&lt;xref:System.Int64.MaxValue?displayProperty=fullName&gt;</ph>.","pos":[244,404],"source":" The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>."},{"content":"In also displays the distribution of the random values generated by the method.","pos":[405,484]}]}]},{"pos":[21381,21736],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#18<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#18<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#18<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]\n [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]\n [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]"},{"pos":[21743,21935],"content":"To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:","nodes":[{"content":"To generate random floating-point numbers between two arbitrary values, like the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method does for integers, use the following formula:","pos":[0,192],"source":"To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:"}]},{"pos":[22014,22133],"content":"The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.","nodes":[{"content":"The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.","pos":[0,119]}]},{"pos":[22140,22495],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#19<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#19<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#19<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]\n [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]\n [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]"},{"pos":[22531,22561],"content":"Generate random Boolean values","linkify":"Generate random Boolean values","nodes":[{"content":"Generate random Boolean values","pos":[0,30]}]},{"pos":[22565,23305],"content":"The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values. However, you can define your own class or method to do that. The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`. The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable. The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=fullName> method. Note that 2 is used as the argument to specify the upper bound of the random number. Since this is an exclusive value, the method call returns either 0 or 1.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class doesn't provide methods that generate <ph id=\"ph2\">&lt;xref:System.Boolean&gt;</ph> values.","pos":[0,98],"source":"The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values."},{"content":"However, you can define your own class or method to do that.","pos":[99,159]},{"content":"The following example defines a class, <ph id=\"ph1\">`BooleanGenerator`</ph>, with a single method, <ph id=\"ph2\">`NextBoolean`</ph>.","pos":[160,255],"source":" The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`."},{"content":"The <ph id=\"ph1\">`BooleanGenerator`</ph> class stores a <ph id=\"ph2\">&lt;xref:System.Random&gt;</ph> object as a private variable.","pos":[256,344],"source":" The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable."},{"content":"The <ph id=\"ph1\">`NextBoolean`</ph> method calls the <ph id=\"ph2\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName&gt;</ph> method and passes the result to the <ph id=\"ph3\">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=fullName&gt;</ph> method.","pos":[345,582],"source":" The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=fullName> method."},{"content":"Note that 2 is used as the argument to specify the upper bound of the random number.","pos":[583,667]},{"content":"Since this is an exclusive value, the method call returns either 0 or 1.","pos":[668,740]}]},{"pos":[23312,23652],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#8<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#8<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#8<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]\n [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]\n [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]"},{"pos":[23659,24200],"content":"Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method. In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call. In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.  The following example provides an implementation.","nodes":[{"content":"Instead of creating a separate class to generate random <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph> values, the example could simply have defined a single method.","pos":[0,140],"source":"Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method."},{"content":"In that case, however, the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object should have been defined as a class-level variable to avoid instantiating a new <ph id=\"ph2\">&lt;xref:System.Random&gt;</ph> instance in each method call.","pos":[141,326],"source":" In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call."},{"content":"In Visual Basic, the Random instance can be defined as a <bpt id=\"p1\">[</bpt>Static<ept id=\"p1\">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> variable in the <ph id=\"ph1\">`NextBoolean`</ph> method.","pos":[327,490],"source":" In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method."},{"content":"The following example provides an implementation.","pos":[492,541]}]},{"pos":[24207,24553],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#20<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#20<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#20<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]\n [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]\n [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]"},{"pos":[24586,24617],"content":"Generate random 64-bit integers","linkify":"Generate random 64-bit integers","nodes":[{"content":"Generate random 64-bit integers","pos":[0,31]}]},{"pos":[24621,24798],"content":"The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers. However, in some cases, you might want to work with 64-bit integers. You can do this as follows:","nodes":[{"content":"The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers. However, in some cases, you might want to work with 64-bit integers. You can do this as follows:","pos":[0,177],"nodes":[{"content":"The overloads of the <ph id=\"ph1\">&lt;xref:System.Random.Next%2A&gt;</ph> method return 32-bit integers.","pos":[0,80],"source":"The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers."},{"content":"However, in some cases, you might want to work with 64-bit integers.","pos":[81,149]},{"content":"You can do this as follows:","pos":[150,177]}]}]},{"pos":[24808,24911],"content":"Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to retrieve a double-precision floating point value.","pos":[0,103],"source":"Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value."}]},{"pos":[24921,24998],"content":"Multiply that value by <xref:System.Int64.MaxValue?displayProperty=fullName>.","nodes":[{"content":"Multiply that value by <ph id=\"ph1\">&lt;xref:System.Int64.MaxValue?displayProperty=fullName&gt;</ph>.","pos":[0,77],"source":"Multiply that value by <xref:System.Int64.MaxValue?displayProperty=fullName>."}]},{"pos":[25005,25414],"content":"The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups. It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.","nodes":[{"content":"The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups. It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.","pos":[0,409],"nodes":[{"content":"The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.","pos":[0,126]},{"content":"It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <ph id=\"ph1\">&lt;xref:System.Int64.MaxValue?displayProperty=fullName&gt;</ph>.","pos":[127,285],"source":" It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>."},{"content":"As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.","pos":[286,409]}]}]},{"pos":[25421,25755],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#14<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#14<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#14<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)</ept><ept id=\"p5\">]</ept>","leadings":[""," "," "],"source":"[!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]\n[!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]\n[!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]"},{"pos":[25762,26013],"content":"An alternative technique that uses bit manipulation does not generate truly random numbers. This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together. This technique has two limitations:","nodes":[{"content":"An alternative technique that uses bit manipulation does not generate truly random numbers. This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together. This technique has two limitations:","pos":[0,251],"nodes":[{"content":"An alternative technique that uses bit manipulation does not generate truly random numbers.","pos":[0,91]},{"content":"This technique calls <ph id=\"ph1\">&lt;xref:System.Random.Next&gt;</ph> to generate two integers, left-shifts one by 32 bits, and ORs them together.","pos":[92,215],"source":" This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together."},{"content":"This technique has two limitations:","pos":[216,251]}]}]},{"pos":[26023,26249],"content":"Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.  This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.","nodes":[{"content":"Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.  This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.","pos":[0,226],"nodes":[{"content":"Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.","pos":[0,94]},{"content":"This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.","pos":[96,226]}]}]},{"pos":[26259,26439],"content":"More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.","nodes":[{"content":"More seriously, because the probability that the value returned by <ph id=\"ph1\">&lt;xref:System.Random.Next&gt;</ph> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.","pos":[0,180],"source":"More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF."}]},{"pos":[26473,26508],"content":"Retrieve bytes in a specified range","linkify":"Retrieve bytes in a specified range","nodes":[{"content":"Retrieve bytes in a specified range","pos":[0,35]}]},{"pos":[26512,26892],"content":"The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not. The following example implements a `NextBytes` method that lets you specify the range of the returned bytes. It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.","nodes":[{"content":"The overloads of the <ph id=\"ph1\">&lt;xref:System.Random.Next%2A&gt;</ph> method allow you to specify the range of random numbers, but the <ph id=\"ph2\">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method does not.","pos":[0,165],"source":"The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not."},{"content":"The following example implements a <ph id=\"ph1\">`NextBytes`</ph> method that lets you specify the range of the returned bytes.","pos":[166,274],"source":" The following example implements a `NextBytes` method that lets you specify the range of the returned bytes."},{"content":"It defines a <ph id=\"ph1\">`Random2`</ph> class that derives from <ph id=\"ph2\">&lt;xref:System.Random&gt;</ph> and overloads its <ph id=\"ph3\">`NextBytes`</ph> method.","pos":[275,380],"source":" It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method."}]},{"pos":[26899,27230],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#9<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#9<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#9<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]\n [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]\n [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]"},{"pos":[27237,27747],"content":"The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array. Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.","nodes":[{"content":"The <ph id=\"ph1\">`NextBytes(Byte[], Byte, Byte)`</ph> method wraps a call to the <ph id=\"ph2\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.","pos":[0,266],"source":"The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array."},{"content":"Because we are sure that the integer values returned by the <ph id=\"ph1\">&lt;xref:System.Random.Next%2A&gt;</ph> method are within the range of the <ph id=\"ph2\">&lt;xref:System.Byte&gt;</ph> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.","pos":[267,510],"source":" Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes."}]},{"pos":[27781,27838],"content":"Retrieve an element from an array or collection at random","linkify":"Retrieve an element from an array or collection at random","nodes":[{"content":"Retrieve an element from an array or collection at random","pos":[0,57]}]},{"pos":[27842,28524],"content":"Random numbers often serve as indexes to retrieve values from arrays or collections. To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument. For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=fullName> method. The following example randomly retrieves the name of a city in the United States from an array of cities.","nodes":[{"content":"Random numbers often serve as indexes to retrieve values from arrays or collections.","pos":[0,84]},{"content":"To retrieve a random index value, you can call the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, and use the lower bound of the array as the value of its <ph id=\"ph2\">`minValue`</ph> argument and one greater than the upper bound of the array as the value of its <ph id=\"ph3\">`maxValue`</ph> argument.","pos":[85,370],"source":" To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument."},{"content":"For a zero-based array, this is equivalent to its <ph id=\"ph1\">&lt;xref:System.Array.Length%2A&gt;</ph> property, or one greater than the value returned by the <ph id=\"ph2\">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=fullName&gt;</ph> method.","pos":[371,576],"source":" For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=fullName> method."},{"content":"The following example randomly retrieves the name of a city in the United States from an array of cities.","pos":[577,682]}]},{"pos":[28531,28868],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#10<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#10<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#10<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]\n [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]\n [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]"},{"pos":[28908,28961],"content":"Retrieve a unique element from an array or collection","linkify":"Retrieve a unique element from an array or collection","nodes":[{"content":"Retrieve a unique element from an array or collection","pos":[0,53]}]},{"pos":[28965,29287],"content":"A random number generator can always return duplicate values. As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows. If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.","nodes":[{"content":"A random number generator can always return duplicate values. As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows. If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.","pos":[0,322],"nodes":[{"content":"A random number generator can always return duplicate values.","pos":[0,61]},{"content":"As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.","pos":[62,188]},{"content":"If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.","pos":[189,322]}]}]},{"pos":[29294,29778],"content":"There are a number of techniques to handle this scenario. One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers. The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is used to sort the first array by using the values in the parallel array.","nodes":[{"content":"There are a number of techniques to handle this scenario. One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers. The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is used to sort the first array by using the values in the parallel array.","pos":[0,484],"nodes":[{"content":"There are a number of techniques to handle this scenario.","pos":[0,57]},{"content":"One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.","pos":[58,221]},{"content":"The second array is populated with random numbers at the time the first array is created, and the <ph id=\"ph1\">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName&gt;</ph> method is used to sort the first array by using the values in the parallel array.","pos":[222,484],"source":" The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is used to sort the first array by using the values in the parallel array."}]}]},{"pos":[29785,30194],"content":"For example, if you're developing a Solitaire game, you want to ensure that each card is used only once. Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck. Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.","nodes":[{"content":"For example, if you're developing a Solitaire game, you want to ensure that each card is used only once. Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck. Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.","pos":[0,409],"nodes":[{"content":"For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.","pos":[0,104]},{"content":"Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.","pos":[105,300]},{"content":"Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.","pos":[301,409]}]}]},{"pos":[30201,30830],"content":"The following example illustrates this approach. It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards. The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.  The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is then called to sort the `deck` array based on the values in the `order` array.","nodes":[{"content":"The following example illustrates this approach.","pos":[0,48]},{"content":"It defines a <ph id=\"ph1\">`Card`</ph> class that represents a playing card and a <ph id=\"ph2\">`Dealer`</ph> class that deals a deck of shuffled cards.","pos":[49,163],"source":" It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards."},{"content":"The <ph id=\"ph1\">`Dealer`</ph> class constructor populates two arrays: a <ph id=\"ph2\">`deck`</ph> array that has class scope and that represents all the cards in the deck; and a local <ph id=\"ph3\">`order`</ph> array that has the same number of elements as the <ph id=\"ph4\">`deck`</ph> array and is populated with randomly generated <ph id=\"ph5\">&lt;xref:System.Double&gt;</ph> values.","pos":[164,452],"source":" The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName&gt;</ph> method is then called to sort the <ph id=\"ph2\">`deck`</ph> array based on the values in the <ph id=\"ph3\">`order`</ph> array.","pos":[454,629],"source":"  The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is then called to sort the `deck` array based on the values in the `order` array."}]},{"pos":[30837,31192],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Random#11<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Random#11<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Random#11<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]\n [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]\n [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]"}],"pos":[751,32234],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Random\"></xref> class, using a time-dependent default seed value.","nodes":[{"pos":[0,118],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Random\"&gt;&lt;/xref&gt;</ph> class, using a time-dependent default seed value.","source":"Initializes a new instance of the <xref href=\"System.Random\"></xref> class, using a time-dependent default seed value."}],"pos":[35246,35365],"yaml":true},{"content":"The default seed value is derived from the system clock and has finite resolution. As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers. This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers. You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.  \n  \n Call this constructor if you want your random number generator to generate a random sequence of numbers. To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value . This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.  \n  \n Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.","nodes":[{"pos":[0,709],"content":"The default seed value is derived from the system clock and has finite resolution. As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers. This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers. You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.","nodes":[{"content":"The default seed value is derived from the system clock and has finite resolution. As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers. This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers. You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.","pos":[0,709],"nodes":[{"content":"The default seed value is derived from the system clock and has finite resolution.","pos":[0,82]},{"content":"As a result, different <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.","pos":[83,311],"source":" As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers."},{"content":"This problem can be avoided by using a single <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object to generate all random numbers.","pos":[312,417],"source":" This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers."},{"content":"You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.","pos":[418,619],"source":" You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.","pos":[620,709],"source":" For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor."}]}]},{"pos":[716,1133],"content":"Call this constructor if you want your random number generator to generate a random sequence of numbers. To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value . This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.","nodes":[{"content":"Call this constructor if you want your random number generator to generate a random sequence of numbers. To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value . This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.","pos":[0,417],"nodes":[{"content":"Call this constructor if you want your random number generator to generate a random sequence of numbers.","pos":[0,104]},{"content":"To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <ph id=\"ph1\">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor with a fixed seed value .","pos":[105,308],"source":" To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value ."},{"content":"This <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> constructor overload is frequently used when testing apps that use random numbers.","pos":[309,417],"source":" This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers."}]}]},{"pos":[1140,1341],"content":"Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.","nodes":[{"content":"Once you've instantiated the random number generator, you call individual <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> methods, such as <ph id=\"ph2\">&lt;xref:System.Random.Next&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Random.NextDouble&gt;</ph>, to generate random numbers.","pos":[0,201],"source":"Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers."}]}],"pos":[35376,36724],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Random\"></xref> class, using the specified seed value.","nodes":[{"pos":[0,107],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Random\"&gt;&lt;/xref&gt;</ph> class, using the specified seed value.","source":"Initializes a new instance of the <xref href=\"System.Random\"></xref> class, using the specified seed value."}],"pos":[39277,39385],"yaml":true},{"content":"Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers. This is often done when testing apps that rely on random number generators.  \n  \n If your application requires different random number sequences, invoke this constructor repeatedly with different seed values. One way to produce a unique seed value is to make it time-dependent. For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does. However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value. This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example. To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to ensure that you provide each constructor with a different seed value.  \n  \n [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]\n [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  \n  \n Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application. This yields slightly better performance, since instantiating a random number generator is fairly expensive.","nodes":[{"pos":[0,222],"content":"Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers. This is often done when testing apps that rely on random number generators.","nodes":[{"content":"Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers. This is often done when testing apps that rely on random number generators.","pos":[0,222],"nodes":[{"content":"Providing an identical seed value to different <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects causes each instance to produce identical sequences of random numbers.","pos":[0,146],"source":"Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers."},{"content":"This is often done when testing apps that rely on random number generators.","pos":[147,222]}]}]},{"pos":[229,1111],"content":"If your application requires different random number sequences, invoke this constructor repeatedly with different seed values. One way to produce a unique seed value is to make it time-dependent. For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does. However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value. This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example. To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to ensure that you provide each constructor with a different seed value.","nodes":[{"content":"If your application requires different random number sequences, invoke this constructor repeatedly with different seed values. One way to produce a unique seed value is to make it time-dependent. For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does. However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value. This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example. To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to ensure that you provide each constructor with a different seed value.","pos":[0,882],"nodes":[{"content":"If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.","pos":[0,126]},{"content":"One way to produce a unique seed value is to make it time-dependent.","pos":[127,195]},{"content":"For example, derive the seed value from the system clock, as the <ph id=\"ph1\">&lt;xref:System.Random.%23ctor&gt;</ph> overload does.","pos":[196,304],"source":" For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does."},{"content":"However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.","pos":[305,449]},{"content":"This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> objects in the following example.","pos":[450,637],"source":" This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example."},{"content":"To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt;</ph> method to ensure that you provide each constructor with a different seed value.","pos":[638,882],"source":" To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to ensure that you provide each constructor with a different seed value."}]}]},{"pos":[1118,1359],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Random.Ctor#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Random.Ctor#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]\n [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]"},{"pos":[1366,1612],"content":"Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application. This yields slightly better performance, since instantiating a random number generator is fairly expensive.","nodes":[{"content":"Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application. This yields slightly better performance, since instantiating a random number generator is fairly expensive.","pos":[0,246],"nodes":[{"content":"Another option is to instantiate a single <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> object that you use to generate all the random numbers in your application.","pos":[0,138],"source":"Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application."},{"content":"This yields slightly better performance, since instantiating a random number generator is fairly expensive.","pos":[139,246]}]}]}],"pos":[39396,41018],"yaml":true,"extradata":"MT"},{"content":"A number used to calculate a starting value for the pseudo-random number sequence. If a negative number is specified, the absolute value of the number is used.","nodes":[{"pos":[0,159],"content":"A number used to calculate a starting value for the pseudo-random number sequence. If a negative number is specified, the absolute value of the number is used.","nodes":[{"content":"A number used to calculate a starting value for the pseudo-random number sequence. If a negative number is specified, the absolute value of the number is used.","pos":[0,159],"nodes":[{"content":"A number used to calculate a starting value for the pseudo-random number sequence.","pos":[0,82]},{"content":"If a negative number is specified, the absolute value of the number is used.","pos":[83,159]}]}]}],"pos":[41851,42011],"yaml":true},{"content":"Returns a non-negative random integer.","nodes":[{"pos":[0,38],"content":"Returns a non-negative random integer.","nodes":[{"content":"Returns a non-negative random integer.","pos":[0,38]}]}],"pos":[43420,43459],"yaml":true},{"content":"<xref:System.Random.Next%2A?displayProperty=fullName> generates a random number whose value ranges from 0 to less than <xref:System.Int32?displayProperty=fullName>. To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=fullName> method overload. To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload.","nodes":[{"pos":[0,506],"content":"<xref:System.Random.Next%2A?displayProperty=fullName> generates a random number whose value ranges from 0 to less than <xref:System.Int32?displayProperty=fullName>. To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=fullName> method overload. To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload.","nodes":[{"content":"<xref:System.Random.Next%2A?displayProperty=fullName> generates a random number whose value ranges from 0 to less than <xref:System.Int32?displayProperty=fullName>. To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=fullName> method overload. To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload.","pos":[0,506],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Random.Next%2A?displayProperty=fullName&gt;</ph> generates a random number whose value ranges from 0 to less than <ph id=\"ph2\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>.","pos":[0,164],"source":"<xref:System.Random.Next%2A?displayProperty=fullName> generates a random number whose value ranges from 0 to less than <xref:System.Int32?displayProperty=fullName>."},{"content":"To generate a random number whose value ranges from 0 to some other positive number, use the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=fullName&gt;</ph> method overload.","pos":[165,343],"source":" To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=fullName> method overload."},{"content":"To generate a random number within a different range, use the <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName&gt;</ph> method overload.","pos":[344,506],"source":" To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload."}]}]}],"pos":[43470,43977],"yaml":true,"extradata":"MT"},{"content":"A 32-bit signed integer that is greater than or equal to 0 and less than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,116],"content":"A 32-bit signed integer that is greater than or equal to 0 and less than <ph id=\"ph1\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"A 32-bit signed integer that is greater than or equal to 0 and less than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[45591,45708],"yaml":true},{"content":"Returns a non-negative random integer that is less than the specified maximum.","nodes":[{"pos":[0,78],"content":"Returns a non-negative random integer that is less than the specified maximum.","nodes":[{"content":"Returns a non-negative random integer that is less than the specified maximum.","pos":[0,78]}]}],"pos":[47173,47252],"yaml":true},{"content":"The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` – 1. However, if `maxValue` is 0, the method returns 0.","nodes":[{"pos":[0,168],"content":"The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` – 1. However, if `maxValue` is 0, the method returns 0.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> overload returns random integers that range from 0 to <ph id=\"ph2\">`maxValue`</ph> – 1.","pos":[0,117],"source":"The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` – 1."},{"content":"However, if <ph id=\"ph1\">`maxValue`</ph> is 0, the method returns 0.","pos":[118,168],"source":" However, if `maxValue` is 0, the method returns 0."}]}],"pos":[47263,47432],"yaml":true,"extradata":"MT"},{"content":"The exclusive upper bound of the random number to be generated. <code>maxValue</code> must be greater than or equal to 0.","nodes":[{"pos":[0,121],"content":"The exclusive upper bound of the random number to be generated. <code>maxValue</code> must be greater than or equal to 0.","nodes":[{"content":"The exclusive upper bound of the random number to be generated.","pos":[0,63]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">maxValue</ph><ept id=\"p1\">&lt;/code&gt;</ept> must be greater than or equal to 0.","pos":[64,121],"source":"<code>maxValue</code> must be greater than or equal to 0."}]}],"pos":[48757,48879],"yaml":true},{"content":"A 32-bit signed integer that is greater than or equal to 0, and less than <code>maxValue</code>; that is, the range of return values ordinarily includes 0 but not <code>maxValue</code>. However, if <code>maxValue</code> equals 0, <code>maxValue</code> is returned.","nodes":[{"pos":[0,264],"content":"A 32-bit signed integer that is greater than or equal to 0, and less than <code>maxValue</code>; that is, the range of return values ordinarily includes 0 but not <code>maxValue</code>. However, if <code>maxValue</code> equals 0, <code>maxValue</code> is returned.","nodes":[{"content":"A 32-bit signed integer that is greater than or equal to 0, and less than <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">maxValue</ph><ept id=\"p1\">&lt;/code&gt;</ept>; that is, the range of return values ordinarily includes 0 but not <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">maxValue</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","pos":[0,185],"source":"A 32-bit signed integer that is greater than or equal to 0, and less than <code>maxValue</code>; that is, the range of return values ordinarily includes 0 but not <code>maxValue</code>."},{"content":"However, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">maxValue</ph><ept id=\"p1\">&lt;/code&gt;</ept> equals 0, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">maxValue</ph><ept id=\"p2\">&lt;/code&gt;</ept> is returned.","pos":[186,264],"source":" However, if <code>maxValue</code> equals 0, <code>maxValue</code> is returned."}]}],"pos":[48935,49200],"yaml":true},{"content":"<code>maxValue</code> is less than 0.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;maxValue&lt;/code&gt;</ph> is less than 0.","source":"<code>maxValue</code> is less than 0."}],"pos":[49360,49398],"yaml":true},{"content":"Returns a random integer that is within a specified range.","nodes":[{"pos":[0,58],"content":"Returns a random integer that is within a specified range.","nodes":[{"content":"Returns a random integer that is within a specified range.","pos":[0,58]}]}],"pos":[50874,50933],"yaml":true},{"content":"The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` – 1. However, if `maxValue` equals `minValue`, the method returns `minValue`.  \n  \n Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.","nodes":[{"pos":[0,214],"content":"The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` – 1. However, if `maxValue` equals `minValue`, the method returns `minValue`.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> overload returns random integers that range from <ph id=\"ph2\">`minValue`</ph> to <ph id=\"ph3\">`maxValue`</ph> – 1.","pos":[0,141],"source":"The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` – 1."},{"content":"However, if <ph id=\"ph1\">`maxValue`</ph> equals <ph id=\"ph2\">`minValue`</ph>, the method returns <ph id=\"ph3\">`minValue`</ph>.","pos":[142,214],"source":" However, if `maxValue` equals `minValue`, the method returns `minValue`."}]},{"pos":[221,380],"content":"Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.","nodes":[{"content":"Unlike the other overloads of the <ph id=\"ph1\">&lt;xref:System.Random.Next%2A&gt;</ph> method, which return only non-negative values, this method can return a negative random integer.","pos":[0,159],"source":"Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer."}]}],"pos":[50944,51329],"yaml":true,"extradata":"MT"},{"content":"The inclusive lower bound of the random number returned.","nodes":[{"pos":[0,56],"content":"The inclusive lower bound of the random number returned.","nodes":[{"content":"The inclusive lower bound of the random number returned.","pos":[0,56]}]}],"pos":[52874,52931],"yaml":true},{"content":"The exclusive upper bound of the random number returned. <code>maxValue</code> must be greater than or equal to <code>minValue</code>.","nodes":[{"pos":[0,134],"content":"The exclusive upper bound of the random number returned. <code>maxValue</code> must be greater than or equal to <code>minValue</code>.","nodes":[{"content":"The exclusive upper bound of the random number returned.","pos":[0,56]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">maxValue</ph><ept id=\"p1\">&lt;/code&gt;</ept> must be greater than or equal to <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">minValue</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","pos":[57,134],"source":"<code>maxValue</code> must be greater than or equal to <code>minValue</code>."}]}],"pos":[52994,53129],"yaml":true},{"content":"A 32-bit signed integer greater than or equal to <code>minValue</code> and less than <code>maxValue</code>; that is, the range of return values includes <code>minValue</code> but not <code>maxValue</code>. If <code>minValue</code> equals <code>maxValue</code>, <code>minValue</code> is returned.","nodes":[{"pos":[0,295],"content":"A 32-bit signed integer greater than or equal to <code>minValue</code> and less than <code>maxValue</code>; that is, the range of return values includes <code>minValue</code> but not <code>maxValue</code>. If <code>minValue</code> equals <code>maxValue</code>, <code>minValue</code> is returned.","nodes":[{"content":"A 32-bit signed integer greater than or equal to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">minValue</ph><ept id=\"p1\">&lt;/code&gt;</ept> and less than <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">maxValue</ph><ept id=\"p2\">&lt;/code&gt;</ept>; that is, the range of return values includes <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph3\">minValue</ph><ept id=\"p3\">&lt;/code&gt;</ept> but not <bpt id=\"p4\">&lt;code&gt;</bpt><ph id=\"ph4\">maxValue</ph><ept id=\"p4\">&lt;/code&gt;</ept>.","pos":[0,205],"source":"A 32-bit signed integer greater than or equal to <code>minValue</code> and less than <code>maxValue</code>; that is, the range of return values includes <code>minValue</code> but not <code>maxValue</code>."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">minValue</ph><ept id=\"p1\">&lt;/code&gt;</ept> equals <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">maxValue</ph><ept id=\"p2\">&lt;/code&gt;</ept>, <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph3\">minValue</ph><ept id=\"p3\">&lt;/code&gt;</ept> is returned.","pos":[206,295],"source":" If <code>minValue</code> equals <code>maxValue</code>, <code>minValue</code> is returned."}]}],"pos":[53185,53481],"yaml":true},{"content":"<code>minValue</code> is greater than <code>maxValue</code>.","nodes":[{"pos":[0,60],"content":"<ph id=\"ph1\">&lt;code&gt;minValue&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;code&gt;maxValue&lt;/code&gt;</ph>.","source":"<code>minValue</code> is greater than <code>maxValue</code>."}],"pos":[53641,53702],"yaml":true},{"content":"Fills the elements of a specified array of bytes with random numbers.","nodes":[{"pos":[0,69],"content":"Fills the elements of a specified array of bytes with random numbers.","nodes":[{"content":"Fills the elements of a specified array of bytes with random numbers.","pos":[0,69]}]}],"pos":[55154,55224],"yaml":true},{"content":"Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.  \n  \n For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=fullName>.","nodes":[{"pos":[0,143],"content":"Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.","nodes":[{"content":"Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <ph id=\"ph1\">&lt;xref:System.Byte.MaxValue&gt;</ph>.","pos":[0,143],"source":"Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>."}]},{"pos":[150,377],"content":"For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=fullName>.","nodes":[{"content":"For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=fullName&gt;</ph>.","pos":[0,227],"source":"For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=fullName>."}]}],"pos":[55235,55617],"yaml":true,"extradata":"MT"},{"content":"An array of bytes to contain random numbers.","nodes":[{"pos":[0,44],"content":"An array of bytes to contain random numbers.","nodes":[{"content":"An array of bytes to contain random numbers.","pos":[0,44]}]}],"pos":[56383,56428],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[56581,56612],"yaml":true},{"content":"Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.","nodes":[{"pos":[0,95],"content":"Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.","nodes":[{"content":"Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.","pos":[0,95]}]}],"pos":[58007,58103],"yaml":true},{"content":"The actual upper bound of the random number returned by this method is 0.99999999999999978.  \n  \n To retrieve random floating-point values within a range other than 0.0 and 1.0, see the \"Retrieve floating-point values in a specified range\" section of the <xref:System.Random> class topic.  \n  \n This method is the public version of the protected method, <xref:System.Random.Sample%2A>.","nodes":[{"pos":[0,91],"content":"The actual upper bound of the random number returned by this method is 0.99999999999999978.","nodes":[{"content":"The actual upper bound of the random number returned by this method is 0.99999999999999978.","pos":[0,91]}]},{"pos":[98,288],"content":"To retrieve random floating-point values within a range other than 0.0 and 1.0, see the \"Retrieve floating-point values in a specified range\" section of the <xref:System.Random> class topic.","nodes":[{"content":"To retrieve random floating-point values within a range other than 0.0 and 1.0, see the \"Retrieve floating-point values in a specified range\" section of the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class topic.","pos":[0,190],"source":"To retrieve random floating-point values within a range other than 0.0 and 1.0, see the \"Retrieve floating-point values in a specified range\" section of the <xref:System.Random> class topic."}]},{"pos":[295,385],"content":"This method is the public version of the protected method, <xref:System.Random.Sample%2A>.","nodes":[{"content":"This method is the public version of the protected method, <ph id=\"ph1\">&lt;xref:System.Random.Sample%2A&gt;</ph>.","pos":[0,90],"source":"This method is the public version of the protected method, <xref:System.Random.Sample%2A>."}]}],"pos":[58114,58508],"yaml":true,"extradata":"MT"},{"content":"A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.","nodes":[{"pos":[0,97],"content":"A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.","nodes":[{"content":"A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.","pos":[0,97]}]}],"pos":[59584,59682],"yaml":true},{"content":"Returns a random floating-point number between 0.0 and 1.0.","nodes":[{"pos":[0,59],"content":"Returns a random floating-point number between 0.0 and 1.0.","nodes":[{"content":"Returns a random floating-point number between 0.0 and 1.0.","pos":[0,59]}]}],"pos":[61108,61168],"yaml":true},{"content":"To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.  \n  \n> [!IMPORTANT]\n>  The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes. To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.","nodes":[{"pos":[0,199],"content":"To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.","nodes":[{"content":"To produce a different random distribution or a different random number generator principle, derive a class from the <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> class and override the <ph id=\"ph2\">&lt;xref:System.Random.Sample%2A&gt;</ph> method.","pos":[0,199],"source":"To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method."}]},{"pos":[207,516],"content":"[!IMPORTANT]\n The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes. To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.","leadings":["","> "],"nodes":[{"content":" The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes. To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.","pos":[13,307],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Random.Sample%2A&gt;</ph> method is <ph id=\"ph2\">`protected`</ph>, which means that it is accessible only within the <ph id=\"ph3\">&lt;xref:System.Random&gt;</ph> class and its derived classes.","pos":[1,160],"source":" The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes."},{"content":"To generate a random number between 0 and 1 from a <ph id=\"ph1\">&lt;xref:System.Random&gt;</ph> instance, call the <ph id=\"ph2\">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.","pos":[161,294],"source":" To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method."}]}]}],"pos":[61179,61701],"yaml":true,"extradata":"MT"},{"content":"A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.","nodes":[{"pos":[0,97],"content":"A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.","nodes":[{"content":"A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.","pos":[0,97]}]}],"pos":[62540,62638],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Random\n  commentId: T:System.Random\n  id: Random\n  children:\n  - System.Random.#ctor\n  - System.Random.#ctor(System.Int32)\n  - System.Random.Next\n  - System.Random.Next(System.Int32)\n  - System.Random.Next(System.Int32,System.Int32)\n  - System.Random.NextBytes(System.Byte[])\n  - System.Random.NextDouble\n  - System.Random.Sample\n  langs:\n  - csharp\n  name: Random\n  nameWithType: Random\n  fullName: System.Random\n  type: Class\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.\n  remarks: \"> [!NOTE]\\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \\n  \\n Pseudo-random numbers are chosen with equal probability from a finite set of numbers. The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes. The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm. For more information, see D. E. Knuth. *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*. Addison-Wesley, Reading, MA, third edition, 1997.  \\n  \\n To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=fullName>.  \\n  \\n In this topic:  \\n  \\n [Instantiating the random number generator](#Instantiate)   \\n [Avoiding multiple instantiations](#Multiple)   \\n [The System.Random class and thread safety](#ThreadSafety)   \\n [Generating different types of random numbers](#Functionality)   \\n [Substituting your own algorithm](#Overriding)   \\n [How do you use System.Random to…](#Operations)   \\n [Retrieve the same sequence of random values](#Same)  \\n [Retrieve unique sequences of random values](#Unique)  \\n [Retrieve integers in a specified range](#Range)  \\n [Retrieve integers with a specified number of digits](#Digits)  \\n [Retrieve floating-point values in a specified range](#Floats)  \\n [Generate random Boolean values](#Boolean)  \\n [Generate random 64-bit integers](#Long)  \\n [Retrieve bytes in a specified range](#Bytes)  \\n [Retrieve an element from an array or collection at random](#Array)  \\n [Retrieve a unique element from an array or collection](#UniqueArray)  \\n  \\n<a name=\\\"Instantiate\\\"></a>   \\n## Instantiating the random number generator  \\n You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.  You can supply the seed value either explicitly or implicitly:  \\n  \\n-   The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.  \\n  \\n-   The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value. This is the most common way of instantiating the random number generator.  \\n  \\n If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers. This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers. However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.  \\n  \\n To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>. The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value. However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers. The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers. On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.  \\n  \\n [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]\\n [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]\\n [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  \\n  \\n To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.  \\n  \\n<a name=\\\"Multiple\\\"></a>   \\n## Avoiding multiple instantiations  \\n Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers. In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.  \\n  \\n Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.  \\n  \\n However, the <xref:System.Random> class isn't thread safe. If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.  \\n  \\n<a name=\\\"ThreadSafety\\\"></a>   \\n## The System.Random class and thread safety  \\n Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app. However, <xref:System.Random> objects are not thread safe. If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time. If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.  \\n  \\n The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner. Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.  \\n  \\n [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]\\n [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]\\n [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  \\n  \\n The example ensures thread-safety in the following ways:  \\n  \\n-   The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.  \\n  \\n-   A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.  \\n  \\n-   A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.  \\n  \\n-   The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0. If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.  \\n  \\n-   Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object. If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> method to cancel the thread.  \\n  \\n The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.  \\n  \\n [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]\\n [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  \\n  \\n It differs from the first example in the following ways:  \\n  \\n-   The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.  \\n  \\n-   The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method is used to ensure that the main thread doesn't complete before all tasks have finished. There is no need for the <xref:System.Threading.CountdownEvent> object.  \\n  \\n-   The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method. In the previous example, it is handled by each thread.  \\n  \\n<a name=\\\"Functionality\\\"></a>   \\n## Generating different types of random numbers  \\n The random number generator provides methods that let you generate the following kinds of random numbers:  \\n  \\n-   A series of <xref:System.Byte> values. You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method. The following example generates 20 bytes.  \\n  \\n     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]\\n     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]\\n     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  \\n  \\n-   A single integer. You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=fullName> – 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method. In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.  \\n  \\n     The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10. Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method. In other words, the largest integer that the method can return is one less than this value.  \\n  \\n     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]\\n     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]\\n     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  \\n  \\n-   A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method. The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978. The following example generates 10 random floating-point numbers.  \\n  \\n     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]\\n     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]\\n     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  \\n  \\n> [!IMPORTANT]\\n>  The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number. However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value. This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.  \\n  \\n You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray). For these and other common tasks, see the [How do you use System.Random to…](#Operations) section.  \\n  \\n<a name=\\\"Overriding\\\"></a>   \\n## Substituting your own algorithm  \\n You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm. To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm. You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method. You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.  \\n  \\n For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.  \\n  \\n<a name=\\\"Operations\\\"></a>   \\n## How do you use System.Random to…  \\n The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.  \\n  \\n<a name=\\\"Same\\\"></a>   \\n### Retrieve the same sequence of random values  \\n Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing. Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes. Using the same sequence of random number in games allows you to replay previous games.  \\n  \\n You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. The seed value provides a starting value for the pseudo-random number generation algorithm. The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value. It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.  Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.  \\n  \\n [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]\\n [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]\\n [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  \\n  \\n<a name=\\\"Unique\\\"></a>   \\n### Retrieve unique sequences of random numbers  \\n Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values. You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor. Most developers call the parameterless constructor, which uses the system clock. The following example uses this approach to instantiate two <xref:System.Random> instances. Each instance displays a series of 10 random integers.  \\n  \\n [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]\\n [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]\\n [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  \\n  \\n However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds. Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values. To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method call, and compile and run the example again.  \\n  \\n To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones. However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic. Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.  \\n  \\n<a name=\\\"Range\\\"></a>   \\n### Retrieve integers in a specified range  \\n You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return. The upper bound is an exclusive, not an inclusive, value. That is, it isn't included in the range of values returned by the method. The following example uses this method to generate random integers between -10 and 10. Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.  \\n  \\n [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]\\n [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]\\n [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  \\n  \\n<a name=\\\"Digits\\\"></a>   \\n### Retrieve integers with a specified number of digits  \\n You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits. For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.  \\n  \\n [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]\\n [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]\\n [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  \\n  \\n<a name=\\\"Floats\\\"></a>   \\n### Retrieve floating-point values in a specified range  \\n The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1. However, you'll often want to generate random values in some other range.  \\n  \\n If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method. The following example does this to generate 10 random numbers between -1 and 0.  \\n  \\n [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]\\n [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]\\n [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  \\n  \\n To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound. The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. In also displays the distribution of the random values generated by the method.  \\n  \\n [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]\\n [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]\\n [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  \\n  \\n To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:  \\n  \\n```  \\nRandom.NextDouble() * (maxValue – minValue) + minValue  \\n```  \\n  \\n The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.  \\n  \\n [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]\\n [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]\\n [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  \\n  \\n<a name=\\\"Boolean\\\"></a>   \\n### Generate random Boolean values  \\n The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values. However, you can define your own class or method to do that. The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`. The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable. The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=fullName> method. Note that 2 is used as the argument to specify the upper bound of the random number. Since this is an exclusive value, the method call returns either 0 or 1.  \\n  \\n [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]\\n [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]\\n [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  \\n  \\n Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method. In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call. In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.  The following example provides an implementation.  \\n  \\n [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]\\n [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]\\n [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  \\n  \\n<a name=\\\"Long\\\"></a>   \\n### Generate random 64-bit integers  \\n The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers. However, in some cases, you might want to work with 64-bit integers. You can do this as follows:  \\n  \\n1.  Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.  \\n  \\n2.  Multiply that value by <xref:System.Int64.MaxValue?displayProperty=fullName>.  \\n  \\n The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups. It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=fullName>. As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.  \\n  \\n [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]\\n [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]\\n [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  \\n  \\n An alternative technique that uses bit manipulation does not generate truly random numbers. This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together. This technique has two limitations:  \\n  \\n1.  Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.  This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.  \\n  \\n2.  More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.  \\n  \\n<a name=\\\"Bytes\\\"></a>   \\n### Retrieve bytes in a specified range  \\n The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not. The following example implements a `NextBytes` method that lets you specify the range of the returned bytes. It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.  \\n  \\n [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]\\n [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]\\n [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  \\n  \\n The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array. Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.  \\n  \\n<a name=\\\"Array\\\"></a>   \\n### Retrieve an element from an array or collection at random  \\n Random numbers often serve as indexes to retrieve values from arrays or collections. To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument. For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=fullName> method. The following example randomly retrieves the name of a city in the United States from an array of cities.  \\n  \\n [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]\\n [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]\\n [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  \\n  \\n<a name=\\\"UniqueArray\\\"></a>   \\n### Retrieve a unique element from an array or collection  \\n A random number generator can always return duplicate values. As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows. If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.  \\n  \\n There are a number of techniques to handle this scenario. One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers. The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is used to sort the first array by using the values in the parallel array.  \\n  \\n For example, if you're developing a Solitaire game, you want to ensure that each card is used only once. Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck. Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.  \\n  \\n The following example illustrates this approach. It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards. The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.  The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> method is then called to sort the `deck` array based on the values in the `order` array.  \\n  \\n [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]\\n [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]\\n [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]\"\n  example:\n  - \"The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.  \\n  \\n [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]\\n [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]\\n [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  \\n  \\n The following example generates a random integer that it uses as an index to retrieve a string value from an array.  \\n  \\n [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]\\n [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]\\n [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class Random\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.#ctor\n  commentId: M:System.Random.#ctor\n  id: '#ctor'\n  parent: System.Random\n  langs:\n  - csharp\n  name: Random()\n  nameWithType: Random.Random()\n  fullName: Random.Random()\n  type: Constructor\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Initializes a new instance of the <xref href=\"System.Random\"></xref> class, using a time-dependent default seed value.\n  remarks: \"The default seed value is derived from the system clock and has finite resolution. As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers. This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers. You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor. For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.  \\n  \\n Call this constructor if you want your random number generator to generate a random sequence of numbers. To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value . This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.  \\n  \\n Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.\"\n  example:\n  - \"The following example uses the default constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each. Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers. On the other hand, the default constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method. Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.  \\n  \\n [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]\\n [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]\"\n  syntax:\n    content: public Random ();\n    parameters: []\n  overload: System.Random.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.#ctor(System.Int32)\n  commentId: M:System.Random.#ctor(System.Int32)\n  id: '#ctor(System.Int32)'\n  parent: System.Random\n  langs:\n  - csharp\n  name: Random(Int32)\n  nameWithType: Random.Random(Int32)\n  fullName: Random.Random(Int32)\n  type: Constructor\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Initializes a new instance of the <xref href=\"System.Random\"></xref> class, using the specified seed value.\n  remarks: \"Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers. This is often done when testing apps that rely on random number generators.  \\n  \\n If your application requires different random number sequences, invoke this constructor repeatedly with different seed values. One way to produce a unique seed value is to make it time-dependent. For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does. However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value. This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example. To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to ensure that you provide each constructor with a different seed value.  \\n  \\n [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]\\n [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  \\n  \\n Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application. This yields slightly better performance, since instantiating a random number generator is fairly expensive.\"\n  example:\n  - \"The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles. The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.  \\n  \\n [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]\\n [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]\\n [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]\"\n  syntax:\n    content: public Random (int Seed);\n    parameters:\n    - id: Seed\n      type: System.Int32\n      description: A number used to calculate a starting value for the pseudo-random number sequence. If a negative number is specified, the absolute value of the number is used.\n  overload: System.Random.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.Next\n  commentId: M:System.Random.Next\n  id: Next\n  parent: System.Random\n  langs:\n  - csharp\n  name: Next()\n  nameWithType: Random.Next()\n  fullName: Random.Next()\n  type: Method\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a non-negative random integer.\n  remarks: <xref:System.Random.Next%2A?displayProperty=fullName> generates a random number whose value ranges from 0 to less than <xref:System.Int32?displayProperty=fullName>. To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=fullName> method overload. To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload.\n  example:\n  - \"The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user. The <xref:System.Console.ReadLine%2A?displayProperty=fullName> method is used to get customer input.  \\n  \\n [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]\\n [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]\\n [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  \\n  \\n The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class. It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=fullName> method to use series of random numbers.  \\n  \\n [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]\\n [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]\\n [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]\"\n  syntax:\n    content: public virtual int Next ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: A 32-bit signed integer that is greater than or equal to 0 and less than <xref href=\"System.Int32.MaxValue\"></xref>.\n  overload: System.Random.Next*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.Next(System.Int32)\n  commentId: M:System.Random.Next(System.Int32)\n  id: Next(System.Int32)\n  parent: System.Random\n  langs:\n  - csharp\n  name: Next(Int32)\n  nameWithType: Random.Next(Int32)\n  fullName: Random.Next(Int32)\n  type: Method\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a non-negative random integer that is less than the specified maximum.\n  remarks: The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` – 1. However, if `maxValue` is 0, the method returns 0.\n  example:\n  - \"The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.  \\n  \\n [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]\\n [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]\\n [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  \\n  \\n The following example generates a random integer that it uses as an index to retrieve a string value from an array. Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=fullName> property is supplied as a the `maxValue` parameter.  \\n  \\n [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]\\n [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]\\n [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]\"\n  syntax:\n    content: public virtual int Next (int maxValue);\n    parameters:\n    - id: maxValue\n      type: System.Int32\n      description: The exclusive upper bound of the random number to be generated. <code>maxValue</code> must be greater than or equal to 0.\n    return:\n      type: System.Int32\n      description: A 32-bit signed integer that is greater than or equal to 0, and less than <code>maxValue</code>; that is, the range of return values ordinarily includes 0 but not <code>maxValue</code>. However, if <code>maxValue</code> equals 0, <code>maxValue</code> is returned.\n  overload: System.Random.Next*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>maxValue</code> is less than 0.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.Next(System.Int32,System.Int32)\n  commentId: M:System.Random.Next(System.Int32,System.Int32)\n  id: Next(System.Int32,System.Int32)\n  parent: System.Random\n  langs:\n  - csharp\n  name: Next(Int32, Int32)\n  nameWithType: Random.Next(Int32, Int32)\n  fullName: Random.Next(Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a random integer that is within a specified range.\n  remarks: \"The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` – 1. However, if `maxValue` equals `minValue`, the method returns `minValue`.  \\n  \\n Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.\"\n  example:\n  - \"The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> method to generate random integers with three distinct ranges. Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.  \\n  \\n [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]\\n [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]\\n [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  \\n  \\n The following example generates a random integer that it uses as an index to retrieve a string value from an array. Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=fullName> property is supplied as a the `maxValue` parameter.  \\n  \\n [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]\\n [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]\\n [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]\"\n  syntax:\n    content: public virtual int Next (int minValue, int maxValue);\n    parameters:\n    - id: minValue\n      type: System.Int32\n      description: The inclusive lower bound of the random number returned.\n    - id: maxValue\n      type: System.Int32\n      description: The exclusive upper bound of the random number returned. <code>maxValue</code> must be greater than or equal to <code>minValue</code>.\n    return:\n      type: System.Int32\n      description: A 32-bit signed integer greater than or equal to <code>minValue</code> and less than <code>maxValue</code>; that is, the range of return values includes <code>minValue</code> but not <code>maxValue</code>. If <code>minValue</code> equals <code>maxValue</code>, <code>minValue</code> is returned.\n  overload: System.Random.Next*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>minValue</code> is greater than <code>maxValue</code>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.NextBytes(System.Byte[])\n  commentId: M:System.Random.NextBytes(System.Byte[])\n  id: NextBytes(System.Byte[])\n  parent: System.Random\n  langs:\n  - csharp\n  name: NextBytes(Byte[])\n  nameWithType: Random.NextBytes(Byte[])\n  fullName: Random.NextBytes(Byte[])\n  type: Method\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Fills the elements of a specified array of bytes with random numbers.\n  remarks: \"Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.  \\n  \\n For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=fullName>.\"\n  example:\n  - \"The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.  \\n  \\n [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]\\n [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual void NextBytes (byte[] buffer);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of bytes to contain random numbers.\n  overload: System.Random.NextBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.NextDouble\n  commentId: M:System.Random.NextDouble\n  id: NextDouble\n  parent: System.Random\n  langs:\n  - csharp\n  name: NextDouble()\n  nameWithType: Random.NextDouble()\n  fullName: Random.NextDouble()\n  type: Method\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.\n  remarks: \"The actual upper bound of the random number returned by this method is 0.99999999999999978.  \\n  \\n To retrieve random floating-point values within a range other than 0.0 and 1.0, see the \\\"Retrieve floating-point values in a specified range\\\" section of the <xref:System.Random> class topic.  \\n  \\n This method is the public version of the protected method, <xref:System.Random.Sample%2A>.\"\n  example:\n  - \"The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.  \\n  \\n [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]\\n [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]\\n [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  \\n  \\n The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.  \\n  \\n [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]\\n [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]\"\n  syntax:\n    content: public virtual double NextDouble ();\n    parameters: []\n    return:\n      type: System.Double\n      description: A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.\n  overload: System.Random.NextDouble*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Random.Sample\n  commentId: M:System.Random.Sample\n  id: Sample\n  parent: System.Random\n  langs:\n  - csharp\n  name: Sample()\n  nameWithType: Random.Sample()\n  fullName: Random.Sample()\n  type: Method\n  assemblies:\n  - System.Runtime.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a random floating-point number between 0.0 and 1.0.\n  remarks: \"To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.  \\n  \\n> [!IMPORTANT]\\n>  The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes. To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.\"\n  example:\n  - \"The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers. This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.  \\n  \\n [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]\\n [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]\\n [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]\"\n  syntax:\n    content: protected virtual double Sample ();\n    parameters: []\n    return:\n      type: System.Double\n      description: A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.\n  overload: System.Random.Sample*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.Random.#ctor\n  parent: System.Random\n  isExternal: false\n  name: Random()\n  nameWithType: Random.Random()\n  fullName: Random.Random()\n- uid: System.Random.#ctor(System.Int32)\n  parent: System.Random\n  isExternal: false\n  name: Random(Int32)\n  nameWithType: Random.Random(Int32)\n  fullName: Random.Random(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Random.Next\n  parent: System.Random\n  isExternal: false\n  name: Next()\n  nameWithType: Random.Next()\n  fullName: Random.Next()\n- uid: System.Random.Next(System.Int32)\n  parent: System.Random\n  isExternal: false\n  name: Next(Int32)\n  nameWithType: Random.Next(Int32)\n  fullName: Random.Next(Int32)\n- uid: System.Random.Next(System.Int32,System.Int32)\n  parent: System.Random\n  isExternal: false\n  name: Next(Int32, Int32)\n  nameWithType: Random.Next(Int32, Int32)\n  fullName: Random.Next(Int32, Int32)\n- uid: System.Random.NextBytes(System.Byte[])\n  parent: System.Random\n  isExternal: false\n  name: NextBytes(Byte[])\n  nameWithType: Random.NextBytes(Byte[])\n  fullName: Random.NextBytes(Byte[])\n- uid: System.Byte\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte\n- uid: System.Byte[]\n  parent: System\n  isExternal: false\n  name: Byte[]\n  nameWithType: Byte[]\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: System.Byte\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Random.NextDouble\n  parent: System.Random\n  isExternal: false\n  name: NextDouble()\n  nameWithType: Random.NextDouble()\n  fullName: Random.NextDouble()\n- uid: System.Double\n  parent: System\n  isExternal: false\n  name: Double\n  nameWithType: Double\n  fullName: System.Double\n- uid: System.Random.Sample\n  parent: System.Random\n  isExternal: false\n  name: Sample()\n  nameWithType: Random.Sample()\n  fullName: Random.Sample()\n- uid: System.Random.#ctor*\n  parent: System.Random\n  isExternal: false\n  name: Random\n  nameWithType: Random.Random\n  fullName: Random.Random\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n- uid: System.Random.Next*\n  parent: System.Random\n  isExternal: false\n  name: Next\n  nameWithType: Random.Next\n  fullName: Random.Next\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n- uid: System.Random.NextBytes*\n  parent: System.Random\n  isExternal: false\n  name: NextBytes\n  nameWithType: Random.NextBytes\n  fullName: Random.NextBytes\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n- uid: System.Random.NextDouble*\n  parent: System.Random\n  isExternal: false\n  name: NextDouble\n  nameWithType: Random.NextDouble\n  fullName: Random.NextDouble\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n- uid: System.Random.Sample*\n  parent: System.Random\n  isExternal: false\n  name: Sample\n  nameWithType: Random.Sample\n  fullName: Random.Sample\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Random.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}