{"nodes":[{"content":"Represents a wrapper class for handle resources.","nodes":[{"pos":[0,48],"content":"Represents a wrapper class for handle resources.","nodes":[{"content":"Represents a wrapper class for handle resources.","pos":[0,48]}]}],"pos":[1210,1259],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting. You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.  \n  \n Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks. Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost. If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic. The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.","nodes":[{"pos":[0,469],"content":"The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting. You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.","nodes":[{"content":"The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting. You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.","pos":[0,469],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class is similar to the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, except that <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implements reference counting.","pos":[0,228],"source":"The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> instead of <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.","pos":[229,469],"source":" You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself."}]}]},{"pos":[476,1414],"content":"Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks. Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost. If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic. The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.","nodes":[{"content":"Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks. Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost. If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic. The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.","pos":[0,938],"nodes":[{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class does not perform reference counting, it does not provide protection from handle recycling security attacks.","pos":[0,178],"source":"Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks."},{"content":"Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.","pos":[179,301]},{"content":"If you call the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method while an operation that is using the handle is outstanding on another thread, or if you call <ph id=\"ph3\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> from two threads at the same time, the results are non-deterministic.","pos":[302,733],"source":" If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class still provides the guaranteed critical finalization provided by the <ph id=\"ph2\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class.","pos":[734,938],"source":" The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class."}]}]}],"pos":[1270,2689],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref> class with the specified invalid handle value.","nodes":[{"pos":[0,147],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.CriticalHandle\"&gt;&lt;/xref&gt;</ph> class with the specified invalid handle value.","source":"Initializes a new instance of the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref> class with the specified invalid handle value."}],"pos":[5058,5206],"yaml":true},{"content":"The value of an invalid handle (usually 0 or -1).","nodes":[{"pos":[0,49],"content":"The value of an invalid handle (usually 0 or -1).","nodes":[{"content":"The value of an invalid handle (usually 0 or -1).","pos":[0,49]}]}],"pos":[5373,5423],"yaml":true},{"content":"The derived class resides in an assembly without unmanaged code access permission.","nodes":[{"pos":[0,82],"content":"The derived class resides in an assembly without unmanaged code access permission.","nodes":[{"content":"The derived class resides in an assembly without unmanaged code access permission.","pos":[0,82]}]}],"pos":[5596,5679],"yaml":true},{"content":"Marks the handle for releasing and freeing resources.","nodes":[{"pos":[0,53],"content":"Marks the handle for releasing and freeing resources.","nodes":[{"content":"Marks the handle for releasing and freeing resources.","pos":[0,53]}]}],"pos":[7138,7192],"yaml":true},{"content":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.  \n  \n Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.  \n  \n **Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.","nodes":[{"pos":[0,932],"content":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.","nodes":[{"content":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.","pos":[0,932],"nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.","pos":[0,181],"source":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed."},{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.","pos":[182,372],"source":" Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle."},{"content":"Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method.","pos":[373,530],"source":" Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method."},{"content":"Although most classes that use the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).","pos":[531,769],"source":" Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory)."},{"content":"In this case, the class can provide a finalizer that is guaranteed to run before the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.","pos":[770,932],"source":" In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs."}]}]},{"pos":[939,1342],"content":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.","nodes":[{"content":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.","pos":[0,403],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.","pos":[0,237],"source":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.","pos":[238,403],"source":" The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state."}]}]},{"pos":[1349,1833],"content":"**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> Always call <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.","pos":[0,256],"source":"**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.","pos":[257,484],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method."}]}],"pos":[7203,9043],"yaml":true,"extradata":"MT"},{"content":"Releases all resources used by the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref>.","nodes":[{"pos":[0,102],"content":"Releases all resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.CriticalHandle\"&gt;&lt;/xref&gt;</ph>.","source":"Releases all resources used by the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref>."}],"pos":[10558,10661],"yaml":true},{"content":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.  \n  \n Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.  \n  \n **Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.","nodes":[{"pos":[0,934],"content":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.","nodes":[{"content":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.","pos":[0,934],"nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.","pos":[0,181],"source":"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed."},{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.","pos":[182,372],"source":" Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle."},{"content":"Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method.","pos":[373,532],"source":" Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method."},{"content":"Although most classes that use the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).","pos":[533,771],"source":" Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory)."},{"content":"In this case, the class can provide a finalizer that is guaranteed to run before the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.","pos":[772,934],"source":" In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs."}]}]},{"pos":[941,1344],"content":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.","nodes":[{"content":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.","pos":[0,403],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.","pos":[0,237],"source":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.","pos":[238,403],"source":" The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state."}]}]},{"pos":[1351,1846],"content":"**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> Always call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.","pos":[0,267],"source":"**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.","pos":[268,495],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method."}]}],"pos":[10672,12525],"yaml":true,"extradata":"MT"},{"content":"Releases the unmanaged resources used by the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref> class specifying whether to perform a normal dispose operation.","nodes":[{"pos":[0,175],"content":"Releases the unmanaged resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.CriticalHandle\"&gt;&lt;/xref&gt;</ph> class specifying whether to perform a normal dispose operation.","source":"Releases the unmanaged resources used by the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref> class specifying whether to perform a normal dispose operation."}],"pos":[14277,14453],"yaml":true},{"content":"You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.","nodes":[{"pos":[0,154],"content":"You should never explicitly call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method with the <ph id=\"ph2\">`disposing`</ph> parameter set to <ph id=\"ph3\">`false`</ph>.","source":"You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`."}],"pos":[14464,14619],"yaml":true,"extradata":"MT"},{"content":"`true` for a normal dispose operation; `false` to finalize the handle.","nodes":[{"pos":[0,70],"content":"<ph id=\"ph1\">`true`</ph> for a normal dispose operation; <ph id=\"ph2\">`false`</ph> to finalize the handle.","source":"`true` for a normal dispose operation; `false` to finalize the handle."}],"pos":[14824,14897],"yaml":true},{"content":"Frees all resources associated with the handle.","nodes":[{"pos":[0,47],"content":"Frees all resources associated with the handle.","nodes":[{"content":"Frees all resources associated with the handle.","pos":[0,47]}]}],"pos":[16569,16617],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class. Application code should not call this method directly.","nodes":[{"pos":[0,216],"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class. Application code should not call this method directly.","nodes":[{"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class. Application code should not call this method directly.","pos":[0,216],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class.","pos":[0,161],"source":"The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class."},{"content":"Application code should not call this method directly.","pos":[162,216]}]}]}],"pos":[16628,16845],"yaml":true,"extradata":"MT"},{"content":"Specifies the handle to be wrapped.","nodes":[{"pos":[0,35],"content":"Specifies the handle to be wrapped.","nodes":[{"content":"Specifies the handle to be wrapped.","pos":[0,35]}]}],"pos":[18512,18548],"yaml":true},{"content":"Do not expose the handle publicly (that is, outside of the derived class).","nodes":[{"pos":[0,74],"content":"Do not expose the handle publicly (that is, outside of the derived class).","nodes":[{"content":"Do not expose the handle publicly (that is, outside of the derived class).","pos":[0,74]}]}],"pos":[18559,18634],"yaml":true,"extradata":"MT"},{"content":"Gets a value indicating whether the handle is closed.","nodes":[{"pos":[0,53],"content":"Gets a value indicating whether the handle is closed.","nodes":[{"content":"Gets a value indicating whether the handle is closed.","pos":[0,53]}]}],"pos":[20277,20331],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource. This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid. The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:  \n  \n-   The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.  \n  \n-   The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.","nodes":[{"pos":[0,538],"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource. This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid. The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's handle is no longer associated with a native resource.","pos":[0,231],"source":"The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource."},{"content":"This differs from the definition of the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.","pos":[232,415],"source":" This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a <ph id=\"ph2\">`true`</ph> value in the following cases:","pos":[416,538],"source":" The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:"}]},{"pos":[548,645],"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.","pos":[0,97],"source":"The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called."}]},{"pos":[655,925],"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object on other threads.","pos":[0,270],"source":"The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads."}]}],"pos":[20342,21274],"yaml":true,"extradata":"MT"},{"content":"`true` if the handle is closed; otherwise, `false`.","nodes":[{"pos":[0,51],"content":"<ph id=\"ph1\">`true`</ph> if the handle is closed; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the handle is closed; otherwise, `false`."}],"pos":[21582,21636],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the handle value is invalid.","nodes":[{"pos":[0,96],"content":"When overridden in a derived class, gets a value indicating whether the handle value is invalid.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the handle value is invalid.","pos":[0,96]}]}],"pos":[23332,23429],"yaml":true},{"content":"Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.  \n  \n Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.","nodes":[{"pos":[0,396],"content":"Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.","nodes":[{"content":"Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.","pos":[0,396],"nodes":[{"content":"Derived classes must implement the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.","pos":[0,202],"source":"Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required."},{"content":"Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).","pos":[203,322]},{"content":"These classes can then be further derived for specific safe handle types.","pos":[323,396]}]}]},{"pos":[403,913],"content":"Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.","nodes":[{"content":"Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.","pos":[0,510],"nodes":[{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object has finished using the underlying handle, the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.","pos":[0,364],"source":"Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid."},{"content":"Therefore, the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.","pos":[365,510],"source":" Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value."}]}]}],"pos":[23440,24358],"yaml":true,"extradata":"MT"},{"content":"`true` if the handle is valid; otherwise, `false`.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">`true`</ph> if the handle is valid; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the handle is valid; otherwise, `false`."}],"pos":[24676,24729],"yaml":true},{"content":"When overridden in a derived class, executes the code required to free the handle.","nodes":[{"pos":[0,82],"content":"When overridden in a derived class, executes the code required to free the handle.","nodes":[{"content":"When overridden in a derived class, executes the code required to free the handle.","pos":[0,82]}]}],"pos":[26454,26537],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made. The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`. Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail. The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method. In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>. In most cases this code should be:  \n  \n `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  \n  \n Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.  \n  \n If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.","nodes":[{"pos":[0,1942],"content":"The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made. The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`. Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail. The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method. In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>. In most cases this code should be:","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method is made.","pos":[0,358],"source":"The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method will not be called if the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property is <ph id=\"ph4\">`true`</ph>.","pos":[359,619],"source":" The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`."},{"content":"Implement this method in your <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> derived classes to execute any code that is required to free the handle.","pos":[620,775],"source":" Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle."},{"content":"Because one of the functions of <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> must never fail.","pos":[776,1028],"source":" Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail."},{"content":"The garbage collector calls <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.","pos":[1029,1325],"source":" The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress."},{"content":"This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).","pos":[1326,1496]},{"content":"Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method.","pos":[1497,1700],"source":" Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method."},{"content":"In particular, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.","pos":[1701,1907],"source":" In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>."},{"content":"In most cases this code should be:","pos":[1908,1942]}]},{"pos":[2023,2380],"content":"Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.","nodes":[{"content":"Additionally, for simple cleanup (for example, calling the Win32 API <ph id=\"ph1\">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.","pos":[0,168],"source":"Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call."},{"content":"For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.","pos":[169,274]},{"content":"You must ensure that your program logic has fallback code for each of those cases.","pos":[275,357]}]},{"pos":[2387,2633],"content":"If the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method returns <ph id=\"ph2\">`false`</ph> for any reason, it generates a <bpt id=\"p1\">[</bpt>releaseHandleFailed<ept id=\"p1\">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.","source":"If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant."}],"pos":[26548,29190],"yaml":true,"extradata":"MT"},{"content":"`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`. In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.","nodes":[{"pos":[0,251],"content":"`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`. In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id=\"ph2\">`false`</ph>.","pos":[0,106],"source":"`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`."},{"content":"In this case, it generates a <bpt id=\"p1\">[</bpt>releaseHandleFailed<ept id=\"p1\">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.","pos":[107,251],"source":" In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant."}]}],"pos":[29332,29586],"yaml":true},{"content":"Sets the handle to the specified pre-existing handle.","nodes":[{"pos":[0,53],"content":"Sets the handle to the specified pre-existing handle.","nodes":[{"content":"Sets the handle to the specified pre-existing handle.","pos":[0,53]}]}],"pos":[31284,31338],"yaml":true},{"content":"Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.","nodes":[{"pos":[0,292],"content":"Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.","pos":[0,292],"source":"Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure."}]}],"pos":[31349,31642],"yaml":true,"extradata":"MT"},{"content":"The pre-existing handle to use.","nodes":[{"pos":[0,31],"content":"The pre-existing handle to use.","nodes":[{"content":"The pre-existing handle to use.","pos":[0,31]}]}],"pos":[31785,31817],"yaml":true},{"content":"Marks a handle as invalid.","nodes":[{"pos":[0,26],"content":"Marks a handle as invalid.","nodes":[{"content":"Marks a handle as invalid.","pos":[0,26]}]}],"pos":[33502,33529],"yaml":true},{"content":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such. Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.  \n  \n As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.","nodes":[{"pos":[0,447],"content":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such. Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.","nodes":[{"content":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such. Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.","pos":[0,447],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle is invalid and you want to mark it as such.","pos":[0,170],"source":"Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such."},{"content":"Doing so does not change the value of the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> field; it only marks the handle as invalid.","pos":[171,316],"source":" Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid."},{"content":"The handle might then contain a potentially stale value.","pos":[317,373]},{"content":"The effect of this call is that no attempt is made to free the resources.","pos":[374,447]}]}]},{"pos":[454,669],"content":"As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.","nodes":[{"content":"As with the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method, use <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.","pos":[0,215],"source":"As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle."}]}],"pos":[33540,34214],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.InteropServices.CriticalHandle\n  commentId: T:System.Runtime.InteropServices.CriticalHandle\n  id: CriticalHandle\n  children:\n  - System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)\n  - System.Runtime.InteropServices.CriticalHandle.Close\n  - System.Runtime.InteropServices.CriticalHandle.Dispose\n  - System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)\n  - System.Runtime.InteropServices.CriticalHandle.Finalize\n  - System.Runtime.InteropServices.CriticalHandle.handle\n  - System.Runtime.InteropServices.CriticalHandle.IsClosed\n  - System.Runtime.InteropServices.CriticalHandle.IsInvalid\n  - System.Runtime.InteropServices.CriticalHandle.ReleaseHandle\n  - System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)\n  - System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid\n  langs:\n  - csharp\n  name: CriticalHandle\n  nameWithType: CriticalHandle\n  fullName: System.Runtime.InteropServices.CriticalHandle\n  type: Class\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Represents a wrapper class for handle resources.\n  remarks: \"The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting. You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.  \\n  \\n Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks. Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost. If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic. The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable\n  inheritance:\n  - System.Object\n  derivedClasses:\n  - Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid\n  - Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)\n  id: '#ctor(System.IntPtr)'\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: CriticalHandle(IntPtr)\n  nameWithType: CriticalHandle.CriticalHandle(IntPtr)\n  fullName: CriticalHandle.CriticalHandle(IntPtr)\n  type: Constructor\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Initializes a new instance of the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref> class with the specified invalid handle value.\n  syntax:\n    content: protected CriticalHandle (IntPtr invalidHandleValue);\n    parameters:\n    - id: invalidHandleValue\n      type: System.IntPtr\n      description: The value of an invalid handle (usually 0 or -1).\n  overload: System.Runtime.InteropServices.CriticalHandle.#ctor*\n  exceptions:\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: The derived class resides in an assembly without unmanaged code access permission.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.Close\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.Close\n  id: Close\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: Close()\n  nameWithType: CriticalHandle.Close()\n  fullName: CriticalHandle.Close()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Marks the handle for releasing and freeing resources.\n  remarks: \"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.  \\n  \\n Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.  \\n  \\n **Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void Close ();\n    parameters: []\n  overload: System.Runtime.InteropServices.CriticalHandle.Close*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.Dispose\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.Dispose\n  id: Dispose\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: CriticalHandle.Dispose()\n  fullName: CriticalHandle.Dispose()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Releases all resources used by the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref>.\n  remarks: \"Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed. Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle. Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method. Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.  \\n  \\n Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object. The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.  \\n  \\n **Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Runtime.InteropServices.CriticalHandle.Dispose*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: CriticalHandle.Dispose(Boolean)\n  fullName: CriticalHandle.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Releases the unmanaged resources used by the <xref href=\"System.Runtime.InteropServices.CriticalHandle\"></xref> class specifying whether to perform a normal dispose operation.\n  remarks: You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      protected virtual void Dispose (bool disposing);\n    parameters:\n    - id: disposing\n      type: System.Boolean\n      description: '`true` for a normal dispose operation; `false` to finalize the handle.'\n  overload: System.Runtime.InteropServices.CriticalHandle.Dispose*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.Finalize\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.Finalize\n  id: Finalize\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: CriticalHandle.Finalize()\n  fullName: CriticalHandle.Finalize()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Frees all resources associated with the handle.\n  remarks: The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class. Application code should not call this method directly.\n  syntax:\n    content: ~CriticalHandle ();\n    parameters: []\n  overload: System.Runtime.InteropServices.CriticalHandle.Finalize*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.handle\n  commentId: F:System.Runtime.InteropServices.CriticalHandle.handle\n  id: handle\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: handle\n  nameWithType: CriticalHandle.handle\n  fullName: CriticalHandle.handle\n  type: Field\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Specifies the handle to be wrapped.\n  remarks: Do not expose the handle publicly (that is, outside of the derived class).\n  syntax:\n    content: protected IntPtr handle;\n    return:\n      type: System.IntPtr\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.IsClosed\n  commentId: P:System.Runtime.InteropServices.CriticalHandle.IsClosed\n  id: IsClosed\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: IsClosed\n  nameWithType: CriticalHandle.IsClosed\n  fullName: CriticalHandle.IsClosed\n  type: Property\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Gets a value indicating whether the handle is closed.\n  remarks: \"The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource. This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid. The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:  \\n  \\n-   The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.  \\n  \\n-   The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.\"\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      public bool IsClosed { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the handle is closed; otherwise, `false`.'\n  overload: System.Runtime.InteropServices.CriticalHandle.IsClosed*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.IsInvalid\n  commentId: P:System.Runtime.InteropServices.CriticalHandle.IsInvalid\n  id: IsInvalid\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: IsInvalid\n  nameWithType: CriticalHandle.IsInvalid\n  fullName: CriticalHandle.IsInvalid\n  type: Property\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: When overridden in a derived class, gets a value indicating whether the handle value is invalid.\n  remarks: \"Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.  \\n  \\n Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.\"\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      public abstract bool IsInvalid { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the handle is valid; otherwise, `false`.'\n  overload: System.Runtime.InteropServices.CriticalHandle.IsInvalid*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.ReleaseHandle\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle\n  id: ReleaseHandle\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: ReleaseHandle()\n  nameWithType: CriticalHandle.ReleaseHandle()\n  fullName: CriticalHandle.ReleaseHandle()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: When overridden in a derived class, executes the code required to free the handle.\n  remarks: \"The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made. The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`. Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail. The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method. In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>. In most cases this code should be:  \\n  \\n `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  \\n  \\n Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.  \\n  \\n If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.\"\n  syntax:\n    content: protected abstract bool ReleaseHandle ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`. In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.'\n  overload: System.Runtime.InteropServices.CriticalHandle.ReleaseHandle*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)\n  id: SetHandle(System.IntPtr)\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: SetHandle(IntPtr)\n  nameWithType: CriticalHandle.SetHandle(IntPtr)\n  fullName: CriticalHandle.SetHandle(IntPtr)\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Sets the handle to the specified pre-existing handle.\n  remarks: Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.\n  syntax:\n    content: protected void SetHandle (IntPtr handle);\n    parameters:\n    - id: handle\n      type: System.IntPtr\n      description: The pre-existing handle to use.\n  overload: System.Runtime.InteropServices.CriticalHandle.SetHandle*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid\n  commentId: M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid\n  id: SetHandleAsInvalid\n  parent: System.Runtime.InteropServices.CriticalHandle\n  langs:\n  - csharp\n  name: SetHandleAsInvalid()\n  nameWithType: CriticalHandle.SetHandleAsInvalid()\n  fullName: CriticalHandle.SetHandleAsInvalid()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Marks a handle as invalid.\n  remarks: \"Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such. Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.  \\n  \\n As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.\"\n  syntax:\n    content: public void SetHandleAsInvalid ();\n    parameters: []\n  overload: System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.TypeLoadException\n  parent: System\n  isExternal: false\n  name: TypeLoadException\n  nameWithType: TypeLoadException\n  fullName: System.TypeLoadException\n- uid: System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: CriticalHandle(IntPtr)\n  nameWithType: CriticalHandle.CriticalHandle(IntPtr)\n  fullName: CriticalHandle.CriticalHandle(IntPtr)\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Runtime.InteropServices.CriticalHandle.Close\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: Close()\n  nameWithType: CriticalHandle.Close()\n  fullName: CriticalHandle.Close()\n- uid: System.Runtime.InteropServices.CriticalHandle.Dispose\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: Dispose()\n  nameWithType: CriticalHandle.Dispose()\n  fullName: CriticalHandle.Dispose()\n- uid: System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: CriticalHandle.Dispose(Boolean)\n  fullName: CriticalHandle.Dispose(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Runtime.InteropServices.CriticalHandle.Finalize\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: Finalize()\n  nameWithType: CriticalHandle.Finalize()\n  fullName: CriticalHandle.Finalize()\n- uid: System.Runtime.InteropServices.CriticalHandle.handle\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: handle\n  nameWithType: CriticalHandle.handle\n  fullName: CriticalHandle.handle\n- uid: System.Runtime.InteropServices.CriticalHandle.IsClosed\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: IsClosed\n  nameWithType: CriticalHandle.IsClosed\n  fullName: CriticalHandle.IsClosed\n- uid: System.Runtime.InteropServices.CriticalHandle.IsInvalid\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: IsInvalid\n  nameWithType: CriticalHandle.IsInvalid\n  fullName: CriticalHandle.IsInvalid\n- uid: System.Runtime.InteropServices.CriticalHandle.ReleaseHandle\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: ReleaseHandle()\n  nameWithType: CriticalHandle.ReleaseHandle()\n  fullName: CriticalHandle.ReleaseHandle()\n- uid: System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: SetHandle(IntPtr)\n  nameWithType: CriticalHandle.SetHandle(IntPtr)\n  fullName: CriticalHandle.SetHandle(IntPtr)\n- uid: System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: SetHandleAsInvalid()\n  nameWithType: CriticalHandle.SetHandleAsInvalid()\n  fullName: CriticalHandle.SetHandleAsInvalid()\n- uid: System.Runtime.InteropServices.CriticalHandle.#ctor*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: CriticalHandle\n  nameWithType: CriticalHandle.CriticalHandle\n  fullName: CriticalHandle.CriticalHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.Close*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: Close\n  nameWithType: CriticalHandle.Close\n  fullName: CriticalHandle.Close\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.Dispose*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: Dispose\n  nameWithType: CriticalHandle.Dispose\n  fullName: CriticalHandle.Dispose\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.Finalize*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: Finalize\n  nameWithType: CriticalHandle.Finalize\n  fullName: CriticalHandle.Finalize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.IsClosed*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: IsClosed\n  nameWithType: CriticalHandle.IsClosed\n  fullName: CriticalHandle.IsClosed\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.IsInvalid*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: IsInvalid\n  nameWithType: CriticalHandle.IsInvalid\n  fullName: CriticalHandle.IsInvalid\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.ReleaseHandle*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: ReleaseHandle\n  nameWithType: CriticalHandle.ReleaseHandle\n  fullName: CriticalHandle.ReleaseHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.SetHandle*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: SetHandle\n  nameWithType: CriticalHandle.SetHandle\n  fullName: CriticalHandle.SetHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid*\n  parent: System.Runtime.InteropServices.CriticalHandle\n  isExternal: false\n  name: SetHandleAsInvalid\n  nameWithType: CriticalHandle.SetHandleAsInvalid\n  fullName: CriticalHandle.SetHandleAsInvalid\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/CriticalHandle.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n"}