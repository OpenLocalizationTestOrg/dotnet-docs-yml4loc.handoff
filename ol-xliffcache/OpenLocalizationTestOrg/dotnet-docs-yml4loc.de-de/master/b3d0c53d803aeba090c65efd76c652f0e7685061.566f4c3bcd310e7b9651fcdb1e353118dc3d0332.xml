{"nodes":[{"content":"A synchronization primitive that can also be used for interprocess synchronization.","nodes":[{"pos":[0,83],"content":"A synchronization primitive that can also be used for interprocess synchronization.","nodes":[{"content":"A synchronization primitive that can also be used for interprocess synchronization.","pos":[0,83]}]}],"pos":[1216,1300],"yaml":true},{"content":"> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource. <xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread. If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.  \n  \n You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method to request ownership of a mutex. The calling thread blocks until one of the following occurs:  \n  \n-   The mutex is signaled to indicate that it is not owned. When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex. When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex. The first example in the Examples section illustrates this pattern.  \n  \n-   The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed. When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex. In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread. Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method. The second example in the Examples section illustrates this pattern.  \n  \n The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it. By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity. A mutex can also be passed across application domain boundaries.  \n  \n The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution. However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.  \n  \n Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods to synchronize access to a protected resource.  \n  \n If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled, and the next waiting thread gets ownership. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex. Before version 2.0 of the .NET Framework, no exception was thrown.  \n  \n> [!CAUTION]\n>  An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.  \n  \n In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).  \n  \n Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes. A local mutex exists only within your process. It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex. Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.  \n  \n Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name. The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.  \n  \n> [!NOTE]\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","nodes":[{"pos":[2,414],"content":"[!NOTE]\n To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","leadings":["","> "],"nodes":[{"content":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","pos":[8,410],"nodes":[{"content":"To view the .NET Framework source code for this type, see the <bpt id=\"p1\">[</bpt>Reference Source<ept id=\"p1\">](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6)</ept>.","pos":[1,173],"source":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6)."},{"content":"You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id=\"p1\">[</bpt>instructions<ept id=\"p1\">](http://referencesource.microsoft.com/)</ept>.","pos":[174,402],"source":" You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/)."}]}]},{"pos":[421,871],"content":"When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource. <xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread. If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.","nodes":[{"content":"When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource. <xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread. If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.","pos":[0,450],"nodes":[{"content":"When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.","pos":[0,180]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.","pos":[181,313],"source":" <xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread."},{"content":"If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.","pos":[314,450]}]}]},{"pos":[879,1405],"content":"[!IMPORTANT]\n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","leadings":["","> "],"nodes":[{"content":" This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","pos":[13,524],"nodes":[{"content":"This type implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface.","pos":[1,62],"source":" This type implements the <xref:System.IDisposable> interface."},{"content":"When you have finished using the type, you should dispose of it either directly or indirectly.","pos":[63,157]},{"content":"To dispose of the type directly, call its <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`catch`</ph> block.","pos":[158,269],"source":" To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block."},{"content":"To dispose of it indirectly, use a language construct such as <ph id=\"ph1\">`using`</ph> (in C#) or <ph id=\"ph2\">`Using`</ph> (in Visual Basic).","pos":[270,377],"source":" To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic)."},{"content":"For more information, see the \"Using an Object that Implements IDisposable\" section in the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface topic.","pos":[378,511],"source":" For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic."}]}]},{"pos":[1412,1599],"content":"You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method to request ownership of a mutex. The calling thread blocks until one of the following occurs:","nodes":[{"content":"You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method to request ownership of a mutex. The calling thread blocks until one of the following occurs:","pos":[0,187],"nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method to request ownership of a mutex.","pos":[0,126],"source":"You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method to request ownership of a mutex."},{"content":"The calling thread blocks until one of the following occurs:","pos":[127,187]}]}]},{"pos":[1609,2086],"content":"The mutex is signaled to indicate that it is not owned. When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex. When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex. The first example in the Examples section illustrates this pattern.","nodes":[{"content":"The mutex is signaled to indicate that it is not owned.","pos":[0,55]},{"content":"When this happens, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.","pos":[56,251],"source":" When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex."},{"content":"When it has finished accessing the resource, the thread must call the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the mutex.","pos":[252,409],"source":" When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex."},{"content":"The first example in the Examples section illustrates this pattern.","pos":[410,477]}]},{"pos":[2096,2784],"content":"The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed. When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex. In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread. Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method. The second example in the Examples section illustrates this pattern.","nodes":[{"content":"The time-out interval specified in the call to a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method that has a <ph id=\"ph2\">`millisecondsTimeout`</ph> or <ph id=\"ph3\">`timeout`</ph> parameter has elapsed.","pos":[0,170],"source":"The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed."},{"content":"When this happens, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id=\"ph2\">`false`</ph>, and the calling thread makes no further attempt to acquire ownership of the mutex.","pos":[171,346],"source":" When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex."},{"content":"In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.","pos":[347,486]},{"content":"Because the thread never acquired ownership of the mutex, it must not call the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.","pos":[487,619],"source":" Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method."},{"content":"The second example in the Examples section illustrates this pattern.","pos":[620,688]}]},{"pos":[2791,3076],"content":"The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it. By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity. A mutex can also be passed across application domain boundaries.","nodes":[{"content":"The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it. By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity. A mutex can also be passed across application domain boundaries.","pos":[0,285],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> class enforces thread identity, so a mutex can be released only by the thread that acquired it.","pos":[0,129],"source":"The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it."},{"content":"By contrast, the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity.","pos":[130,220],"source":" By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity."},{"content":"A mutex can also be passed across application domain boundaries.","pos":[221,285]}]}]},{"pos":[3083,3384],"content":"The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution. However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.","nodes":[{"content":"The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution. However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.","pos":[0,301],"nodes":[{"content":"The thread that owns a mutex can request the same mutex in repeated calls to <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> without blocking its execution.","pos":[0,154],"source":"The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution."},{"content":"However, the thread must call the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method the same number of times to release ownership of the mutex.","pos":[155,301],"source":" However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex."}]}]},{"pos":[3391,3718],"content":"Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods to synchronize access to a protected resource.","nodes":[{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> class inherits from <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph>, you can also call the static <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;</ph> methods to synchronize access to a protected resource.","pos":[0,327],"source":"Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods to synchronize access to a protected resource."}]},{"pos":[3725,4121],"content":"If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled, and the next waiting thread gets ownership. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex. Before version 2.0 of the .NET Framework, no exception was thrown.","nodes":[{"content":"If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled, and the next waiting thread gets ownership. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex. Before version 2.0 of the .NET Framework, no exception was thrown.","pos":[0,396],"nodes":[{"content":"If a thread terminates while owning a mutex, the mutex is said to be abandoned.","pos":[0,79]},{"content":"The state of the mutex is set to signaled, and the next waiting thread gets ownership.","pos":[80,166]},{"content":"Beginning in version 2.0 of the .NET Framework, an <ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the abandoned mutex.","pos":[167,329],"source":" Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex."},{"content":"Before version 2.0 of the .NET Framework, no exception was thrown.","pos":[330,396]}]}]},{"pos":[4129,4480],"content":"[!CAUTION]\n An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.","leadings":["","> "],"nodes":[{"content":" An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.","pos":[11,349],"nodes":[{"content":"An abandoned mutex often indicates a serious error in the code.","pos":[1,64]},{"content":"When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.","pos":[65,192]},{"content":"The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.","pos":[193,338]}]}]},{"pos":[4487,4651],"content":"In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","nodes":[{"content":"In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[0,164]}]},{"pos":[4658,5012],"content":"Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes. A local mutex exists only within your process. It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex. Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.","nodes":[{"content":"Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes. A local mutex exists only within your process. It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex. Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.","pos":[0,354],"nodes":[{"content":"Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.","pos":[0,85]},{"content":"A local mutex exists only within your process.","pos":[86,132]},{"content":"It can be used by any thread in your process that has a reference to the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the mutex.","pos":[133,269],"source":" It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex."},{"content":"Each unnamed <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object represents a separate local mutex.","pos":[270,354],"source":" Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex."}]}]},{"pos":[5019,5640],"content":"Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name. The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.","nodes":[{"content":"Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name. The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.","pos":[0,621],"nodes":[{"content":"Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.","pos":[0,125]},{"content":"You can create a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex by using a constructor that accepts a name.","pos":[126,260],"source":" You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name."},{"content":"The operating-system object can be created at the same time, or it can exist before the creation of the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object.","pos":[261,402],"source":" The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex, and you can use the <ph id=\"ph2\">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method to open an existing named system mutex.","pos":[403,621],"source":" You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex."}]}]},{"pos":[5648,6534],"content":"[!NOTE]\n On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","leadings":["","> "],"nodes":[{"content":" On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[8,884],"nodes":[{"content":"On a server that is running Terminal Services, a named system mutex can have two levels of visibility.","pos":[1,103]},{"content":"If its name begins with the prefix \"Global<ph id=\"ph1\">\\\\</ph>\", the mutex is visible in all terminal server sessions.","pos":[104,204],"source":" If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions."},{"content":"If its name begins with the prefix \"Local<ph id=\"ph1\">\\\\</ph>\", the mutex is visible only in the terminal server session where it was created.","pos":[205,329],"source":" If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created."},{"content":"In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.","pos":[330,450]},{"content":"If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local<ph id=\"ph1\">\\\\</ph>\".","pos":[451,543],"source":" If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\"."},{"content":"Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.","pos":[544,723]},{"content":"That is, the prefix names \"Global<ph id=\"ph1\">\\\\</ph>\" and \"Local<ph id=\"ph2\">\\\\</ph>\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[724,876],"source":" That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes."}]}]}],"pos":[1311,7902],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with default properties.","nodes":[{"pos":[0,108],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> class with default properties.","source":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with default properties."}],"pos":[13511,13620],"yaml":true},{"content":"Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex. That is, the calling thread does not own the mutex.","nodes":[{"pos":[0,250],"content":"Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex. That is, the calling thread does not own the mutex.","nodes":[{"content":"Calling this constructor overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor overload and specifying <ph id=\"ph2\">`false`</ph> for initial ownership of the mutex.","pos":[0,198],"source":"Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex."},{"content":"That is, the calling thread does not own the mutex.","pos":[199,250]}]}],"pos":[13631,13882],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.","nodes":[{"pos":[0,190],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.","source":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex."}],"pos":[16190,16381],"yaml":true},{"content":"`true` to give the calling thread initial ownership of the mutex; otherwise, `false`.","nodes":[{"pos":[0,85],"content":"<ph id=\"ph1\">`true`</ph> to give the calling thread initial ownership of the mutex; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to give the calling thread initial ownership of the mutex; otherwise, `false`."}],"pos":[17276,17364],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.","nodes":[{"pos":[0,234],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.","source":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex."}],"pos":[18942,19177],"yaml":true},{"content":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call. Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload. You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.  \n  \n This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  \n  \n If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  \n  \n If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.  \n  \n Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  \n  \n> [!NOTE]\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","nodes":[{"pos":[0,505],"content":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call. Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload. You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.","nodes":[{"content":"If <ph id=\"ph1\">`name`</ph> is not <ph id=\"ph2\">`null`</ph> and <ph id=\"ph3\">`initiallyOwned`</ph> is <ph id=\"ph4\">`true`</ph>, the calling thread owns the mutex only if the named system mutex was created as a result of this call.","pos":[0,158],"source":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call."},{"content":"Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <ph id=\"ph1\">`false`</ph> for <ph id=\"ph2\">`initiallyOwned`</ph> when calling this constructor overload.","pos":[159,339],"source":" Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor if you need to determine initial ownership.","pos":[340,505],"source":" You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership."}]},{"pos":[512,723],"content":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.","nodes":[{"content":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.","pos":[0,211],"nodes":[{"content":"This constructor initializes a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.","pos":[0,105],"source":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.","pos":[106,211],"source":" You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex."}]}]},{"pos":[730,1097],"content":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.","nodes":[{"content":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.","pos":[0,367],"nodes":[{"content":"If the named mutex has already been created with access control security, and the caller does not have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>, an exception is thrown.","pos":[0,201],"source":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown."},{"content":"To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.","pos":[202,367],"source":" To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method."}]}]},{"pos":[1104,1323],"content":"If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.","nodes":[{"content":"If you specify <ph id=\"ph1\">`null`</ph> or an empty string for <ph id=\"ph2\">`name`</ph>, a local mutex is created, as if you had called the <ph id=\"ph3\">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.","pos":[0,174],"source":"If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor."},{"content":"In this case, <ph id=\"ph1\">`createdNew`</ph> is always <ph id=\"ph2\">`true`</ph>.","pos":[175,219],"source":" In this case, `createdNew` is always `true`."}]},{"pos":[1330,1439],"content":"Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.","nodes":[{"content":"Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.","pos":[0,109]}]},{"pos":[1447,2333],"content":"[!NOTE]\n On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","leadings":["","> "],"nodes":[{"content":" On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[8,884],"nodes":[{"content":"On a server that is running Terminal Services, a named system mutex can have two levels of visibility.","pos":[1,103]},{"content":"If its name begins with the prefix \"Global<ph id=\"ph1\">\\\\</ph>\", the mutex is visible in all terminal server sessions.","pos":[104,204],"source":" If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions."},{"content":"If its name begins with the prefix \"Local<ph id=\"ph1\">\\\\</ph>\", the mutex is visible only in the terminal server session where it was created.","pos":[205,329],"source":" If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created."},{"content":"In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.","pos":[330,450]},{"content":"If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local<ph id=\"ph1\">\\\\</ph>\".","pos":[451,543],"source":" If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\"."},{"content":"Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.","pos":[544,723]},{"content":"That is, the prefix names \"Global<ph id=\"ph1\">\\\\</ph>\" and \"Local<ph id=\"ph2\">\\\\</ph>\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[724,876],"source":" That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes."}]}]}],"pos":[19188,21555],"yaml":true,"extradata":"MT"},{"content":"`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`."}],"pos":[23237,23400],"yaml":true},{"content":"The name of the <xref href=\"System.Threading.Mutex\"></xref>. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.","nodes":[{"pos":[0,144],"content":"The name of the <xref href=\"System.Threading.Mutex\"></xref>. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.","nodes":[{"content":"The name of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph>.","pos":[0,60],"source":"The name of the <xref href=\"System.Threading.Mutex\"></xref>."},{"content":"If the value is <ph id=\"ph1\">`null`</ph>, the <ph id=\"ph2\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> is unnamed.","pos":[61,144],"source":" If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed."}]}],"pos":[23460,23605],"yaml":true},{"content":"The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>.","nodes":[{"pos":[0,158],"content":"The named mutex exists and has access control security, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>."}],"pos":[23775,23934],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[24022,24046],"yaml":true},{"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,103],"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,103]}]}],"pos":[24192,24296],"yaml":true},{"content":"<code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[24390,24439],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.","nodes":[{"pos":[0,362],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.","source":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex."}],"pos":[26033,26396],"yaml":true},{"content":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A>method.  \n  \n This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  \n  \n If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  \n  \n If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.  \n  \n Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  \n  \n> [!NOTE]\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","nodes":[{"pos":[0,253],"content":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A>method.","nodes":[{"content":"If <ph id=\"ph1\">`name`</ph> is not <ph id=\"ph2\">`null`</ph> and <ph id=\"ph3\">`initiallyOwned`</ph> is <ph id=\"ph4\">`true`</ph>, the calling thread owns the named mutex only if <ph id=\"ph5\">`createdNew`</ph> is <ph id=\"ph6\">`true`</ph> after the call.","pos":[0,142],"source":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call."},{"content":"Otherwise the thread can request the mutex by calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>method.","pos":[143,253],"source":" Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A>method."}]},{"pos":[260,471],"content":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.","nodes":[{"content":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.","pos":[0,211],"nodes":[{"content":"This constructor initializes a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.","pos":[0,105],"source":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.","pos":[106,211],"source":" You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex."}]}]},{"pos":[478,852],"content":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.","nodes":[{"content":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.","pos":[0,374],"nodes":[{"content":"If the named mutex has already been created with access control security, and the caller does not have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights, an exception is thrown.","pos":[0,208],"source":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, an exception is thrown."},{"content":"To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.","pos":[209,374],"source":" To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method."}]}]},{"pos":[859,1078],"content":"If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.","nodes":[{"content":"If you specify <ph id=\"ph1\">`null`</ph> or an empty string for <ph id=\"ph2\">`name`</ph>, a local mutex is created, as if you had called the <ph id=\"ph3\">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.","pos":[0,174],"source":"If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor."},{"content":"In this case, <ph id=\"ph1\">`createdNew`</ph> is always <ph id=\"ph2\">`true`</ph>.","pos":[175,219],"source":" In this case, `createdNew` is always `true`."}]},{"pos":[1085,1194],"content":"Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.","nodes":[{"content":"Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.","pos":[0,109]}]},{"pos":[1202,2088],"content":"[!NOTE]\n On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","leadings":["","> "],"nodes":[{"content":" On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[8,884],"nodes":[{"content":"On a server that is running Terminal Services, a named system mutex can have two levels of visibility.","pos":[1,103]},{"content":"If its name begins with the prefix \"Global<ph id=\"ph1\">\\\\</ph>\", the mutex is visible in all terminal server sessions.","pos":[104,204],"source":" If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions."},{"content":"If its name begins with the prefix \"Local<ph id=\"ph1\">\\\\</ph>\", the mutex is visible only in the terminal server session where it was created.","pos":[205,329],"source":" If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created."},{"content":"In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.","pos":[330,450]},{"content":"If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local<ph id=\"ph1\">\\\\</ph>\".","pos":[451,543],"source":" If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\"."},{"content":"Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.","pos":[544,723]},{"content":"That is, the prefix names \"Global<ph id=\"ph1\">\\\\</ph>\" and \"Local<ph id=\"ph2\">\\\\</ph>\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[724,876],"source":" That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes."}]}]}],"pos":[26407,28529],"yaml":true,"extradata":"MT"},{"content":"`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`."}],"pos":[30012,30175],"yaml":true},{"content":"The name of the <xref href=\"System.Threading.Mutex\"></xref>. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.","nodes":[{"pos":[0,144],"content":"The name of the <xref href=\"System.Threading.Mutex\"></xref>. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.","nodes":[{"content":"The name of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph>.","pos":[0,60],"source":"The name of the <xref href=\"System.Threading.Mutex\"></xref>."},{"content":"If the value is <ph id=\"ph1\">`null`</ph>, the <ph id=\"ph2\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> is unnamed.","pos":[61,144],"source":" If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed."}]}],"pos":[30235,30380],"yaml":true},{"content":"When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed. This parameter is passed uninitialized.","nodes":[{"pos":[0,302],"content":"When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed. This parameter is passed uninitialized.","nodes":[{"content":"When this method returns, contains a Boolean that is <ph id=\"ph1\">`true`</ph> if a local mutex was created (that is, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph> or an empty string) or if the specified named system mutex was created; <ph id=\"ph4\">`false`</ph> if the specified named system mutex already existed.","pos":[0,262],"source":"When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed."},{"content":"This parameter is passed uninitialized.","pos":[263,302]}]}],"pos":[30447,30750],"yaml":true},{"content":"The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>.","nodes":[{"pos":[0,158],"content":"The named mutex exists and has access control security, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>."}],"pos":[30920,31079],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[31167,31191],"yaml":true},{"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,103],"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,103]}]}],"pos":[31337,31441],"yaml":true},{"content":"<code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[31535,31584],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.","nodes":[{"pos":[0,427],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.","source":"Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex."}],"pos":[33318,33746],"yaml":true},{"content":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.  \n  \n Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.  \n  \n This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  \n  \n If the named system mutex does not exist, it is created with the specified access control security. If the named mutex exists, the specified access control security is ignored.  \n  \n> [!NOTE]\n>  The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.  \n  \n If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  \n  \n If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.  \n  \n Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  \n  \n> [!NOTE]\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","nodes":[{"pos":[0,254],"content":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.","nodes":[{"content":"If <ph id=\"ph1\">`name`</ph> is not <ph id=\"ph2\">`null`</ph> and <ph id=\"ph3\">`initiallyOwned`</ph> is <ph id=\"ph4\">`true`</ph>, the calling thread owns the named mutex only if <ph id=\"ph5\">`createdNew`</ph> is <ph id=\"ph6\">`true`</ph> after the call.","pos":[0,142],"source":"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call."},{"content":"Otherwise the thread can request the mutex by calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.","pos":[143,254],"source":" Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method."}]},{"pos":[261,414],"content":"Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.","nodes":[{"content":"Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.","pos":[0,153]}]},{"pos":[421,632],"content":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.","nodes":[{"content":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.","pos":[0,211],"nodes":[{"content":"This constructor initializes a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.","pos":[0,105],"source":"This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.","pos":[106,211],"source":" You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex."}]}]},{"pos":[639,815],"content":"If the named system mutex does not exist, it is created with the specified access control security. If the named mutex exists, the specified access control security is ignored.","nodes":[{"content":"If the named system mutex does not exist, it is created with the specified access control security. If the named mutex exists, the specified access control security is ignored.","pos":[0,176],"nodes":[{"content":"If the named system mutex does not exist, it is created with the specified access control security.","pos":[0,99]},{"content":"If the named mutex exists, the specified access control security is ignored.","pos":[100,176]}]}]},{"pos":[823,1267],"content":"[!NOTE]\n The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.","leadings":["","> "],"nodes":[{"content":" The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.","pos":[8,442],"nodes":[{"content":"The caller has full control over the newly created <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object even if <ph id=\"ph2\">`mutexSecurity`</ph> denies or fails to grant some access rights to the current user.","pos":[1,177],"source":" The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user."},{"content":"However, if the current user attempts to get another <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> object to represent the same named mutex, using either a constructor or the <ph id=\"ph2\">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.","pos":[178,434],"source":" However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied."}]}]},{"pos":[1274,1641],"content":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.","nodes":[{"content":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.","pos":[0,367],"nodes":[{"content":"If the named mutex has already been created with access control security, and the caller does not have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>, an exception is thrown.","pos":[0,201],"source":"If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown."},{"content":"To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.","pos":[202,367],"source":" To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method."}]}]},{"pos":[1648,1867],"content":"If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.","nodes":[{"content":"If you specify <ph id=\"ph1\">`null`</ph> or an empty string for <ph id=\"ph2\">`name`</ph>, a local mutex is created, as if you had called the <ph id=\"ph3\">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.","pos":[0,174],"source":"If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor."},{"content":"In this case, <ph id=\"ph1\">`createdNew`</ph> is always <ph id=\"ph2\">`true`</ph>.","pos":[175,219],"source":" In this case, `createdNew` is always `true`."}]},{"pos":[1874,1983],"content":"Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.","nodes":[{"content":"Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.","pos":[0,109]}]},{"pos":[1991,2877],"content":"[!NOTE]\n On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","leadings":["","> "],"nodes":[{"content":" On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[8,884],"nodes":[{"content":"On a server that is running Terminal Services, a named system mutex can have two levels of visibility.","pos":[1,103]},{"content":"If its name begins with the prefix \"Global<ph id=\"ph1\">\\\\</ph>\", the mutex is visible in all terminal server sessions.","pos":[104,204],"source":" If its name begins with the prefix \"Global\\\\\", the mutex is visible in all terminal server sessions."},{"content":"If its name begins with the prefix \"Local<ph id=\"ph1\">\\\\</ph>\", the mutex is visible only in the terminal server session where it was created.","pos":[205,329],"source":" If its name begins with the prefix \"Local\\\\\", the mutex is visible only in the terminal server session where it was created."},{"content":"In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.","pos":[330,450]},{"content":"If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local<ph id=\"ph1\">\\\\</ph>\".","pos":[451,543],"source":" If you do not specify a prefix when you create a named mutex, it takes the prefix \"Local\\\\\"."},{"content":"Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.","pos":[544,723]},{"content":"That is, the prefix names \"Global<ph id=\"ph1\">\\\\</ph>\" and \"Local<ph id=\"ph2\">\\\\</ph>\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.","pos":[724,876],"source":" That is, the prefix names \"Global\\\\\" and \"Local\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes."}]}]}],"pos":[33757,36675],"yaml":true,"extradata":"MT"},{"content":"`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`."}],"pos":[38546,38709],"yaml":true},{"content":"The name of the system mutex. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.","nodes":[{"pos":[0,113],"content":"The name of the system mutex. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.","nodes":[{"content":"The name of the system mutex.","pos":[0,29]},{"content":"If the value is <ph id=\"ph1\">`null`</ph>, the <ph id=\"ph2\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> is unnamed.","pos":[30,113],"source":" If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed."}]}],"pos":[38769,38883],"yaml":true},{"content":"When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed. This parameter is passed uninitialized.","nodes":[{"pos":[0,302],"content":"When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed. This parameter is passed uninitialized.","nodes":[{"content":"When this method returns, contains a Boolean that is <ph id=\"ph1\">`true`</ph> if a local mutex was created (that is, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph> or an empty string) or if the specified named system mutex was created; <ph id=\"ph4\">`false`</ph> if the specified named system mutex already existed.","pos":[0,262],"source":"When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed."},{"content":"This parameter is passed uninitialized.","pos":[263,302]}]}],"pos":[38950,39253],"yaml":true},{"content":"A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security to be applied to the named system mutex.","nodes":[{"pos":[0,158],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system mutex.","source":"A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security to be applied to the named system mutex."}],"pos":[39352,39511],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[39655,39679],"yaml":true},{"content":"The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>.","nodes":[{"pos":[0,158],"content":"The named mutex exists and has access control security, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>."}],"pos":[39793,39952],"yaml":true},{"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,103],"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,103]}]}],"pos":[40098,40202],"yaml":true},{"content":"<code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,48],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[40296,40345],"yaml":true},{"content":"Gets a <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security for the named mutex.","nodes":[{"pos":[0,143],"content":"Gets a <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named mutex.","source":"Gets a <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security for the named mutex."}],"pos":[41375,41519],"yaml":true},{"content":"The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.  \n  \n The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>.","nodes":[{"pos":[0,428],"content":"The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>.","pos":[0,428],"source":"The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>."}]},{"pos":[435,664],"content":"The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>.","nodes":[{"content":"The user must have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> to call this method, and the mutex must have been opened with <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>.","pos":[0,229],"source":"The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>."}]}],"pos":[41530,42199],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security for the named mutex.","nodes":[{"pos":[0,138],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named mutex.","source":"A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security for the named mutex."}],"pos":[44155,44294],"yaml":true},{"content":"The current <xref href=\"System.Threading.Mutex\"></xref> object represents a named system mutex, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.ReadPermissions\"></xref>.  \n  \n -or-  \n  \n The current <xref href=\"System.Threading.Mutex\"></xref> object represents a named system mutex, and was not opened with <xref href=\"System.Security.AccessControl.MutexRights.ReadPermissions\"></xref>.","nodes":[{"pos":[0,202],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> object represents a named system mutex, but the user does not have <ph id=\"ph2\">&lt;xref href=\"System.Security.AccessControl.MutexRights.ReadPermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The current <xref href=\"System.Threading.Mutex\"></xref> object represents a named system mutex, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.ReadPermissions\"></xref>."},{"pos":[209,213],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[220,419],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> object represents a named system mutex, and was not opened with <ph id=\"ph2\">&lt;xref href=\"System.Security.AccessControl.MutexRights.ReadPermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The current <xref href=\"System.Threading.Mutex\"></xref> object represents a named system mutex, and was not opened with <xref href=\"System.Security.AccessControl.MutexRights.ReadPermissions\"></xref>."}],"pos":[44475,44909],"yaml":true},{"content":"Not supported for Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,59],"content":"Not supported for Windows 98 or Windows Millennium Edition.","nodes":[{"content":"Not supported for Windows 98 or Windows Millennium Edition.","pos":[0,59]}]}],"pos":[45011,45071],"yaml":true},{"content":"Opens the specified named mutex, if it already exists.","nodes":[{"pos":[0,54],"content":"Opens the specified named mutex, if it already exists.","nodes":[{"content":"Opens the specified named mutex, if it already exists.","pos":[0,54]}]}],"pos":[46074,46129],"yaml":true},{"content":"The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \n  \n This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.  \n  \n Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \n  \n This method does not request ownership of the mutex.","nodes":[{"pos":[0,368],"content":"The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open the specified named system mutex.","pos":[0,104],"source":"The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex."},{"content":"If the system mutex does not exist, this method throws an exception instead of creating the system object.","pos":[105,211]},{"content":"To create the system mutex when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[212,368],"source":" To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[375,593],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex."},{"pos":[600,990],"content":"This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.","nodes":[{"content":"This method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload and specifying <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.","pos":[0,390],"source":"This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation."}]},{"pos":[997,1308],"content":"Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.","nodes":[{"content":"Specifying the <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id=\"ph3\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.","pos":[0,311],"source":"Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method."}]},{"pos":[1315,1367],"content":"This method does not request ownership of the mutex.","nodes":[{"content":"This method does not request ownership of the mutex.","pos":[0,52]}]}],"pos":[46140,47518],"yaml":true,"extradata":"MT"},{"content":"The name of the system mutex to open.","nodes":[{"pos":[0,37],"content":"The name of the system mutex to open.","nodes":[{"content":"The name of the system mutex to open.","pos":[0,37]}]}],"pos":[49314,49352],"yaml":true},{"content":"An object that represents the named system mutex.","nodes":[{"pos":[0,49],"content":"An object that represents the named system mutex.","nodes":[{"content":"An object that represents the named system mutex.","pos":[0,49]}]}],"pos":[49418,49468],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[49625,49735],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[49837,49866],"yaml":true},{"content":"The named mutex does not exist.","nodes":[{"pos":[0,31],"content":"The named mutex does not exist.","nodes":[{"content":"The named mutex does not exist.","pos":[0,31]}]}],"pos":[50012,50044],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[50132,50156],"yaml":true},{"content":"The named mutex exists, but the user does not have the security access required to use it.","nodes":[{"pos":[0,90],"content":"The named mutex exists, but the user does not have the security access required to use it.","nodes":[{"content":"The named mutex exists, but the user does not have the security access required to use it.","pos":[0,90]}]}],"pos":[50270,50361],"yaml":true},{"content":"Opens the specified named mutex, if it already exists, with the desired security access.","nodes":[{"pos":[0,88],"content":"Opens the specified named mutex, if it already exists, with the desired security access.","nodes":[{"content":"Opens the specified named mutex, if it already exists, with the desired security access.","pos":[0,88]}]}],"pos":[51954,52043],"yaml":true},{"content":"The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \n  \n The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \n  \n This method does not request ownership of the mutex.","nodes":[{"pos":[0,327],"content":"The <ph id=\"ph1\">`rights`</ph> parameter must include the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id=\"ph4\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.","source":"The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method."},{"pos":[334,693],"content":"The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open an existing named mutex.","pos":[0,95],"source":"The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex."},{"content":"If the system mutex does not exist, this method throws an exception instead of creating the system object.","pos":[96,202]},{"content":"To create the system mutex when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[203,359],"source":" To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[700,918],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex."},{"pos":[925,977],"content":"This method does not request ownership of the mutex.","nodes":[{"content":"This method does not request ownership of the mutex.","pos":[0,52]}]}],"pos":[52054,53040],"yaml":true,"extradata":"MT"},{"content":"The name of the system mutex to open.","nodes":[{"pos":[0,37],"content":"The name of the system mutex to open.","nodes":[{"content":"The name of the system mutex to open.","pos":[0,37]}]}],"pos":[54886,54924],"yaml":true},{"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"pos":[0,91],"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"content":"A bitwise combination of the enumeration values that represent the desired security access.","pos":[0,91]}]}],"pos":[55014,55106],"yaml":true},{"content":"An object that represents the named system mutex.","nodes":[{"pos":[0,49],"content":"An object that represents the named system mutex.","nodes":[{"content":"An object that represents the named system mutex.","pos":[0,49]}]}],"pos":[55172,55222],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[55379,55489],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[55591,55620],"yaml":true},{"content":"The named mutex does not exist.","nodes":[{"pos":[0,31],"content":"The named mutex does not exist.","nodes":[{"content":"The named mutex does not exist.","pos":[0,31]}]}],"pos":[55766,55798],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[55886,55910],"yaml":true},{"content":"The named mutex exists, but the user does not have the desired security access.","nodes":[{"pos":[0,79],"content":"The named mutex exists, but the user does not have the desired security access.","nodes":[{"content":"The named mutex exists, but the user does not have the desired security access.","pos":[0,79]}]}],"pos":[56024,56104],"yaml":true},{"content":"Releases the <xref href=\"System.Threading.Mutex\"></xref> once.","nodes":[{"pos":[0,62],"content":"Releases the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> once.","source":"Releases the <xref href=\"System.Threading.Mutex\"></xref> once."}],"pos":[57130,57193],"yaml":true},{"content":"Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex. If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.  \n  \n [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]\n [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  \n  \n A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. The number of calls is kept by the common language runtime. The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.  \n  \n If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled and the next waiting thread gets ownership. If no one owns the mutex, the state of the mutex is signaled. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex. Prior to version 2.0 of the .NET Framework, no exception was thrown.  \n  \n> [!CAUTION]\n>  An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.  \n  \n In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","nodes":[{"pos":[0,744],"content":"Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex. If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.","nodes":[{"content":"Whenever a thread acquires a mutex (for example, by calling its <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method), it must subsequently call <ph id=\"ph2\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.","pos":[0,301],"source":"Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex."},{"content":"If the attempt to get ownership of the mutex fails (for example, when a call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method with a <ph id=\"ph2\">`millisecondsTimeout`</ph> or a <ph id=\"ph3\">`timeout`</ph> parameter returns <ph id=\"ph4\">`false`</ph> because the request times out), the thread shouldn't call <ph id=\"ph5\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.","pos":[302,744],"source":" If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows."}]},{"pos":[751,1038],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Mutex.Class#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Mutex.Class#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]\n [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]"},{"pos":[1045,1349],"content":"A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. The number of calls is kept by the common language runtime. The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.","nodes":[{"content":"A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. The number of calls is kept by the common language runtime. The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.","pos":[0,304],"nodes":[{"content":"A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.","pos":[0,117]},{"content":"The number of calls is kept by the common language runtime.","pos":[118,177]},{"content":"The thread must call <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> the same number of times to release ownership of the mutex.","pos":[178,304],"source":" The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex."}]}]},{"pos":[1356,1805],"content":"If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled and the next waiting thread gets ownership. If no one owns the mutex, the state of the mutex is signaled. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex. Prior to version 2.0 of the .NET Framework, no exception was thrown.","nodes":[{"content":"If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled and the next waiting thread gets ownership. If no one owns the mutex, the state of the mutex is signaled. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex. Prior to version 2.0 of the .NET Framework, no exception was thrown.","pos":[0,449],"nodes":[{"content":"If a thread terminates while owning a mutex, the mutex is said to be abandoned.","pos":[0,79]},{"content":"The state of the mutex is set to signaled and the next waiting thread gets ownership.","pos":[80,165]},{"content":"If no one owns the mutex, the state of the mutex is signaled.","pos":[166,227]},{"content":"Beginning in version 2.0 of the .NET Framework, an <ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the mutex.","pos":[228,380],"source":" Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex."},{"content":"Prior to version 2.0 of the .NET Framework, no exception was thrown.","pos":[381,449]}]}]},{"pos":[1813,2164],"content":"[!CAUTION]\n An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.","leadings":["","> "],"nodes":[{"content":" An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.","pos":[11,349],"nodes":[{"content":"An abandoned mutex often indicates a serious error in the code.","pos":[1,64]},{"content":"When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.","pos":[65,192]},{"content":"The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.","pos":[193,338]}]}]},{"pos":[2171,2335],"content":"In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","nodes":[{"content":"In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[0,164]}]}],"pos":[57204,59554],"yaml":true,"extradata":"MT"},{"content":"The calling thread does not own the mutex.","nodes":[{"pos":[0,42],"content":"The calling thread does not own the mutex.","nodes":[{"content":"The calling thread does not own the mutex.","pos":[0,42]}]}],"pos":[60635,60678],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[60784,60832],"yaml":true},{"content":"Sets the access control security for a named system mutex.","nodes":[{"pos":[0,58],"content":"Sets the access control security for a named system mutex.","nodes":[{"content":"Sets the access control security for a named system mutex.","pos":[0,58]}]}],"pos":[62412,62471],"yaml":true},{"content":"The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>.","nodes":[{"pos":[0,236],"content":"The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>.","nodes":[{"content":"The user must have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights to call this method, and the mutex must have been opened with <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>.","pos":[0,236],"source":"The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>."}]}],"pos":[62482,62719],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security to be applied to the named system mutex.","nodes":[{"pos":[0,158],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system mutex.","source":"A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security to be applied to the named system mutex."}],"pos":[64702,64861],"yaml":true},{"content":"<code>mutexSecurity</code> is `null`.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;mutexSecurity&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>mutexSecurity</code> is `null`."}],"pos":[65030,65068],"yaml":true},{"content":"The user does not have <xref href=\"System.Security.AccessControl.MutexRights.ChangePermissions\"></xref>.  \n  \n -or-  \n  \n The mutex was not opened with <xref href=\"System.Security.AccessControl.MutexRights.ChangePermissions\"></xref>.","nodes":[{"pos":[0,104],"content":"The user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexRights.ChangePermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The user does not have <xref href=\"System.Security.AccessControl.MutexRights.ChangePermissions\"></xref>."},{"pos":[111,115],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[122,233],"content":"The mutex was not opened with <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.MutexRights.ChangePermissions\"&gt;&lt;/xref&gt;</ph>.","source":"The mutex was not opened with <xref href=\"System.Security.AccessControl.MutexRights.ChangePermissions\"></xref>."}],"pos":[65182,65426],"yaml":true},{"content":"The current <xref href=\"System.Threading.Mutex\"></xref> object does not represent a named system mutex.","nodes":[{"pos":[0,103],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> object does not represent a named system mutex.","source":"The current <xref href=\"System.Threading.Mutex\"></xref> object does not represent a named system mutex."}],"pos":[65516,65620],"yaml":true},{"content":"Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.","nodes":[{"pos":[0,122],"content":"Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.","nodes":[{"content":"Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.","pos":[0,122]}]}],"pos":[66734,66857],"yaml":true},{"content":"If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \n  \n If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \n  \n This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \n  \n This method does not request ownership of the mutex.","nodes":[{"pos":[0,223],"content":"If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"If the named mutex does not exist, this method does not create it.","pos":[0,66]},{"content":"To create the system mutex when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[67,223],"source":" To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[230,454],"content":"If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.","nodes":[{"content":"If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.","pos":[0,224],"source":"If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist."}]},{"pos":[461,679],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex."},{"pos":[686,1419],"content":"This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.","nodes":[{"content":"This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.","pos":[0,733],"nodes":[{"content":"This method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> method overload and specifying <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.","pos":[0,421],"source":"This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation."},{"content":"Specifying the <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id=\"ph3\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.","pos":[422,733],"source":" Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method."}]}]},{"pos":[1426,1478],"content":"This method does not request ownership of the mutex.","nodes":[{"content":"This method does not request ownership of the mutex.","pos":[0,52]}]}],"pos":[66868,68357],"yaml":true,"extradata":"MT"},{"content":"The name of the system mutex to open.","nodes":[{"pos":[0,37],"content":"The name of the system mutex to open.","nodes":[{"content":"The name of the system mutex to open.","pos":[0,37]}]}],"pos":[68541,68579],"yaml":true},{"content":"When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"pos":[0,216],"content":"When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"content":"When this method returns, contains a <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id=\"ph2\">`null`</ph> if the call failed.","pos":[0,172],"source":"When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed."},{"content":"This parameter is treated as uninitialized.","pos":[173,216]}]}],"pos":[68650,68867],"yaml":true},{"content":"`true` if the named mutex was opened successfully; otherwise, `false`.","nodes":[{"pos":[0,70],"content":"<ph id=\"ph1\">`true`</ph> if the named mutex was opened successfully; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the named mutex was opened successfully; otherwise, `false`."}],"pos":[68925,68998],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[69158,69268],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[69370,69399],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[69487,69511],"yaml":true},{"content":"The named mutex exists, but the user does not have the security access required to use it.","nodes":[{"pos":[0,90],"content":"The named mutex exists, but the user does not have the security access required to use it.","nodes":[{"content":"The named mutex exists, but the user does not have the security access required to use it.","pos":[0,90]}]}],"pos":[69625,69716],"yaml":true},{"content":"Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","nodes":[{"pos":[0,156],"content":"Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","nodes":[{"content":"Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","pos":[0,156]}]}],"pos":[71420,71577],"yaml":true},{"content":"If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \n  \n If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.  \n  \n The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \n  \n This method does not request ownership of the mutex.","nodes":[{"pos":[0,223],"content":"If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"If the named mutex does not exist, this method does not create it.","pos":[0,66]},{"content":"To create the system mutex when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[67,223],"source":" To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[230,498],"content":"If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.","nodes":[{"content":"If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.","pos":[0,268],"source":"If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist."}]},{"pos":[505,832],"content":"The <ph id=\"ph1\">`rights`</ph> parameter must include the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id=\"ph4\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.","source":"The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method."},{"pos":[839,1057],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex."},{"pos":[1064,1116],"content":"This method does not request ownership of the mutex.","nodes":[{"content":"This method does not request ownership of the mutex.","pos":[0,52]}]}],"pos":[71588,72715],"yaml":true,"extradata":"MT"},{"content":"The name of the system mutex to open.","nodes":[{"pos":[0,37],"content":"The name of the system mutex to open.","nodes":[{"content":"The name of the system mutex to open.","pos":[0,37]}]}],"pos":[72949,72987],"yaml":true},{"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"pos":[0,91],"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"content":"A bitwise combination of the enumeration values that represent the desired security access.","pos":[0,91]}]}],"pos":[73077,73169],"yaml":true},{"content":"When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"pos":[0,216],"content":"When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"content":"When this method returns, contains a <ph id=\"ph1\">&lt;xref href=\"System.Threading.Mutex\"&gt;&lt;/xref&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id=\"ph2\">`null`</ph> if the call failed.","pos":[0,172],"source":"When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed."},{"content":"This parameter is treated as uninitialized.","pos":[173,216]}]}],"pos":[73240,73457],"yaml":true},{"content":"`true` if the named mutex was opened successfully; otherwise, `false`.","nodes":[{"pos":[0,70],"content":"<ph id=\"ph1\">`true`</ph> if the named mutex was opened successfully; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the named mutex was opened successfully; otherwise, `false`."}],"pos":[73515,73588],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[73748,73858],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[73960,73989],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[74077,74101],"yaml":true},{"content":"The named mutex exists, but the user does not have the security access required to use it.","nodes":[{"pos":[0,90],"content":"The named mutex exists, but the user does not have the security access required to use it.","nodes":[{"content":"The named mutex exists, but the user does not have the security access required to use it.","pos":[0,90]}]}],"pos":[74215,74306],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.Mutex\n  commentId: T:System.Threading.Mutex\n  id: Mutex\n  children:\n  - System.Threading.Mutex.#ctor\n  - System.Threading.Mutex.#ctor(System.Boolean)\n  - System.Threading.Mutex.#ctor(System.Boolean,System.String)\n  - System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)\n  - System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)\n  - System.Threading.Mutex.GetAccessControl\n  - System.Threading.Mutex.OpenExisting(System.String)\n  - System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)\n  - System.Threading.Mutex.ReleaseMutex\n  - System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)\n  - System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)\n  - System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)\n  langs:\n  - csharp\n  name: Mutex\n  nameWithType: Mutex\n  fullName: System.Threading.Mutex\n  type: Class\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: A synchronization primitive that can also be used for interprocess synchronization.\n  remarks: \"> [!NOTE]\\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \\n  \\n When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource. <xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread. If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.  \\n  \\n> [!IMPORTANT]\\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \\\"Using an Object that Implements IDisposable\\\" section in the <xref:System.IDisposable> interface topic.  \\n  \\n You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method to request ownership of a mutex. The calling thread blocks until one of the following occurs:  \\n  \\n-   The mutex is signaled to indicate that it is not owned. When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex. When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex. The first example in the Examples section illustrates this pattern.  \\n  \\n-   The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed. When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex. In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread. Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method. The second example in the Examples section illustrates this pattern.  \\n  \\n The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it. By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity. A mutex can also be passed across application domain boundaries.  \\n  \\n The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution. However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.  \\n  \\n Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods to synchronize access to a protected resource.  \\n  \\n If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled, and the next waiting thread gets ownership. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex. Before version 2.0 of the .NET Framework, no exception was thrown.  \\n  \\n> [!CAUTION]\\n>  An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.  \\n  \\n In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).  \\n  \\n Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes. A local mutex exists only within your process. It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex. Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.  \\n  \\n Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name. The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.  \\n  \\n> [!NOTE]\\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \\\"Global\\\\\\\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \\\"Local\\\\\\\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \\\"Local\\\\\\\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \\\"Global\\\\\\\\\\\" and \\\"Local\\\\\\\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.\"\n  example:\n  - \"This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource. Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.  \\n  \\n [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]\\n [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  \\n  \\n In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex. If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects. The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.  \\n  \\n [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]\\n [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public sealed class Mutex : System.Threading.WaitHandle\n  inheritance:\n  - System.Object\n  - System.Threading.WaitHandle\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  - System.Threading.WaitHandle.Close\n  - System.Threading.WaitHandle.Dispose\n  - System.Threading.WaitHandle.Dispose(System.Boolean)\n  - System.Threading.WaitHandle.Handle\n  - System.Threading.WaitHandle.InvalidHandle\n  - System.Threading.WaitHandle.SafeWaitHandle\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne\n  - System.Threading.WaitHandle.WaitOne(System.Int32)\n  - System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitTimeout\n  extensionMethods:\n  - System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.Mutex)\n  - System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.Mutex,System.Security.AccessControl.MutexSecurity)\n  - System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  - System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.#ctor\n  commentId: M:System.Threading.Mutex.#ctor\n  id: '#ctor'\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: Mutex()\n  nameWithType: Mutex.Mutex()\n  fullName: Mutex.Mutex()\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with default properties.\n  remarks: Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex. That is, the calling thread does not own the mutex.\n  example:\n  - \"The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource. The thread that creates the mutex does not own it initially.  \\n  \\n [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]\\n [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public Mutex ();\n    parameters: []\n  overload: System.Threading.Mutex.#ctor*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.#ctor(System.Boolean)\n  commentId: M:System.Threading.Mutex.#ctor(System.Boolean)\n  id: '#ctor(System.Boolean)'\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: Mutex(Boolean)\n  nameWithType: Mutex.Mutex(Boolean)\n  fullName: Mutex.Mutex(Boolean)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.\n  remarks: ''\n  example:\n  - \"The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource. The thread that creates the <xref:System.Threading.Mutex> owns it initially.  \\n  \\n [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]\\n [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public Mutex (bool initiallyOwned);\n    parameters:\n    - id: initiallyOwned\n      type: System.Boolean\n      description: '`true` to give the calling thread initial ownership of the mutex; otherwise, `false`.'\n  overload: System.Threading.Mutex.#ctor*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.#ctor(System.Boolean,System.String)\n  commentId: M:System.Threading.Mutex.#ctor(System.Boolean,System.String)\n  id: '#ctor(System.Boolean,System.String)'\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: Mutex(Boolean, String)\n  nameWithType: Mutex.Mutex(Boolean, String)\n  fullName: Mutex.Mutex(Boolean, String)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.\n  remarks: \"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call. Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload. You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.  \\n  \\n This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  \\n  \\n If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  \\n  \\n If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.  \\n  \\n Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  \\n  \\n> [!NOTE]\\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \\\"Global\\\\\\\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \\\"Local\\\\\\\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \\\"Local\\\\\\\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \\\"Global\\\\\\\\\\\" and \\\"Local\\\\\\\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.\"\n  example:\n  - \"The following example shows how a named mutex is used to signal between threads running in two separate processes.  \\n  \\n Run this program from two or more command windows. Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`. The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it. The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program. The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.  \\n  \\n The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted. You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.  \\n  \\n [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]\\n [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public Mutex (bool initiallyOwned, string name);\n    parameters:\n    - id: initiallyOwned\n      type: System.Boolean\n      description: '`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`.'\n    - id: name\n      type: System.String\n      description: The name of the <xref href=\"System.Threading.Mutex\"></xref>. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.\n  overload: System.Threading.Mutex.#ctor*\n  exceptions:\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>name</code> is longer than 260 characters.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)\n  commentId: M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)\n  id: '#ctor(System.Boolean,System.String,System.Boolean@)'\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: Mutex(Boolean, String, Boolean)\n  nameWithType: Mutex.Mutex(Boolean, String, Boolean)\n  fullName: Mutex.Mutex(Boolean, String, Boolean)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.\n  remarks: \"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A>method.  \\n  \\n This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  \\n  \\n If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  \\n  \\n If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.  \\n  \\n Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  \\n  \\n> [!NOTE]\\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \\\"Global\\\\\\\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \\\"Local\\\\\\\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \\\"Local\\\\\\\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \\\"Global\\\\\\\\\\\" and \\\"Local\\\\\\\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.\"\n  example:\n  - \"The following code example shows how a named mutex is used to signal between processes or threads. Run this program from two or more command windows. Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex \\\"MyMutex\\\". The named mutex is a system object. In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it. The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released. The named mutex is initially owned by the first process. The second process and any subsequent processes wait for earlier processes to release the named mutex.  \\n  \\n [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]\\n [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public Mutex (bool initiallyOwned, string name, out bool createdNew);\n    parameters:\n    - id: initiallyOwned\n      type: System.Boolean\n      description: '`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`.'\n    - id: name\n      type: System.String\n      description: The name of the <xref href=\"System.Threading.Mutex\"></xref>. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.\n    - id: createdNew\n      type: System.Boolean\n      description: When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed. This parameter is passed uninitialized.\n  overload: System.Threading.Mutex.#ctor*\n  exceptions:\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>name</code> is longer than 260 characters.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)\n  commentId: M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)\n  id: '#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)'\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: Mutex(Boolean, String, Boolean, MutexSecurity)\n  nameWithType: Mutex.Mutex(Boolean, String, Boolean, MutexSecurity)\n  fullName: Mutex.Mutex(Boolean, String, Boolean, MutexSecurity)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Mutex\"></xref> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.\n  remarks: \"If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.  \\n  \\n Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.  \\n  \\n This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  \\n  \\n If the named system mutex does not exist, it is created with the specified access control security. If the named mutex exists, the specified access control security is ignored.  \\n  \\n> [!NOTE]\\n>  The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.  \\n  \\n If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  \\n  \\n If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, `createdNew` is always `true`.  \\n  \\n Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  \\n  \\n> [!NOTE]\\n>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix \\\"Global\\\\\\\\\\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix \\\"Local\\\\\\\\\\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix \\\"Local\\\\\\\\\\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names \\\"Global\\\\\\\\\\\" and \\\"Local\\\\\\\\\\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.  \\n  \\n If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]\\n [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]\"\n  syntax:\n    content: public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);\n    parameters:\n    - id: initiallyOwned\n      type: System.Boolean\n      description: '`true` to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, `false`.'\n    - id: name\n      type: System.String\n      description: The name of the system mutex. If the value is `null`, the <xref href=\"System.Threading.Mutex\"></xref> is unnamed.\n    - id: createdNew\n      type: System.Boolean\n      description: When this method returns, contains a Boolean that is `true` if a local mutex was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system mutex was created; `false` if the specified named system mutex already existed. This parameter is passed uninitialized.\n    - id: mutexSecurity\n      type: System.Security.AccessControl.MutexSecurity\n      description: A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security to be applied to the named system mutex.\n  overload: System.Threading.Mutex.#ctor*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named mutex exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.MutexRights.FullControl\"></xref>.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>name</code> is longer than 260 characters.\n  attributes: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.GetAccessControl\n  commentId: M:System.Threading.Mutex.GetAccessControl\n  id: GetAccessControl\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: GetAccessControl()\n  nameWithType: Mutex.GetAccessControl()\n  fullName: Mutex.GetAccessControl()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets a <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security for the named mutex.\n  remarks: \"The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.  \\n  \\n The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.  \\n  \\n If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.  \\n  \\n After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]\\n [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]\"\n  syntax:\n    content: public System.Security.AccessControl.MutexSecurity GetAccessControl ();\n    parameters: []\n    return:\n      type: System.Security.AccessControl.MutexSecurity\n      description: A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security for the named mutex.\n  overload: System.Threading.Mutex.GetAccessControl*\n  exceptions:\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The current <xref href=\\\"System.Threading.Mutex\\\"></xref> object represents a named system mutex, but the user does not have <xref href=\\\"System.Security.AccessControl.MutexRights.ReadPermissions\\\"></xref>.  \\n  \\n -or-  \\n  \\n The current <xref href=\\\"System.Threading.Mutex\\\"></xref> object represents a named system mutex, and was not opened with <xref href=\\\"System.Security.AccessControl.MutexRights.ReadPermissions\\\"></xref>.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Not supported for Windows 98 or Windows Millennium Edition.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.OpenExisting(System.String)\n  commentId: M:System.Threading.Mutex.OpenExisting(System.String)\n  id: OpenExisting(System.String)\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: OpenExisting(String)\n  nameWithType: Mutex.OpenExisting(String)\n  fullName: Mutex.OpenExisting(String)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Opens the specified named mutex, if it already exists.\n  remarks: \"The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \\n  \\n This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.  \\n  \\n Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \\n  \\n This method does not request ownership of the mutex.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.  \\n  \\n If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]\\n [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]\"\n  syntax:\n    content: public static System.Threading.Mutex OpenExisting (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system mutex to open.\n    return:\n      type: System.Threading.Mutex\n      description: An object that represents the named system mutex.\n  overload: System.Threading.Mutex.OpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named mutex does not exist.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named mutex exists, but the user does not have the security access required to use it.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)\n  commentId: M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)\n  id: OpenExisting(System.String,System.Security.AccessControl.MutexRights)\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: OpenExisting(String, MutexRights)\n  nameWithType: Mutex.OpenExisting(String, MutexRights)\n  fullName: Mutex.OpenExisting(String, MutexRights)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Opens the specified named mutex, if it already exists, with the desired security access.\n  remarks: \"The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \\n  \\n The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \\n  \\n This method does not request ownership of the mutex.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.  \\n  \\n If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]\\n [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]\"\n  syntax:\n    content: public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system mutex to open.\n    - id: rights\n      type: System.Security.AccessControl.MutexRights\n      description: A bitwise combination of the enumeration values that represent the desired security access.\n    return:\n      type: System.Threading.Mutex\n      description: An object that represents the named system mutex.\n  overload: System.Threading.Mutex.OpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named mutex does not exist.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named mutex exists, but the user does not have the desired security access.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.ReleaseMutex\n  commentId: M:System.Threading.Mutex.ReleaseMutex\n  id: ReleaseMutex\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: ReleaseMutex()\n  nameWithType: Mutex.ReleaseMutex()\n  fullName: Mutex.ReleaseMutex()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the <xref href=\"System.Threading.Mutex\"></xref> once.\n  remarks: \"Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex. If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.  \\n  \\n [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]\\n [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  \\n  \\n A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. The number of calls is kept by the common language runtime. The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.  \\n  \\n If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled and the next waiting thread gets ownership. If no one owns the mutex, the state of the mutex is signaled. Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex. Prior to version 2.0 of the .NET Framework, no exception was thrown.  \\n  \\n> [!CAUTION]\\n>  An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.  \\n  \\n In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).\"\n  example:\n  - \"The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource. The thread that creates the mutex does not own it initially. The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.  \\n  \\n [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]\\n [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public void ReleaseMutex ();\n    parameters: []\n  overload: System.Threading.Mutex.ReleaseMutex*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: The calling thread does not own the mutex.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)\n  commentId: M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)\n  id: SetAccessControl(System.Security.AccessControl.MutexSecurity)\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: SetAccessControl(MutexSecurity)\n  nameWithType: Mutex.SetAccessControl(MutexSecurity)\n  fullName: Mutex.SetAccessControl(MutexSecurity)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Sets the access control security for a named system mutex.\n  remarks: The user must have <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName>.\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.  \\n  \\n If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.  \\n  \\n After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]\\n [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]\"\n  syntax:\n    content: public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);\n    parameters:\n    - id: mutexSecurity\n      type: System.Security.AccessControl.MutexSecurity\n      description: A <xref href=\"System.Security.AccessControl.MutexSecurity\"></xref> object that represents the access control security to be applied to the named system mutex.\n  overload: System.Threading.Mutex.SetAccessControl*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>mutexSecurity</code> is `null`.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The user does not have <xref href=\\\"System.Security.AccessControl.MutexRights.ChangePermissions\\\"></xref>.  \\n  \\n -or-  \\n  \\n The mutex was not opened with <xref href=\\\"System.Security.AccessControl.MutexRights.ChangePermissions\\\"></xref>.\"\n  - type: System.SystemException\n    commentId: T:System.SystemException\n    description: The current <xref href=\"System.Threading.Mutex\"></xref> object does not represent a named system mutex.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)\n  commentId: M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)\n  id: TryOpenExisting(System.String,System.Threading.Mutex@)\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: TryOpenExisting(String, Mutex)\n  nameWithType: Mutex.TryOpenExisting(String, Mutex)\n  fullName: Mutex.TryOpenExisting(String, Mutex)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.\n  remarks: \"If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \\n  \\n This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \\n  \\n This method does not request ownership of the mutex.\"\n  syntax:\n    content: public static bool TryOpenExisting (string name, out System.Threading.Mutex result);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system mutex to open.\n    - id: result\n      type: System.Threading.Mutex\n      description: When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.\n    return:\n      type: System.Boolean\n      description: '`true` if the named mutex was opened successfully; otherwise, `false`.'\n  overload: System.Threading.Mutex.TryOpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named mutex exists, but the user does not have the security access required to use it.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)\n  commentId: M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)\n  id: TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)\n  parent: System.Threading.Mutex\n  langs:\n  - csharp\n  name: TryOpenExisting(String, MutexRights, Mutex)\n  nameWithType: Mutex.TryOpenExisting(String, MutexRights, Mutex)\n  fullName: Mutex.TryOpenExisting(String, MutexRights, Mutex)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.\n  remarks: \"If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.  \\n  \\n The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  \\n  \\n This method does not request ownership of the mutex.\"\n  syntax:\n    content: public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system mutex to open.\n    - id: rights\n      type: System.Security.AccessControl.MutexRights\n      description: A bitwise combination of the enumeration values that represent the desired security access.\n    - id: result\n      type: System.Threading.Mutex\n      description: When this method returns, contains a <xref href=\"System.Threading.Mutex\"></xref> object that represents the named mutex if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.\n    return:\n      type: System.Boolean\n      description: '`true` if the named mutex was opened successfully; otherwise, `false`.'\n  overload: System.Threading.Mutex.TryOpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named mutex exists, but the user does not have the security access required to use it.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Threading.WaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandle\n  nameWithType: WaitHandle\n  fullName: System.Threading.WaitHandle\n- uid: System.UnauthorizedAccessException\n  parent: System\n  isExternal: false\n  name: UnauthorizedAccessException\n  nameWithType: UnauthorizedAccessException\n  fullName: System.UnauthorizedAccessException\n- uid: System.IO.IOException\n  parent: System.IO\n  isExternal: false\n  name: IOException\n  nameWithType: IOException\n  fullName: System.IO.IOException\n- uid: System.Threading.WaitHandleCannotBeOpenedException\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandleCannotBeOpenedException\n  nameWithType: WaitHandleCannotBeOpenedException\n  fullName: System.Threading.WaitHandleCannotBeOpenedException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.ApplicationException\n  parent: System\n  isExternal: false\n  name: ApplicationException\n  nameWithType: ApplicationException\n  fullName: System.ApplicationException\n- uid: System.ObjectDisposedException\n  parent: System\n  isExternal: false\n  name: ObjectDisposedException\n  nameWithType: ObjectDisposedException\n  fullName: System.ObjectDisposedException\n- uid: System.SystemException\n  parent: System\n  isExternal: false\n  name: SystemException\n  nameWithType: SystemException\n  fullName: System.SystemException\n- uid: System.Threading.Mutex.#ctor\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: Mutex()\n  nameWithType: Mutex.Mutex()\n  fullName: Mutex.Mutex()\n- uid: System.Threading.Mutex.#ctor(System.Boolean)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: Mutex(Boolean)\n  nameWithType: Mutex.Mutex(Boolean)\n  fullName: Mutex.Mutex(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.Mutex.#ctor(System.Boolean,System.String)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: Mutex(Boolean, String)\n  nameWithType: Mutex.Mutex(Boolean, String)\n  fullName: Mutex.Mutex(Boolean, String)\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: Mutex(Boolean, String, Boolean)\n  nameWithType: Mutex.Mutex(Boolean, String, Boolean)\n  fullName: Mutex.Mutex(Boolean, String, Boolean)\n- uid: System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: Mutex(Boolean, String, Boolean, MutexSecurity)\n  nameWithType: Mutex.Mutex(Boolean, String, Boolean, MutexSecurity)\n  fullName: Mutex.Mutex(Boolean, String, Boolean, MutexSecurity)\n- uid: System.Security.AccessControl.MutexSecurity\n  parent: System.Security.AccessControl\n  isExternal: false\n  name: MutexSecurity\n  nameWithType: MutexSecurity\n  fullName: System.Security.AccessControl.MutexSecurity\n- uid: System.Threading.Mutex.GetAccessControl\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: GetAccessControl()\n  nameWithType: Mutex.GetAccessControl()\n  fullName: Mutex.GetAccessControl()\n- uid: System.Threading.Mutex.OpenExisting(System.String)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: OpenExisting(String)\n  nameWithType: Mutex.OpenExisting(String)\n  fullName: Mutex.OpenExisting(String)\n- uid: System.Threading.Mutex\n  parent: System.Threading\n  isExternal: false\n  name: Mutex\n  nameWithType: Mutex\n  fullName: System.Threading.Mutex\n- uid: System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: OpenExisting(String, MutexRights)\n  nameWithType: Mutex.OpenExisting(String, MutexRights)\n  fullName: Mutex.OpenExisting(String, MutexRights)\n- uid: System.Security.AccessControl.MutexRights\n  parent: System.Security.AccessControl\n  isExternal: false\n  name: MutexRights\n  nameWithType: MutexRights\n  fullName: System.Security.AccessControl.MutexRights\n- uid: System.Threading.Mutex.ReleaseMutex\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: ReleaseMutex()\n  nameWithType: Mutex.ReleaseMutex()\n  fullName: Mutex.ReleaseMutex()\n- uid: System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: SetAccessControl(MutexSecurity)\n  nameWithType: Mutex.SetAccessControl(MutexSecurity)\n  fullName: Mutex.SetAccessControl(MutexSecurity)\n- uid: System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: TryOpenExisting(String, Mutex)\n  nameWithType: Mutex.TryOpenExisting(String, Mutex)\n  fullName: Mutex.TryOpenExisting(String, Mutex)\n- uid: System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: TryOpenExisting(String, MutexRights, Mutex)\n  nameWithType: Mutex.TryOpenExisting(String, MutexRights, Mutex)\n  fullName: Mutex.TryOpenExisting(String, MutexRights, Mutex)\n- uid: System.Threading.Mutex.#ctor*\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: Mutex\n  nameWithType: Mutex.Mutex\n  fullName: Mutex.Mutex\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n- uid: System.Threading.Mutex.GetAccessControl*\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: GetAccessControl\n  nameWithType: Mutex.GetAccessControl\n  fullName: Mutex.GetAccessControl\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n- uid: System.Threading.Mutex.OpenExisting*\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: OpenExisting\n  nameWithType: Mutex.OpenExisting\n  fullName: Mutex.OpenExisting\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n- uid: System.Threading.Mutex.ReleaseMutex*\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: ReleaseMutex\n  nameWithType: Mutex.ReleaseMutex\n  fullName: Mutex.ReleaseMutex\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n- uid: System.Threading.Mutex.SetAccessControl*\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: SetAccessControl\n  nameWithType: Mutex.SetAccessControl\n  fullName: Mutex.SetAccessControl\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n- uid: System.Threading.Mutex.TryOpenExisting*\n  parent: System.Threading.Mutex\n  isExternal: false\n  name: TryOpenExisting\n  nameWithType: Mutex.TryOpenExisting\n  fullName: Mutex.TryOpenExisting\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Mutex.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Threading.WaitHandle.Close\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Close()\n  nameWithType: WaitHandle.Close()\n  fullName: WaitHandle.Close()\n- uid: System.Threading.WaitHandle.Dispose\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose()\n  nameWithType: WaitHandle.Dispose()\n  fullName: WaitHandle.Dispose()\n- uid: System.Threading.WaitHandle.Dispose(System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: WaitHandle.Dispose(Boolean)\n  fullName: WaitHandle.Dispose(Boolean)\n- uid: System.Threading.WaitHandle.Handle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Handle\n  nameWithType: WaitHandle.Handle\n  fullName: WaitHandle.Handle\n- uid: System.Threading.WaitHandle.InvalidHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: InvalidHandle\n  nameWithType: WaitHandle.InvalidHandle\n  fullName: WaitHandle.InvalidHandle\n- uid: System.Threading.WaitHandle.SafeWaitHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SafeWaitHandle\n  nameWithType: WaitHandle.SafeWaitHandle\n  fullName: WaitHandle.SafeWaitHandle\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[])\n  nameWithType: WaitHandle.WaitAll(WaitHandle[])\n  fullName: WaitHandle.WaitAll(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[])\n  nameWithType: WaitHandle.WaitAny(WaitHandle[])\n  fullName: WaitHandle.WaitAny(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne()\n  nameWithType: WaitHandle.WaitOne()\n  fullName: WaitHandle.WaitOne()\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32)\n  nameWithType: WaitHandle.WaitOne(Int32)\n  fullName: WaitHandle.WaitOne(Int32)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan)\n  nameWithType: WaitHandle.WaitOne(TimeSpan)\n  fullName: WaitHandle.WaitOne(TimeSpan)\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32, Boolean)\n  nameWithType: WaitHandle.WaitOne(Int32, Boolean)\n  fullName: WaitHandle.WaitOne(Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitOne(TimeSpan, Boolean)\n  fullName: WaitHandle.WaitOne(TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitTimeout\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitTimeout\n  nameWithType: WaitHandle.WaitTimeout\n  fullName: WaitHandle.WaitTimeout\n- uid: System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.Mutex)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: GetAccessControl(Mutex)\n  nameWithType: ThreadingAclExtensions.GetAccessControl(Mutex)\n  fullName: ThreadingAclExtensions.GetAccessControl(Mutex)\n- uid: System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.Mutex,System.Security.AccessControl.MutexSecurity)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: SetAccessControl(Mutex, MutexSecurity)\n  nameWithType: ThreadingAclExtensions.SetAccessControl(Mutex, MutexSecurity)\n  fullName: ThreadingAclExtensions.SetAccessControl(Mutex, MutexSecurity)\n- uid: System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: GetSafeWaitHandle(WaitHandle)\n  nameWithType: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n  fullName: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n- uid: System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  nameWithType: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  fullName: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n"}