{"nodes":[{"content":"Indicates that the modified garbage collection reference represents a reference parameter within a method signature. This class cannot be inherited.","nodes":[{"pos":[0,148],"content":"Indicates that the modified garbage collection reference represents a reference parameter within a method signature. This class cannot be inherited.","nodes":[{"content":"Indicates that the modified garbage collection reference represents a reference parameter within a method signature. This class cannot be inherited.","pos":[0,148],"nodes":[{"content":"Indicates that the modified garbage collection reference represents a reference parameter within a method signature.","pos":[0,116]},{"content":"This class cannot be inherited.","pos":[117,148]}]}]}],"pos":[538,687],"yaml":true},{"content":"The C++ compiler uses the <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> modifier to distinguish reference classes that are passed by managed reference from those passed by managed pointer.  The <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> class and its partner, the <xref:System.Runtime.CompilerServices.IsExplicitlyDereferenced> class, disambiguate reference parameters from pointer parameters.  \n  \n Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.  When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.  Compilers can apply custom modifiers to methods, parameters, and return values.  The JIT compiler must respond to required modifiers but can ignore optional modifiers.  \n  \n You can emit custom modifiers into metadata using one of the following techniques:  \n  \n-   Using methods in the <xref:System.Reflection.Emit.TypeBuilder> class such as <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, and <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>.  \n  \n-   Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to `modopt` and `modreq`, and assembling the file with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \n  \n-   Using the unmanaged reflection API.","nodes":[{"pos":[0,432],"content":"The C++ compiler uses the <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> modifier to distinguish reference classes that are passed by managed reference from those passed by managed pointer.  The <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> class and its partner, the <xref:System.Runtime.CompilerServices.IsExplicitlyDereferenced> class, disambiguate reference parameters from pointer parameters.","nodes":[{"content":"The C++ compiler uses the <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> modifier to distinguish reference classes that are passed by managed reference from those passed by managed pointer.  The <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> class and its partner, the <xref:System.Runtime.CompilerServices.IsExplicitlyDereferenced> class, disambiguate reference parameters from pointer parameters.","pos":[0,432],"nodes":[{"content":"The C++ compiler uses the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced&gt;</ph> modifier to distinguish reference classes that are passed by managed reference from those passed by managed pointer.","pos":[0,206],"source":"The C++ compiler uses the <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> modifier to distinguish reference classes that are passed by managed reference from those passed by managed pointer."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced&gt;</ph> class and its partner, the <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.IsExplicitlyDereferenced&gt;</ph> class, disambiguate reference parameters from pointer parameters.","pos":[208,432],"source":"  The <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> class and its partner, the <xref:System.Runtime.CompilerServices.IsExplicitlyDereferenced> class, disambiguate reference parameters from pointer parameters."}]}]},{"pos":[439,885],"content":"Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.  When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.  Compilers can apply custom modifiers to methods, parameters, and return values.  The JIT compiler must respond to required modifiers but can ignore optional modifiers.","nodes":[{"content":"Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.  When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.  Compilers can apply custom modifiers to methods, parameters, and return values.  The JIT compiler must respond to required modifiers but can ignore optional modifiers.","pos":[0,446],"nodes":[{"content":"Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.","pos":[0,163]},{"content":"When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.","pos":[165,277]},{"content":"Compilers can apply custom modifiers to methods, parameters, and return values.","pos":[279,358]},{"content":"The JIT compiler must respond to required modifiers but can ignore optional modifiers.","pos":[360,446]}]}]},{"pos":[892,974],"content":"You can emit custom modifiers into metadata using one of the following techniques:","nodes":[{"content":"You can emit custom modifiers into metadata using one of the following techniques:","pos":[0,82]}]},{"pos":[984,1306],"content":"Using methods in the <xref:System.Reflection.Emit.TypeBuilder> class such as <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, and <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>.","nodes":[{"content":"Using methods in the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class such as <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineField%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A&gt;</ph>.","pos":[0,322],"source":"Using methods in the <xref:System.Reflection.Emit.TypeBuilder> class such as <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, and <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>."}]},{"pos":[1316,1541],"content":"Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to <ph id=\"ph1\">`modopt`</ph> and <ph id=\"ph2\">`modreq`</ph>, and assembling the file with the <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.","source":"Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to `modopt` and `modreq`, and assembling the file with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)."},{"pos":[1551,1586],"content":"Using the unmanaged reflection API.","nodes":[{"content":"Using the unmanaged reflection API.","pos":[0,35]}]}],"pos":[698,2297],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.CompilerServices.IsImplicitlyDereferenced\n  commentId: T:System.Runtime.CompilerServices.IsImplicitlyDereferenced\n  id: IsImplicitlyDereferenced\n  children: []\n  langs:\n  - csharp\n  name: IsImplicitlyDereferenced\n  nameWithType: IsImplicitlyDereferenced\n  fullName: System.Runtime.CompilerServices.IsImplicitlyDereferenced\n  type: Class\n  assemblies:\n  - System.Runtime.CompilerServices.VisualC\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Indicates that the modified garbage collection reference represents a reference parameter within a method signature. This class cannot be inherited.\n  remarks: \"The C++ compiler uses the <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> modifier to distinguish reference classes that are passed by managed reference from those passed by managed pointer.  The <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> class and its partner, the <xref:System.Runtime.CompilerServices.IsExplicitlyDereferenced> class, disambiguate reference parameters from pointer parameters.  \\n  \\n Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.  When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.  Compilers can apply custom modifiers to methods, parameters, and return values.  The JIT compiler must respond to required modifiers but can ignore optional modifiers.  \\n  \\n You can emit custom modifiers into metadata using one of the following techniques:  \\n  \\n-   Using methods in the <xref:System.Reflection.Emit.TypeBuilder> class such as <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, and <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>.  \\n  \\n-   Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to `modopt` and `modreq`, and assembling the file with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \\n  \\n-   Using the unmanaged reflection API.\"\n  example:\n  - \"The following example demonstrates how to emit an <xref:System.Runtime.CompilerServices.IsImplicitlyDereferenced> object into an assembly using reflection.  \\n  \\n [!code-cpp[Runtime.CompilerServices.IsImplicitlyDereferenced#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.CompilerServices.IsImplicitlyDereferenced/cpp/sample.cpp#1)]\"\n  syntax:\n    content: public static class IsImplicitlyDereferenced\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/IsImplicitlyDereferenced.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}