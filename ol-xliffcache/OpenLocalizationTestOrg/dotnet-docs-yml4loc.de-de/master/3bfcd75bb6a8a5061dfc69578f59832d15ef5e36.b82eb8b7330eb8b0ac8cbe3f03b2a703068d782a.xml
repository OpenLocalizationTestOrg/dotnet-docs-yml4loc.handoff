{"nodes":[{"content":"Provides atomic operations for variables that are shared by multiple threads.","nodes":[{"pos":[0,77],"content":"Provides atomic operations for variables that are shared by multiple threads.","nodes":[{"content":"Provides atomic operations for variables that are shared by multiple threads.","pos":[0,77]}]}],"pos":[1995,2073],"yaml":true},{"content":"The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors. The members of this class do not throw exceptions.  \n  \n The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation. On most computers, incrementing a variable is not an atomic operation, requiring the following steps:  \n  \n1.  Load a value from an instance variable into a register.  \n  \n2.  Increment or decrement the value.  \n  \n3.  Store the value in the instance variable.  \n  \n If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps. Another thread can then execute all three steps. When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.  \n  \n The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables. The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison. The compare and exchange operations are performed as an atomic operation.","nodes":[{"pos":[0,304],"content":"The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors. The members of this class do not throw exceptions.","nodes":[{"content":"The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors. The members of this class do not throw exceptions.","pos":[0,304],"nodes":[{"content":"The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.","pos":[0,253]},{"content":"The members of this class do not throw exceptions.","pos":[254,304]}]}]},{"pos":[311,613],"content":"The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation. On most computers, incrementing a variable is not an atomic operation, requiring the following steps:","nodes":[{"content":"The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation. On most computers, incrementing a variable is not an atomic operation, requiring the following steps:","pos":[0,302],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> methods increment or decrement a variable and store the resulting value in a single operation.","pos":[0,200],"source":"The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation."},{"content":"On most computers, incrementing a variable is not an atomic operation, requiring the following steps:","pos":[201,302]}]}]},{"pos":[623,678],"content":"Load a value from an instance variable into a register.","nodes":[{"content":"Load a value from an instance variable into a register.","pos":[0,55]}]},{"pos":[688,721],"content":"Increment or decrement the value.","nodes":[{"content":"Increment or decrement the value.","pos":[0,33]}]},{"pos":[731,772],"content":"Store the value in the instance variable.","nodes":[{"content":"Store the value in the instance variable.","pos":[0,41]}]},{"pos":[779,1187],"content":"If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps. Another thread can then execute all three steps. When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.","nodes":[{"content":"If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps. Another thread can then execute all three steps. When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.","pos":[0,408],"nodes":[{"content":"If you do not use <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, a thread can be preempted after executing the first two steps.","pos":[0,183],"source":"If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps."},{"content":"Another thread can then execute all three steps.","pos":[184,232]},{"content":"When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.","pos":[233,408]}]}]},{"pos":[1194,1589],"content":"The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables. The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison. The compare and exchange operations are performed as an atomic operation.","nodes":[{"content":"The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables. The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison. The compare and exchange operations are performed as an atomic operation.","pos":[0,395],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method atomically exchanges the values of the specified variables.","pos":[0,118],"source":"The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.","pos":[119,321],"source":" The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison."},{"content":"The compare and exchange operations are performed as an atomic operation.","pos":[322,395]}]}]}],"pos":[2084,3688],"yaml":true,"extradata":"MT"},{"content":"Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.","nodes":[{"pos":[0,93],"content":"Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.","nodes":[{"content":"Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.","pos":[0,93]}]}],"pos":[6253,6347],"yaml":true},{"content":"This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int32?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int32?displayProperty=fullName> + 1); and so on. No exception is thrown.","nodes":[{"pos":[0,326],"content":"This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int32?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int32?displayProperty=fullName> + 1); and so on. No exception is thrown.","nodes":[{"content":"This method handles an overflow condition by wrapping: if the value at <ph id=\"ph1\">`location1`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">`value`</ph> is 1, the result is <ph id=\"ph4\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>; if <ph id=\"ph5\">`value`</ph> is 2, the result is (<ph id=\"ph6\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph> + 1); and so on.","pos":[0,302],"source":"This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int32?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int32?displayProperty=fullName> + 1); and so on."},{"content":"No exception is thrown.","pos":[303,326]}]}],"pos":[6358,6687],"yaml":true,"extradata":"MT"},{"content":"A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.","nodes":[{"pos":[0,113],"content":"A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.","nodes":[{"content":"A variable containing the first value to be added.","pos":[0,50]},{"content":"The sum of the two values is stored in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[51,113],"source":" The sum of the two values is stored in <code>location1</code>."}]}],"pos":[6844,6958],"yaml":true},{"content":"The value to be added to the integer at <code>location1</code>.","nodes":[{"pos":[0,63],"content":"The value to be added to the integer at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The value to be added to the integer at <code>location1</code>."}],"pos":[7018,7082],"yaml":true},{"content":"The new value stored at <code>location1</code>.","nodes":[{"pos":[0,47],"content":"The new value stored at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The new value stored at <code>location1</code>."}],"pos":[7138,7186],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[7350,7407],"yaml":true},{"content":"Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.","nodes":[{"pos":[0,93],"content":"Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.","nodes":[{"content":"Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.","pos":[0,93]}]}],"pos":[8928,9022],"yaml":true},{"content":"This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int64?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int64?displayProperty=fullName> + 1); and so on. No exception is thrown.  \n  \n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","nodes":[{"pos":[0,326],"content":"This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int64?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int64?displayProperty=fullName> + 1); and so on. No exception is thrown.","nodes":[{"content":"This method handles an overflow condition by wrapping: if the value at <ph id=\"ph1\">`location1`</ph> is <ph id=\"ph2\">&lt;xref:System.Int64?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">`value`</ph> is 1, the result is <ph id=\"ph4\">&lt;xref:System.Int64?displayProperty=fullName&gt;</ph>; if <ph id=\"ph5\">`value`</ph> is 2, the result is (<ph id=\"ph6\">&lt;xref:System.Int64?displayProperty=fullName&gt;</ph> + 1); and so on.","pos":[0,302],"source":"This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int64?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int64?displayProperty=fullName> + 1); and so on."},{"content":"No exception is thrown.","pos":[303,326]}]},{"pos":[333,963],"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","nodes":[{"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","pos":[0,630],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id=\"ph2\">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id=\"ph5\">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> is 64 bits long.","pos":[0,345],"source":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long."},{"content":"On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.","pos":[346,475]},{"content":"Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class.","pos":[476,630],"source":" Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class."}]}]}],"pos":[9033,10001],"yaml":true,"extradata":"MT"},{"content":"A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.","nodes":[{"pos":[0,113],"content":"A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.","nodes":[{"content":"A variable containing the first value to be added.","pos":[0,50]},{"content":"The sum of the two values is stored in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[51,113],"source":" The sum of the two values is stored in <code>location1</code>."}]}],"pos":[10161,10275],"yaml":true},{"content":"The value to be added to the integer at <code>location1</code>.","nodes":[{"pos":[0,63],"content":"The value to be added to the integer at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The value to be added to the integer at <code>location1</code>."}],"pos":[10335,10399],"yaml":true},{"content":"The new value stored at <code>location1</code>.","nodes":[{"pos":[0,47],"content":"The new value stored at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The new value stored at <code>location1</code>."}],"pos":[10455,10503],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[10667,10724],"yaml":true},{"content":"Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.","nodes":[{"pos":[0,115],"content":"Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.","nodes":[{"content":"Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.","pos":[0,115]}]}],"pos":[12395,12511],"yaml":true},{"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"pos":[0,359],"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"content":"If <ph id=\"ph1\">`comparand`</ph> and the value in <ph id=\"ph2\">`location1`</ph> are equal, then <ph id=\"ph3\">`value`</ph> is stored in <ph id=\"ph4\">`location1`</ph>.","pos":[0,93],"source":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`."},{"content":"Otherwise, no operation is performed.","pos":[94,131]},{"content":"The compare and exchange operations are performed as an atomic operation.","pos":[132,205]},{"content":"The return value of <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id=\"ph2\">`location1`</ph>, whether or not the exchange takes place.","pos":[206,359],"source":" The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place."}]}],"pos":[12522,12882],"yaml":true,"extradata":"MT"},{"content":"The destination, whose value is compared with <code>comparand</code> and possibly replaced.","nodes":[{"pos":[0,91],"content":"The destination, whose value is compared with <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">comparand</ph><ept id=\"p1\">&lt;/code&gt;</ept> and possibly replaced.","source":"The destination, whose value is compared with <code>comparand</code> and possibly replaced."}],"pos":[14278,14370],"yaml":true},{"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"pos":[0,84],"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"content":"The value that replaces the destination value if the comparison results in equality.","pos":[0,84]}]}],"pos":[14431,14516],"yaml":true},{"content":"The value that is compared to the value at <code>location1</code>.","nodes":[{"pos":[0,66],"content":"The value that is compared to the value at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The value that is compared to the value at <code>location1</code>."}],"pos":[14581,14648],"yaml":true},{"content":"The original value in <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value in <code>location1</code>."}],"pos":[14705,14751],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[14927,14984],"yaml":true},{"content":"Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.","nodes":[{"pos":[0,98],"content":"Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.","nodes":[{"content":"Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.","pos":[0,98]}]}],"pos":[16620,16719],"yaml":true},{"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"pos":[0,359],"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"content":"If <ph id=\"ph1\">`comparand`</ph> and the value in <ph id=\"ph2\">`location1`</ph> are equal, then <ph id=\"ph3\">`value`</ph> is stored in <ph id=\"ph4\">`location1`</ph>.","pos":[0,93],"source":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`."},{"content":"Otherwise, no operation is performed.","pos":[94,131]},{"content":"The compare and exchange operations are performed as an atomic operation.","pos":[132,205]},{"content":"The return value of <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id=\"ph2\">`location1`</ph>, whether or not the exchange takes place.","pos":[206,359],"source":" The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place."}]}],"pos":[16730,17090],"yaml":true,"extradata":"MT"},{"content":"The destination, whose value is compared with <code>comparand</code> and possibly replaced.","nodes":[{"pos":[0,91],"content":"The destination, whose value is compared with <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">comparand</ph><ept id=\"p1\">&lt;/code&gt;</ept> and possibly replaced.","source":"The destination, whose value is compared with <code>comparand</code> and possibly replaced."}],"pos":[18525,18617],"yaml":true},{"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"pos":[0,84],"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"content":"The value that replaces the destination value if the comparison results in equality.","pos":[0,84]}]}],"pos":[18677,18762],"yaml":true},{"content":"The value that is compared to the value at <code>location1</code>.","nodes":[{"pos":[0,66],"content":"The value that is compared to the value at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The value that is compared to the value at <code>location1</code>."}],"pos":[18826,18893],"yaml":true},{"content":"The original value in <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value in <code>location1</code>."}],"pos":[18949,18995],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[19171,19228],"yaml":true},{"content":"Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.","nodes":[{"pos":[0,98],"content":"Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.","nodes":[{"content":"Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.","pos":[0,98]}]}],"pos":[20881,20980],"yaml":true},{"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"pos":[0,359],"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"content":"If <ph id=\"ph1\">`comparand`</ph> and the value in <ph id=\"ph2\">`location1`</ph> are equal, then <ph id=\"ph3\">`value`</ph> is stored in <ph id=\"ph4\">`location1`</ph>.","pos":[0,93],"source":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`."},{"content":"Otherwise, no operation is performed.","pos":[94,131]},{"content":"The compare and exchange operations are performed as an atomic operation.","pos":[132,205]},{"content":"The return value of <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id=\"ph2\">`location1`</ph>, whether or not the exchange takes place.","pos":[206,359],"source":" The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place."}]}],"pos":[20991,21351],"yaml":true,"extradata":"MT"},{"content":"The destination, whose value is compared with <code>comparand</code> and possibly replaced.","nodes":[{"pos":[0,91],"content":"The destination, whose value is compared with <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">comparand</ph><ept id=\"p1\">&lt;/code&gt;</ept> and possibly replaced.","source":"The destination, whose value is compared with <code>comparand</code> and possibly replaced."}],"pos":[21539,21631],"yaml":true},{"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"pos":[0,84],"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"content":"The value that replaces the destination value if the comparison results in equality.","pos":[0,84]}]}],"pos":[21691,21776],"yaml":true},{"content":"The value that is compared to the value at <code>location1</code>.","nodes":[{"pos":[0,66],"content":"The value that is compared to the value at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The value that is compared to the value at <code>location1</code>."}],"pos":[21840,21907],"yaml":true},{"content":"The original value in <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value in <code>location1</code>."}],"pos":[21963,22009],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[22185,22242],"yaml":true},{"content":"Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.","nodes":[{"pos":[0,111],"content":"Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.","nodes":[{"content":"Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.","pos":[0,111]}]}],"pos":[23896,24008],"yaml":true},{"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of this method is the original value in `location1`, whether or not the exchange takes place.  \n  \n> [!NOTE]\n>  <xref:System.IntPtr> is a platform-specific type.","nodes":[{"pos":[0,316],"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of this method is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"content":"If <ph id=\"ph1\">`comparand`</ph> and the value in <ph id=\"ph2\">`location1`</ph> are equal, then <ph id=\"ph3\">`value`</ph> is stored in <ph id=\"ph4\">`location1`</ph>.","pos":[0,93],"source":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`."},{"content":"Otherwise, no operation is performed.","pos":[94,131]},{"content":"The compare and exchange operations are performed as an atomic operation.","pos":[132,205]},{"content":"The return value of this method is the original value in <ph id=\"ph1\">`location1`</ph>, whether or not the exchange takes place.","pos":[206,316],"source":" The return value of this method is the original value in `location1`, whether or not the exchange takes place."}]},{"pos":[324,384],"content":"[!NOTE]\n <xref:System.IntPtr> is a platform-specific type.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.","pos":[9,58],"source":" <xref:System.IntPtr> is a platform-specific type."}]}],"pos":[24019,24409],"yaml":true,"extradata":"MT"},{"content":"The destination <xref href=\"System.IntPtr\"></xref>, whose value is compared with the value of <code>comparand</code> and possibly replaced by <code>value</code>.","nodes":[{"pos":[0,161],"content":"The destination <ph id=\"ph1\">&lt;xref href=\"System.IntPtr\"&gt;&lt;/xref&gt;</ph>, whose value is compared with the value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">comparand</ph><ept id=\"p1\">&lt;/code&gt;</ept> and possibly replaced by <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">value</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","source":"The destination <xref href=\"System.IntPtr\"></xref>, whose value is compared with the value of <code>comparand</code> and possibly replaced by <code>value</code>."}],"pos":[24606,24768],"yaml":true},{"content":"The <xref href=\"System.IntPtr\"></xref> that replaces the destination value if the comparison results in equality.","nodes":[{"pos":[0,113],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IntPtr\"&gt;&lt;/xref&gt;</ph> that replaces the destination value if the comparison results in equality.","source":"The <xref href=\"System.IntPtr\"></xref> that replaces the destination value if the comparison results in equality."}],"pos":[24829,24943],"yaml":true},{"content":"The <xref href=\"System.IntPtr\"></xref> that is compared to the value at <code>location1</code>.","nodes":[{"pos":[0,95],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IntPtr\"&gt;&lt;/xref&gt;</ph> that is compared to the value at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The <xref href=\"System.IntPtr\"></xref> that is compared to the value at <code>location1</code>."}],"pos":[25008,25104],"yaml":true},{"content":"The original value in <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value in <code>location1</code>."}],"pos":[25161,25207],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[25383,25440],"yaml":true},{"content":"Compares two objects for reference equality and, if they are equal, replaces the first object.","nodes":[{"pos":[0,94],"content":"Compares two objects for reference equality and, if they are equal, replaces the first object.","nodes":[{"content":"Compares two objects for reference equality and, if they are equal, replaces the first object.","pos":[0,94]}]}],"pos":[27111,27206],"yaml":true},{"content":"If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.  \n  \n Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.  \n  \n> [!NOTE]\n>  The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=fullName>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.","nodes":[{"pos":[0,360],"content":"If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"content":"If <ph id=\"ph1\">`comparand`</ph> and the object in <ph id=\"ph2\">`location1`</ph> are equal, then <ph id=\"ph3\">`value`</ph> is stored in <ph id=\"ph4\">`location1`</ph>.","pos":[0,94],"source":"If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`."},{"content":"Otherwise, no operation is performed.","pos":[95,132]},{"content":"The compare and exchange operations are performed as an atomic operation.","pos":[133,206]},{"content":"The return value of <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id=\"ph2\">`location1`</ph>, whether or not the exchange takes place.","pos":[207,360],"source":" The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place."}]},{"pos":[367,578],"content":"Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.","nodes":[{"content":"Beginning with .NET Framework version 2.0, the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.","pos":[0,211],"source":"Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types."}]},{"pos":[586,902],"content":"[!NOTE]\n The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=fullName>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.","leadings":["","> "],"nodes":[{"content":" The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=fullName>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.","pos":[8,314],"nodes":[{"content":"The objects are compared for reference equality, rather than <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.","pos":[1,118],"source":" The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=fullName>."},{"content":"As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.","pos":[119,263]},{"content":"Do not use this overload with value types.","pos":[264,306]}]}]}],"pos":[27217,28127],"yaml":true,"extradata":"MT"},{"content":"The destination object that is compared with <code>comparand</code> and possibly replaced.","nodes":[{"pos":[0,90],"content":"The destination object that is compared with <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">comparand</ph><ept id=\"p1\">&lt;/code&gt;</ept> and possibly replaced.","source":"The destination object that is compared with <code>comparand</code> and possibly replaced."}],"pos":[28324,28415],"yaml":true},{"content":"The object that replaces the destination object if the comparison results in equality.","nodes":[{"pos":[0,86],"content":"The object that replaces the destination object if the comparison results in equality.","nodes":[{"content":"The object that replaces the destination object if the comparison results in equality.","pos":[0,86]}]}],"pos":[28476,28563],"yaml":true},{"content":"The object that is compared to the object at <code>location1</code>.","nodes":[{"pos":[0,68],"content":"The object that is compared to the object at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The object that is compared to the object at <code>location1</code>."}],"pos":[28628,28697],"yaml":true},{"content":"The original value in <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value in <code>location1</code>."}],"pos":[28754,28800],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[28974,29031],"yaml":true},{"content":"Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.","nodes":[{"pos":[0,115],"content":"Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.","nodes":[{"content":"Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.","pos":[0,115]}]}],"pos":[30702,30818],"yaml":true},{"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"pos":[0,359],"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"content":"If <ph id=\"ph1\">`comparand`</ph> and the value in <ph id=\"ph2\">`location1`</ph> are equal, then <ph id=\"ph3\">`value`</ph> is stored in <ph id=\"ph4\">`location1`</ph>.","pos":[0,93],"source":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`."},{"content":"Otherwise, no operation is performed.","pos":[94,131]},{"content":"The compare and exchange operations are performed as an atomic operation.","pos":[132,205]},{"content":"The return value of <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id=\"ph2\">`location1`</ph>, whether or not the exchange takes place.","pos":[206,359],"source":" The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place."}]}],"pos":[30829,31189],"yaml":true,"extradata":"MT"},{"content":"The destination, whose value is compared with <code>comparand</code> and possibly replaced.","nodes":[{"pos":[0,91],"content":"The destination, whose value is compared with <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">comparand</ph><ept id=\"p1\">&lt;/code&gt;</ept> and possibly replaced.","source":"The destination, whose value is compared with <code>comparand</code> and possibly replaced."}],"pos":[32581,32673],"yaml":true},{"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"pos":[0,84],"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"content":"The value that replaces the destination value if the comparison results in equality.","pos":[0,84]}]}],"pos":[32734,32819],"yaml":true},{"content":"The value that is compared to the value at <code>location1</code>.","nodes":[{"pos":[0,66],"content":"The value that is compared to the value at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The value that is compared to the value at <code>location1</code>."}],"pos":[32884,32951],"yaml":true},{"content":"The original value in <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value in <code>location1</code>."}],"pos":[33008,33054],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[33230,33287],"yaml":true},{"content":"Compares two instances of the specified reference type <code>T</code> for equality and, if they are equal, replaces the first one.","nodes":[{"pos":[0,130],"content":"Compares two instances of the specified reference type <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">T</ph><ept id=\"p1\">&lt;/code&gt;</ept> for equality and, if they are equal, replaces the first one.","source":"Compares two instances of the specified reference type <code>T</code> for equality and, if they are equal, replaces the first one."}],"pos":[34824,34955],"yaml":true},{"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The comparison and the exchange are performed as an atomic operation. The return value of this method is the original value in `location1`, whether or not the exchange takes place.  \n  \n This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.  \n  \n> [!NOTE]\n>  This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.","nodes":[{"pos":[0,312],"content":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The comparison and the exchange are performed as an atomic operation. The return value of this method is the original value in `location1`, whether or not the exchange takes place.","nodes":[{"content":"If <ph id=\"ph1\">`comparand`</ph> and the value in <ph id=\"ph2\">`location1`</ph> are equal, then <ph id=\"ph3\">`value`</ph> is stored in <ph id=\"ph4\">`location1`</ph>.","pos":[0,93],"source":"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`."},{"content":"Otherwise, no operation is performed.","pos":[94,131]},{"content":"The comparison and the exchange are performed as an atomic operation.","pos":[132,201]},{"content":"The return value of this method is the original value in <ph id=\"ph1\">`location1`</ph>, whether or not the exchange takes place.","pos":[202,312],"source":" The return value of this method is the original value in `location1`, whether or not the exchange takes place."}]},{"pos":[319,629],"content":"This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.","nodes":[{"content":"This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.","pos":[0,310],"nodes":[{"content":"This method only supports reference types.","pos":[0,42]},{"content":"There are overloads of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method for the value types <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Int64&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.IntPtr&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Single&gt;</ph>, and <ph id=\"ph6\">&lt;xref:System.Double&gt;</ph>, but there is no support for other value types.","pos":[43,310],"source":" There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types."}]}]},{"pos":[637,890],"content":"[!NOTE]\n This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.","leadings":["","> "],"nodes":[{"content":"This method overload is preferable to the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29&gt;</ph> method overload, because the latter requires the destination object to be accessed late-bound.","pos":[9,251],"source":" This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound."}]}],"pos":[34966,35864],"yaml":true,"extradata":"MT"},{"content":"The destination, whose value is compared with <code>comparand</code> and possibly replaced. This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic).","nodes":[{"pos":[0,161],"content":"The destination, whose value is compared with <code>comparand</code> and possibly replaced. This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic).","nodes":[{"content":"The destination, whose value is compared with <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">comparand</ph><ept id=\"p1\">&lt;/code&gt;</ept> and possibly replaced.","pos":[0,91],"source":"The destination, whose value is compared with <code>comparand</code> and possibly replaced."},{"content":"This is a reference parameter (<ph id=\"ph1\">`ref`</ph> in C#, <ph id=\"ph2\">`ByRef`</ph> in Visual Basic).","pos":[92,161],"source":" This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic)."}]}],"pos":[36115,36277],"yaml":true},{"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"pos":[0,84],"content":"The value that replaces the destination value if the comparison results in equality.","nodes":[{"content":"The value that replaces the destination value if the comparison results in equality.","pos":[0,84]}]}],"pos":[36326,36411],"yaml":true},{"content":"The value that is compared to the value at <code>location1</code>.","nodes":[{"pos":[0,66],"content":"The value that is compared to the value at <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The value that is compared to the value at <code>location1</code>."}],"pos":[36464,36531],"yaml":true},{"content":"The type to be used for <code>location1</code>, <code>value</code>, and <code>comparand</code>. This type must be a reference type.","nodes":[{"pos":[0,131],"content":"The type to be used for <code>location1</code>, <code>value</code>, and <code>comparand</code>. This type must be a reference type.","nodes":[{"content":"The type to be used for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">value</ph><ept id=\"p2\">&lt;/code&gt;</ept>, and <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph3\">comparand</ph><ept id=\"p3\">&lt;/code&gt;</ept>.","pos":[0,95],"source":"The type to be used for <code>location1</code>, <code>value</code>, and <code>comparand</code>."},{"content":"This type must be a reference type.","pos":[96,131]}]}],"pos":[36582,36714],"yaml":true},{"content":"The original value in <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value in <code>location1</code>."}],"pos":[36759,36805],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[36984,37041],"yaml":true},{"content":"Decrements a specified variable and stores the result, as an atomic operation.","nodes":[{"pos":[0,78],"content":"Decrements a specified variable and stores the result, as an atomic operation.","nodes":[{"content":"Decrements a specified variable and stores the result, as an atomic operation.","pos":[0,78]}]}],"pos":[38596,38675],"yaml":true},{"content":"This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32?displayProperty=fullName>, `location` - 1 = <xref:System.Int32?displayProperty=fullName>. No exception is thrown.","nodes":[{"pos":[0,203],"content":"This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32?displayProperty=fullName>, `location` - 1 = <xref:System.Int32?displayProperty=fullName>. No exception is thrown.","nodes":[{"content":"This method handles an overflow condition by wrapping: If <ph id=\"ph1\">`location`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>, <ph id=\"ph4\">`location`</ph> - 1 = <ph id=\"ph5\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>.","pos":[0,179],"source":"This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32?displayProperty=fullName>, `location` - 1 = <xref:System.Int32?displayProperty=fullName>."},{"content":"No exception is thrown.","pos":[180,203]}]}],"pos":[38686,38892],"yaml":true,"extradata":"MT"},{"content":"The variable whose value is to be decremented.","nodes":[{"pos":[0,46],"content":"The variable whose value is to be decremented.","nodes":[{"content":"The variable whose value is to be decremented.","pos":[0,46]}]}],"pos":[40927,40974],"yaml":true},{"content":"The decremented value.","nodes":[{"pos":[0,22],"content":"The decremented value.","nodes":[{"content":"The decremented value.","pos":[0,22]}]}],"pos":[41030,41053],"yaml":true},{"content":"The address of <code>location</code> is a null pointer.","nodes":[{"pos":[0,55],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location</code> is a null pointer."}],"pos":[41221,41277],"yaml":true},{"content":"Decrements the specified variable and stores the result, as an atomic operation.","nodes":[{"pos":[0,80],"content":"Decrements the specified variable and stores the result, as an atomic operation.","nodes":[{"content":"Decrements the specified variable and stores the result, as an atomic operation.","pos":[0,80]}]}],"pos":[42774,42855],"yaml":true},{"content":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` - 1 = <xref:System.Int64?displayProperty=fullName>. No exception is thrown.  \n  \n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","nodes":[{"pos":[0,203],"content":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` - 1 = <xref:System.Int64?displayProperty=fullName>. No exception is thrown.","nodes":[{"content":"This method handles an overflow condition by wrapping: if <ph id=\"ph1\">`location`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">&lt;xref:System.Int64?displayProperty=fullName&gt;</ph>, <ph id=\"ph4\">`location`</ph> - 1 = <ph id=\"ph5\">&lt;xref:System.Int64?displayProperty=fullName&gt;</ph>.","pos":[0,179],"source":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` - 1 = <xref:System.Int64?displayProperty=fullName>."},{"content":"No exception is thrown.","pos":[180,203]}]},{"pos":[210,840],"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","nodes":[{"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","pos":[0,630],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id=\"ph2\">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id=\"ph5\">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> is 64 bits long.","pos":[0,345],"source":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long."},{"content":"On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.","pos":[346,475]},{"content":"Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class.","pos":[476,630],"source":" Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class."}]}]}],"pos":[42866,43711],"yaml":true,"extradata":"MT"},{"content":"The variable whose value is to be decremented.","nodes":[{"pos":[0,46],"content":"The variable whose value is to be decremented.","nodes":[{"content":"The variable whose value is to be decremented.","pos":[0,46]}]}],"pos":[43863,43910],"yaml":true},{"content":"The decremented value.","nodes":[{"pos":[0,22],"content":"The decremented value.","nodes":[{"content":"The decremented value.","pos":[0,22]}]}],"pos":[43966,43989],"yaml":true},{"content":"The address of <code>location</code> is a null pointer.","nodes":[{"pos":[0,55],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location</code> is a null pointer."}],"pos":[44157,44213],"yaml":true},{"content":"Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.","nodes":[{"pos":[0,122],"content":"Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.","nodes":[{"content":"Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.","pos":[0,122]}]}],"pos":[45759,45882],"yaml":true},{"content":"The variable to set to the specified value.","nodes":[{"pos":[0,43],"content":"The variable to set to the specified value.","nodes":[{"content":"The variable to set to the specified value.","pos":[0,43]}]}],"pos":[46051,46095],"yaml":true},{"content":"The value to which the <code>location1</code> parameter is set.","nodes":[{"pos":[0,63],"content":"The value to which the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set.","source":"The value to which the <code>location1</code> parameter is set."}],"pos":[46156,46220],"yaml":true},{"content":"The original value of <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value of <code>location1</code>."}],"pos":[46277,46323],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[46492,46549],"yaml":true},{"content":"Sets an object to a specified value and returns a reference to the original object, as an atomic operation.","nodes":[{"pos":[0,107],"content":"Sets an object to a specified value and returns a reference to the original object, as an atomic operation.","nodes":[{"content":"Sets an object to a specified value and returns a reference to the original object, as an atomic operation.","pos":[0,107]}]}],"pos":[48095,48203],"yaml":true},{"content":"Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.","nodes":[{"pos":[0,194],"content":"Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.","nodes":[{"content":"Beginning with .NET Framework version 2.0, the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.","pos":[0,194],"source":"Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types."}]}],"pos":[48214,48409],"yaml":true,"extradata":"MT"},{"content":"The variable to set to the specified value.","nodes":[{"pos":[0,43],"content":"The variable to set to the specified value.","nodes":[{"content":"The variable to set to the specified value.","pos":[0,43]}]}],"pos":[49181,49225],"yaml":true},{"content":"The value to which the <code>location1</code> parameter is set.","nodes":[{"pos":[0,63],"content":"The value to which the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set.","source":"The value to which the <code>location1</code> parameter is set."}],"pos":[49286,49350],"yaml":true},{"content":"The original value of <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value of <code>location1</code>."}],"pos":[49407,49453],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[49620,49677],"yaml":true},{"content":"Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.","nodes":[{"pos":[0,119],"content":"Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.","nodes":[{"content":"Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.","pos":[0,119]}]}],"pos":[51240,51360],"yaml":true},{"content":"The variable to set to the specified value.","nodes":[{"pos":[0,43],"content":"The variable to set to the specified value.","nodes":[{"content":"The variable to set to the specified value.","pos":[0,43]}]}],"pos":[51532,51576],"yaml":true},{"content":"The value to which the <code>location1</code> parameter is set.","nodes":[{"pos":[0,63],"content":"The value to which the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set.","source":"The value to which the <code>location1</code> parameter is set."}],"pos":[51637,51701],"yaml":true},{"content":"The original value of <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value of <code>location1</code>."}],"pos":[51758,51804],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[51973,52030],"yaml":true},{"content":"Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.","nodes":[{"pos":[0,122],"content":"Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.","nodes":[{"content":"Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.","pos":[0,122]}]}],"pos":[53593,53716],"yaml":true},{"content":"The variable to set to the specified value.","nodes":[{"pos":[0,43],"content":"The variable to set to the specified value.","nodes":[{"content":"The variable to set to the specified value.","pos":[0,43]}]}],"pos":[53888,53932],"yaml":true},{"content":"The value to which the <code>location1</code> parameter is set.","nodes":[{"pos":[0,63],"content":"The value to which the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set.","source":"The value to which the <code>location1</code> parameter is set."}],"pos":[53993,54057],"yaml":true},{"content":"The original value of <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value of <code>location1</code>."}],"pos":[54114,54160],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[54329,54386],"yaml":true},{"content":"Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.","nodes":[{"pos":[0,105],"content":"Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.","nodes":[{"content":"Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.","pos":[0,105]}]}],"pos":[55920,56026],"yaml":true},{"content":"The variable to set to the specified value.","nodes":[{"pos":[0,43],"content":"The variable to set to the specified value.","nodes":[{"content":"The variable to set to the specified value.","pos":[0,43]}]}],"pos":[56864,56908],"yaml":true},{"content":"The value to which the <code>location1</code> parameter is set.","nodes":[{"pos":[0,63],"content":"The value to which the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set.","source":"The value to which the <code>location1</code> parameter is set."}],"pos":[56968,57032],"yaml":true},{"content":"The original value of <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value of <code>location1</code>."}],"pos":[57088,57134],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[57301,57358],"yaml":true},{"content":"Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.","nodes":[{"pos":[0,105],"content":"Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.","nodes":[{"content":"Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.","pos":[0,105]}]}],"pos":[58909,59015],"yaml":true},{"content":"The variable to set to the specified value.","nodes":[{"pos":[0,43],"content":"The variable to set to the specified value.","nodes":[{"content":"The variable to set to the specified value.","pos":[0,43]}]}],"pos":[59180,59224],"yaml":true},{"content":"The value to which the <code>location1</code> parameter is set.","nodes":[{"pos":[0,63],"content":"The value to which the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set.","source":"The value to which the <code>location1</code> parameter is set."}],"pos":[59284,59348],"yaml":true},{"content":"The original value of <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value of <code>location1</code>."}],"pos":[59404,59450],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[59619,59676],"yaml":true},{"content":"Sets a variable of the specified type <code>T</code> to a specified value and returns the original value, as an atomic operation.","nodes":[{"pos":[0,129],"content":"Sets a variable of the specified type <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">T</ph><ept id=\"p1\">&lt;/code&gt;</ept> to a specified value and returns the original value, as an atomic operation.","source":"Sets a variable of the specified type <code>T</code> to a specified value and returns the original value, as an atomic operation."}],"pos":[61150,61280],"yaml":true},{"content":"This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.  \n  \n> [!NOTE]\n>  This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .","nodes":[{"pos":[0,303],"content":"This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.","nodes":[{"content":"This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.","pos":[0,303],"nodes":[{"content":"This method only supports reference types.","pos":[0,42]},{"content":"There are overloads of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method for the <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Int64&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.IntPtr&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Single&gt;</ph>, and <ph id=\"ph6\">&lt;xref:System.Double&gt;</ph> value types, but there is no support for other value types.","pos":[43,303],"source":" There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types."}]}]},{"pos":[311,537],"content":"[!NOTE]\n This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .","leadings":["","> "],"nodes":[{"content":"This method overload is preferable to the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29&gt;</ph> method overload, because the latter requires late-bound access to the destination object .","pos":[9,224],"source":" This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object ."}]}],"pos":[61291,61834],"yaml":true,"extradata":"MT"},{"content":"The variable to set to the specified value. This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic).","nodes":[{"pos":[0,113],"content":"The variable to set to the specified value. This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic).","nodes":[{"content":"The variable to set to the specified value.","pos":[0,43]},{"content":"This is a reference parameter (<ph id=\"ph1\">`ref`</ph> in C#, <ph id=\"ph2\">`ByRef`</ph> in Visual Basic).","pos":[44,113],"source":" This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic)."}]}],"pos":[62943,63057],"yaml":true},{"content":"The value to which the <code>location1</code> parameter is set.","nodes":[{"pos":[0,63],"content":"The value to which the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set.","source":"The value to which the <code>location1</code> parameter is set."}],"pos":[63106,63170],"yaml":true},{"content":"The type to be used for <code>location1</code> and <code>value</code>. This type must be a reference type.","nodes":[{"pos":[0,106],"content":"The type to be used for <code>location1</code> and <code>value</code>. This type must be a reference type.","nodes":[{"content":"The type to be used for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">value</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","pos":[0,70],"source":"The type to be used for <code>location1</code> and <code>value</code>."},{"content":"This type must be a reference type.","pos":[71,106]}]}],"pos":[63221,63328],"yaml":true},{"content":"The original value of <code>location1</code>.","nodes":[{"pos":[0,45],"content":"The original value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The original value of <code>location1</code>."}],"pos":[63373,63419],"yaml":true},{"content":"The address of <code>location1</code> is a null pointer.","nodes":[{"pos":[0,56],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location1</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location1</code> is a null pointer."}],"pos":[63591,63648],"yaml":true},{"content":"Increments a specified variable and stores the result, as an atomic operation.","nodes":[{"pos":[0,78],"content":"Increments a specified variable and stores the result, as an atomic operation.","nodes":[{"content":"Increments a specified variable and stores the result, as an atomic operation.","pos":[0,78]}]}],"pos":[65203,65282],"yaml":true},{"content":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32?displayProperty=fullName>, `location` + 1 = <xref:System.Int32?displayProperty=fullName>. No exception is thrown.","nodes":[{"pos":[0,203],"content":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32?displayProperty=fullName>, `location` + 1 = <xref:System.Int32?displayProperty=fullName>. No exception is thrown.","nodes":[{"content":"This method handles an overflow condition by wrapping: if <ph id=\"ph1\">`location`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>, <ph id=\"ph4\">`location`</ph> + 1 = <ph id=\"ph5\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph>.","pos":[0,179],"source":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32?displayProperty=fullName>, `location` + 1 = <xref:System.Int32?displayProperty=fullName>."},{"content":"No exception is thrown.","pos":[180,203]}]}],"pos":[65293,65499],"yaml":true,"extradata":"MT"},{"content":"The variable whose value is to be incremented.","nodes":[{"pos":[0,46],"content":"The variable whose value is to be incremented.","nodes":[{"content":"The variable whose value is to be incremented.","pos":[0,46]}]}],"pos":[67562,67609],"yaml":true},{"content":"The incremented value.","nodes":[{"pos":[0,22],"content":"The incremented value.","nodes":[{"content":"The incremented value.","pos":[0,22]}]}],"pos":[67665,67688],"yaml":true},{"content":"The address of <code>location</code> is a null pointer.","nodes":[{"pos":[0,55],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location</code> is a null pointer."}],"pos":[67858,67914],"yaml":true},{"content":"Increments a specified variable and stores the result, as an atomic operation.","nodes":[{"pos":[0,78],"content":"Increments a specified variable and stores the result, as an atomic operation.","nodes":[{"content":"Increments a specified variable and stores the result, as an atomic operation.","pos":[0,78]}]}],"pos":[69411,69490],"yaml":true},{"content":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` + 1 = <xref:System.Int64?displayProperty=fullName>. No exception is thrown.  \n  \n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","nodes":[{"pos":[0,203],"content":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` + 1 = <xref:System.Int64?displayProperty=fullName>. No exception is thrown.","nodes":[{"content":"This method handles an overflow condition by wrapping: if <ph id=\"ph1\">`location`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">&lt;xref:System.Int64?displayProperty=fullName&gt;</ph>, <ph id=\"ph4\">`location`</ph> + 1 = <ph id=\"ph5\">&lt;xref:System.Int64?displayProperty=fullName&gt;</ph>.","pos":[0,179],"source":"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` + 1 = <xref:System.Int64?displayProperty=fullName>."},{"content":"No exception is thrown.","pos":[180,203]}]},{"pos":[210,840],"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","nodes":[{"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","pos":[0,630],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id=\"ph2\">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id=\"ph5\">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> is 64 bits long.","pos":[0,345],"source":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long."},{"content":"On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.","pos":[346,475]},{"content":"Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class.","pos":[476,630],"source":" Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class."}]}]}],"pos":[69501,70346],"yaml":true,"extradata":"MT"},{"content":"The variable whose value is to be incremented.","nodes":[{"pos":[0,46],"content":"The variable whose value is to be incremented.","nodes":[{"content":"The variable whose value is to be incremented.","pos":[0,46]}]}],"pos":[70498,70545],"yaml":true},{"content":"The incremented value.","nodes":[{"pos":[0,22],"content":"The incremented value.","nodes":[{"content":"The incremented value.","pos":[0,22]}]}],"pos":[70601,70624],"yaml":true},{"content":"The address of <code>location</code> is a null pointer.","nodes":[{"pos":[0,55],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">location</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","source":"The address of <code>location</code> is a null pointer."}],"pos":[70794,70850],"yaml":true},{"content":"Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\"></xref> execute after memory accesses that follow the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\"></xref>.","nodes":[{"pos":[0,350],"content":"Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <ph id=\"ph1\">&lt;xref href=\"System.Threading.Interlocked.MemoryBarrier\"&gt;&lt;/xref&gt;</ph> execute after memory accesses that follow the call to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Interlocked.MemoryBarrier\"&gt;&lt;/xref&gt;</ph>.","source":"Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\"></xref> execute after memory accesses that follow the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\"></xref>."}],"pos":[72311,72664],"yaml":true},{"content":"This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=fullName> method.  \n  \n <xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).  \n  \n For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.","nodes":[{"pos":[0,245],"content":"This method was added to the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class in the <ph id=\"ph2\">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> as a convenience; it's a wrapper for the <ph id=\"ph3\">&lt;xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=fullName&gt;</ph> method.","source":"This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=fullName> method."},{"pos":[252,450],"content":"<xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).","pos":[0,198],"source":"<xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors)."}]},{"pos":[457,625],"content":"For most purposes, the C# <ph id=\"ph1\">`lock`</ph> statement, the Visual Basic <ph id=\"ph2\">`SyncLock`</ph> statement, or the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.","source":"For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data."}],"pos":[72675,73307],"yaml":true,"extradata":"MT"},{"content":"Returns a 64-bit value, loaded as an atomic operation.","nodes":[{"pos":[0,54],"content":"Returns a 64-bit value, loaded as an atomic operation.","nodes":[{"content":"Returns a 64-bit value, loaded as an atomic operation.","pos":[0,54]}]}],"pos":[75678,75733],"yaml":true},{"content":"The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.  \n  \n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.  \n  \n> [!NOTE]\n>  <xref:System.IntPtr> is a platform-specific type.","nodes":[{"pos":[0,264],"content":"The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.","nodes":[{"content":"The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.","pos":[0,264],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.","pos":[0,139],"source":"The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic."},{"content":"On 32-bit systems, 64-bit read operations are not atomic unless performed using <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph>.","pos":[140,264],"source":" On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>."}]}]},{"pos":[271,901],"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","nodes":[{"content":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.","pos":[0,630],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id=\"ph2\">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id=\"ph5\">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> is 64 bits long.","pos":[0,345],"source":"The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long."},{"content":"On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.","pos":[346,475]},{"content":"Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class.","pos":[476,630],"source":" Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class."}]}]},{"pos":[909,969],"content":"[!NOTE]\n <xref:System.IntPtr> is a platform-specific type.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.","pos":[9,58],"source":" <xref:System.IntPtr> is a platform-specific type."}]}],"pos":[75744,76721],"yaml":true,"extradata":"MT"},{"content":"The 64-bit value to be loaded.","nodes":[{"pos":[0,30],"content":"The 64-bit value to be loaded.","nodes":[{"content":"The 64-bit value to be loaded.","pos":[0,30]}]}],"pos":[76868,76899],"yaml":true},{"content":"The loaded value.","nodes":[{"pos":[0,17],"content":"The loaded value.","nodes":[{"content":"The loaded value.","pos":[0,17]}]}],"pos":[76955,76973],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.Interlocked\n  commentId: T:System.Threading.Interlocked\n  id: Interlocked\n  children:\n  - System.Threading.Interlocked.Add(System.Int32@,System.Int32)\n  - System.Threading.Interlocked.Add(System.Int64@,System.Int64)\n  - System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)\n  - System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)\n  - System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)\n  - System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)\n  - System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)\n  - System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)\n  - System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)\n  - System.Threading.Interlocked.Decrement(System.Int32@)\n  - System.Threading.Interlocked.Decrement(System.Int64@)\n  - System.Threading.Interlocked.Exchange(System.Single@,System.Single)\n  - System.Threading.Interlocked.Exchange(System.Object@,System.Object)\n  - System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)\n  - System.Threading.Interlocked.Exchange(System.Double@,System.Double)\n  - System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)\n  - System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)\n  - System.Threading.Interlocked.Exchange``1(``0@,``0)\n  - System.Threading.Interlocked.Increment(System.Int32@)\n  - System.Threading.Interlocked.Increment(System.Int64@)\n  - System.Threading.Interlocked.MemoryBarrier\n  - System.Threading.Interlocked.MemoryBarrierProcessWide\n  - System.Threading.Interlocked.Read(System.Int64@)\n  langs:\n  - csharp\n  name: Interlocked\n  nameWithType: Interlocked\n  fullName: System.Threading.Interlocked\n  type: Class\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Provides atomic operations for variables that are shared by multiple threads.\n  remarks: \"The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors. The members of this class do not throw exceptions.  \\n  \\n The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation. On most computers, incrementing a variable is not an atomic operation, requiring the following steps:  \\n  \\n1.  Load a value from an instance variable into a register.  \\n  \\n2.  Increment or decrement the value.  \\n  \\n3.  Store the value in the instance variable.  \\n  \\n If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps. Another thread can then execute all three steps. When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.  \\n  \\n The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables. The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison. The compare and exchange operations are performed as an atomic operation.\"\n  example:\n  - \"The following code example shows a thread-safe resource locking mechanism.  \\n  \\n [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]\\n [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static class Interlocked\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Add(System.Int32@,System.Int32)\n  commentId: M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)\n  id: Add(System.Int32@,System.Int32)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Add(Int32, Int32)\n  nameWithType: Interlocked.Add(Int32, Int32)\n  fullName: Interlocked.Add(Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.\n  remarks: 'This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int32?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int32?displayProperty=fullName> + 1); and so on. No exception is thrown.'\n  syntax:\n    content: public static int Add (ref int location1, int value);\n    parameters:\n    - id: location1\n      type: System.Int32\n      description: A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.\n    - id: value\n      type: System.Int32\n      description: The value to be added to the integer at <code>location1</code>.\n    return:\n      type: System.Int32\n      description: The new value stored at <code>location1</code>.\n  overload: System.Threading.Interlocked.Add*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Add(System.Int64@,System.Int64)\n  commentId: M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)\n  id: Add(System.Int64@,System.Int64)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Add(Int64, Int64)\n  nameWithType: Interlocked.Add(Int64, Int64)\n  fullName: Interlocked.Add(Int64, Int64)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.\n  remarks: \"This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64?displayProperty=fullName> and `value` is 1, the result is <xref:System.Int64?displayProperty=fullName>; if `value` is 2, the result is (<xref:System.Int64?displayProperty=fullName> + 1); and so on. No exception is thrown.  \\n  \\n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.\"\n  syntax:\n    content: public static long Add (ref long location1, long value);\n    parameters:\n    - id: location1\n      type: System.Int64\n      description: A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.\n    - id: value\n      type: System.Int64\n      description: The value to be added to the integer at <code>location1</code>.\n    return:\n      type: System.Int64\n      description: The new value stored at <code>location1</code>.\n  overload: System.Threading.Interlocked.Add*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)\n  commentId: M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)\n  id: CompareExchange(System.Double@,System.Double,System.Double)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: CompareExchange(Double, Double, Double)\n  nameWithType: Interlocked.CompareExchange(Double, Double, Double)\n  fullName: Interlocked.CompareExchange(Double, Double, Double)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.\n  remarks: If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.\n  example:\n  - \"The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values. Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals.  \\n  \\n In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.  \\n  \\n [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]\\n [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]\"\n  syntax:\n    content: public static double CompareExchange (ref double location1, double value, double comparand);\n    parameters:\n    - id: location1\n      type: System.Double\n      description: The destination, whose value is compared with <code>comparand</code> and possibly replaced.\n    - id: value\n      type: System.Double\n      description: The value that replaces the destination value if the comparison results in equality.\n    - id: comparand\n      type: System.Double\n      description: The value that is compared to the value at <code>location1</code>.\n    return:\n      type: System.Double\n      description: The original value in <code>location1</code>.\n  overload: System.Threading.Interlocked.CompareExchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)\n  commentId: M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)\n  id: CompareExchange(System.Int32@,System.Int32,System.Int32)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: CompareExchange(Int32, Int32, Int32)\n  nameWithType: Interlocked.CompareExchange(Int32, Int32, Int32)\n  fullName: Interlocked.CompareExchange(Int32, Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.\n  remarks: If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.\n  example:\n  - \"The following code example demonstrates a thread-safe method that accumulates a running total. The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.  \\n  \\n [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]\\n [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]\"\n  syntax:\n    content: public static int CompareExchange (ref int location1, int value, int comparand);\n    parameters:\n    - id: location1\n      type: System.Int32\n      description: The destination, whose value is compared with <code>comparand</code> and possibly replaced.\n    - id: value\n      type: System.Int32\n      description: The value that replaces the destination value if the comparison results in equality.\n    - id: comparand\n      type: System.Int32\n      description: The value that is compared to the value at <code>location1</code>.\n    return:\n      type: System.Int32\n      description: The original value in <code>location1</code>.\n  overload: System.Threading.Interlocked.CompareExchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)\n  commentId: M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)\n  id: CompareExchange(System.Int64@,System.Int64,System.Int64)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: CompareExchange(Int64, Int64, Int64)\n  nameWithType: Interlocked.CompareExchange(Int64, Int64, Int64)\n  fullName: Interlocked.CompareExchange(Int64, Int64, Int64)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.\n  remarks: If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.\n  syntax:\n    content: public static long CompareExchange (ref long location1, long value, long comparand);\n    parameters:\n    - id: location1\n      type: System.Int64\n      description: The destination, whose value is compared with <code>comparand</code> and possibly replaced.\n    - id: value\n      type: System.Int64\n      description: The value that replaces the destination value if the comparison results in equality.\n    - id: comparand\n      type: System.Int64\n      description: The value that is compared to the value at <code>location1</code>.\n    return:\n      type: System.Int64\n      description: The original value in <code>location1</code>.\n  overload: System.Threading.Interlocked.CompareExchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)\n  commentId: M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)\n  id: CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: CompareExchange(IntPtr, IntPtr, IntPtr)\n  nameWithType: Interlocked.CompareExchange(IntPtr, IntPtr, IntPtr)\n  fullName: Interlocked.CompareExchange(IntPtr, IntPtr, IntPtr)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.\n  remarks: \"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of this method is the original value in `location1`, whether or not the exchange takes place.  \\n  \\n> [!NOTE]\\n>  <xref:System.IntPtr> is a platform-specific type.\"\n  syntax:\n    content: public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);\n    parameters:\n    - id: location1\n      type: System.IntPtr\n      description: The destination <xref href=\"System.IntPtr\"></xref>, whose value is compared with the value of <code>comparand</code> and possibly replaced by <code>value</code>.\n    - id: value\n      type: System.IntPtr\n      description: The <xref href=\"System.IntPtr\"></xref> that replaces the destination value if the comparison results in equality.\n    - id: comparand\n      type: System.IntPtr\n      description: The <xref href=\"System.IntPtr\"></xref> that is compared to the value at <code>location1</code>.\n    return:\n      type: System.IntPtr\n      description: The original value in <code>location1</code>.\n  overload: System.Threading.Interlocked.CompareExchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)\n  commentId: M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)\n  id: CompareExchange(System.Object@,System.Object,System.Object)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: CompareExchange(Object, Object, Object)\n  nameWithType: Interlocked.CompareExchange(Object, Object, Object)\n  fullName: Interlocked.CompareExchange(Object, Object, Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Compares two objects for reference equality and, if they are equal, replaces the first object.\n  remarks: \"If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.  \\n  \\n Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.  \\n  \\n> [!NOTE]\\n>  The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=fullName>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.\"\n  syntax:\n    content: public static object CompareExchange (ref object location1, object value, object comparand);\n    parameters:\n    - id: location1\n      type: System.Object\n      description: The destination object that is compared with <code>comparand</code> and possibly replaced.\n    - id: value\n      type: System.Object\n      description: The object that replaces the destination object if the comparison results in equality.\n    - id: comparand\n      type: System.Object\n      description: The object that is compared to the object at <code>location1</code>.\n    return:\n      type: System.Object\n      description: The original value in <code>location1</code>.\n  overload: System.Threading.Interlocked.CompareExchange*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)\n  commentId: M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)\n  id: CompareExchange(System.Single@,System.Single,System.Single)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: CompareExchange(Single, Single, Single)\n  nameWithType: Interlocked.CompareExchange(Single, Single, Single)\n  fullName: Interlocked.CompareExchange(Single, Single, Single)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.\n  remarks: If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.\n  example:\n  - \"The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values. Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals.  \\n  \\n In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.  \\n  \\n [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]\\n [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]\"\n  syntax:\n    content: public static float CompareExchange (ref float location1, float value, float comparand);\n    parameters:\n    - id: location1\n      type: System.Single\n      description: The destination, whose value is compared with <code>comparand</code> and possibly replaced.\n    - id: value\n      type: System.Single\n      description: The value that replaces the destination value if the comparison results in equality.\n    - id: comparand\n      type: System.Single\n      description: The value that is compared to the value at <code>location1</code>.\n    return:\n      type: System.Single\n      description: The original value in <code>location1</code>.\n  overload: System.Threading.Interlocked.CompareExchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)\n  commentId: M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)\n  id: CompareExchange``1(``0@,``0,``0)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: CompareExchange<T>(T, T, T)\n  nameWithType: Interlocked.CompareExchange<T>(T, T, T)\n  fullName: Interlocked.CompareExchange<T>(T, T, T)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Compares two instances of the specified reference type <code>T</code> for equality and, if they are equal, replaces the first one.\n  remarks: \"If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`. Otherwise, no operation is performed. The comparison and the exchange are performed as an atomic operation. The return value of this method is the original value in `location1`, whether or not the exchange takes place.  \\n  \\n This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.  \\n  \\n> [!NOTE]\\n>  This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public static T CompareExchange<T> (ref T location1, T value, T comparand) where T : class;\n    parameters:\n    - id: location1\n      type: T\n      description: The destination, whose value is compared with <code>comparand</code> and possibly replaced. This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic).\n    - id: value\n      type: T\n      description: The value that replaces the destination value if the comparison results in equality.\n    - id: comparand\n      type: T\n      description: The value that is compared to the value at <code>location1</code>.\n    typeParameters:\n    - id: T\n      description: The type to be used for <code>location1</code>, <code>value</code>, and <code>comparand</code>. This type must be a reference type.\n    return:\n      type: T\n      description: The original value in <code>location1</code>.\n  overload: System.Threading.Interlocked.CompareExchange``1*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Decrement(System.Int32@)\n  commentId: M:System.Threading.Interlocked.Decrement(System.Int32@)\n  id: Decrement(System.Int32@)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Decrement(Int32)\n  nameWithType: Interlocked.Decrement(Int32)\n  fullName: Interlocked.Decrement(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Decrements a specified variable and stores the result, as an atomic operation.\n  remarks: 'This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32?displayProperty=fullName>, `location` - 1 = <xref:System.Int32?displayProperty=fullName>. No exception is thrown.'\n  example:\n  - \"The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value. Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently. Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.  \\n  \\n [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]\\n [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  \\n  \\n The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.  \\n  \\n [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]\\n [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]\"\n  syntax:\n    content: public static int Decrement (ref int location);\n    parameters:\n    - id: location\n      type: System.Int32\n      description: The variable whose value is to be decremented.\n    return:\n      type: System.Int32\n      description: The decremented value.\n  overload: System.Threading.Interlocked.Decrement*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The address of <code>location</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Decrement(System.Int64@)\n  commentId: M:System.Threading.Interlocked.Decrement(System.Int64@)\n  id: Decrement(System.Int64@)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Decrement(Int64)\n  nameWithType: Interlocked.Decrement(Int64)\n  fullName: Interlocked.Decrement(Int64)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Decrements the specified variable and stores the result, as an atomic operation.\n  remarks: \"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` - 1 = <xref:System.Int64?displayProperty=fullName>. No exception is thrown.  \\n  \\n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.\"\n  syntax:\n    content: public static long Decrement (ref long location);\n    parameters:\n    - id: location\n      type: System.Int64\n      description: The variable whose value is to be decremented.\n    return:\n      type: System.Int64\n      description: The decremented value.\n  overload: System.Threading.Interlocked.Decrement*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The address of <code>location</code> is a null pointer.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Exchange(System.Single@,System.Single)\n  commentId: M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)\n  id: Exchange(System.Single@,System.Single)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Exchange(Single, Single)\n  nameWithType: Interlocked.Exchange(Single, Single)\n  fullName: Interlocked.Exchange(Single, Single)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.\n  syntax:\n    content: public static float Exchange (ref float location1, float value);\n    parameters:\n    - id: location1\n      type: System.Single\n      description: The variable to set to the specified value.\n    - id: value\n      type: System.Single\n      description: The value to which the <code>location1</code> parameter is set.\n    return:\n      type: System.Single\n      description: The original value of <code>location1</code>.\n  overload: System.Threading.Interlocked.Exchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Exchange(System.Object@,System.Object)\n  commentId: M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)\n  id: Exchange(System.Object@,System.Object)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Exchange(Object, Object)\n  nameWithType: Interlocked.Exchange(Object, Object)\n  fullName: Interlocked.Exchange(Object, Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets an object to a specified value and returns a reference to the original object, as an atomic operation.\n  remarks: Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.\n  example:\n  - \"The following code example shows the syntax for using `Exchange` with any reference type object.  \\n  \\n [!code-cpp[System.Threading.Interlocked.Exchange#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Interlocked.Exchange#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/source.cs#1)]\\n [!code-vb[System.Threading.Interlocked.Exchange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/source.vb#1)]\"\n  syntax:\n    content: public static object Exchange (ref object location1, object value);\n    parameters:\n    - id: location1\n      type: System.Object\n      description: The variable to set to the specified value.\n    - id: value\n      type: System.Object\n      description: The value to which the <code>location1</code> parameter is set.\n    return:\n      type: System.Object\n      description: The original value of <code>location1</code>.\n  overload: System.Threading.Interlocked.Exchange*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)\n  commentId: M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)\n  id: Exchange(System.IntPtr@,System.IntPtr)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Exchange(IntPtr, IntPtr)\n  nameWithType: Interlocked.Exchange(IntPtr, IntPtr)\n  fullName: Interlocked.Exchange(IntPtr, IntPtr)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.\n  syntax:\n    content: public static IntPtr Exchange (ref IntPtr location1, IntPtr value);\n    parameters:\n    - id: location1\n      type: System.IntPtr\n      description: The variable to set to the specified value.\n    - id: value\n      type: System.IntPtr\n      description: The value to which the <code>location1</code> parameter is set.\n    return:\n      type: System.IntPtr\n      description: The original value of <code>location1</code>.\n  overload: System.Threading.Interlocked.Exchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Exchange(System.Double@,System.Double)\n  commentId: M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)\n  id: Exchange(System.Double@,System.Double)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Exchange(Double, Double)\n  nameWithType: Interlocked.Exchange(Double, Double)\n  fullName: Interlocked.Exchange(Double, Double)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.\n  syntax:\n    content: public static double Exchange (ref double location1, double value);\n    parameters:\n    - id: location1\n      type: System.Double\n      description: The variable to set to the specified value.\n    - id: value\n      type: System.Double\n      description: The value to which the <code>location1</code> parameter is set.\n    return:\n      type: System.Double\n      description: The original value of <code>location1</code>.\n  overload: System.Threading.Interlocked.Exchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)\n  commentId: M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)\n  id: Exchange(System.Int32@,System.Int32)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Exchange(Int32, Int32)\n  nameWithType: Interlocked.Exchange(Int32, Int32)\n  fullName: Interlocked.Exchange(Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.\n  remarks: ''\n  example:\n  - \"The following code example shows a thread-safe resource locking mechanism.  \\n  \\n [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]\\n [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static int Exchange (ref int location1, int value);\n    parameters:\n    - id: location1\n      type: System.Int32\n      description: The variable to set to the specified value.\n    - id: value\n      type: System.Int32\n      description: The value to which the <code>location1</code> parameter is set.\n    return:\n      type: System.Int32\n      description: The original value of <code>location1</code>.\n  overload: System.Threading.Interlocked.Exchange*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)\n  commentId: M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)\n  id: Exchange(System.Int64@,System.Int64)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Exchange(Int64, Int64)\n  nameWithType: Interlocked.Exchange(Int64, Int64)\n  fullName: Interlocked.Exchange(Int64, Int64)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.\n  syntax:\n    content: public static long Exchange (ref long location1, long value);\n    parameters:\n    - id: location1\n      type: System.Int64\n      description: The variable to set to the specified value.\n    - id: value\n      type: System.Int64\n      description: The value to which the <code>location1</code> parameter is set.\n    return:\n      type: System.Int64\n      description: The original value of <code>location1</code>.\n  overload: System.Threading.Interlocked.Exchange*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Exchange``1(``0@,``0)\n  commentId: M:System.Threading.Interlocked.Exchange``1(``0@,``0)\n  id: Exchange``1(``0@,``0)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Exchange<T>(T, T)\n  nameWithType: Interlocked.Exchange<T>(T, T)\n  fullName: Interlocked.Exchange<T>(T, T)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Sets a variable of the specified type <code>T</code> to a specified value and returns the original value, as an atomic operation.\n  remarks: \"This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.  \\n  \\n> [!NOTE]\\n>  This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .\"\n  example:\n  - \"The following example launches ten tasks, each of which generates  100 ten-character part numbers. It then the part number that is first alphabetically.  \\n  \\n [!code-csharp[System.Threading.Interlocked.Exchange#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/Exchange5.cs#2)]\\n [!code-vb[System.Threading.Interlocked.Exchange#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/Exchange5.vb#2)]  \\n  \\n The example uses the `firstWidget` variable to store the ID that occurs first in the sort order. It compares each ID that it generates with the `firstWidget` value.  If the new value precedes the current value of `firstWidget` in the sort order, the example calls the <xref:System.Threading.Interlocked.Exchange%2A> method to assign the new value to `firstWidget`.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public static T Exchange<T> (ref T location1, T value) where T : class;\n    parameters:\n    - id: location1\n      type: T\n      description: The variable to set to the specified value. This is a reference parameter (`ref` in C#, `ByRef` in Visual Basic).\n    - id: value\n      type: T\n      description: The value to which the <code>location1</code> parameter is set.\n    typeParameters:\n    - id: T\n      description: The type to be used for <code>location1</code> and <code>value</code>. This type must be a reference type.\n    return:\n      type: T\n      description: The original value of <code>location1</code>.\n  overload: System.Threading.Interlocked.Exchange``1*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location1</code> is a null pointer.\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Increment(System.Int32@)\n  commentId: M:System.Threading.Interlocked.Increment(System.Int32@)\n  id: Increment(System.Int32@)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Increment(Int32)\n  nameWithType: Interlocked.Increment(Int32)\n  fullName: Interlocked.Increment(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Increments a specified variable and stores the result, as an atomic operation.\n  remarks: 'This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32?displayProperty=fullName>, `location` + 1 = <xref:System.Int32?displayProperty=fullName>. No exception is thrown.'\n  example:\n  - \"The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000. Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently. Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.  \\n  \\n [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]\\n [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  \\n  \\n The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.  \\n  \\n [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]\\n [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]\"\n  syntax:\n    content: public static int Increment (ref int location);\n    parameters:\n    - id: location\n      type: System.Int32\n      description: The variable whose value is to be incremented.\n    return:\n      type: System.Int32\n      description: The incremented value.\n  overload: System.Threading.Interlocked.Increment*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.Increment(System.Int64@)\n  commentId: M:System.Threading.Interlocked.Increment(System.Int64@)\n  id: Increment(System.Int64@)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Increment(Int64)\n  nameWithType: Interlocked.Increment(Int64)\n  fullName: Interlocked.Increment(Int64)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Increments a specified variable and stores the result, as an atomic operation.\n  remarks: \"This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64?displayProperty=fullName>, `location` + 1 = <xref:System.Int64?displayProperty=fullName>. No exception is thrown.  \\n  \\n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.\"\n  syntax:\n    content: public static long Increment (ref long location);\n    parameters:\n    - id: location\n      type: System.Int64\n      description: The variable whose value is to be incremented.\n    return:\n      type: System.Int64\n      description: The incremented value.\n  overload: System.Threading.Interlocked.Increment*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>location</code> is a null pointer.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.MemoryBarrier\n  commentId: M:System.Threading.Interlocked.MemoryBarrier\n  id: MemoryBarrier\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: MemoryBarrier()\n  nameWithType: Interlocked.MemoryBarrier()\n  fullName: Interlocked.MemoryBarrier()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: 'Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\"></xref> execute after memory accesses that follow the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\"></xref>.'\n  remarks: \"This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=fullName> method.  \\n  \\n <xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).  \\n  \\n For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.\"\n  syntax:\n    content: public static void MemoryBarrier ();\n    parameters: []\n  overload: System.Threading.Interlocked.MemoryBarrier*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Interlocked.MemoryBarrierProcessWide\n  commentId: M:System.Threading.Interlocked.MemoryBarrierProcessWide\n  id: MemoryBarrierProcessWide\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: MemoryBarrierProcessWide()\n  nameWithType: Interlocked.MemoryBarrierProcessWide()\n  fullName: Interlocked.MemoryBarrierProcessWide()\n  type: Method\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  syntax:\n    content: public static void MemoryBarrierProcessWide ();\n    parameters: []\n  overload: System.Threading.Interlocked.MemoryBarrierProcessWide*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.Read(System.Int64@)\n  commentId: M:System.Threading.Interlocked.Read(System.Int64@)\n  id: Read(System.Int64@)\n  parent: System.Threading.Interlocked\n  langs:\n  - csharp\n  name: Read(Int64)\n  nameWithType: Interlocked.Read(Int64)\n  fullName: Interlocked.Read(Int64)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Returns a 64-bit value, loaded as an atomic operation.\n  remarks: \"The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.  \\n  \\n The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.  \\n  \\n> [!NOTE]\\n>  <xref:System.IntPtr> is a platform-specific type.\"\n  syntax:\n    content: public static long Read (ref long location);\n    parameters:\n    - id: location\n      type: System.Int64\n      description: The 64-bit value to be loaded.\n    return:\n      type: System.Int64\n      description: The loaded value.\n  overload: System.Threading.Interlocked.Read*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.NullReferenceException\n  parent: System\n  isExternal: false\n  name: NullReferenceException\n  nameWithType: NullReferenceException\n  fullName: System.NullReferenceException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.Threading.Interlocked.Add(System.Int32@,System.Int32)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Add(Int32, Int32)\n  nameWithType: Interlocked.Add(Int32, Int32)\n  fullName: Interlocked.Add(Int32, Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.Interlocked.Add(System.Int64@,System.Int64)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Add(Int64, Int64)\n  nameWithType: Interlocked.Add(Int64, Int64)\n  fullName: Interlocked.Add(Int64, Int64)\n- uid: System.Int64\n  parent: System\n  isExternal: false\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64\n- uid: System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange(Double, Double, Double)\n  nameWithType: Interlocked.CompareExchange(Double, Double, Double)\n  fullName: Interlocked.CompareExchange(Double, Double, Double)\n- uid: System.Double\n  parent: System\n  isExternal: false\n  name: Double\n  nameWithType: Double\n  fullName: System.Double\n- uid: System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange(Int32, Int32, Int32)\n  nameWithType: Interlocked.CompareExchange(Int32, Int32, Int32)\n  fullName: Interlocked.CompareExchange(Int32, Int32, Int32)\n- uid: System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange(Int64, Int64, Int64)\n  nameWithType: Interlocked.CompareExchange(Int64, Int64, Int64)\n  fullName: Interlocked.CompareExchange(Int64, Int64, Int64)\n- uid: System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange(IntPtr, IntPtr, IntPtr)\n  nameWithType: Interlocked.CompareExchange(IntPtr, IntPtr, IntPtr)\n  fullName: Interlocked.CompareExchange(IntPtr, IntPtr, IntPtr)\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange(Object, Object, Object)\n  nameWithType: Interlocked.CompareExchange(Object, Object, Object)\n  fullName: Interlocked.CompareExchange(Object, Object, Object)\n- uid: System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange(Single, Single, Single)\n  nameWithType: Interlocked.CompareExchange(Single, Single, Single)\n  fullName: Interlocked.CompareExchange(Single, Single, Single)\n- uid: System.Single\n  parent: System\n  isExternal: false\n  name: Single\n  nameWithType: Single\n  fullName: System.Single\n- uid: System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange<T>(T, T, T)\n  nameWithType: Interlocked.CompareExchange<T>(T, T, T)\n  fullName: Interlocked.CompareExchange<T>(T, T, T)\n- uid: T\n  isExternal: true\n  name: T\n  nameWithType: T\n  fullName: T\n- uid: System.Threading.Interlocked.Decrement(System.Int32@)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Decrement(Int32)\n  nameWithType: Interlocked.Decrement(Int32)\n  fullName: Interlocked.Decrement(Int32)\n- uid: System.Threading.Interlocked.Decrement(System.Int64@)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Decrement(Int64)\n  nameWithType: Interlocked.Decrement(Int64)\n  fullName: Interlocked.Decrement(Int64)\n- uid: System.Threading.Interlocked.Exchange(System.Single@,System.Single)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange(Single, Single)\n  nameWithType: Interlocked.Exchange(Single, Single)\n  fullName: Interlocked.Exchange(Single, Single)\n- uid: System.Threading.Interlocked.Exchange(System.Object@,System.Object)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange(Object, Object)\n  nameWithType: Interlocked.Exchange(Object, Object)\n  fullName: Interlocked.Exchange(Object, Object)\n- uid: System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange(IntPtr, IntPtr)\n  nameWithType: Interlocked.Exchange(IntPtr, IntPtr)\n  fullName: Interlocked.Exchange(IntPtr, IntPtr)\n- uid: System.Threading.Interlocked.Exchange(System.Double@,System.Double)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange(Double, Double)\n  nameWithType: Interlocked.Exchange(Double, Double)\n  fullName: Interlocked.Exchange(Double, Double)\n- uid: System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange(Int32, Int32)\n  nameWithType: Interlocked.Exchange(Int32, Int32)\n  fullName: Interlocked.Exchange(Int32, Int32)\n- uid: System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange(Int64, Int64)\n  nameWithType: Interlocked.Exchange(Int64, Int64)\n  fullName: Interlocked.Exchange(Int64, Int64)\n- uid: System.Threading.Interlocked.Exchange``1(``0@,``0)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange<T>(T, T)\n  nameWithType: Interlocked.Exchange<T>(T, T)\n  fullName: Interlocked.Exchange<T>(T, T)\n- uid: System.Threading.Interlocked.Increment(System.Int32@)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Increment(Int32)\n  nameWithType: Interlocked.Increment(Int32)\n  fullName: Interlocked.Increment(Int32)\n- uid: System.Threading.Interlocked.Increment(System.Int64@)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Increment(Int64)\n  nameWithType: Interlocked.Increment(Int64)\n  fullName: Interlocked.Increment(Int64)\n- uid: System.Threading.Interlocked.MemoryBarrier\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: MemoryBarrier()\n  nameWithType: Interlocked.MemoryBarrier()\n  fullName: Interlocked.MemoryBarrier()\n- uid: System.Threading.Interlocked.MemoryBarrierProcessWide\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: MemoryBarrierProcessWide()\n  nameWithType: Interlocked.MemoryBarrierProcessWide()\n  fullName: Interlocked.MemoryBarrierProcessWide()\n- uid: System.Threading.Interlocked.Read(System.Int64@)\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Read(Int64)\n  nameWithType: Interlocked.Read(Int64)\n  fullName: Interlocked.Read(Int64)\n- uid: System.Threading.Interlocked.Add*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Add\n  nameWithType: Interlocked.Add\n  fullName: Interlocked.Add\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.CompareExchange*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange\n  nameWithType: Interlocked.CompareExchange\n  fullName: Interlocked.CompareExchange\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.CompareExchange``1*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: CompareExchange<T>\n  nameWithType: Interlocked.CompareExchange<T>\n  fullName: Interlocked.CompareExchange<T>\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.Decrement*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Decrement\n  nameWithType: Interlocked.Decrement\n  fullName: Interlocked.Decrement\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.Exchange*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange\n  nameWithType: Interlocked.Exchange\n  fullName: Interlocked.Exchange\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.Exchange``1*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Exchange<T>\n  nameWithType: Interlocked.Exchange<T>\n  fullName: Interlocked.Exchange<T>\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.Increment*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Increment\n  nameWithType: Interlocked.Increment\n  fullName: Interlocked.Increment\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.MemoryBarrier*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: MemoryBarrier\n  nameWithType: Interlocked.MemoryBarrier\n  fullName: Interlocked.MemoryBarrier\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.MemoryBarrierProcessWide*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: MemoryBarrierProcessWide\n  nameWithType: Interlocked.MemoryBarrierProcessWide\n  fullName: Interlocked.MemoryBarrierProcessWide\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Threading.Interlocked.Read*\n  parent: System.Threading.Interlocked\n  isExternal: false\n  name: Read\n  nameWithType: Interlocked.Read\n  fullName: Interlocked.Read\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Interlocked.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}