{"nodes":[{"content":"The `FileSystem` module contains the procedures that are used to perform file, directory or folder, and system operations. The `My` feature gives you better productivity and performance in file I/O operations than using the `FileSystem` module. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,332],"content":"The `FileSystem` module contains the procedures that are used to perform file, directory or folder, and system operations. The `My` feature gives you better productivity and performance in file I/O operations than using the `FileSystem` module. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"The <ph id=\"ph1\">`FileSystem`</ph> module contains the procedures that are used to perform file, directory or folder, and system operations.","pos":[0,122],"source":"The `FileSystem` module contains the procedures that are used to perform file, directory or folder, and system operations."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than using the <ph id=\"ph2\">`FileSystem`</ph> module.","pos":[123,244],"source":" The `My` feature gives you better productivity and performance in file I/O operations than using the `FileSystem` module."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[245,332],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[6614,6947],"yaml":true},{"content":"This module supports the Visual Basic language keywords and run-time library members that access files and folders.","nodes":[{"pos":[0,115],"content":"This module supports the Visual Basic language keywords and run-time library members that access files and folders.","nodes":[{"content":"This module supports the Visual Basic language keywords and run-time library members that access files and folders.","pos":[0,115]}]}],"pos":[6958,7074],"yaml":true,"extradata":"MT"},{"content":"Changes the current directory or folder. The `My` feature gives you better productivity and performance in file I/O operations than the `ChDir` function. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref> .","nodes":[{"pos":[0,259],"content":"Changes the current directory or folder. The `My` feature gives you better productivity and performance in file I/O operations than the `ChDir` function. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref> .","nodes":[{"content":"Changes the current directory or folder.","pos":[0,40]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than the <ph id=\"ph2\">`ChDir`</ph> function.","pos":[41,153],"source":" The `My` feature gives you better productivity and performance in file I/O operations than the `ChDir` function."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"&gt;&lt;/xref&gt;</ph> .","pos":[154,259],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref> ."}]}],"pos":[8882,9142],"yaml":true},{"content":"The `ChDir` function changes the default directory, but not the default drive. For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:  \n  \n [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  \n  \n You can make relative directory changes is by typing two periods, as follows:  \n  \n [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  \n  \n> [!IMPORTANT]\n>  The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and .","nodes":[{"pos":[0,217],"content":"The `ChDir` function changes the default directory, but not the default drive. For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:","nodes":[{"content":"The <ph id=\"ph1\">`ChDir`</ph> function changes the default directory, but not the default drive.","pos":[0,78],"source":"The `ChDir` function changes the default directory, but not the default drive."},{"content":"For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:","pos":[79,217]}]},{"pos":[224,335],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#39<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]"},{"pos":[342,419],"content":"You can make relative directory changes is by typing two periods, as follows:","nodes":[{"content":"You can make relative directory changes is by typing two periods, as follows:","pos":[0,77]}]},{"pos":[426,537],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#40<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]"},{"pos":[545,763],"content":"[!IMPORTANT]\n The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and .","leadings":["","> "],"nodes":[{"content":" The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and .","pos":[13,216],"nodes":[{"content":"The <ph id=\"ph1\">`ChDir`</ph> function requires unmanaged code permission, which may affect its execution in partial-trust situations.","pos":[1,117],"source":" The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> and .","pos":[118,203],"source":" For more information, see <xref:System.Security.Permissions.SecurityPermission> and ."}]}]}],"pos":[9153,9928],"yaml":true,"extradata":"MT"},{"content":"Required. A `String` expression that identifies which directory or folder becomes the new default directory or folder. <code>Path</code> may include the drive. If no drive is specified, `ChDir` changes the default directory or folder on the current drive.","nodes":[{"pos":[0,255],"content":"Required. A `String` expression that identifies which directory or folder becomes the new default directory or folder. <code>Path</code> may include the drive. If no drive is specified, `ChDir` changes the default directory or folder on the current drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"A <ph id=\"ph1\">`String`</ph> expression that identifies which directory or folder becomes the new default directory or folder.","pos":[10,118],"source":" A `String` expression that identifies which directory or folder becomes the new default directory or folder."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Path</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include the drive.","pos":[119,159],"source":"<code>Path</code> may include the drive."},{"content":"If no drive is specified, <ph id=\"ph1\">`ChDir`</ph> changes the default directory or folder on the current drive.","pos":[160,255],"source":" If no drive is specified, `ChDir` changes the default directory or folder on the current drive."}]}],"pos":[10286,10542],"yaml":true},{"content":"<code>Path</code> is empty.","nodes":[{"pos":[0,27],"content":"<ph id=\"ph1\">&lt;code&gt;Path&lt;/code&gt;</ph> is empty.","source":"<code>Path</code> is empty."}],"pos":[10702,10730],"yaml":true},{"content":"Invalid drive is specified, or drive is unavailable.","nodes":[{"pos":[0,52],"content":"Invalid drive is specified, or drive is unavailable.","nodes":[{"content":"Invalid drive is specified, or drive is unavailable.","pos":[0,52]}]}],"pos":[10838,10891],"yaml":true},{"content":"Changes the current drive.","nodes":[{"pos":[0,26],"content":"Changes the current drive.","nodes":[{"content":"Changes the current drive.","pos":[0,26]}]}],"pos":[11807,11834],"yaml":true},{"content":"The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","nodes":[{"pos":[0,299],"content":"The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","nodes":[{"content":"The <ph id=\"ph1\">`ChDrive`</ph> function requires unmanaged-code permission, which may affect its execution in partial-trust situations.","pos":[0,118],"source":"The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> and <bpt id=\"p1\">[</bpt>Code Access Permissions<ept id=\"p1\">](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.","pos":[119,299],"source":" For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)."}]}],"pos":[11845,12145],"yaml":true,"extradata":"MT"},{"content":"Required. String expression that specifies an existing drive. If you supply a zero-length string (\"\"), the current drive does not change. If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter.","nodes":[{"pos":[0,242],"content":"Required. String expression that specifies an existing drive. If you supply a zero-length string (\"\"), the current drive does not change. If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"String expression that specifies an existing drive.","pos":[10,61]},{"content":"If you supply a zero-length string (\"\"), the current drive does not change.","pos":[62,137]},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Drive</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument is a multiple-character string, <ph id=\"ph2\">`ChDrive`</ph> uses only the first letter.","pos":[138,242],"source":" If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter."}]}],"pos":[12553,12796],"yaml":true},{"content":"Invalid drive is specified, or drive is unavailable.","nodes":[{"pos":[0,52],"content":"Invalid drive is specified, or drive is unavailable.","nodes":[{"content":"Invalid drive is specified, or drive is unavailable.","pos":[0,52]}]}],"pos":[12952,13005],"yaml":true},{"content":"Changes the current drive.","nodes":[{"pos":[0,26],"content":"Changes the current drive.","nodes":[{"content":"Changes the current drive.","pos":[0,26]}]}],"pos":[13933,13960],"yaml":true},{"content":"The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","nodes":[{"pos":[0,299],"content":"The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","nodes":[{"content":"The <ph id=\"ph1\">`ChDrive`</ph> function requires unmanaged-code permission, which may affect its execution in partial-trust situations.","pos":[0,118],"source":"The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> and <bpt id=\"p1\">[</bpt>Code Access Permissions<ept id=\"p1\">](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.","pos":[119,299],"source":" For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)."}]}],"pos":[13971,14271],"yaml":true,"extradata":"MT"},{"content":"Required. String expression that specifies an existing drive. If you supply a zero-length string (\"\"), the current drive does not change. If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter.","nodes":[{"pos":[0,242],"content":"Required. String expression that specifies an existing drive. If you supply a zero-length string (\"\"), the current drive does not change. If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"String expression that specifies an existing drive.","pos":[10,61]},{"content":"If you supply a zero-length string (\"\"), the current drive does not change.","pos":[62,137]},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Drive</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument is a multiple-character string, <ph id=\"ph2\">`ChDrive`</ph> uses only the first letter.","pos":[138,242],"source":" If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter."}]}],"pos":[14683,14926],"yaml":true},{"content":"Invalid drive is specified, or drive is unavailable.","nodes":[{"pos":[0,52],"content":"Invalid drive is specified, or drive is unavailable.","nodes":[{"content":"Invalid drive is specified, or drive is unavailable.","pos":[0,52]}]}],"pos":[15082,15135],"yaml":true},{"content":"Returns a string representing the current path. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>.","nodes":[{"pos":[0,301],"content":"Returns a string representing the current path. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>.","nodes":[{"content":"Returns a string representing the current path.","pos":[0,47]},{"content":"The <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`CurDir`</ph>.","pos":[48,196],"source":" The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"&gt;&lt;/xref&gt;</ph>.","pos":[197,301],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>."}]}],"pos":[15994,16296],"yaml":true},{"content":"A string representing the current path.","nodes":[{"pos":[0,39],"content":"A string representing the current path.","nodes":[{"content":"A string representing the current path.","pos":[0,39]}]}],"pos":[16646,16686],"yaml":true},{"content":"Returns a string representing the current path. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>.","nodes":[{"pos":[0,301],"content":"Returns a string representing the current path. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>.","nodes":[{"content":"Returns a string representing the current path.","pos":[0,47]},{"content":"The <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`CurDir`</ph>.","pos":[48,196],"source":" The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"&gt;&lt;/xref&gt;</ph>.","pos":[197,301],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>."}]}],"pos":[17666,17968],"yaml":true},{"content":"Optional. `Char` expression that specifies an existing drive. If no drive is specified, or if <code>Drive</code> is a zero-length string (\"\"), `CurDir` returns the path for the current drive.","nodes":[{"pos":[0,191],"content":"Optional. `Char` expression that specifies an existing drive. If no drive is specified, or if <code>Drive</code> is a zero-length string (\"\"), `CurDir` returns the path for the current drive.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"<ph id=\"ph1\">`Char`</ph> expression that specifies an existing drive.","pos":[10,61],"source":"`Char` expression that specifies an existing drive."},{"content":"If no drive is specified, or if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Drive</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a zero-length string (\"\"), <ph id=\"ph2\">`CurDir`</ph> returns the path for the current drive.","pos":[62,191],"source":" If no drive is specified, or if <code>Drive</code> is a zero-length string (\"\"), `CurDir` returns the path for the current drive."}]}],"pos":[18327,18519],"yaml":true},{"content":"A string representing the current path.","nodes":[{"pos":[0,39],"content":"A string representing the current path.","nodes":[{"content":"A string representing the current path.","pos":[0,39]}]}],"pos":[18576,18616],"yaml":true},{"content":"Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information.","nodes":[{"pos":[0,432],"content":"Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information.","nodes":[{"content":"Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","pos":[0,154]},{"content":"The <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> gives you better productivity and performance in file I/O operations than the <ph id=\"ph2\">`Dir`</ph> function.","pos":[155,313],"source":" The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function."},{"content":"See <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"&gt;&lt;/xref&gt;</ph> for more information.","pos":[314,432],"source":" See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information."}]}],"pos":[19527,19960],"yaml":true},{"content":"The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.  \n  \n `VbVolume` returns the volume label for the drive instead of a specific file name.  \n  \n You must supply a `PathName` the first time that you call the `Dir` function. To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.  \n  \n> [!IMPORTANT]\n>  To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).  \n  \n The `Attributes` argument enumeration values are as follows:  \n  \n|Value|Constant|Description|  \n|-|-|-|  \n|`Normal`|`vbnormal`|Default. Specifies files without attributes.|  \n|`ReadOnly`|`vbReadOnly`|Specifies read-only files, and also files without attributes.|  \n|`Hidden`|`vbHidden`|Specifies hidden files, and also files without attributes.|  \n|`System`|`vbSystem`|Specifies system files, and also files without attributes.|  \n|`Volume`|`vbVolume`|Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.|  \n|`Directory`|`vbDirectory`|Specifies directories or folders, and also files without attributes.|  \n|`Archive`|`vbArchive`|File has changed since last backup.|  \n|`Alias`|`vbAlias`|File has a different name.|  \n  \n> [!NOTE]\n>  These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">`Dir`</ph> function supports the use of multiple-character (<ph id=\"ph2\">`*`</ph>) and single-character (<ph id=\"ph3\">`?`</ph>) wildcards to specify multiple files.","source":"The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files."},{"pos":[134,216],"content":"<ph id=\"ph1\">`VbVolume`</ph> returns the volume label for the drive instead of a specific file name.","source":"`VbVolume` returns the volume label for the drive instead of a specific file name."},{"pos":[223,399],"content":"You must supply a `PathName` the first time that you call the `Dir` function. To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.","nodes":[{"content":"You must supply a <ph id=\"ph1\">`PathName`</ph> the first time that you call the <ph id=\"ph2\">`Dir`</ph> function.","pos":[0,77],"source":"You must supply a `PathName` the first time that you call the `Dir` function."},{"content":"To retrieve the next item, you can make subsequent calls to the <ph id=\"ph1\">`Dir`</ph> function without parameters.","pos":[78,176],"source":" To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters."}]},{"pos":[407,930],"content":"[!IMPORTANT]\n To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","leadings":["","> "],"nodes":[{"content":" To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","pos":[13,521],"nodes":[{"content":"To run correctly, the <ph id=\"ph1\">`Dir`</ph> function requires the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery&gt;</ph>flags of <ph id=\"ph4\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> to be granted to the executing code.","pos":[1,286],"source":" To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Security.SecurityException&gt;</ph>, and <bpt id=\"p1\">[</bpt>Code Access Permissions<ept id=\"p1\">](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.","pos":[287,508],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)."}]}]},{"pos":[937,997],"content":"The <ph id=\"ph1\">`Attributes`</ph> argument enumeration values are as follows:","source":"The `Attributes` argument enumeration values are as follows:"},{"pos":[1004,1009],"content":"Value","nodes":[{"content":"Value","pos":[0,5]}]},{"pos":[1010,1018],"content":"Constant","nodes":[{"content":"Constant","pos":[0,8]}]},{"pos":[1019,1030],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[1065,1109],"content":"Default. Specifies files without attributes.","nodes":[{"content":"Default. Specifies files without attributes.","pos":[0,44],"nodes":[{"content":"Default.","pos":[0,8]},{"content":"Specifies files without attributes.","pos":[9,44]}]}]},{"pos":[1138,1199],"content":"Specifies read-only files, and also files without attributes.","nodes":[{"content":"Specifies read-only files, and also files without attributes.","pos":[0,61]}]},{"pos":[1224,1282],"content":"Specifies hidden files, and also files without attributes.","nodes":[{"content":"Specifies hidden files, and also files without attributes.","pos":[0,58]}]},{"pos":[1307,1365],"content":"Specifies system files, and also files without attributes.","nodes":[{"content":"Specifies system files, and also files without attributes.","pos":[0,58]}]},{"pos":[1390,1473],"content":"Specifies volume label; if any other attribute is specified, <ph id=\"ph1\">`vbVolume`</ph> is ignored.","source":"Specifies volume label; if any other attribute is specified, `vbVolume` is ignored."},{"pos":[1504,1572],"content":"Specifies directories or folders, and also files without attributes.","nodes":[{"content":"Specifies directories or folders, and also files without attributes.","pos":[0,68]}]},{"pos":[1599,1634],"content":"File has changed since last backup.","nodes":[{"content":"File has changed since last backup.","pos":[0,35]}]},{"pos":[1657,1683],"content":"File has a different name.","nodes":[{"content":"File has a different name.","pos":[0,26]}]},{"pos":[1692,1832],"content":"[!NOTE]\n These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.","leadings":["","> "],"nodes":[{"content":"These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.","pos":[9,138]}]}],"pos":[19971,21829],"yaml":true,"extradata":"MT"},{"content":"A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","nodes":[{"pos":[0,146],"content":"A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","nodes":[{"content":"A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","pos":[0,146]}]}],"pos":[22178,22325],"yaml":true},{"content":"Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information.","nodes":[{"pos":[0,432],"content":"Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information.","nodes":[{"content":"Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","pos":[0,154]},{"content":"The <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> gives you better productivity and performance in file I/O operations than the <ph id=\"ph2\">`Dir`</ph> function.","pos":[155,313],"source":" The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function."},{"content":"See <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"&gt;&lt;/xref&gt;</ph> for more information.","pos":[314,432],"source":" See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information."}]}],"pos":[23449,23882],"yaml":true},{"content":"The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.  \n  \n `VbVolume` returns the volume label for the drive instead of a specific file name.  \n  \n You must supply a `PathName` the first time that you call the `Dir` function. To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.  \n  \n> [!IMPORTANT]\n>  To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).  \n  \n The `Attributes` argument enumeration values are as follows:  \n  \n|Value|Constant|Description|  \n|-|-|-|  \n|`Normal`|`vbnormal`|Default. Specifies files that have no attributes.|  \n|`ReadOnly`|`vbReadOnly`|Specifies read-only files, in addition to files that have no attributes.|  \n|`Hidden`|`vbHidden`|Specifies hidden files, in addition to files that have no attributes.|  \n|`System`|`vbSystem`|Specifies system files, in addition to files that have no attributes.|  \n|`Volume`|`vbVolume`|Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.|  \n|`Directory`|`vbDirectory`|Specifies directories or folders, in addition to files that have no attributes.|  \n|`Archive`|`vbArchive`|File has changed since last backup.|  \n|`Alias`|`vbAlias`|File has a different name.|  \n  \n> [!NOTE]\n>  These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">`Dir`</ph> function supports the use of multiple-character (<ph id=\"ph2\">`*`</ph>) and single-character (<ph id=\"ph3\">`?`</ph>) wildcards to specify multiple files.","source":"The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files."},{"pos":[134,216],"content":"<ph id=\"ph1\">`VbVolume`</ph> returns the volume label for the drive instead of a specific file name.","source":"`VbVolume` returns the volume label for the drive instead of a specific file name."},{"pos":[223,399],"content":"You must supply a `PathName` the first time that you call the `Dir` function. To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.","nodes":[{"content":"You must supply a <ph id=\"ph1\">`PathName`</ph> the first time that you call the <ph id=\"ph2\">`Dir`</ph> function.","pos":[0,77],"source":"You must supply a `PathName` the first time that you call the `Dir` function."},{"content":"To retrieve the next item, you can make subsequent calls to the <ph id=\"ph1\">`Dir`</ph> function with no parameters.","pos":[78,176],"source":" To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters."}]},{"pos":[407,930],"content":"[!IMPORTANT]\n To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","leadings":["","> "],"nodes":[{"content":" To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).","pos":[13,521],"nodes":[{"content":"To run correctly, the <ph id=\"ph1\">`Dir`</ph> function requires the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery&gt;</ph>flags of <ph id=\"ph4\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> to be granted to the executing code.","pos":[1,286],"source":" To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Security.SecurityException&gt;</ph>, and <bpt id=\"p1\">[</bpt>Code Access Permissions<ept id=\"p1\">](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.","pos":[287,508],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)."}]}]},{"pos":[937,997],"content":"The <ph id=\"ph1\">`Attributes`</ph> argument enumeration values are as follows:","source":"The `Attributes` argument enumeration values are as follows:"},{"pos":[1004,1009],"content":"Value","nodes":[{"content":"Value","pos":[0,5]}]},{"pos":[1010,1018],"content":"Constant","nodes":[{"content":"Constant","pos":[0,8]}]},{"pos":[1019,1030],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[1065,1114],"content":"Default. Specifies files that have no attributes.","nodes":[{"content":"Default. Specifies files that have no attributes.","pos":[0,49],"nodes":[{"content":"Default.","pos":[0,8]},{"content":"Specifies files that have no attributes.","pos":[9,49]}]}]},{"pos":[1143,1215],"content":"Specifies read-only files, in addition to files that have no attributes.","nodes":[{"content":"Specifies read-only files, in addition to files that have no attributes.","pos":[0,72]}]},{"pos":[1240,1309],"content":"Specifies hidden files, in addition to files that have no attributes.","nodes":[{"content":"Specifies hidden files, in addition to files that have no attributes.","pos":[0,69]}]},{"pos":[1334,1403],"content":"Specifies system files, in addition to files that have no attributes.","nodes":[{"content":"Specifies system files, in addition to files that have no attributes.","pos":[0,69]}]},{"pos":[1428,1511],"content":"Specifies volume label; if any other attribute is specified, <ph id=\"ph1\">`vbVolume`</ph> is ignored.","source":"Specifies volume label; if any other attribute is specified, `vbVolume` is ignored."},{"pos":[1542,1621],"content":"Specifies directories or folders, in addition to files that have no attributes.","nodes":[{"content":"Specifies directories or folders, in addition to files that have no attributes.","pos":[0,79]}]},{"pos":[1648,1683],"content":"File has changed since last backup.","nodes":[{"content":"File has changed since last backup.","pos":[0,35]}]},{"pos":[1706,1732],"content":"File has a different name.","nodes":[{"content":"File has a different name.","pos":[0,26]}]},{"pos":[1741,1882],"content":"[!NOTE]\n These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.","leadings":["","> "],"nodes":[{"content":"These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.","pos":[9,139]}]}],"pos":[23893,25801],"yaml":true,"extradata":"MT"},{"content":"Optional. `String` expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (`\"\"`) is returned if <code>PathName</code> is not found.","nodes":[{"pos":[0,185],"content":"Optional. `String` expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (`\"\"`) is returned if <code>PathName</code> is not found.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies a file name, directory or folder name, or drive volume label.","pos":[10,106],"source":"`String` expression that specifies a file name, directory or folder name, or drive volume label."},{"content":"A zero-length string (<ph id=\"ph1\">`\"\"`</ph>) is returned if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">PathName</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not found.","pos":[107,185],"source":" A zero-length string (`\"\"`) is returned if <code>PathName</code> is not found."}]}],"pos":[26262,26448],"yaml":true},{"content":"Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, `Dir` returns files that match <code>PathName</code> but have no attributes.","nodes":[{"pos":[0,171],"content":"Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, `Dir` returns files that match <code>PathName</code> but have no attributes.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Enumeration or numeric expression whose value specifies file attributes.","pos":[10,82]},{"content":"If omitted, <ph id=\"ph1\">`Dir`</ph> returns files that match <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">PathName</ph><ept id=\"p1\">&lt;/code&gt;</ept> but have no attributes.","pos":[83,171],"source":" If omitted, `Dir` returns files that match <code>PathName</code> but have no attributes."}]}],"pos":[26536,26708],"yaml":true},{"content":"A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","nodes":[{"pos":[0,146],"content":"A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","nodes":[{"content":"A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.","pos":[0,146]}]}],"pos":[26765,26912],"yaml":true},{"content":"Returns a Boolean value `True` when the end of a file opened for `Random` or sequential `Input` has been reached.","nodes":[{"pos":[0,113],"content":"Returns a Boolean value <ph id=\"ph1\">`True`</ph> when the end of a file opened for <ph id=\"ph2\">`Random`</ph> or sequential <ph id=\"ph3\">`Input`</ph> has been reached.","source":"Returns a Boolean value `True` when the end of a file opened for `Random` or sequential `Input` has been reached."}],"pos":[27877,27991],"yaml":true},{"content":"Use `EOF` to avoid the error generated by attempting to get input past the end of a file.  \n  \n The `EOF` function returns `False` until the end of the file has been reached. With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.  \n  \n With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error. Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function. With files opened for `Output`, `EOF` always returns `True`.","nodes":[{"pos":[0,89],"content":"Use <ph id=\"ph1\">`EOF`</ph> to avoid the error generated by attempting to get input past the end of a file.","source":"Use `EOF` to avoid the error generated by attempting to get input past the end of a file."},{"pos":[96,324],"content":"The `EOF` function returns `False` until the end of the file has been reached. With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.","nodes":[{"content":"The <ph id=\"ph1\">`EOF`</ph> function returns <ph id=\"ph2\">`False`</ph> until the end of the file has been reached.","pos":[0,78],"source":"The `EOF` function returns `False` until the end of the file has been reached."},{"content":"With files opened for <ph id=\"ph1\">`Random`</ph> or <ph id=\"ph2\">`Binary`</ph> access, <ph id=\"ph3\">`EOF`</ph> returns <ph id=\"ph4\">`False`</ph> until the last executed <ph id=\"ph5\">`FileGet`</ph> function is unable to read a whole record.","pos":[79,228],"source":" With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record."}]},{"pos":[331,675],"content":"With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error. Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function. With files opened for `Output`, `EOF` always returns `True`.","nodes":[{"content":"With files opened for <ph id=\"ph1\">`Binary`</ph> access, an attempt to read through the file using the <ph id=\"ph2\">`Input`</ph> function until <ph id=\"ph3\">`EOF`</ph> returns <ph id=\"ph4\">`True`</ph> generates an error.","pos":[0,148],"source":"With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error."},{"content":"Use the <ph id=\"ph1\">`LOF`</ph> and <ph id=\"ph2\">`Loc`</ph> functions instead of <ph id=\"ph3\">`EOF`</ph> when reading binary files with <ph id=\"ph4\">`Input`</ph>, or use <ph id=\"ph5\">`Get`</ph> when using the <ph id=\"ph6\">`EOF`</ph> function.","pos":[149,283],"source":" Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function."},{"content":"With files opened for <ph id=\"ph1\">`Output`</ph>, <ph id=\"ph2\">`EOF`</ph> always returns <ph id=\"ph3\">`True`</ph>.","pos":[284,344],"source":" With files opened for `Output`, `EOF` always returns `True`."}]}],"pos":[28002,28684],"yaml":true,"extradata":"MT"},{"content":"Required. An `Integer` that contains any valid file number.","nodes":[{"pos":[0,59],"content":"Required. An `Integer` that contains any valid file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"An <ph id=\"ph1\">`Integer`</ph> that contains any valid file number.","pos":[10,59],"source":" An `Integer` that contains any valid file number."}]}],"pos":[29121,29181],"yaml":true},{"content":"Returns a Boolean value `True` when the end of a file opened for `Random` or sequential `Input` has been reached.","nodes":[{"pos":[0,113],"content":"Returns a Boolean value <ph id=\"ph1\">`True`</ph> when the end of a file opened for <ph id=\"ph2\">`Random`</ph> or sequential <ph id=\"ph3\">`Input`</ph> has been reached.","source":"Returns a Boolean value `True` when the end of a file opened for `Random` or sequential `Input` has been reached."}],"pos":[29239,29353],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[29505,29527],"yaml":true},{"content":"Returns an enumeration representing the file mode for files opened using the `FileOpen` function. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `FileAttr` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref> for more information.","nodes":[{"pos":[0,375],"content":"Returns an enumeration representing the file mode for files opened using the `FileOpen` function. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `FileAttr` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref> for more information.","nodes":[{"content":"Returns an enumeration representing the file mode for files opened using the <ph id=\"ph1\">`FileOpen`</ph> function.","pos":[0,97],"source":"Returns an enumeration representing the file mode for files opened using the `FileOpen` function."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> gives you better productivity and performance in file I/O operations than the <ph id=\"ph2\">`FileAttr`</ph> function.","pos":[98,261],"source":" The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `FileAttr` function."},{"content":"See <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"&gt;&lt;/xref&gt;</ph> for more information.","pos":[262,375],"source":" See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref> for more information."}]}],"pos":[30455,30831],"yaml":true},{"content":"This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.","nodes":[{"pos":[0,111],"content":"This function returns an enumeration representing the file mode for files opened using the <ph id=\"ph1\">`FileOpen`</ph> function.","source":"This function returns an enumeration representing the file mode for files opened using the `FileOpen` function."}],"pos":[30842,30954],"yaml":true,"extradata":"MT"},{"content":"Required. `Integer`. Any valid file number.","nodes":[{"pos":[0,43],"content":"Required. `Integer`. Any valid file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`Integer`</ph>.","pos":[10,20],"source":"`Integer`."},{"content":"Any valid file number.","pos":[21,43]}]}],"pos":[31350,31394],"yaml":true},{"content":"The following enumeration values indicate the file access mode:  \n  \n <table><tbody><tr><td> Value  \n  \n </td><td> Mode  \n  \n </td></tr><tr><td> 1  \n  \n </td><td>`OpenMode.Input`</td></tr><tr><td> 2  \n  \n </td><td>`OpenMode.Output`</td></tr><tr><td> 4  \n  \n </td><td>`OpenMode.Random`</td></tr><tr><td> 8  \n  \n </td><td>`OpenMode.Append`</td></tr><tr><td> 32  \n  \n </td><td>`OpenMode.Binary`</td></tr></tbody></table>","nodes":[{"pos":[0,63],"content":"The following enumeration values indicate the file access mode:","nodes":[{"content":"The following enumeration values indicate the file access mode:","pos":[0,63]}]},{"pos":[70,418],"content":"<table><tbody><tr><td> Value  \n  \n </td><td> Mode  \n  \n </td></tr><tr><td> 1  \n  \n </td><td>`OpenMode.Input`</td></tr><tr><td> 2  \n  \n </td><td>`OpenMode.Output`</td></tr><tr><td> 4  \n  \n </td><td>`OpenMode.Random`</td></tr><tr><td> 8  \n  \n </td><td>`OpenMode.Append`</td></tr><tr><td> 32  \n  \n </td><td>`OpenMode.Binary`</td></tr></tbody></table>","nodes":[{"content":"Value","pos":[23,33],"source":" Value  \n  \n "},{"content":"Mode","pos":[45,54],"source":" Mode  \n  \n "},{"content":"1","pos":[75,81],"source":" 1  \n  \n "},{"content":"2","pos":[127,133],"source":" 2  \n  \n "},{"content":"4","pos":[180,186],"source":" 4  \n  \n "},{"content":"8","pos":[233,239],"source":" 8  \n  \n "},{"content":"32","pos":[286,293],"source":" 32  \n  \n "}]}],"pos":[31468,31904],"yaml":true},{"content":"Concludes input/output (I/O) to a file opened using the `FileOpen` function. `My` gives you better productivity and performance in file I/O operations. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> for more information.","nodes":[{"pos":[0,238],"content":"Concludes input/output (I/O) to a file opened using the `FileOpen` function. `My` gives you better productivity and performance in file I/O operations. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> for more information.","nodes":[{"content":"Concludes input/output (I/O) to a file opened using the <ph id=\"ph1\">`FileOpen`</ph> function.","pos":[0,76],"source":"Concludes input/output (I/O) to a file opened using the `FileOpen` function."},{"content":"<ph id=\"ph1\">`My`</ph> gives you better productivity and performance in file I/O operations.","pos":[77,151],"source":"`My` gives you better productivity and performance in file I/O operations."},{"content":"See <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> for more information.","pos":[152,238],"source":" See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> for more information."}]}],"pos":[32922,33161],"yaml":true},{"content":"The `FileClose` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  \n  \n If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.  \n  \n When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file. All buffer space associated with the closed file is released.  \n  \n When the `FileClose` function is executed, the association of a file with its file number ends.","nodes":[{"pos":[0,757],"content":"The `FileClose` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).","nodes":[{"content":"The <ph id=\"ph1\">`FileClose`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,91],"source":"The `FileClose` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[92,185],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Read Text from Files with a StreamReader<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)</ept>,<bpt id=\"p2\">[</bpt>How to: Write Text to Files with a StreamWriter<ept id=\"p2\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)</ept>, and <bpt id=\"p3\">[</bpt>Walkthrough: Manipulating Files and Directories in Visual Basic<ept id=\"p3\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)</ept>.","pos":[186,757],"source":" For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)."}]},{"pos":[764,853],"content":"If you omit <ph id=\"ph1\">`FileNumbers`</ph>, all active files opened by the <ph id=\"ph2\">`FileOpen`</ph> function are closed.","source":"If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed."},{"pos":[860,1069],"content":"When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file. All buffer space associated with the closed file is released.","nodes":[{"content":"When you close files that were opened for <ph id=\"ph1\">`Output`</ph> or <ph id=\"ph2\">`Append`</ph>, the final buffer of output is written to the operating system buffer for that file.","pos":[0,147],"source":"When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file."},{"content":"All buffer space associated with the closed file is released.","pos":[148,209]}]},{"pos":[1076,1171],"content":"When the <ph id=\"ph1\">`FileClose`</ph> function is executed, the association of a file with its file number ends.","source":"When the `FileClose` function is executed, the association of a file with its file number ends."}],"pos":[33172,34352],"yaml":true,"extradata":"MT"},{"content":"Optional. Parameter array of 0 or more channels to be closed.","nodes":[{"pos":[0,61],"content":"Optional. Parameter array of 0 or more channels to be closed.","nodes":[{"content":"Optional. Parameter array of 0 or more channels to be closed.","pos":[0,61],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Parameter array of 0 or more channels to be closed.","pos":[10,61]}]}]}],"pos":[34725,34787],"yaml":true},{"content":"<code>FileNumber</code> does not exist.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;FileNumber&lt;/code&gt;</ph> does not exist.","source":"<code>FileNumber</code> does not exist."}],"pos":[34945,34985],"yaml":true},{"content":"Copies a file. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `FileCopy`. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)\"></xref> for more information.","nodes":[{"pos":[0,290],"content":"Copies a file. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `FileCopy`. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)\"></xref> for more information.","nodes":[{"content":"Copies a file.","pos":[0,14]},{"content":"The <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileCopy`</ph>.","pos":[15,165],"source":" The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `FileCopy`."},{"content":"See <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)\"&gt;&lt;/xref&gt;</ph> for more information.","pos":[166,290],"source":" See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)\"></xref> for more information."}]}],"pos":[35985,36276],"yaml":true},{"content":"If you try to use the `FileCopy` function on a currently open file, an error occurs.  \n  \n `FileCopy` requires full trust to work on the local drive.","nodes":[{"pos":[0,84],"content":"If you try to use the <ph id=\"ph1\">`FileCopy`</ph> function on a currently open file, an error occurs.","source":"If you try to use the `FileCopy` function on a currently open file, an error occurs."},{"pos":[91,149],"content":"<ph id=\"ph1\">`FileCopy`</ph> requires full trust to work on the local drive.","source":"`FileCopy` requires full trust to work on the local drive."}],"pos":[36287,36441],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that specifies the name of the file to be copied. <code>Source</code> may include the directory or folder, and drive, of the source file.","nodes":[{"pos":[0,167],"content":"Required. `String` expression that specifies the name of the file to be copied. <code>Source</code> may include the directory or folder, and drive, of the source file.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies the name of the file to be copied.","pos":[10,79],"source":"`String` expression that specifies the name of the file to be copied."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Source</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include the directory or folder, and drive, of the source file.","pos":[80,167],"source":"<code>Source</code> may include the directory or folder, and drive, of the source file."}]}],"pos":[36895,37063],"yaml":true},{"content":"Required. `String` expression that specifies the destination file name. <code>Destination</code> may include the directory or folder, and drive, of the destination file.","nodes":[{"pos":[0,169],"content":"Required. `String` expression that specifies the destination file name. <code>Destination</code> may include the directory or folder, and drive, of the destination file.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies the destination file name.","pos":[10,71],"source":"`String` expression that specifies the destination file name."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Destination</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include the directory or folder, and drive, of the destination file.","pos":[72,169],"source":"<code>Destination</code> may include the directory or folder, and drive, of the destination file."}]}],"pos":[37130,37300],"yaml":true},{"content":"<code>Source</code> or <code>Destination</code> is invalid or not specified.","nodes":[{"pos":[0,76],"content":"<ph id=\"ph1\">&lt;code&gt;Source&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;Destination&lt;/code&gt;</ph> is invalid or not specified.","source":"<code>Source</code> or <code>Destination</code> is invalid or not specified."}],"pos":[37463,37540],"yaml":true},{"content":"File is already open.","nodes":[{"pos":[0,21],"content":"File is already open.","nodes":[{"content":"File is already open.","pos":[0,21]}]}],"pos":[37628,37650],"yaml":true},{"content":"File does not exist.","nodes":[{"pos":[0,20],"content":"File does not exist.","nodes":[{"content":"File does not exist.","pos":[0,20]}]}],"pos":[37758,37779],"yaml":true},{"content":"Returns a `Date` value that indicates the date and time a file was written to. The `My` feature gives you better productivity and performance in file I/O operations than `FileDateTime`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>","nodes":[{"pos":[0,299],"content":"Returns a `Date` value that indicates the date and time a file was written to. The `My` feature gives you better productivity and performance in file I/O operations than `FileDateTime`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>","nodes":[{"content":"Returns a <ph id=\"ph1\">`Date`</ph> value that indicates the date and time a file was written to.","pos":[0,78],"source":"Returns a `Date` value that indicates the date and time a file was written to."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileDateTime`</ph>.","pos":[79,185],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileDateTime`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"&gt;&lt;/xref&gt;</ph>","pos":[186,299],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>"}]}],"pos":[38737,39037],"yaml":true},{"content":"Required. `String` expression that specifies a file name. <code>PathName</code> may include the directory or folder, and the drive.","nodes":[{"pos":[0,131],"content":"Required. `String` expression that specifies a file name. <code>PathName</code> may include the directory or folder, and the drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies a file name.","pos":[10,57],"source":"`String` expression that specifies a file name."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">PathName</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include the directory or folder, and the drive.","pos":[58,131],"source":"<code>PathName</code> may include the directory or folder, and the drive."}]}],"pos":[39549,39681],"yaml":true},{"content":"`Date` value that indicates the date and time a file was created or last modified.","nodes":[{"pos":[0,82],"content":"<ph id=\"ph1\">`Date`</ph> value that indicates the date and time a file was created or last modified.","source":"`Date` value that indicates the date and time a file was created or last modified."}],"pos":[39740,39825],"yaml":true},{"content":"<code>PathName</code> is invalid or contains wildcards.","nodes":[{"pos":[0,55],"content":"<ph id=\"ph1\">&lt;code&gt;PathName&lt;/code&gt;</ph> is invalid or contains wildcards.","source":"<code>PathName</code> is invalid or contains wildcards."}],"pos":[39992,40048],"yaml":true},{"content":"Target file does not exist.","nodes":[{"pos":[0,27],"content":"Target file does not exist.","nodes":[{"content":"Target file does not exist.","pos":[0,27]}]}],"pos":[40156,40184],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[41373,41614],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1209],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.","pos":[192,324]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[325,495]}]},{"pos":[1219,1867],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1877,2332],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2343,2828],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2839,2950],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2961,3002],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3016,3056],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3070,3107],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3117,3415],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3425,4113],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4122,4133],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4137,4327],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4337,4500],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4510,4613],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4623,4828],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4840,5014],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[41625,46684],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[46937,46970],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[47030,47085],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[47152,47260],"yaml":true},{"content":"Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.","nodes":[{"pos":[0,191],"content":"Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.","nodes":[{"content":"Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.","pos":[0,191],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Applies only when writing an array.","pos":[10,45]},{"content":"Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.","pos":[46,191]}]}]}],"pos":[47331,47523],"yaml":true},{"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is `False`.","nodes":[{"pos":[0,160],"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is `False`.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Applies only when writing a string.","pos":[10,45]},{"content":"Specifies whether to write a two-byte descriptor for the string that describes the length.","pos":[46,136]},{"content":"The default is <ph id=\"ph1\">`False`</ph>.","pos":[137,160],"source":" The default is `False`."}]}],"pos":[47599,47760],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[47922,47973],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[48061,48083],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[49206,49447],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5011],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[49458,54514],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[54739,54772],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[54833,54888],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[54955,55063],"yaml":true},{"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is `False`.","nodes":[{"pos":[0,160],"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is `False`.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Applies only when writing a string.","pos":[10,45]},{"content":"Specifies whether to write a two-byte descriptor for the string that describes the length.","pos":[46,136]},{"content":"The default is <ph id=\"ph1\">`False`</ph>.","pos":[137,160],"source":" The default is `False`."}]}],"pos":[55139,55300],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[55462,55513],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[55601,55623],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[56692,56933],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5011],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[56944,62000],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[62194,62227],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[62291,62346],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[62413,62521],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[62683,62734],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[62822,62844],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[63895,64136],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5011],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[64147,69203],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[69393,69426],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[69487,69542],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[69609,69717],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[69879,69930],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[70018,70040],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[71085,71326],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5011],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[71337,76393],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[76582,76615],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[76675,76730],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[76797,76905],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[77067,77118],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[77206,77228],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[78273,78514],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5011],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[78525,83581],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[83769,83802],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[83862,83917],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[83984,84092],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[84254,84305],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[84393,84415],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[85472,85713],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5011],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[85724,90780],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[90972,91005],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[91067,91122],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[91189,91297],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[91459,91510],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[91598,91620],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[92671,92912],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5010],"content":"[!IMPORTANT]\nReading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the<ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,166],"source":"Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[92923,97978],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[98169,98202],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[98263,98318],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[98385,98493],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[98655,98706],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[98794,98816],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[99879,100120],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,130],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file with <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file with `FilePut`."},{"pos":[137,400],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[408,615],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[624,635],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[639,700],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[710,1201],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function,<ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,190],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[191,320]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[321,491]}]},{"pos":[1211,1859],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1869,2324],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2335,2820],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2831,2942],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2953,2994],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3008,3048],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3062,3099],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3109,3407],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3417,4105],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4114,4125],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4129,4319],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4329,4492],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4502,4605],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4615,4820],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4832,5006],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[100131,105182],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[105375,105408],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[105471,105526],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[105593,105701],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[105863,105914],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[106002,106024],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[107063,107304],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,130],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file with <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file with `FilePut`."},{"pos":[137,400],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[408,615],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[624,635],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[639,700],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[710,1202],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1212,1860],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1870,2325],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2336,2821],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2832,2943],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2954,2995],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3009,3049],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3063,3100],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3110,3408],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3418,4106],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4115,4126],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4130,4320],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4330,4493],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4503,4606],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4616,4821],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4833,5007],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[107315,112367],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[112556,112589],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[112648,112703],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[112770,112878],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[113040,113091],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[113179,113201],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[114240,114481],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,130],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file with <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file with `FilePut`."},{"pos":[137,400],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[408,615],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[624,635],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[639,700],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[710,1202],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1212,1860],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1870,2330],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used.","pos":[346,376]},{"content":"Then the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[377,460],"source":" Then the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2341,2826],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2837,2948],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2959,3000],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3014,3054],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3068,3105],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3115,3413],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3423,4111],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4120,4131],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4135,4325],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4335,4498],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4508,4611],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4621,4826],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4838,5012],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[114492,119549],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[119738,119771],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[119830,119885],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[119952,120060],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[120222,120273],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[120361,120383],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>","nodes":[{"pos":[0,239],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>","pos":[153,239],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>"}]}],"pos":[121440,121680],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,130],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file with <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file with `FilePut`."},{"pos":[137,400],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[408,615],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[624,635],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[639,700],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[710,1202],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1212,1860],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1870,2325],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2336,2821],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2832,2943],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2954,2995],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3009,3049],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3063,3100],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3110,3408],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3418,4106],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4115,4126],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4130,4320],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4330,4493],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4503,4606],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4616,4821],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4833,5006],"content":"[!IMPORTANT]\nReading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the<ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,166],"source":"Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[121691,126742],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[126931,126964],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[127026,127081],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[127148,127256],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[127418,127469],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[127557,127579],"yaml":true},{"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGet`</ph>.","pos":[51,152],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[128624,128865],"yaml":true},{"content":"`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 * 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FileGet`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGet` is valid only in `Random` and `Binary` mode."},{"pos":[61,134],"content":"Data read with <ph id=\"ph1\">`FileGet`</ph> is usually written to a file by using <ph id=\"ph2\">`FilePut`</ph>.","source":"Data read with `FileGet` is usually written to a file by using `FilePut`."},{"pos":[141,404],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte following the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function (or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function) is read.","pos":[108,263],"source":" If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read."}]},{"pos":[412,619],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[628,639],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[643,704],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[714,1206],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGet`</ph> reads subsequent records on record-length boundaries.","pos":[0,191],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[192,321]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.","pos":[322,492]}]},{"pos":[1216,1864],"content":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"By default, if the variable being read into is a string, <ph id=\"ph1\">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.","pos":[0,179],"source":"By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[180,347],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.","pos":[348,473]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[474,648],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[1874,2329],"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.","nodes":[{"content":"If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.","pos":[0,129]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[130,200],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When reading the array, you have to match the way the array was written.","pos":[201,273]},{"content":"If it was written with the descriptor, you have to read the descriptor.","pos":[274,345]},{"content":"If the descriptor is not used, the size and bounds of the array passed into <ph id=\"ph1\">`FileGet`</ph> determine what to read.","pos":[346,455],"source":" If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read."}]},{"pos":[2340,2825],"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[0,93]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[94,182]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[183,386],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[387,485]}]},{"pos":[2836,2947],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#21<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]"},{"pos":[2958,2999],"content":"The 218 bytes are distributed as follows:","nodes":[{"content":"The 218 bytes are distributed as follows:","pos":[0,41]}]},{"pos":[3013,3053],"content":"18 bytes for the descriptor: (2 + 8 * 2)","nodes":[{"content":"18 bytes for the descriptor: (2 + 8 * 2)","pos":[0,40]}]},{"pos":[3067,3104],"content":"200 bytes for the data: (5 * 10 * 4).","nodes":[{"content":"200 bytes for the data: (5 * 10 * 4).","pos":[0,37]}]},{"pos":[3114,3412],"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.","nodes":[{"content":"If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FileGet`</ph> reads only the variable data.","pos":[0,146],"source":"If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.","pos":[147,298],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read."}]},{"pos":[3422,4110],"content":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,129],"source":"`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[130,321],"source":" On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions)."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.","pos":[322,505],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements."},{"content":"This includes any arrays and their descriptors.","pos":[506,553]},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.","pos":[554,688],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk."}]},{"pos":[4119,4130],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4134,4324],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[4334,4497],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.","pos":[68,163],"source":"`FileGet` reads all variables from disk contiguously; that is, without padding between records."}]},{"pos":[4507,4610],"content":"For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGet`</ph> reads only the data.","pos":[0,80],"source":"For any array other than an array in a structure, `FileGet` reads only the data."},{"content":"No descriptor is read.","pos":[81,103]}]},{"pos":[4620,4825],"content":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,125],"source":"`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[126,205]}]},{"pos":[4837,5011],"content":"[!IMPORTANT]\nReading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","    >  "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`FileGet`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[13,167],"source":"Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[128876,133932],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[134122,134155],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[134215,134270],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[134337,134445],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[134607,134658],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[134746,134768],"yaml":true},{"content":"Reads data from an open disk file into a variable.  The `My` feature gives you better productivity and performance in file I/O operations than `FileGetObject`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,247],"content":"Reads data from an open disk file into a variable.  The `My` feature gives you better productivity and performance in file I/O operations than `FileGetObject`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Reads data from an open disk file into a variable.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileGetObject`</ph>.","pos":[52,159],"source":"  The `My` feature gives you better productivity and performance in file I/O operations than `FileGetObject`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[160,247],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[135855,136103],"yaml":true},{"content":"The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.","nodes":[{"pos":[0,198],"content":"The <ph id=\"ph1\">`FileGetObject`</ph> function is used instead of <ph id=\"ph2\">`FileGet`</ph> to avoid ambiguities at compile time if type <ph id=\"ph3\">`Object`</ph> is returned instead of another type, such as <ph id=\"ph4\">`Integer`</ph>, <ph id=\"ph5\">`Long`</ph>, <ph id=\"ph6\">`Short`</ph>, and so forth.","source":"The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth."},{"pos":[205,421],"content":"If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.","nodes":[{"content":"If you intend to write out the <ph id=\"ph1\">`Variant`</ph> type, <ph id=\"ph2\">`FileGetObject`</ph> is required.","pos":[0,75],"source":"If you intend to write out the `Variant` type, `FileGetObject` is required."},{"content":"When in doubt, if you are using an object for the second parameter, it is always suggested that you use <ph id=\"ph1\">`FilePutObject`</ph> and <ph id=\"ph2\">`FileGetObject`</ph>.","pos":[76,216],"source":" When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`."}]},{"pos":[428,488],"content":"<ph id=\"ph1\">`FileGetObject`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FileGetObject` is valid only in `Random` and `Binary` mode."},{"pos":[495,566],"content":"Data read with <ph id=\"ph1\">`FileGetObject`</ph> is usually written with <ph id=\"ph2\">`FilePutObject`</ph>.","source":"Data read with `FileGetObject` is usually written with `FilePutObject`."},{"pos":[573,853],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, <ph id=\"ph2\">`FileGetObject`</ph> reads the record or byte after the last <ph id=\"ph3\">`FileGetObject`</ph> or <ph id=\"ph4\">`FilePutObject`</ph> function (or pointed to by the last <ph id=\"ph5\">`Seek`</ph> function).","pos":[108,280],"source":" If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function)."}]},{"pos":[862,873],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[877,938],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[948,1431],"content":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.","nodes":[{"content":"If the length of the data being read is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FileGetObject`</ph> reads subsequent records on record-length boundaries.","pos":[0,197],"source":"If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.","pos":[198,331]},{"content":"Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.","pos":[332,483]}]},{"pos":[1441,2095],"content":"If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being read into is a string, by default <ph id=\"ph1\">`FileGetObject`</ph> reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.","pos":[0,181],"source":"If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[182,349],"source":" Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string."},{"content":"Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.","pos":[350,479]},{"content":"If you want to read a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[480,654],"source":" If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[2105,2539],"content":"If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.","nodes":[{"content":"If the variable being read into is an array, then the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[0,253],"source":"If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[254,347]},{"content":"Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.","pos":[348,434]}]},{"pos":[2550,2648],"content":"For example, the following array declaration requires 218 bytes when the array is written to disk:","nodes":[{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk:","pos":[0,98]}]},{"pos":[2659,2770],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#27<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]"},{"pos":[2781,2904],"content":"The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 4).","nodes":[{"content":"The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 4).","pos":[0,123]}]},{"pos":[2914,3638],"content":"`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FileGetObject`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.","pos":[0,135],"source":"`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements."},{"content":"On disk, a dynamic array in a user-defined type (written with <ph id=\"ph1\">`FilePutObject`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.","pos":[136,331],"source":" On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.","pos":[332,559],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.VisualBasic.VBFixedStringAttribute&gt;</ph> class can be applied to string fields in the structures to indicate the size of string when written to disk.","pos":[560,724],"source":" The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk."}]},{"pos":[3647,3658],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[3662,3752],"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, all of the <ph id=\"ph2\">`Random`</ph> rules apply, with these exceptions:","source":"For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:"},{"pos":[3762,3931],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FileGetObject`</ph> reads all variables from disk contiguously, that is, with no padding between records.","pos":[68,169],"source":"`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records."}]},{"pos":[3941,4050],"content":"For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FileGetObject`</ph> reads only the data.","pos":[0,86],"source":"For any array other than an array in a structure, `FileGetObject` reads only the data."},{"content":"No descriptor is read.","pos":[87,109]}]},{"pos":[4057,4268],"content":"`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.","nodes":[{"content":"<ph id=\"ph1\">`FileGetObject`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.","pos":[0,131],"source":"`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor."},{"content":"The number of bytes read equals the number of characters already in the string.","pos":[132,211]}]},{"pos":[4276,4475],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.","pos":[13,197],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file named Form1.vb may not be a Visual Basic source file.","pos":[111,184]}]}]}],"pos":[136114,140629],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[141040,141073],"yaml":true},{"content":"Required. Valid variable name into which data is read.","nodes":[{"pos":[0,54],"content":"Required. Valid variable name into which data is read.","nodes":[{"content":"Required. Valid variable name into which data is read.","pos":[0,54],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name into which data is read.","pos":[10,54]}]}]}],"pos":[141134,141189],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which reading starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts."}]}],"pos":[141256,141364],"yaml":true},{"content":"Returns a `Long` value that specifies the length of a file in bytes. The `My` feature gives you better productivity and performance in file I/O operations than `FileLen`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>.","nodes":[{"pos":[0,285],"content":"Returns a `Long` value that specifies the length of a file in bytes. The `My` feature gives you better productivity and performance in file I/O operations than `FileLen`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>.","nodes":[{"content":"Returns a <ph id=\"ph1\">`Long`</ph> value that specifies the length of a file in bytes.","pos":[0,68],"source":"Returns a `Long` value that specifies the length of a file in bytes."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileLen`</ph>.","pos":[69,170],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileLen`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"&gt;&lt;/xref&gt;</ph>.","pos":[171,285],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>."}]}],"pos":[142369,142655],"yaml":true},{"content":"If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.  \n  \n> [!NOTE]\n>  To obtain the current length of an open file, use the `LOF` function.","nodes":[{"pos":[0,146],"content":"If the specified file is open when the <ph id=\"ph1\">`FileLen`</ph> function is called, the value returned represents the size of the file at the time it was opened.","source":"If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened."},{"pos":[154,234],"content":"[!NOTE]\n To obtain the current length of an open file, use the `LOF` function.","leadings":["","> "],"nodes":[{"content":"To obtain the current length of an open file, use the <ph id=\"ph1\">`LOF`</ph> function.","pos":[9,78],"source":" To obtain the current length of an open file, use the `LOF` function."}]}],"pos":[142666,142906],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that specifies a file. <code>PathName</code> may include the directory or folder, and the drive.","nodes":[{"pos":[0,126],"content":"Required. `String` expression that specifies a file. <code>PathName</code> may include the directory or folder, and the drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies a file.","pos":[10,52],"source":"`String` expression that specifies a file."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">PathName</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include the directory or folder, and the drive.","pos":[53,126],"source":"<code>PathName</code> may include the directory or folder, and the drive."}]}],"pos":[143360,143487],"yaml":true},{"content":"`Long` value that specifies the length of a file in bytes.","nodes":[{"pos":[0,58],"content":"<ph id=\"ph1\">`Long`</ph> value that specifies the length of a file in bytes.","source":"`Long` value that specifies the length of a file in bytes."}],"pos":[143543,143604],"yaml":true},{"content":"File does not exist.","nodes":[{"pos":[0,20],"content":"File does not exist.","nodes":[{"content":"File does not exist.","pos":[0,20]}]}],"pos":[143780,143801],"yaml":true},{"content":"Opens a file for input or output. The `My` feature gives you better productivity and performance in file I/O operations than `FileOpen`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,224],"content":"Opens a file for input or output. The `My` feature gives you better productivity and performance in file I/O operations than `FileOpen`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Opens a file for input or output.","pos":[0,33]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileOpen`</ph>.","pos":[34,136],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileOpen`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[137,224],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[145242,145467],"yaml":true},{"content":"The `FileOpen` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n You must open a file before any I/O operation can be performed on it. `FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.  \n  \n> [!IMPORTANT]\n>  When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist. To do so, it needs permission for the directory in which the file is to be created. However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself. Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory. To help improve security, write data to user directories instead of to the root directory or the Program Files directory.  \n  \n The channel to open can be found by using the `FreeFile()` function.  \n  \n> [!IMPORTANT]\n>  The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,332],"content":"The `FileOpen` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`FileOpen`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,90],"source":"The `FileOpen` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[91,184],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[185,332],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[339,516],"content":"You must open a file before any I/O operation can be performed on it. `FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.","nodes":[{"content":"You must open a file before any I/O operation can be performed on it.","pos":[0,69]},{"content":"<ph id=\"ph1\">`FileOpen`</ph> allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.","pos":[70,177],"source":"`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer."}]},{"pos":[524,1155],"content":"[!IMPORTANT]\n When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist. To do so, it needs permission for the directory in which the file is to be created. However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself. Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory. To help improve security, write data to user directories instead of to the root directory or the Program Files directory.","leadings":["","> "],"nodes":[{"content":" When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist. To do so, it needs permission for the directory in which the file is to be created. However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself. Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory. To help improve security, write data to user directories instead of to the root directory or the Program Files directory.","pos":[13,629],"nodes":[{"content":"When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.","pos":[1,125]},{"content":"To do so, it needs permission for the directory in which the file is to be created.","pos":[126,209]},{"content":"However, if the file specified by <ph id=\"ph1\">`FileName`</ph> does exist, the application needs <ph id=\"ph2\">`Write`</ph> permission only to the file itself.","pos":[210,332],"source":" However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself."},{"content":"Wherever possible, to help improve security, create the file during deployment and grant <ph id=\"ph1\">`Write`</ph> permission to that file only, instead of to the whole directory.","pos":[333,494],"source":" Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory."},{"content":"To help improve security, write data to user directories instead of to the root directory or the Program Files directory.","pos":[495,616]}]}]},{"pos":[1162,1230],"content":"The channel to open can be found by using the <ph id=\"ph1\">`FreeFile()`</ph> function.","source":"The channel to open can be found by using the `FreeFile()` function."},{"pos":[1238,1504],"content":"[!IMPORTANT]\n The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","> "],"nodes":[{"content":" The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","pos":[13,264],"nodes":[{"content":"The <ph id=\"ph1\">`FileOpen`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration, which may affect its execution in partial trust situations.","pos":[1,154],"source":" The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[155,251],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}]}],"pos":[145478,146995],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number. Use the `FreeFile` function to obtain the next available file number.","nodes":[{"pos":[0,102],"content":"Required. Any valid file number. Use the `FreeFile` function to obtain the next available file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]},{"content":"Use the <ph id=\"ph1\">`FreeFile`</ph> function to obtain the next available file number.","pos":[33,102],"source":" Use the `FreeFile` function to obtain the next available file number."}]}],"pos":[148568,148671],"yaml":true},{"content":"Required. `String` expression that specifies a file name—may include directory or folder, and drive.","nodes":[{"pos":[0,100],"content":"Required. `String` expression that specifies a file name—may include directory or folder, and drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies a file name—may include directory or folder, and drive.","pos":[10,100],"source":"`String` expression that specifies a file name—may include directory or folder, and drive."}]}],"pos":[148735,148836],"yaml":true},{"content":"Required. Enumeration specifying the file mode: `Append`, `Binary`, `Input`, `Output`, or `Random`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenMode\"></xref> .","nodes":[{"pos":[0,179],"content":"Required. Enumeration specifying the file mode: `Append`, `Binary`, `Input`, `Output`, or `Random`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenMode\"></xref> .","nodes":[{"content":"Required.","pos":[0,9]},{"content":"Enumeration specifying the file mode: <ph id=\"ph1\">`Append`</ph>, <ph id=\"ph2\">`Binary`</ph>, <ph id=\"ph3\">`Input`</ph>, <ph id=\"ph4\">`Output`</ph>, or <ph id=\"ph5\">`Random`</ph>.","pos":[10,99],"source":" Enumeration specifying the file mode: `Append`, `Binary`, `Input`, `Output`, or `Random`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.OpenMode\"&gt;&lt;/xref&gt;</ph> .","pos":[100,179],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.OpenMode\"></xref> ."}]}],"pos":[148913,149095],"yaml":true},{"content":"Optional. Enumeration specifying the operations permitted on the open file: `Read`, `Write`, or `ReadWrite`. Defaults to `ReadWrite`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenAccess\"></xref> .","nodes":[{"pos":[0,215],"content":"Optional. Enumeration specifying the operations permitted on the open file: `Read`, `Write`, or `ReadWrite`. Defaults to `ReadWrite`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenAccess\"></xref> .","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Enumeration specifying the operations permitted on the open file: <ph id=\"ph1\">`Read`</ph>, <ph id=\"ph2\">`Write`</ph>, or <ph id=\"ph3\">`ReadWrite`</ph>.","pos":[10,108],"source":" Enumeration specifying the operations permitted on the open file: `Read`, `Write`, or `ReadWrite`."},{"content":"Defaults to <ph id=\"ph1\">`ReadWrite`</ph>.","pos":[109,133],"source":" Defaults to `ReadWrite`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.OpenAccess\"&gt;&lt;/xref&gt;</ph> .","pos":[134,215],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.OpenAccess\"></xref> ."}]}],"pos":[149176,149394],"yaml":true},{"content":"Optional. Enumeration specifying the operations not permitted on the open file by other processes: `Shared`, `Lock Read`, `Lock Write`, and `Lock Read Write`. Defaults to `Lock Read Write`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenShare\"></xref> .","nodes":[{"pos":[0,270],"content":"Optional. Enumeration specifying the operations not permitted on the open file by other processes: `Shared`, `Lock Read`, `Lock Write`, and `Lock Read Write`. Defaults to `Lock Read Write`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenShare\"></xref> .","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Enumeration specifying the operations not permitted on the open file by other processes: <ph id=\"ph1\">`Shared`</ph>, <ph id=\"ph2\">`Lock Read`</ph>, <ph id=\"ph3\">`Lock Write`</ph>, and <ph id=\"ph4\">`Lock Read Write`</ph>.","pos":[10,158],"source":" Enumeration specifying the operations not permitted on the open file by other processes: `Shared`, `Lock Read`, `Lock Write`, and `Lock Read Write`."},{"content":"Defaults to <ph id=\"ph1\">`Lock Read Write`</ph>.","pos":[159,189],"source":" Defaults to `Lock Read Write`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.OpenShare\"&gt;&lt;/xref&gt;</ph> .","pos":[190,270],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.OpenShare\"></xref> ."}]}],"pos":[149473,149746],"yaml":true},{"content":"Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.","nodes":[{"pos":[0,194],"content":"Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.","nodes":[{"content":"Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.","pos":[0,194],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Number less than or equal to 32,767 (bytes).","pos":[10,54]},{"content":"For files opened for random access, this value is the record length.","pos":[55,123]},{"content":"For sequential files, this value is the number of characters buffered.","pos":[124,194]}]}]}],"pos":[149813,150008],"yaml":true},{"content":"Record length is negative (and not equal to -1).","nodes":[{"pos":[0,48],"content":"Record length is negative (and not equal to -1).","nodes":[{"content":"Record length is negative (and not equal to -1).","pos":[0,48]}]}],"pos":[150171,150220],"yaml":true},{"content":"<code>FileName</code> is already open, or <code>FileName</code> is invalid.","nodes":[{"pos":[0,75],"content":"<ph id=\"ph1\">&lt;code&gt;FileName&lt;/code&gt;</ph> is already open, or <ph id=\"ph2\">&lt;code&gt;FileName&lt;/code&gt;</ph> is invalid.","source":"<code>FileName</code> is already open, or <code>FileName</code> is invalid."}],"pos":[150308,150384],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[151426,151660],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[151671,157674],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[158126,158159],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[158219,158285],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[158352,158460],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[158622,158673],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[158761,158783],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>..","nodes":[{"pos":[0,234],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>..","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>..","pos":[146,234],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.."}]}],"pos":[159903,160138],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[160149,166152],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[166640,166673],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[166734,166800],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[166867,166975],"yaml":true},{"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is `False`.","nodes":[{"pos":[0,160],"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is `False`.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Applies only when writing a string.","pos":[10,45]},{"content":"Specifies whether to write a two-byte string length descriptor for the string to the file.","pos":[46,136]},{"content":"The default is <ph id=\"ph1\">`False`</ph>.","pos":[137,160],"source":" The default is `False`."}]}],"pos":[167051,167212],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[167374,167425],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[167513,167535],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[168595,168829],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[168840,174843],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[175545,175578],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[175639,175705],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[175773,175881],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[176043,176094],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[176182,176204],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[177319,177553],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1533],"content":"If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the<ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,194],"source":"If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[195,324]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[325,498]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[499,661],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1543,1879],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1889,2435],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2445,3021],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3031,4052],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4063,4174],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4184,4484],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4494,4753],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4765,4898],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4907,4918],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4922,5112],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5122,5284],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5294,5401],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5411,5673],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5684,5795],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5805,5958],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[177564,183566],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[184023,184056],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[184120,184186],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[184253,184361],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[184523,184574],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[184662,184684],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[185732,185966],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[185977,191980],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[192433,192466],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[192527,192593],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[192660,192768],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[192930,192981],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[193069,193091],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[194133,194367],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[194378,200381],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[200832,200865],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[200925,200991],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[201058,201166],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[201328,201379],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[201467,201489],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[202675,202909],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[202920,208923],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[209439,209472],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[209532,209598],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[209665,209773],"yaml":true},{"content":"Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.","nodes":[{"pos":[0,185],"content":"Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.","nodes":[{"content":"Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.","pos":[0,185],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Applies only when writing an array.","pos":[10,45]},{"content":"Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.","pos":[46,185]}]}]}],"pos":[209844,210030],"yaml":true},{"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is `False`.","nodes":[{"pos":[0,160],"content":"Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is `False`.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Applies only when writing a string.","pos":[10,45]},{"content":"Specifies whether to write a two-byte string length descriptor for the string to the file.","pos":[46,136]},{"content":"The default is <ph id=\"ph1\">`False`</ph>.","pos":[137,160],"source":" The default is `False`."}]}],"pos":[210106,210267],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[210429,210480],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[210568,210590],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[211638,211872],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[211883,217886],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[218340,218373],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[218434,218500],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[218567,218675],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[218837,218888],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[218976,218998],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[220052,220286],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[220297,226300],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[226755,226788],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[226850,226916],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[226983,227091],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[227253,227304],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[227392,227414],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[228474,228708],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[228719,234722],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[235178,235211],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[235274,235340],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[235407,235515],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[235677,235728],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[235816,235838],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[236874,237108],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[237119,243122],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[243574,243607],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[243666,243732],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[243799,243907],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[244069,244120],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[244208,244230],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[245266,245500],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[245511,251514],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[251966,251999],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[252058,252124],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[252191,252299],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[252461,252512],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[252600,252622],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[253676,253910],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3022],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,241],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[242,402],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[403,576],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3032,4053],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4064,4175],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4185,4485],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4495,4754],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4766,4899],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4908,4919],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4923,5113],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5123,5285],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5295,5402],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5412,5674],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5685,5796],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5806,5959],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[253921,259924],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[260376,260409],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[260471,260537],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[260604,260712],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[260874,260925],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[261013,261035],"yaml":true},{"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,233],"content":"Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePut`</ph>.","pos":[44,145],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[146,233],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[262077,262311],"yaml":true},{"content":"`FilePut` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePut` is usually read from a file by using `FileGet`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \n  \n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \n  \n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \n  \n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \n  \n    > [!NOTE]\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \n  \n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \n  \n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \n  \n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">`FilePut`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePut` is valid only in `Random` and `Binary` mode."},{"pos":[61,136],"content":"Data written with <ph id=\"ph1\">`FilePut`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGet`</ph>.","source":"Data written with `FilePut` is usually read from a file by using `FileGet`."},{"pos":[143,403],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, the next record or byte after the last <ph id=\"ph2\">`FileGet`</ph> or <ph id=\"ph3\">`FilePut`</ph> function or pointed to by the last <ph id=\"ph4\">`Seek`</ph> function is written.","pos":[108,260],"source":" If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written."}]},{"pos":[410,777],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePut`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,188],"source":"`FilePut` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePut`</ph>, you have to do the same with <ph id=\"ph5\">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.","pos":[189,367],"source":" If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected."}]},{"pos":[786,797],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[801,862],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[872,1534],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePut`</ph> writes subsequent records on record-length boundaries.","pos":[0,195],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[196,325]},{"content":"Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.","pos":[326,499]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception will be thrown.","pos":[500,662],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown."}]},{"pos":[1544,1880],"content":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.","nodes":[{"content":"If the variable being written is a string, <ph id=\"ph1\">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.","pos":[0,168],"source":"If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable."},{"content":"Therefore, the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.","pos":[169,336],"source":" Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string."}]},{"pos":[1890,2436],"content":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePut`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,169],"source":"If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[170,360],"source":" For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[361,546],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2446,3021],"content":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePut`</ph> writes a two byte descriptor identifying the<ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,240],"source":"If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[241,401],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[402,575],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3031,4052],"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.","nodes":[{"content":"If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.","pos":[0,145]},{"content":"Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.","pos":[146,261]},{"content":"Visual Basic 2005 defaults to not writing the descriptor.","pos":[262,319]},{"content":"To write the descriptor, set the <ph id=\"ph1\">`ArrayIsDynamic`</ph> parameter to <ph id=\"ph2\">`True`</ph>.","pos":[320,390],"source":" To write the descriptor, set the `ArrayIsDynamic` parameter to `True`."},{"content":"When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.","pos":[391,538]},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[539,632]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[633,721]},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[722,922],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"For example, the following array declaration requires 218 bytes when the array is written to disk.","pos":[923,1021]}]},{"pos":[4063,4174],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#43<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]"},{"pos":[4184,4484],"content":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.","nodes":[{"content":"If the variable being written is any other type of variable (not a variable-length string or an object), <ph id=\"ph1\">`FilePut`</ph> writes only the variable data.","pos":[0,145],"source":"If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.","pos":[146,300],"source":" The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written."}]},{"pos":[4494,4753],"content":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.","pos":[0,122],"source":"`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements."},{"content":"The <ph id=\"ph1\">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.","pos":[123,259],"source":" The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk."}]},{"pos":[4765,4898],"content":"[!NOTE]\nString fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,","leadings":["","    >  "],"nodes":[{"content":"String fields that have more bytes than specified by the <ph id=\"ph1\">`VBFixedString`</ph> attribute are truncated when written to disk,","pos":[8,126],"source":"String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,"}]},{"pos":[4907,4918],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[4922,5112],"content":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:","nodes":[{"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, most of the <ph id=\"ph2\">`Random`</ph> mode rules apply, with some exceptions.","pos":[0,95],"source":"For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions."},{"content":"The following rules for files opened in <ph id=\"ph1\">`Binary`</ph> mode differ from the rules for <ph id=\"ph2\">`Random`</ph> mode:","pos":[96,190],"source":" The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:"}]},{"pos":[5122,5284],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,162],"source":"`FilePut` writes all variables to disk contiguously, that is, without padding between records."}]},{"pos":[5294,5401],"content":"For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.","nodes":[{"content":"For any array other than an array in a structure, <ph id=\"ph1\">`FilePut`</ph> writes only the data.","pos":[0,81],"source":"For any array other than an array in a structure, `FilePut` writes only the data."},{"content":"No descriptor is written.","pos":[82,107]}]},{"pos":[5411,5673],"content":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:","nodes":[{"content":"<ph id=\"ph1\">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.","pos":[0,116],"source":"`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor."},{"content":"The number of bytes written equals the number of characters in the string.","pos":[117,191]},{"content":"For example, the following statements write 11 bytes to file number 1:","pos":[192,262]}]},{"pos":[5684,5795],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#44<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]"},{"pos":[5805,5958],"content":"Writing to a file by using the <ph id=\"ph1\">`FilePut`</ph> function requires <ph id=\"ph2\">`Write`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","source":"Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}],"pos":[262322,268324],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[268777,268810],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[268870,268936],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[269003,269111],"yaml":true},{"content":"<code>RecordNumber</code> < 1 and not equal to -1.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">&lt;code&gt;RecordNumber&lt;/code&gt;</ph> &lt; 1 and not equal to -1.","source":"<code>RecordNumber</code> < 1 and not equal to -1."}],"pos":[269273,269324],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[269412,269434],"yaml":true},{"content":"Writes data from a variable to a disk file.  The `My` feature gives you better productivity and performance in file I/O operations than `FilePutObject`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,240],"content":"Writes data from a variable to a disk file.  The `My` feature gives you better productivity and performance in file I/O operations than `FilePutObject`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Writes data from a variable to a disk file.","pos":[0,43]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FilePutObject`</ph>.","pos":[45,152],"source":"  The `My` feature gives you better productivity and performance in file I/O operations than `FilePutObject`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[153,240],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[270518,270759],"yaml":true},{"content":"The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n `FilePutObject` writes and reads descriptors that describe the object. If you intend to write out the `Variant` type, `FilePutObject` is required. When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.  \n  \n `FilePutObject` is valid only in `Random` and `Binary` mode.  \n  \n Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).  \n  \n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePutObject` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.  \n  \n-   If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \n  \n-   If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all the `Random` mode rules apply, except:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePutObject` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"pos":[0,196],"content":"The <ph id=\"ph1\">`FilePutObject`</ph> function is used instead of <ph id=\"ph2\">`FilePut`</ph> to avoid ambiguities at compile time if type <ph id=\"ph3\">`Object`</ph> is passed instead of another type, such as <ph id=\"ph4\">`Integer`</ph>, <ph id=\"ph5\">`Long`</ph>, <ph id=\"ph6\">`Short`</ph>, and so forth.","source":"The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth."},{"pos":[203,487],"content":"`FilePutObject` writes and reads descriptors that describe the object. If you intend to write out the `Variant` type, `FilePutObject` is required. When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.","nodes":[{"content":"<ph id=\"ph1\">`FilePutObject`</ph> writes and reads descriptors that describe the object.","pos":[0,70],"source":"`FilePutObject` writes and reads descriptors that describe the object."},{"content":"If you intend to write out the <ph id=\"ph1\">`Variant`</ph> type, <ph id=\"ph2\">`FilePutObject`</ph> is required.","pos":[71,146],"source":" If you intend to write out the `Variant` type, `FilePutObject` is required."},{"content":"When in doubt, if you are using an object for the second parameter, we recommend that you always use <ph id=\"ph1\">`FilePutObject`</ph> and <ph id=\"ph2\">`FileGetObject`</ph>.","pos":[147,284],"source":" When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`."}]},{"pos":[494,554],"content":"<ph id=\"ph1\">`FilePutObject`</ph> is valid only in <ph id=\"ph2\">`Random`</ph> and <ph id=\"ph3\">`Binary`</ph> mode.","source":"`FilePutObject` is valid only in `Random` and `Binary` mode."},{"pos":[561,648],"content":"Data written with <ph id=\"ph1\">`FilePutObject`</ph> is usually read from a file by using <ph id=\"ph2\">`FileGetObject`</ph>.","source":"Data written with `FilePutObject` is usually read from a file by using `FileGetObject`."},{"pos":[655,960],"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).","nodes":[{"content":"The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.","pos":[0,107]},{"content":"If you omit <ph id=\"ph1\">`RecordNumber`</ph>, <ph id=\"ph2\">`FilePutObject`</ph> writes the next record or byte after the last <ph id=\"ph3\">`FileGetObject`</ph> or <ph id=\"ph4\">`FilePutObject`</ph> function (or the record or byte pointed to by the last <ph id=\"ph5\">`Seek`</ph> function).","pos":[108,305],"source":" If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function)."}]},{"pos":[967,1354],"content":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePutObject` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.","nodes":[{"content":"The <ph id=\"ph1\">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.","pos":[0,112],"source":"The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length."},{"content":"<ph id=\"ph1\">`FilePutObject`</ph> does not write the length descriptor when the argument is <ph id=\"ph2\">`True`</ph>.","pos":[113,194],"source":"`FilePutObject` does not write the length descriptor when the argument is `True`."},{"content":"If you use <ph id=\"ph1\">`StringIsFixedLength`</ph><ph id=\"ph2\"> = </ph><ph id=\"ph3\">`True`</ph> with <ph id=\"ph4\">`FilePutObject`</ph>, you have to do the same with <ph id=\"ph5\">`FileGetObject`</ph>, and you must also make sure that the string is initialized to the length expected.","pos":[195,387],"source":" If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected."}]},{"pos":[1363,1374],"content":"Random Mode","linkify":"Random Mode","nodes":[{"content":"Random Mode","pos":[0,11]}]},{"pos":[1378,1439],"content":"For files opened in <ph id=\"ph1\">`Random`</ph> mode, the following rules apply:","source":"For files opened in `Random` mode, the following rules apply:"},{"pos":[1449,2103],"content":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.","nodes":[{"content":"If the length of the data being written is less than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, <ph id=\"ph3\">`FilePutObject`</ph> writes subsequent records on record-length boundaries.","pos":[0,201],"source":"If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries."},{"content":"The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.","pos":[202,331]},{"content":"Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.","pos":[332,496]},{"content":"If the length of the data being written is greater than the length specified in the <ph id=\"ph1\">`RecordLength`</ph> clause of the <ph id=\"ph2\">`FileOpen`</ph> function, an exception is thrown.","pos":[497,654],"source":" If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown."}]},{"pos":[2113,2671],"content":"If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.","nodes":[{"content":"If the variable being written is an object that contains a numeric type, <ph id=\"ph1\">`FilePutObject`</ph> writes two bytes identifying the <ph id=\"ph2\">`VarType`</ph> of the object and then writes the variable.","pos":[0,175],"source":"If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable."},{"content":"For example, when writing an object that contains an integer, <ph id=\"ph1\">`FilePutObject`</ph> writes six bytes: two bytes that identify the object as <ph id=\"ph2\">`VarType(3)`</ph> (<ph id=\"ph3\">`Integer`</ph>) and four bytes that contain the data.","pos":[176,372],"source":" For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.","pos":[373,558],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable."}]},{"pos":[2681,3263],"content":"If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.","nodes":[{"content":"If the variable being written is an object that contains a string, <ph id=\"ph1\">`FilePutObject`</ph> writes a two-byte descriptor identifying the <ph id=\"ph2\">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.","pos":[0,247],"source":"If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data."},{"content":"The record length specified by the <ph id=\"ph1\">`RecordLength`</ph> parameter in the <ph id=\"ph2\">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.","pos":[248,408],"source":" The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string."},{"content":"If you want to put a string without the descriptor, you should pass <ph id=\"ph1\">`True`</ph> to the <ph id=\"ph2\">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.","pos":[409,582],"source":" If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length."}]},{"pos":[3273,3704],"content":"If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","nodes":[{"content":"If the variable being written is an array, then the record length specified by the <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.","pos":[0,248],"source":"If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor."},{"content":"The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.","pos":[249,342]},{"content":"Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).","pos":[343,431]}]},{"pos":[3713,3724],"content":"Binary Mode","linkify":"Binary Mode","nodes":[{"content":"Binary Mode","pos":[0,11]}]},{"pos":[3728,3805],"content":"For files opened in <ph id=\"ph1\">`Binary`</ph> mode, all the <ph id=\"ph2\">`Random`</ph> mode rules apply, except:","source":"For files opened in `Binary` mode, all the `Random` mode rules apply, except:"},{"pos":[3815,3983],"content":"The `RecordLength` clause in the `FileOpen` function has no effect. `FilePutObject` writes all variables to disk contiguously, that is, without padding between records.","nodes":[{"content":"The <ph id=\"ph1\">`RecordLength`</ph> clause in the <ph id=\"ph2\">`FileOpen`</ph> function has no effect.","pos":[0,67],"source":"The `RecordLength` clause in the `FileOpen` function has no effect."},{"content":"<ph id=\"ph1\">`FilePutObject`</ph> writes all variables to disk contiguously, that is, without padding between records.","pos":[68,168],"source":"`FilePutObject` writes all variables to disk contiguously, that is, without padding between records."}]}],"pos":[270770,274782],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[275188,275221],"yaml":true},{"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"pos":[0,65],"content":"Required. Valid variable name that contains data written to disk.","nodes":[{"content":"Required. Valid variable name that contains data written to disk.","pos":[0,65],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Valid variable name that contains data written to disk.","pos":[10,65]}]}]}],"pos":[275282,275348],"yaml":true},{"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"pos":[0,107],"content":"Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Record number (<ph id=\"ph1\">`Random`</ph> mode files) or byte number (<ph id=\"ph2\">`Binary`</ph> mode files) at which writing starts.","pos":[10,107],"source":" Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts."}]}],"pos":[275415,275523],"yaml":true},{"content":"Assigns an output line width to a file opened by using the `FileOpen` function.","nodes":[{"pos":[0,79],"content":"Assigns an output line width to a file opened by using the <ph id=\"ph1\">`FileOpen`</ph> function.","source":"Assigns an output line width to a file opened by using the `FileOpen` function."}],"pos":[276594,276674],"yaml":true},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[277077,277110],"yaml":true},{"content":"Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <code>RecordWidth</code> equals 0, there is no limit to the length of a line. The default value for <code>RecordWidth</code> is 0.","nodes":[{"pos":[0,276],"content":"Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <code>RecordWidth</code> equals 0, there is no limit to the length of a line. The default value for <code>RecordWidth</code> is 0.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.","pos":[10,142]},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">RecordWidth</ph><ept id=\"p1\">&lt;/code&gt;</ept> equals 0, there is no limit to the length of a line.","pos":[143,223],"source":" If <code>RecordWidth</code> equals 0, there is no limit to the length of a line."},{"content":"The default value for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">RecordWidth</ph><ept id=\"p1\">&lt;/code&gt;</ept> is 0.","pos":[224,276],"source":" The default value for <code>RecordWidth</code> is 0."}]}],"pos":[277176,277453],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[277611,277633],"yaml":true},{"content":"Returns an `Integer` value that represents the next file number available for use by the `FileOpen` function.","nodes":[{"pos":[0,109],"content":"Returns an <ph id=\"ph1\">`Integer`</ph> value that represents the next file number available for use by the <ph id=\"ph2\">`FileOpen`</ph> function.","source":"Returns an `Integer` value that represents the next file number available for use by the `FileOpen` function."}],"pos":[278504,278614],"yaml":true},{"content":"Use `FreeFile` to supply a file number that is not already being used.","nodes":[{"pos":[0,70],"content":"Use <ph id=\"ph1\">`FreeFile`</ph> to supply a file number that is not already being used.","source":"Use `FreeFile` to supply a file number that is not already being used."}],"pos":[278625,278696],"yaml":true,"extradata":"MT"},{"content":"Returns an `Integer` value that represents the next file number available for use by the `FileOpen` function.","nodes":[{"pos":[0,109],"content":"Returns an <ph id=\"ph1\">`Integer`</ph> value that represents the next file number available for use by the <ph id=\"ph2\">`FileOpen`</ph> function.","source":"Returns an `Integer` value that represents the next file number available for use by the `FileOpen` function."}],"pos":[279137,279247],"yaml":true},{"content":"More than 255 files are in use.","nodes":[{"pos":[0,31],"content":"More than 255 files are in use.","nodes":[{"content":"More than 255 files are in use.","pos":[0,31]}]}],"pos":[279404,279436],"yaml":true},{"content":"Returns a `FileAttribute` value that represents the attributes of a file, directory, or folder. The `My` feature gives you better productivity and performance in file I/O operations than `FileAttribute`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,291],"content":"Returns a `FileAttribute` value that represents the attributes of a file, directory, or folder. The `My` feature gives you better productivity and performance in file I/O operations than `FileAttribute`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Returns a <ph id=\"ph1\">`FileAttribute`</ph> value that represents the attributes of a file, directory, or folder.","pos":[0,95],"source":"Returns a `FileAttribute` value that represents the attributes of a file, directory, or folder."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`FileAttribute`</ph>.","pos":[96,203],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `FileAttribute`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[204,291],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[280364,280656],"yaml":true},{"content":"To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want. If the result is not zero, that attribute is set for the named file. For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:  \n  \n```vb  \nResult = GetAttr(FName) And vbArchive  \n```  \n  \n A nonzero value is returned if the `Archive` attribute is set.","nodes":[{"pos":[0,378],"content":"To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want. If the result is not zero, that attribute is set for the named file. For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:","nodes":[{"content":"To determine which attributes are set, use the <ph id=\"ph1\">`And`</ph> operator to perform a bitwise comparison of the value returned by the <ph id=\"ph2\">`GetAttr`</ph> function and the value of the individual file attribute you want.","pos":[0,198],"source":"To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want."},{"content":"If the result is not zero, that attribute is set for the named file.","pos":[199,267]},{"content":"For example, the return value of the following <ph id=\"ph1\">`And`</ph> expression is zero if the <ph id=\"ph2\">`Archive`</ph> attribute is not set:","pos":[268,378],"source":" For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:"}]},{"pos":[442,504],"content":"A nonzero value is returned if the <ph id=\"ph1\">`Archive`</ph> attribute is set.","source":"A nonzero value is returned if the `Archive` attribute is set."}],"pos":[280667,281180],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that specifies a file, directory, or folder name. <code>PathName</code> can include the directory or folder, and the drive.","nodes":[{"pos":[0,153],"content":"Required. `String` expression that specifies a file, directory, or folder name. <code>PathName</code> can include the directory or folder, and the drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies a file, directory, or folder name.","pos":[10,79],"source":"`String` expression that specifies a file, directory, or folder name."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">PathName</ph><ept id=\"p1\">&lt;/code&gt;</ept> can include the directory or folder, and the drive.","pos":[80,153],"source":"<code>PathName</code> can include the directory or folder, and the drive."}]}],"pos":[281601,281755],"yaml":true},{"content":"The value returned by `GetAttr` is the sum of the following enumeration values:  \n  \n <table><tbody><tr><td> Value  \n  \n </td><td> Constant  \n  \n  Description  \n  \n </td></tr><tr><td>`Normal`</td><td>`vbNormal` Normal.  \n  \n </td></tr><tr><td>`ReadOnly`</td><td>`vbReadOnly` Read-only.  \n  \n </td></tr><tr><td>`Hidden`</td><td>`vbHidden` Hidden.  \n  \n </td></tr><tr><td>`System`</td><td>`vbSystem` System file.  \n  \n </td></tr><tr><td>`Directory`</td><td>`vbDirectory` Directory or folder.  \n  \n </td></tr><tr><td>`Archive`</td><td>`vbArchive` File has changed since last backup.  \n  \n </td></tr><tr><td>`Alias`</td><td>`vbAlias` File has a different name.  \n  \n </td></tr></tbody></table><block subset=\"none\" type=\"note\"><p>  \n These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  \n  \n</p></block>","nodes":[{"pos":[0,79],"content":"The value returned by <ph id=\"ph1\">`GetAttr`</ph> is the sum of the following enumeration values:","source":"The value returned by `GetAttr` is the sum of the following enumeration values:"},{"pos":[86,139],"content":"<table><tbody><tr><td> Value  \n  \n </td><td> Constant","nodes":[{"content":"Value","pos":[23,33],"source":" Value  \n  \n "},{"content":"Constant","pos":[45,53]}]},{"pos":[147,158],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[165,885],"content":"</td></tr><tr><td>`Normal`</td><td>`vbNormal` Normal.  \n  \n </td></tr><tr><td>`ReadOnly`</td><td>`vbReadOnly` Read-only.  \n  \n </td></tr><tr><td>`Hidden`</td><td>`vbHidden` Hidden.  \n  \n </td></tr><tr><td>`System`</td><td>`vbSystem` System file.  \n  \n </td></tr><tr><td>`Directory`</td><td>`vbDirectory` Directory or folder.  \n  \n </td></tr><tr><td>`Archive`</td><td>`vbArchive` File has changed since last backup.  \n  \n </td></tr><tr><td>`Alias`</td><td>`vbAlias` File has a different name.  \n  \n </td></tr></tbody></table><block subset=\"none\" type=\"note\"><p>  \n These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  \n  \n</p></block>","nodes":[{"content":"`vbNormal` Normal.  \n  \n ","pos":[35,60],"nodes":[{"content":"<ph id=\"ph1\">`vbNormal`</ph> Normal.","pos":[0,18],"source":"`vbNormal` Normal."}]},{"content":"`vbReadOnly` Read-only.  \n  \n ","pos":[97,127],"nodes":[{"content":"<ph id=\"ph1\">`vbReadOnly`</ph> Read-only.","pos":[0,23],"source":"`vbReadOnly` Read-only."}]},{"content":"`vbHidden` Hidden.  \n  \n ","pos":[162,187],"nodes":[{"content":"<ph id=\"ph1\">`vbHidden`</ph> Hidden.","pos":[0,18],"source":"`vbHidden` Hidden."}]},{"content":"`vbSystem` System file.  \n  \n ","pos":[222,252],"nodes":[{"content":"<ph id=\"ph1\">`vbSystem`</ph> System file.","pos":[0,23],"source":"`vbSystem` System file."}]},{"content":"`vbDirectory` Directory or folder.  \n  \n ","pos":[290,331],"nodes":[{"content":"<ph id=\"ph1\">`vbDirectory`</ph> Directory or folder.","pos":[0,34],"source":"`vbDirectory` Directory or folder."}]},{"content":"`vbArchive` File has changed since last backup.  \n  \n ","pos":[367,421],"nodes":[{"content":"<ph id=\"ph1\">`vbArchive`</ph> File has changed since last backup.","pos":[0,47],"source":"`vbArchive` File has changed since last backup."}]},{"content":"`vbAlias` File has a different name.  \n  \n ","pos":[455,498],"nodes":[{"content":"<ph id=\"ph1\">`vbAlias`</ph> File has a different name.","pos":[0,36],"source":"`vbAlias` File has a different name."}]},{"content":"  \n These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  \n  \n","pos":[560,707],"nodes":[{"content":"These enumerations are specified by the Visual Basic language.","pos":[1,66],"source":"  \n These enumerations are specified by the Visual Basic language."},{"content":"The names can be used anywhere in your code in place of the actual values.","pos":[67,141]}]}]}],"pos":[281834,282750],"yaml":true},{"content":"<code>Pathname</code> is invalid or contains wildcards.","nodes":[{"pos":[0,55],"content":"<ph id=\"ph1\">&lt;code&gt;Pathname&lt;/code&gt;</ph> is invalid or contains wildcards.","source":"<code>Pathname</code> is invalid or contains wildcards."}],"pos":[282906,282962],"yaml":true},{"content":"Target file does not exist.","nodes":[{"pos":[0,27],"content":"Target file does not exist.","nodes":[{"content":"Target file does not exist.","pos":[0,27]}]}],"pos":[283070,283098],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[284077,284152],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[284163,285921],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[286537,286570],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[286631,286736],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[286890,286912],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[287885,287960],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[287971,289729],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[290343,290376],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[290436,290541],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[290695,290717],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[291690,291765],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1502],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.","pos":[8,206],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.","pos":[40,198]}]}]},{"pos":[1510,1730],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[291776,293532],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[294145,294178],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[294238,294343],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[294497,294519],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[295492,295567],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[295578,297336],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[297951,297984],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[298044,298149],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[298303,298325],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[299304,299379],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[299390,301148],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[301764,301797],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[301858,301963],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[302117,302139],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[303124,303199],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[303210,304968],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[305579,305612],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[305674,305779],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[305933,305955],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[306946,307021],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[307032,308790],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[309408,309441],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[309504,309609],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[309763,309785],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[310752,310827],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[310838,312596],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[313210,313243],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[313302,313407],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[313561,313583],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[314550,314625],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[314636,316394],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[317005,317038],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[317097,317202],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[317356,317378],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[318357,318432],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[318443,320201],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[320816,320849],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[320910,321015],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[321169,321191],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[322176,322251],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[322262,324020],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[324637,324670],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[324732,324837],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[324991,325013],"yaml":true},{"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"pos":[0,74],"content":"Reads data from an open sequential file and assigns the data to variables.","nodes":[{"content":"Reads data from an open sequential file and assigns the data to variables.","pos":[0,74]}]}],"pos":[325992,326067],"yaml":true},{"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \n  \n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \n  \n|Data|Value assigned to variable|  \n|-|-|  \n|Delimiting comma or blank line|Empty|  \n|#NULL#|`DBNull`|  \n|#TRUE# or #FALSE#|`True` or `False`|  \n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \n  \n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \n  \n> [!NOTE]\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","nodes":[{"pos":[0,329],"content":"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,87],"source":"The `Input` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[88,181],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[182,329],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[336,475],"content":"Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with <ph id=\"ph1\">`Input`</ph> is usually written to a file by using <ph id=\"ph2\">`Write`</ph>.","pos":[0,69],"source":"Data read with `Input` is usually written to a file by using `Write`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[70,139],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[483,697],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[13,212],"nodes":[{"content":"When reading from files, do not make decisions about the contents of the file based on the file name extension.","pos":[1,112]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.","pos":[113,199]}]}]},{"pos":[704,858],"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.","pos":[0,154],"nodes":[{"content":"When read, standard string or numeric data is assigned to variables without modification.","pos":[0,89]},{"content":"The following table illustrates how other input data is treated.","pos":[90,154]}]}]},{"pos":[865,869],"content":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[870,896],"content":"Value assigned to variable","nodes":[{"content":"Value assigned to variable","pos":[0,26]}]},{"pos":[909,939],"content":"Delimiting comma or blank line","nodes":[{"content":"Delimiting comma or blank line","pos":[0,30]}]},{"pos":[940,945],"content":"Empty","nodes":[{"content":"Empty","pos":[0,5]}]},{"pos":[950,956],"content":"#NULL#","nodes":[{"content":"#NULL#","pos":[0,6]}]},{"pos":[970,987],"content":"#TRUE# or #FALSE#","nodes":[{"content":"#TRUE# or #FALSE#","pos":[0,17]}]},{"pos":[988,1005],"content":"<ph id=\"ph1\">`True`</ph> or <ph id=\"ph2\">`False`</ph>","source":"`True` or `False`"},{"pos":[1034,1084],"content":"The date and/or time represented by the expression","nodes":[{"content":"The date and/or time represented by the expression","pos":[0,50]}]},{"pos":[1089,1110],"content":"#ERROR <ph id=\"ph1\">`errornumber`</ph><ph id=\"ph2\">#</ph>","source":"#ERROR `errornumber`#"},{"pos":[1111,1167],"content":"<ph id=\"ph1\">`errornumber`</ph> (variable is an object tagged as an error)","source":"`errornumber` (variable is an object tagged as an error)"},{"pos":[1175,1286],"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","nodes":[{"content":"If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.","pos":[0,111]}]},{"pos":[1294,1504],"content":"[!NOTE]\n The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","leadings":["","> "],"nodes":[{"content":" The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[8,208],"nodes":[{"content":"The <ph id=\"ph1\">`Input`</ph> function is not localized.","pos":[1,39],"source":" The `Input` function is not localized."},{"content":"For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.","pos":[40,200]}]}]},{"pos":[1512,1732],"content":"[!IMPORTANT]\n Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","leadings":["","> "],"nodes":[{"content":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.","pos":[13,218],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`Input`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">`FileIOPermissionAccess`</ph> enumeration.","pos":[1,120],"source":" Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.","pos":[121,205],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>."}]}]}],"pos":[326078,327836],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[328452,328485],"yaml":true},{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"pos":[0,104],"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","nodes":[{"content":"Required. Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[0,104],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Variable that is assigned the values read from the file—cannot be an array or object variable.","pos":[10,104]}]}]}],"pos":[328546,328651],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[328805,328827],"yaml":true},{"content":"Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode. The `My` feature gives you better productivity and performance in file I/O operations than `InputString`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,289],"content":"Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode. The `My` feature gives you better productivity and performance in file I/O operations than `InputString`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Returns <ph id=\"ph1\">`String`</ph> value that contains characters from a file opened in <ph id=\"ph2\">`Input`</ph> or <ph id=\"ph3\">`Binary`</ph> mode.","pos":[0,95],"source":"Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`InputString`</ph>.","pos":[96,201],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `InputString`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[202,289],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[329833,330123],"yaml":true},{"content":"The `InputString` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`. Use this function only with files opened in `Input` or `Binary` mode.  \n  \n Unlike the `Input` function, the `InputString` function returns all the characters it reads. This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.  \n  \n With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error. Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.  \n  \n> [!NOTE]\n>  When reading from files, do not make security decisions about the contents of the file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.","nodes":[{"pos":[0,335],"content":"The `InputString` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`InputString`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,93],"source":"The `InputString` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[94,187],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[188,335],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[342,513],"content":"Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`. Use this function only with files opened in `Input` or `Binary` mode.","nodes":[{"content":"Data read with the <ph id=\"ph1\">`InputString`</ph> function is usually written to a file by using <ph id=\"ph2\">`Print`</ph> or <ph id=\"ph3\">`FilePut`</ph>.","pos":[0,101],"source":"Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`."},{"content":"Use this function only with files opened in <ph id=\"ph1\">`Input`</ph> or <ph id=\"ph2\">`Binary`</ph> mode.","pos":[102,171],"source":" Use this function only with files opened in `Input` or `Binary` mode."}]},{"pos":[520,701],"content":"Unlike the `Input` function, the `InputString` function returns all the characters it reads. This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.","nodes":[{"content":"Unlike the <ph id=\"ph1\">`Input`</ph> function, the <ph id=\"ph2\">`InputString`</ph> function returns all the characters it reads.","pos":[0,92],"source":"Unlike the `Input` function, the `InputString` function returns all the characters it reads."},{"content":"This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.","pos":[93,181]}]},{"pos":[708,1017],"content":"With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error. Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.","nodes":[{"content":"With files opened for <ph id=\"ph1\">`Binary`</ph> access, an attempt to read through the file by using the <ph id=\"ph2\">`InputString`</ph> function until <ph id=\"ph3\">`EOF`</ph> returns <ph id=\"ph4\">`True`</ph> generates an error.","pos":[0,157],"source":"With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error."},{"content":"Use the <ph id=\"ph1\">`LOF`</ph> and <ph id=\"ph2\">`Loc`</ph> functions instead of <ph id=\"ph3\">`EOF`</ph> when you read binary files by using <ph id=\"ph4\">`InputString`</ph>, or use <ph id=\"ph5\">`FileGet`</ph> when you use the <ph id=\"ph6\">`EOF`</ph> function.","pos":[158,309],"source":" Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function."}]},{"pos":[1025,1230],"content":"[!NOTE]\n When reading from files, do not make security decisions about the contents of the file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make security decisions about the contents of the file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.","pos":[8,203],"nodes":[{"content":"When reading from files, do not make security decisions about the contents of the file based on the file name extension.","pos":[1,121]},{"content":"For example, a file named Form1.vb may not be a Visual Basic source file.","pos":[122,195]}]}]}],"pos":[330134,331376],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[331898,331931],"yaml":true},{"content":"Required. Any valid numeric expression specifying the number of characters to read.","nodes":[{"pos":[0,83],"content":"Required. Any valid numeric expression specifying the number of characters to read.","nodes":[{"content":"Required. Any valid numeric expression specifying the number of characters to read.","pos":[0,83],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid numeric expression specifying the number of characters to read.","pos":[10,83]}]}]}],"pos":[331995,332079],"yaml":true},{"content":"Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode. The `My` feature gives you better productivity and performance in file I/O operations than `InputString`.","nodes":[{"pos":[0,201],"content":"Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode. The `My` feature gives you better productivity and performance in file I/O operations than `InputString`.","nodes":[{"content":"Returns <ph id=\"ph1\">`String`</ph> value that contains characters from a file opened in <ph id=\"ph2\">`Input`</ph> or <ph id=\"ph3\">`Binary`</ph> mode.","pos":[0,95],"source":"Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`InputString`</ph>.","pos":[96,201],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `InputString`."}]}],"pos":[332136,332338],"yaml":true},{"content":"<code>FileNumber</code> does not exist.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;FileNumber&lt;/code&gt;</ph> does not exist.","source":"<code>FileNumber</code> does not exist."}],"pos":[332498,332538],"yaml":true},{"content":"<code>CharCount</code> < 0 or > 214.","nodes":[{"pos":[0,36],"content":"<ph id=\"ph1\">&lt;code&gt;CharCount&lt;/code&gt;</ph> &lt; 0 or &gt; 214.","source":"<code>CharCount</code> < 0 or > 214."}],"pos":[332632,332669],"yaml":true},{"content":"Deletes files from a disk. The `My` feature gives you better productivity and performance in file I/O operations than `Kill`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> .","nodes":[{"pos":[0,214],"content":"Deletes files from a disk. The `My` feature gives you better productivity and performance in file I/O operations than `Kill`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> .","nodes":[{"content":"Deletes files from a disk.","pos":[0,26]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Kill`</ph>.","pos":[27,125],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Kill`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph> .","pos":[126,214],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> ."}]}],"pos":[333579,333794],"yaml":true},{"content":"`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.  \n  \n **Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)","nodes":[{"pos":[0,115],"content":"<ph id=\"ph1\">`Kill`</ph> supports the use of multiple-character (<ph id=\"ph2\">`*`</ph>) and single-character (<ph id=\"ph3\">`?`</ph>) wildcards to specify multiple files.","source":"`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files."},{"pos":[122,476],"content":"**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Security Note<ept id=\"p1\">**</ept> In order to execute, the <ph id=\"ph1\">`Kill`</ph> function requires <ph id=\"ph2\">`Read`</ph> and <ph id=\"ph3\">`PathDiscovery`</ph> flags of <ph id=\"ph4\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> to be granted to the executing code.","pos":[0,192],"source":"**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.SecurityException&gt;</ph><bpt id=\"p1\">[</bpt>Code Access Permissions<ept id=\"p1\">](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>","pos":[193,354],"source":" For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)"}]}],"pos":[333805,334286],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that specifies one or more file names to be deleted. <code>PathName</code> can include the directory or folder, and the drive.","nodes":[{"pos":[0,156],"content":"Required. `String` expression that specifies one or more file names to be deleted. <code>PathName</code> can include the directory or folder, and the drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies one or more file names to be deleted.","pos":[10,82],"source":"`String` expression that specifies one or more file names to be deleted."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">PathName</ph><ept id=\"p1\">&lt;/code&gt;</ept> can include the directory or folder, and the drive.","pos":[83,156],"source":"<code>PathName</code> can include the directory or folder, and the drive."}]}],"pos":[334637,334794],"yaml":true},{"content":"Target file(s) open.","nodes":[{"pos":[0,20],"content":"Target file(s) open.","nodes":[{"content":"Target file(s) open.","pos":[0,20]}]}],"pos":[334947,334968],"yaml":true},{"content":"Target file(s) not found.","nodes":[{"pos":[0,25],"content":"Target file(s) not found.","nodes":[{"content":"Target file(s) not found.","pos":[0,25]}]}],"pos":[335076,335102],"yaml":true},{"content":"Permission denied.","nodes":[{"pos":[0,18],"content":"Permission denied.","nodes":[{"content":"Permission denied.","pos":[0,18]}]}],"pos":[335214,335233],"yaml":true},{"content":"Reads a single line from an open sequential file and assigns it to a `String` variable.","nodes":[{"pos":[0,87],"content":"Reads a single line from an open sequential file and assigns it to a <ph id=\"ph1\">`String`</ph> variable.","source":"Reads a single line from an open sequential file and assigns it to a `String` variable."}],"pos":[336167,336255],"yaml":true},{"content":"The `LineInput` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n Data read with `LineInput` is usually written to a file by using `Print`.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence. Carriage return/line feed sequences are skipped instead of appended to the character string.  \n  \n> [!IMPORTANT]\n>  Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","nodes":[{"pos":[0,333],"content":"The `LineInput` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`LineInput`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,91],"source":"The `LineInput` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[92,185],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[186,333],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[340,413],"content":"Data read with <ph id=\"ph1\">`LineInput`</ph> is usually written to a file by using <ph id=\"ph2\">`Print`</ph>.","source":"Data read with `LineInput` is usually written to a file by using `Print`."},{"pos":[421,628],"content":"[!IMPORTANT]\n When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","leadings":["","> "],"nodes":[{"content":" When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[13,205],"nodes":[{"content":"When reading from files, do not make decisions about the contents of a file based on the file name extension.","pos":[1,110]},{"content":"For example, a file that is named Form1.vb may not be a Visual Basic source file.","pos":[111,192]}]}]},{"pos":[635,905],"content":"The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence. Carriage return/line feed sequences are skipped instead of appended to the character string.","nodes":[{"content":"The <ph id=\"ph1\">`LineInput`</ph> function reads from a file one character at a time until it encounters a carriage return (<ph id=\"ph2\">`Chr(13)`</ph>) or carriage return/line feed (<ph id=\"ph3\">`Chr(13) + Chr(10)`</ph>) sequence.","pos":[0,177],"source":"The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence."},{"content":"Carriage return/line feed sequences are skipped instead of appended to the character string.","pos":[178,270]}]},{"pos":[913,1085],"content":"[!IMPORTANT]\n Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.","leadings":["","> "],"nodes":[{"content":"Reading from a file by using the <ph id=\"ph1\">`LineInput`</ph> function requires <ph id=\"ph2\">`Read`</ph> access from the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.","pos":[14,170],"source":" Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."}]}],"pos":[336266,337364],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[337855,337888],"yaml":true},{"content":"Reads a single line from an open sequential file and assigns it to a `String` variable.","nodes":[{"pos":[0,87],"content":"Reads a single line from an open sequential file and assigns it to a <ph id=\"ph1\">`String`</ph> variable.","source":"Reads a single line from an open sequential file and assigns it to a `String` variable."}],"pos":[337945,338033],"yaml":true},{"content":"End of file reached.","nodes":[{"pos":[0,20],"content":"End of file reached.","nodes":[{"content":"End of file reached.","pos":[0,20]}]}],"pos":[338209,338230],"yaml":true},{"content":"<code>FileNumber</code> does not exist.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;FileNumber&lt;/code&gt;</ph> does not exist.","source":"<code>FileNumber</code> does not exist."}],"pos":[338318,338358],"yaml":true},{"content":"Returns a `Long` value that specifies the current read/write position in an open file.","nodes":[{"pos":[0,86],"content":"Returns a <ph id=\"ph1\">`Long`</ph> value that specifies the current read/write position in an open file.","source":"Returns a `Long` value that specifies the current read/write position in an open file."}],"pos":[339256,339343],"yaml":true},{"content":"The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.  \n  \n The `Loc` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n The following describes the return value for each file access mode:  \n  \n|Mode|Return value|  \n|-|-|  \n|`Random`|Number of the last record read from or written to the file.|  \n|`Sequential`|Current byte position in the file divided by 128. However, information returned by `Loc` for sequential files is neither used nor required.|  \n|`Binary`|Position of the last byte read or written.|","nodes":[{"pos":[0,94],"content":"The <ph id=\"ph1\">`Loc`</ph> function is zero-based; using it to retrieve the first byte in a file will return 0.","source":"The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0."},{"pos":[101,428],"content":"The `Loc` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Loc`</ph> function is provided for backward compatibility and may affect performance.","pos":[0,85],"source":"The `Loc` function is provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[86,179],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[180,327],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[435,502],"content":"The following describes the return value for each file access mode:","nodes":[{"content":"The following describes the return value for each file access mode:","pos":[0,67]}]},{"pos":[509,513],"content":"Mode","nodes":[{"content":"Mode","pos":[0,4]}]},{"pos":[514,526],"content":"Return value","nodes":[{"content":"Return value","pos":[0,12]}]},{"pos":[548,607],"content":"Number of the last record read from or written to the file.","nodes":[{"content":"Number of the last record read from or written to the file.","pos":[0,59]}]},{"pos":[625,764],"content":"Current byte position in the file divided by 128. However, information returned by `Loc` for sequential files is neither used nor required.","nodes":[{"content":"Current byte position in the file divided by 128.","pos":[0,49]},{"content":"However, information returned by <ph id=\"ph1\">`Loc`</ph> for sequential files is neither used nor required.","pos":[50,139],"source":" However, information returned by `Loc` for sequential files is neither used nor required."}]},{"pos":[778,820],"content":"Position of the last byte read or written.","nodes":[{"content":"Position of the last byte read or written.","pos":[0,42]}]}],"pos":[339354,340188],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid `Integer` file number.","nodes":[{"pos":[0,42],"content":"Required. Any valid `Integer` file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid <ph id=\"ph1\">`Integer`</ph> file number.","pos":[10,42],"source":" Any valid `Integer` file number."}]}],"pos":[340655,340698],"yaml":true},{"content":"Returns a `Long` value that specifies the current read/write position in an open file.","nodes":[{"pos":[0,86],"content":"Returns a <ph id=\"ph1\">`Long`</ph> value that specifies the current read/write position in an open file.","source":"Returns a `Long` value that specifies the current read/write position in an open file."}],"pos":[340754,340841],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[340993,341015],"yaml":true},{"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,296],"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Controls access by other processes to all or part of a file opened by using the <ph id=\"ph1\">`Open`</ph> function.","pos":[0,96],"source":"Controls access by other processes to all or part of a file opened by using the `Open` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Lock`</ph> and <ph id=\"ph3\">`Unlock`</ph>.","pos":[97,208],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[209,296],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[341919,342216],"yaml":true},{"content":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \n  \n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \n  \n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \n  \n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.","source":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file."},{"pos":[125,236],"content":"`Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.","nodes":[{"content":"<ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are always used in pairs.","pos":[0,55],"source":"`Lock` and `Unlock` functions are always used in pairs."},{"content":"The arguments to <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> must be identical.","pos":[56,111],"source":" The arguments to `Lock` and `Unlock` must be identical."}]},{"pos":[243,415],"content":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.","nodes":[{"content":"If <ph id=\"ph1\">`Record`</ph>, or <ph id=\"ph2\">`FromRecord`</ph> and <ph id=\"ph3\">`ToRecord`</ph> are not supplied, the lock will be for the whole file.","pos":[0,98],"source":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file."},{"content":"If <ph id=\"ph1\">`Record`</ph> alone is specified the single record will be locked/unlocked.","pos":[99,172],"source":" If `Record` alone is specified the single record will be locked/unlocked."}]},{"pos":[422,589],"content":"If the file has been opened for sequential input or output, <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id=\"ph3\">`FromRecord`</ph> and<ph id=\"ph4\">`ToRecord`</ph>.","source":"If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`."}],"pos":[342227,342825],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[343277,343310],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[343463,343485],"yaml":true},{"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,296],"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Controls access by other processes to all or part of a file opened by using the <ph id=\"ph1\">`Open`</ph> function.","pos":[0,96],"source":"Controls access by other processes to all or part of a file opened by using the `Open` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Lock`</ph> and <ph id=\"ph3\">`Unlock`</ph>.","pos":[97,208],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[209,296],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[344449,344746],"yaml":true},{"content":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \n  \n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \n  \n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \n  \n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.","source":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file."},{"pos":[125,236],"content":"`Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.","nodes":[{"content":"<ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are always used in pairs.","pos":[0,55],"source":"`Lock` and `Unlock` functions are always used in pairs."},{"content":"The arguments to <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> must be identical.","pos":[56,111],"source":" The arguments to `Lock` and `Unlock` must be identical."}]},{"pos":[243,415],"content":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.","nodes":[{"content":"If <ph id=\"ph1\">`Record`</ph>, or <ph id=\"ph2\">`FromRecord`</ph> and <ph id=\"ph3\">`ToRecord`</ph> are not supplied, the lock will be for the whole file.","pos":[0,98],"source":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file."},{"content":"If <ph id=\"ph1\">`Record`</ph> alone is specified the single record will be locked/unlocked.","pos":[99,172],"source":" If `Record` alone is specified the single record will be locked/unlocked."}]},{"pos":[422,589],"content":"If the file has been opened for sequential input or output, <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id=\"ph3\">`FromRecord`</ph> and<ph id=\"ph4\">`ToRecord`</ph>.","source":"If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`."}],"pos":[344757,345355],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[345820,345853],"yaml":true},{"content":"Optional. Number of the only record or byte to lock or unlock","nodes":[{"pos":[0,61],"content":"Optional. Number of the only record or byte to lock or unlock","nodes":[{"content":"Optional. Number of the only record or byte to lock or unlock","pos":[0,61],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Number of the only record or byte to lock or unlock","pos":[10,61]}]}]}],"pos":[345914,345976],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[346129,346151],"yaml":true},{"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,296],"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Controls access by other processes to all or part of a file opened by using the <ph id=\"ph1\">`Open`</ph> function.","pos":[0,96],"source":"Controls access by other processes to all or part of a file opened by using the `Open` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Lock`</ph> and <ph id=\"ph3\">`Unlock`</ph>.","pos":[97,208],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[209,296],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[347175,347472],"yaml":true},{"content":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \n  \n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \n  \n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \n  \n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.","source":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file."},{"pos":[125,236],"content":"`Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.","nodes":[{"content":"<ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are always used in pairs.","pos":[0,55],"source":"`Lock` and `Unlock` functions are always used in pairs."},{"content":"The arguments to <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> must be identical.","pos":[56,111],"source":" The arguments to `Lock` and `Unlock` must be identical."}]},{"pos":[243,415],"content":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.","nodes":[{"content":"If <ph id=\"ph1\">`Record`</ph>, or <ph id=\"ph2\">`FromRecord`</ph> and <ph id=\"ph3\">`ToRecord`</ph> are not supplied, the lock will be for the whole file.","pos":[0,98],"source":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file."},{"content":"If <ph id=\"ph1\">`Record`</ph> alone is specified the single record will be locked/unlocked.","pos":[99,172],"source":" If `Record` alone is specified the single record will be locked/unlocked."}]},{"pos":[422,589],"content":"If the file has been opened for sequential input or output, <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id=\"ph3\">`FromRecord`</ph> and<ph id=\"ph4\">`ToRecord`</ph>.","source":"If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`."}],"pos":[347483,348081],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[348565,348598],"yaml":true},{"content":"Optional. Number of the first record or byte to lock or unlock.","nodes":[{"pos":[0,63],"content":"Optional. Number of the first record or byte to lock or unlock.","nodes":[{"content":"Optional. Number of the first record or byte to lock or unlock.","pos":[0,63],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Number of the first record or byte to lock or unlock.","pos":[10,63]}]}]}],"pos":[348663,348727],"yaml":true},{"content":"Optional. Number of the last record or byte to lock or unlock.","nodes":[{"pos":[0,62],"content":"Optional. Number of the last record or byte to lock or unlock.","nodes":[{"content":"Optional. Number of the last record or byte to lock or unlock.","pos":[0,62],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Number of the last record or byte to lock or unlock.","pos":[10,62]}]}]}],"pos":[348790,348853],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[349006,349028],"yaml":true},{"content":"Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `LOF`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,286],"content":"Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `LOF`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Returns a <ph id=\"ph1\">`Long`</ph> representing the size, in bytes, of a file opened by using the <ph id=\"ph2\">`FileOpen`</ph> function.","pos":[0,100],"source":"Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`LOF`</ph>.","pos":[101,198],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `LOF`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[199,286],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[349926,350213],"yaml":true},{"content":"Use the `FileLen` function to obtain the length of a file that is not open.","nodes":[{"pos":[0,75],"content":"Use the <ph id=\"ph1\">`FileLen`</ph> function to obtain the length of a file that is not open.","source":"Use the `FileLen` function to obtain the length of a file that is not open."}],"pos":[350224,350300],"yaml":true,"extradata":"MT"},{"content":"Required. An `Integer` that contains a valid file number.","nodes":[{"pos":[0,57],"content":"Required. An `Integer` that contains a valid file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"An <ph id=\"ph1\">`Integer`</ph> that contains a valid file number.","pos":[10,57],"source":" An `Integer` that contains a valid file number."}]}],"pos":[350737,350795],"yaml":true},{"content":"Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `LOF`.","nodes":[{"pos":[0,198],"content":"Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `LOF`.","nodes":[{"content":"Returns a <ph id=\"ph1\">`Long`</ph> representing the size, in bytes, of a file opened by using the <ph id=\"ph2\">`FileOpen`</ph> function.","pos":[0,100],"source":"Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`LOF`</ph>.","pos":[101,198],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `LOF`."}]}],"pos":[350851,351050],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[351202,351224],"yaml":true},{"content":"Creates a new directory. The `My` feature gives you better productivity and performance in file I/O operations than `MkDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)\"></xref>.","nodes":[{"pos":[0,243],"content":"Creates a new directory. The `My` feature gives you better productivity and performance in file I/O operations than `MkDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)\"></xref>.","nodes":[{"content":"Creates a new directory.","pos":[0,24]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`MkDir`</ph>.","pos":[25,124],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `MkDir`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)\"&gt;&lt;/xref&gt;</ph>.","pos":[125,243],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)\"></xref>."}]}],"pos":[352140,352384],"yaml":true},{"content":"This function creates a new directory.","nodes":[{"pos":[0,38],"content":"This function creates a new directory.","nodes":[{"content":"This function creates a new directory.","pos":[0,38]}]}],"pos":[352395,352434],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that identifies the directory to be created. The <code>Path</code> may include the drive. If no drive is specified, `MkDir` creates the new directory on the current drive.","nodes":[{"pos":[0,201],"content":"Required. `String` expression that identifies the directory to be created. The <code>Path</code> may include the drive. If no drive is specified, `MkDir` creates the new directory on the current drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that identifies the directory to be created.","pos":[10,74],"source":"`String` expression that identifies the directory to be created."},{"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Path</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include the drive.","pos":[75,119],"source":" The <code>Path</code> may include the drive."},{"content":"If no drive is specified, <ph id=\"ph1\">`MkDir`</ph> creates the new directory on the current drive.","pos":[120,201],"source":" If no drive is specified, `MkDir` creates the new directory on the current drive."}]}],"pos":[352854,353056],"yaml":true},{"content":"<code>Path</code> is not specified or is empty.","nodes":[{"pos":[0,47],"content":"<ph id=\"ph1\">&lt;code&gt;Path&lt;/code&gt;</ph> is not specified or is empty.","source":"<code>Path</code> is not specified or is empty."}],"pos":[353216,353264],"yaml":true},{"content":"Permission denied.","nodes":[{"pos":[0,18],"content":"Permission denied.","nodes":[{"content":"Permission denied.","pos":[0,18]}]}],"pos":[353376,353395],"yaml":true},{"content":"Directory already exists.","nodes":[{"pos":[0,25],"content":"Directory already exists.","nodes":[{"content":"Directory already exists.","pos":[0,25]}]}],"pos":[353483,353509],"yaml":true},{"content":"Writes display-formatted data to a sequential file.","nodes":[{"pos":[0,51],"content":"Writes display-formatted data to a sequential file.","nodes":[{"content":"Writes display-formatted data to a sequential file.","pos":[0,51]}]}],"pos":[354497,354549],"yaml":true},{"content":"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n `Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.  \n  \n Data written with `Print` is usually read from a file by using `LineInput` or `Input`.  \n  \n If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.  \n  \n For `Boolean` data, either `True` or `False` is printed. The `True` and `False` keywords are not translated, regardless of the locale.  \n  \n Date data is written to the file by using the standard short date format recognized by your system. When either the date or the time component is missing or zero, only the part provided is written to the file.  \n  \n Nothing is written to the file if `Output` data is empty. However, if `Output` list data is `DBNull`, `Null` is written to the file.  \n  \n For `Error` data, the output appears as `Error errorcode`. The `Error` keyword is not translated regardless of the locale.  \n  \n All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, `Write` should be used.  \n  \n Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"pos":[0,347],"content":"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Print`</ph> and <ph id=\"ph2\">`PrintLine`</ph> functions are provided for backward compatibility and may affect performance.","pos":[0,105],"source":"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[106,199],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[200,347],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[354,459],"content":"<ph id=\"ph1\">`Print`</ph> does not include a line feed at the end of a line; however, <ph id=\"ph2\">`PrintLine`</ph> does include a line feed.","source":"`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed."},{"pos":[466,552],"content":"Data written with <ph id=\"ph1\">`Print`</ph> is usually read from a file by using <ph id=\"ph2\">`LineInput`</ph> or <ph id=\"ph3\">`Input`</ph>.","source":"Data written with `Print` is usually read from a file by using `LineInput` or `Input`."},{"pos":[559,804],"content":"If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.","nodes":[{"content":"If you omit <ph id=\"ph1\">`Output`</ph> for <ph id=\"ph2\">`PrintLine`</ph>, a blank line is printed to the file; for <ph id=\"ph3\">`Print`</ph>, nothing is output.","pos":[0,106],"source":"If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output."},{"content":"Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and <ph id=\"ph1\">`TAB`</ph> may cause inconsistent results.","pos":[107,245],"source":" Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results."}]},{"pos":[811,945],"content":"For `Boolean` data, either `True` or `False` is printed. The `True` and `False` keywords are not translated, regardless of the locale.","nodes":[{"content":"For <ph id=\"ph1\">`Boolean`</ph> data, either <ph id=\"ph2\">`True`</ph> or <ph id=\"ph3\">`False`</ph> is printed.","pos":[0,56],"source":"For `Boolean` data, either `True` or `False` is printed."},{"content":"The <ph id=\"ph1\">`True`</ph> and <ph id=\"ph2\">`False`</ph> keywords are not translated, regardless of the locale.","pos":[57,134],"source":" The `True` and `False` keywords are not translated, regardless of the locale."}]},{"pos":[952,1161],"content":"Date data is written to the file by using the standard short date format recognized by your system. When either the date or the time component is missing or zero, only the part provided is written to the file.","nodes":[{"content":"Date data is written to the file by using the standard short date format recognized by your system. When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[0,209],"nodes":[{"content":"Date data is written to the file by using the standard short date format recognized by your system.","pos":[0,99]},{"content":"When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[100,209]}]}]},{"pos":[1168,1300],"content":"Nothing is written to the file if `Output` data is empty. However, if `Output` list data is `DBNull`, `Null` is written to the file.","nodes":[{"content":"Nothing is written to the file if <ph id=\"ph1\">`Output`</ph> data is empty.","pos":[0,57],"source":"Nothing is written to the file if `Output` data is empty."},{"content":"However, if <ph id=\"ph1\">`Output`</ph> list data is <ph id=\"ph2\">`DBNull`</ph>, <ph id=\"ph3\">`Null`</ph> is written to the file.","pos":[58,132],"source":" However, if `Output` list data is `DBNull`, `Null` is written to the file."}]},{"pos":[1307,1429],"content":"For `Error` data, the output appears as `Error errorcode`. The `Error` keyword is not translated regardless of the locale.","nodes":[{"content":"For <ph id=\"ph1\">`Error`</ph> data, the output appears as <ph id=\"ph2\">`Error errorcode`</ph>.","pos":[0,58],"source":"For `Error` data, the output appears as `Error errorcode`."},{"content":"The <ph id=\"ph1\">`Error`</ph> keyword is not translated regardless of the locale.","pos":[59,122],"source":" The `Error` keyword is not translated regardless of the locale."}]},{"pos":[1436,1676],"content":"All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, `Write` should be used.","nodes":[{"content":"All data written to the file by using <ph id=\"ph1\">`Print`</ph> is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.","pos":[0,153],"source":"All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator."},{"content":"If the user wishes to output data for use by multiple locales, <ph id=\"ph1\">`Write`</ph> should be used.","pos":[154,240],"source":" If the user wishes to output data for use by multiple locales, `Write` should be used."}]},{"pos":[1683,1903],"content":"Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"content":"Writing to a file by using the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions requires <ph id=\"ph3\">`Write`</ph> access from the <ph id=\"ph4\">`FileIOPermissionAccess`</ph> enumeration.","pos":[0,134],"source":"Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .","pos":[135,220],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> ."}]}],"pos":[354560,356484],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[356866,356899],"yaml":true},{"content":"Optional. Zero or more comma-delimited expressions to write to a file.  \n  \n The <code>Output</code> argument settings are:  \n  \n `T:System.IO.IOException`: File mode is invalid.  \n  \n `T:System.IO.IOException`: <code>FileNumber</code> does not exist.","nodes":[{"pos":[0,70],"content":"Optional. Zero or more comma-delimited expressions to write to a file.","nodes":[{"content":"Optional. Zero or more comma-delimited expressions to write to a file.","pos":[0,70],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Zero or more comma-delimited expressions to write to a file.","pos":[10,70]}]}]},{"pos":[77,123],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Output</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument settings are:","source":"The <code>Output</code> argument settings are:"},{"pos":[130,178],"content":"<ph id=\"ph1\">`T:System.IO.IOException`</ph>: File mode is invalid.","source":"`T:System.IO.IOException`: File mode is invalid."},{"pos":[185,251],"content":"<ph id=\"ph1\">`T:System.IO.IOException`</ph>: <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">FileNumber</ph><ept id=\"p1\">&lt;/code&gt;</ept> does not exist.","source":"`T:System.IO.IOException`: <code>FileNumber</code> does not exist."}],"pos":[356963,357223],"yaml":true},{"content":"Writes display-formatted data to a sequential file.","nodes":[{"pos":[0,51],"content":"Writes display-formatted data to a sequential file.","nodes":[{"content":"Writes display-formatted data to a sequential file.","pos":[0,51]}]}],"pos":[358304,358356],"yaml":true},{"content":"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n `Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.  \n  \n Data written with `Print` is usually read from a file by using `LineInput` or `Input`.  \n  \n If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.  \n  \n For `Boolean` data, either `True` or `False` is printed. The `True` and `False` keywords are not translated, regardless of the locale.  \n  \n Date data is written to the file by using the standard short date format recognized by the system. When either the date or the time component is missing or zero, only the part provided is written to the file.  \n  \n Nothing is written to the file if `Output` data is empty. However, if `Output` list data is `DBNull`, `Null` is written to the file.  \n  \n For `Error` data, the output appears as `Error errorcode`. The `Error` keyword is not translated regardless of the locale.  \n  \n All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, `Write` should be used.  \n  \n Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"pos":[0,347],"content":"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Print`</ph> and <ph id=\"ph2\">`PrintLine`</ph> functions are provided for backward compatibility and may affect performance.","pos":[0,105],"source":"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[106,199],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[200,347],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[354,458],"content":"<ph id=\"ph1\">`Print`</ph> does not include a line feed at the end of a line; however,<ph id=\"ph2\">`PrintLine`</ph> does include a line feed.","source":"`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed."},{"pos":[465,551],"content":"Data written with <ph id=\"ph1\">`Print`</ph> is usually read from a file by using <ph id=\"ph2\">`LineInput`</ph> or <ph id=\"ph3\">`Input`</ph>.","source":"Data written with `Print` is usually read from a file by using `LineInput` or `Input`."},{"pos":[558,803],"content":"If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.","nodes":[{"content":"If you omit <ph id=\"ph1\">`Output`</ph> for <ph id=\"ph2\">`PrintLine`</ph>, a blank line is printed to the file; for <ph id=\"ph3\">`Print`</ph>, nothing is output.","pos":[0,106],"source":"If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output."},{"content":"Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and <ph id=\"ph1\">`TAB`</ph> may cause inconsistent results.","pos":[107,245],"source":" Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results."}]},{"pos":[810,944],"content":"For `Boolean` data, either `True` or `False` is printed. The `True` and `False` keywords are not translated, regardless of the locale.","nodes":[{"content":"For <ph id=\"ph1\">`Boolean`</ph> data, either <ph id=\"ph2\">`True`</ph> or <ph id=\"ph3\">`False`</ph> is printed.","pos":[0,56],"source":"For `Boolean` data, either `True` or `False` is printed."},{"content":"The <ph id=\"ph1\">`True`</ph> and <ph id=\"ph2\">`False`</ph> keywords are not translated, regardless of the locale.","pos":[57,134],"source":" The `True` and `False` keywords are not translated, regardless of the locale."}]},{"pos":[951,1159],"content":"Date data is written to the file by using the standard short date format recognized by the system. When either the date or the time component is missing or zero, only the part provided is written to the file.","nodes":[{"content":"Date data is written to the file by using the standard short date format recognized by the system. When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[0,208],"nodes":[{"content":"Date data is written to the file by using the standard short date format recognized by the system.","pos":[0,98]},{"content":"When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[99,208]}]}]},{"pos":[1166,1298],"content":"Nothing is written to the file if `Output` data is empty. However, if `Output` list data is `DBNull`, `Null` is written to the file.","nodes":[{"content":"Nothing is written to the file if <ph id=\"ph1\">`Output`</ph> data is empty.","pos":[0,57],"source":"Nothing is written to the file if `Output` data is empty."},{"content":"However, if <ph id=\"ph1\">`Output`</ph> list data is <ph id=\"ph2\">`DBNull`</ph>, <ph id=\"ph3\">`Null`</ph> is written to the file.","pos":[58,132],"source":" However, if `Output` list data is `DBNull`, `Null` is written to the file."}]},{"pos":[1305,1427],"content":"For `Error` data, the output appears as `Error errorcode`. The `Error` keyword is not translated regardless of the locale.","nodes":[{"content":"For <ph id=\"ph1\">`Error`</ph> data, the output appears as <ph id=\"ph2\">`Error errorcode`</ph>.","pos":[0,58],"source":"For `Error` data, the output appears as `Error errorcode`."},{"content":"The <ph id=\"ph1\">`Error`</ph> keyword is not translated regardless of the locale.","pos":[59,122],"source":" The `Error` keyword is not translated regardless of the locale."}]},{"pos":[1434,1674],"content":"All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, `Write` should be used.","nodes":[{"content":"All data written to the file by using <ph id=\"ph1\">`Print`</ph> is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.","pos":[0,153],"source":"All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator."},{"content":"If the user wishes to output data for use by multiple locales, <ph id=\"ph1\">`Write`</ph> should be used.","pos":[154,240],"source":" If the user wishes to output data for use by multiple locales, `Write` should be used."}]},{"pos":[1681,1901],"content":"Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"content":"Writing to a file by using the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions requires <ph id=\"ph3\">`Write`</ph> access from the <ph id=\"ph4\">`FileIOPermissionAccess`</ph> enumeration.","pos":[0,134],"source":"Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .","pos":[135,220],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> ."}]}],"pos":[358367,360289],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[360675,360708],"yaml":true},{"content":"Optional. Zero or more comma-delimited expressions to write to a file.  \n  \n The <code>Output</code> argument settings are:  \n  \n `T:System.IO.IOException`: File mode is invalid.  \n  \n `T:System.IO.IOException`: <code>FileNumber</code> does not exist.","nodes":[{"pos":[0,70],"content":"Optional. Zero or more comma-delimited expressions to write to a file.","nodes":[{"content":"Optional. Zero or more comma-delimited expressions to write to a file.","pos":[0,70],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Zero or more comma-delimited expressions to write to a file.","pos":[10,70]}]}]},{"pos":[77,123],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Output</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument settings are:","source":"The <code>Output</code> argument settings are:"},{"pos":[130,178],"content":"<ph id=\"ph1\">`T:System.IO.IOException`</ph>: File mode is invalid.","source":"`T:System.IO.IOException`: File mode is invalid."},{"pos":[185,251],"content":"<ph id=\"ph1\">`T:System.IO.IOException`</ph>: <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">FileNumber</ph><ept id=\"p1\">&lt;/code&gt;</ept> does not exist.","source":"`T:System.IO.IOException`: <code>FileNumber</code> does not exist."}],"pos":[360772,361032],"yaml":true},{"content":"Renames a disk file or directory. The `My` feature gives you better productivity and performance in file I/O operations than `Rename`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,222],"content":"Renames a disk file or directory. The `My` feature gives you better productivity and performance in file I/O operations than `Rename`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Renames a disk file or directory.","pos":[0,33]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Rename`</ph>.","pos":[34,134],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Rename`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[135,222],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[362093,362316],"yaml":true},{"content":"The`Rename` function renames a file and moves it to a different directory, if it is required. The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive. `Rename` cannot create a new file or directory.  \n  \n Using the `Rename` function on an open file produces an error. You must close an open file before renaming it. `Rename` arguments cannot include multiple-character (*) and single-character (?) wildcards.  \n  \n> [!IMPORTANT]\n>  When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights. Check to make sure that you are not introducing a possible security risk.","nodes":[{"pos":[0,304],"content":"The`Rename` function renames a file and moves it to a different directory, if it is required. The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive. `Rename` cannot create a new file or directory.","nodes":[{"content":"The<ph id=\"ph1\">`Rename`</ph> function renames a file and moves it to a different directory, if it is required.","pos":[0,93],"source":"The`Rename` function renames a file and moves it to a different directory, if it is required."},{"content":"The <ph id=\"ph1\">`Rename`</ph> function can move a file across drives, but it can only rename an existing directory when both <ph id=\"ph2\">`NewPath`</ph> and <ph id=\"ph3\">`OldPath`</ph> are located on the same drive.","pos":[94,256],"source":" The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive."},{"content":"<ph id=\"ph1\">`Rename`</ph> cannot create a new file or directory.","pos":[257,304],"source":"`Rename` cannot create a new file or directory."}]},{"pos":[311,514],"content":"Using the `Rename` function on an open file produces an error. You must close an open file before renaming it. `Rename` arguments cannot include multiple-character (*) and single-character (?) wildcards.","nodes":[{"content":"Using the <ph id=\"ph1\">`Rename`</ph> function on an open file produces an error.","pos":[0,62],"source":"Using the `Rename` function on an open file produces an error."},{"content":"You must close an open file before renaming it.","pos":[63,110]},{"content":"<ph id=\"ph1\">`Rename`</ph> arguments cannot include multiple-character (*) and single-character (?) wildcards.","pos":[111,203],"source":"`Rename` arguments cannot include multiple-character (*) and single-character (?) wildcards."}]},{"pos":[522,745],"content":"[!IMPORTANT]\n When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights. Check to make sure that you are not introducing a possible security risk.","leadings":["","> "],"nodes":[{"content":" When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights. Check to make sure that you are not introducing a possible security risk.","pos":[13,221],"nodes":[{"content":"When using <ph id=\"ph1\">`Rename`</ph> to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.","pos":[1,134],"source":" When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights."},{"content":"Check to make sure that you are not introducing a possible security risk.","pos":[135,208]}]}]}],"pos":[362327,363080],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that specifies the existing file name and location. <code>OldPath</code> may include the directory, and drive, of the file.","nodes":[{"pos":[0,153],"content":"Required. `String` expression that specifies the existing file name and location. <code>OldPath</code> may include the directory, and drive, of the file.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies the existing file name and location.","pos":[10,81],"source":"`String` expression that specifies the existing file name and location."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">OldPath</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include the directory, and drive, of the file.","pos":[82,153],"source":"<code>OldPath</code> may include the directory, and drive, of the file."}]}],"pos":[363529,363683],"yaml":true},{"content":"Required. `String` expression that specifies the new file name and location. <code>NewPath</code> may include directory and drive of the destination location. The file name specified by <code>NewPath</code> cannot already exist.","nodes":[{"pos":[0,228],"content":"Required. `String` expression that specifies the new file name and location. <code>NewPath</code> may include directory and drive of the destination location. The file name specified by <code>NewPath</code> cannot already exist.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies the new file name and location.","pos":[10,76],"source":"`String` expression that specifies the new file name and location."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">NewPath</ph><ept id=\"p1\">&lt;/code&gt;</ept> may include directory and drive of the destination location.","pos":[77,158],"source":"<code>NewPath</code> may include directory and drive of the destination location."},{"content":"The file name specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">NewPath</ph><ept id=\"p1\">&lt;/code&gt;</ept> cannot already exist.","pos":[159,228],"source":" The file name specified by <code>NewPath</code> cannot already exist."}]}],"pos":[363746,363975],"yaml":true},{"content":"Path is invalid.","nodes":[{"pos":[0,16],"content":"Path is invalid.","nodes":[{"content":"Path is invalid.","pos":[0,16]}]}],"pos":[364136,364153],"yaml":true},{"content":"<code>OldPath</code> file does not exist.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;OldPath&lt;/code&gt;</ph> file does not exist.","source":"<code>OldPath</code> file does not exist."}],"pos":[364261,364303],"yaml":true},{"content":"Cannot rename to different device.","nodes":[{"pos":[0,34],"content":"Cannot rename to different device.","nodes":[{"content":"Cannot rename to different device.","pos":[0,34]}]}],"pos":[364391,364426],"yaml":true},{"content":"Closes all disk files opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Reset`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,250],"content":"Closes all disk files opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Reset`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Closes all disk files opened by using the <ph id=\"ph1\">`FileOpen`</ph> function.","pos":[0,62],"source":"Closes all disk files opened by using the `FileOpen` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Reset`</ph>.","pos":[63,162],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Reset`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[163,250],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[365279,365530],"yaml":true},{"content":"The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.","nodes":[{"pos":[0,145],"content":"The <ph id=\"ph1\">`Reset`</ph> function closes all active files opened by the <ph id=\"ph2\">`FileOpen`</ph> function and has the same function as <ph id=\"ph3\">`FileClose()`</ph> without any parameters.","source":"The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters."}],"pos":[365541,365687],"yaml":true,"extradata":"MT"},{"content":"Removes an existing directory. The `My` feature gives you better productivity and performance in file I/O operations than `RmDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*\"></xref>.","nodes":[{"pos":[0,235],"content":"Removes an existing directory. The `My` feature gives you better productivity and performance in file I/O operations than `RmDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*\"></xref>.","nodes":[{"content":"Removes an existing directory.","pos":[0,30]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`RmDir`</ph>.","pos":[31,130],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `RmDir`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*\"&gt;&lt;/xref&gt;</ph>.","pos":[131,235],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*\"></xref>."}]}],"pos":[367077,367313],"yaml":true},{"content":"An error occurs if you try to use `RmDir` on a directory that contains files. Use the `Kill` function to delete all files before you try to remove a directory.","nodes":[{"pos":[0,159],"content":"An error occurs if you try to use `RmDir` on a directory that contains files. Use the `Kill` function to delete all files before you try to remove a directory.","nodes":[{"content":"An error occurs if you try to use <ph id=\"ph1\">`RmDir`</ph> on a directory that contains files.","pos":[0,77],"source":"An error occurs if you try to use `RmDir` on a directory that contains files."},{"content":"Use the <ph id=\"ph1\">`Kill`</ph> function to delete all files before you try to remove a directory.","pos":[78,159],"source":" Use the `Kill` function to delete all files before you try to remove a directory."}]}],"pos":[367324,367484],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that identifies the directory or folder to be removed. <code>Path</code> can include the drive. If no drive is specified, `RmDir` removes the directory on the current drive.","nodes":[{"pos":[0,203],"content":"Required. `String` expression that identifies the directory or folder to be removed. <code>Path</code> can include the drive. If no drive is specified, `RmDir` removes the directory on the current drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that identifies the directory or folder to be removed.","pos":[10,84],"source":"`String` expression that identifies the directory or folder to be removed."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">Path</ph><ept id=\"p1\">&lt;/code&gt;</ept> can include the drive.","pos":[85,125],"source":"<code>Path</code> can include the drive."},{"content":"If no drive is specified, <ph id=\"ph1\">`RmDir`</ph> removes the directory on the current drive.","pos":[126,203],"source":" If no drive is specified, `RmDir` removes the directory on the current drive."}]}],"pos":[367832,368036],"yaml":true},{"content":"<code>Path</code> is not specified or is empty.","nodes":[{"pos":[0,47],"content":"<ph id=\"ph1\">&lt;code&gt;Path&lt;/code&gt;</ph> is not specified or is empty.","source":"<code>Path</code> is not specified or is empty."}],"pos":[368196,368244],"yaml":true},{"content":"Target directory contains files.","nodes":[{"pos":[0,32],"content":"Target directory contains files.","nodes":[{"content":"Target directory contains files.","pos":[0,32]}]}],"pos":[368332,368365],"yaml":true},{"content":"Directory does not exist.","nodes":[{"pos":[0,25],"content":"Directory does not exist.","nodes":[{"content":"Directory does not exist.","pos":[0,25]}]}],"pos":[368473,368499],"yaml":true},{"content":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Seek`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,403],"content":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Seek`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Returns a <ph id=\"ph1\">`Long`</ph> specifying the current read/write position in a file opened by using the <ph id=\"ph2\">`FileOpen`</ph> function, or sets the position for the next read/write operation in a file opened by using the <ph id=\"ph3\">`FileOpen`</ph> function.","pos":[0,216],"source":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Seek`</ph>.","pos":[217,315],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Seek`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[316,403],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[369403,369807],"yaml":true},{"content":"`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.  \n  \n The following describes the return values for each file access mode:  \n  \n|Mode|Return Value|  \n|-|-|  \n|`Random`|Number of the next record read or written|  \n|`Binary`, `Input`, `Output`, `Append`|Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.|","nodes":[{"pos":[0,87],"content":"<ph id=\"ph1\">`Seek`</ph> returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.","source":"`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive."},{"pos":[94,162],"content":"The following describes the return values for each file access mode:","nodes":[{"content":"The following describes the return values for each file access mode:","pos":[0,68]}]},{"pos":[169,173],"content":"Mode","nodes":[{"content":"Mode","pos":[0,4]}]},{"pos":[174,186],"content":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[208,249],"content":"Number of the next record read or written","nodes":[{"content":"Number of the next record read or written","pos":[0,41]}]},{"pos":[254,291],"content":"<ph id=\"ph1\">`Binary`</ph>, <ph id=\"ph2\">`Input`</ph>, <ph id=\"ph3\">`Output`</ph>, <ph id=\"ph4\">`Append`</ph>","source":"`Binary`, `Input`, `Output`, `Append`"},{"pos":[292,429],"content":"Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.","nodes":[{"content":"Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.","pos":[0,137],"nodes":[{"content":"Byte position at which the next operation occurs.","pos":[0,49]},{"content":"The first byte in a file is at position 1, the second byte is at position 2, and so on.","pos":[50,137]}]}]}],"pos":[369818,370258],"yaml":true,"extradata":"MT"},{"content":"Required. An `Integer` that contains a valid file number.","nodes":[{"pos":[0,57],"content":"Required. An `Integer` that contains a valid file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"An <ph id=\"ph1\">`Integer`</ph> that contains a valid file number.","pos":[10,57],"source":" An `Integer` that contains a valid file number."}]}],"pos":[371640,371698],"yaml":true},{"content":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function.","nodes":[{"pos":[0,216],"content":"Returns a <ph id=\"ph1\">`Long`</ph> specifying the current read/write position in a file opened by using the <ph id=\"ph2\">`FileOpen`</ph> function, or sets the position for the next read/write operation in a file opened by using the <ph id=\"ph3\">`FileOpen`</ph> function.","source":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function."}],"pos":[371754,371971],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[372124,372146],"yaml":true},{"content":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Seek`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,403],"content":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Seek`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Returns a <ph id=\"ph1\">`Long`</ph> specifying the current read/write position in a file opened by using the <ph id=\"ph2\">`FileOpen`</ph> function, or sets the position for the next read/write operation in a file opened by using the <ph id=\"ph3\">`FileOpen`</ph> function.","pos":[0,216],"source":"Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Seek`</ph>.","pos":[217,315],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Seek`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[316,403],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[373110,373514],"yaml":true},{"content":"`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.  \n  \n The following describes the return values for each file access mode:  \n  \n|Mode|Return Value|  \n|-|-|  \n|`Random`|Number of the next record read or written|  \n|`Binary`, `Input`, `Output`, `Append`|Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.|","nodes":[{"pos":[0,87],"content":"<ph id=\"ph1\">`Seek`</ph> returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.","source":"`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive."},{"pos":[94,162],"content":"The following describes the return values for each file access mode:","nodes":[{"content":"The following describes the return values for each file access mode:","pos":[0,68]}]},{"pos":[169,173],"content":"Mode","nodes":[{"content":"Mode","pos":[0,4]}]},{"pos":[174,186],"content":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[208,249],"content":"Number of the next record read or written","nodes":[{"content":"Number of the next record read or written","pos":[0,41]}]},{"pos":[254,291],"content":"<ph id=\"ph1\">`Binary`</ph>, <ph id=\"ph2\">`Input`</ph>, <ph id=\"ph3\">`Output`</ph>, <ph id=\"ph4\">`Append`</ph>","source":"`Binary`, `Input`, `Output`, `Append`"},{"pos":[292,429],"content":"Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.","nodes":[{"content":"Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.","pos":[0,137],"nodes":[{"content":"Byte position at which the next operation occurs.","pos":[0,49]},{"content":"The first byte in a file is at position 1, the second byte is at position 2, and so on.","pos":[50,137]}]}]}],"pos":[373525,373965],"yaml":true,"extradata":"MT"},{"content":"Required. An `Integer` that contains a valid file number.","nodes":[{"pos":[0,57],"content":"Required. An `Integer` that contains a valid file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"An <ph id=\"ph1\">`Integer`</ph> that contains a valid file number.","pos":[10,57],"source":" An `Integer` that contains a valid file number."}]}],"pos":[375362,375420],"yaml":true},{"content":"Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.","nodes":[{"pos":[0,122],"content":"Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.","nodes":[{"content":"Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.","pos":[0,122],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.","pos":[10,122]}]}]}],"pos":[375483,375606],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[375759,375781],"yaml":true},{"content":"Sets attribute information for a file. The `My` feature gives you better productivity and performance in file I/O operations than `SetAttr`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,228],"content":"Sets attribute information for a file. The `My` feature gives you better productivity and performance in file I/O operations than `SetAttr`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Sets attribute information for a file.","pos":[0,38]},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`SetAttr`</ph>.","pos":[39,140],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `SetAttr`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[141,228],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[376862,377091],"yaml":true},{"content":"A run-time error occurs if you try to set the attributes of an open file.  \n  \n The `Attributes` argument enumeration values are as follows:  \n  \n|Value|Constant|Description|  \n|-|-|-|  \n|`Normal`|`vbNormal`|Normal (default).|  \n|`ReadOnly`|`vbReadOnly`|Read-only.|  \n|`Hidden`|`vbHidden`|Hidden.|  \n|`System`|`vbSystem`|System file.|  \n|`Volume`|`vbVolume`|Volume label|  \n|`Directory`|`vbDirectory`|Directory or folder.|  \n|`Archive`|`vbArchive`|File has changed since last backup.|  \n|`Alias`|`vbAlias`|File has a different name.|  \n  \n> [!NOTE]\n>  These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code instead of the actual values.","nodes":[{"pos":[0,73],"content":"A run-time error occurs if you try to set the attributes of an open file.","nodes":[{"content":"A run-time error occurs if you try to set the attributes of an open file.","pos":[0,73]}]},{"pos":[80,140],"content":"The <ph id=\"ph1\">`Attributes`</ph> argument enumeration values are as follows:","source":"The `Attributes` argument enumeration values are as follows:"},{"pos":[147,152],"content":"Value","nodes":[{"content":"Value","pos":[0,5]}]},{"pos":[153,161],"content":"Constant","nodes":[{"content":"Constant","pos":[0,8]}]},{"pos":[162,173],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[208,225],"content":"Normal (default).","nodes":[{"content":"Normal (default).","pos":[0,17]}]},{"pos":[254,264],"content":"Read-only.","nodes":[{"content":"Read-only.","pos":[0,10]}]},{"pos":[289,296],"content":"Hidden.","nodes":[{"content":"Hidden.","pos":[0,7]}]},{"pos":[321,333],"content":"System file.","nodes":[{"content":"System file.","pos":[0,12]}]},{"pos":[358,370],"content":"Volume label","nodes":[{"content":"Volume label","pos":[0,12]}]},{"pos":[401,421],"content":"Directory or folder.","nodes":[{"content":"Directory or folder.","pos":[0,20]}]},{"pos":[448,483],"content":"File has changed since last backup.","nodes":[{"content":"File has changed since last backup.","pos":[0,35]}]},{"pos":[506,532],"content":"File has a different name.","nodes":[{"content":"File has a different name.","pos":[0,26]}]},{"pos":[541,688],"content":"[!NOTE]\n These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code instead of the actual values.","leadings":["","> "],"nodes":[{"content":" These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code instead of the actual values.","pos":[8,145],"nodes":[{"content":"These enumerations are specified by the Visual Basic language.","pos":[1,63]},{"content":"The names can be used anywhere in your code instead of the actual values.","pos":[64,137]}]}]}],"pos":[377102,377809],"yaml":true,"extradata":"MT"},{"content":"Required. `String` expression that specifies a file name. <code>PathName</code> can include directory or folder, and drive.","nodes":[{"pos":[0,123],"content":"Required. `String` expression that specifies a file name. <code>PathName</code> can include directory or folder, and drive.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"<ph id=\"ph1\">`String`</ph> expression that specifies a file name.","pos":[10,57],"source":"`String` expression that specifies a file name."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">PathName</ph><ept id=\"p1\">&lt;/code&gt;</ept> can include directory or folder, and drive.","pos":[58,123],"source":"<code>PathName</code> can include directory or folder, and drive."}]}],"pos":[378214,378338],"yaml":true},{"content":"Required. Constant or numeric expression, whose sum specifies file attributes.","nodes":[{"pos":[0,78],"content":"Required. Constant or numeric expression, whose sum specifies file attributes.","nodes":[{"content":"Required. Constant or numeric expression, whose sum specifies file attributes.","pos":[0,78],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Constant or numeric expression, whose sum specifies file attributes.","pos":[10,78]}]}]}],"pos":[378426,378505],"yaml":true},{"content":"<code>Attribute</code> type is invalid.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;Attribute&lt;/code&gt;</ph> type is invalid.","source":"<code>Attribute</code> type is invalid."}],"pos":[378667,378707],"yaml":true},{"content":"Used with the `Print` or `PrintLine` function to position output.","nodes":[{"pos":[0,65],"content":"Used with the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> function to position output.","source":"Used with the `Print` or `PrintLine` function to position output."}],"pos":[379605,379671],"yaml":true},{"content":"If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed. If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:  \n  \n `currentprintposition`(+(`Count``Mod``width`))  \n  \n For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80). If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).  \n  \n> [!NOTE]\n>  Make sure your tabular columns are wide enough to allow for wide letters.","nodes":[{"pos":[0,229],"content":"If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed. If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:","nodes":[{"content":"If <ph id=\"ph1\">`Count`</ph> is less than the output line width, the next print position immediately follows the number of spaces printed.","pos":[0,120],"source":"If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed."},{"content":"If<ph id=\"ph1\">`Count`</ph> is greater than the output line width, <ph id=\"ph2\">`SPC`</ph> calculates the next print position using the formula:","pos":[121,229],"source":" If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:"}]},{"pos":[236,282],"content":"<ph id=\"ph1\">`currentprintposition`</ph>(+(<ph id=\"ph2\">`Count``Mod``width`</ph>))","source":"`currentprintposition`(+(`Count``Mod``width`))"},{"pos":[289,745],"content":"For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80). If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).","nodes":[{"content":"For example, if the current print position is 24, the output line width is 80, and you specify <ph id=\"ph1\">`SPC(90)`</ph>, the next print will start at position 34 (current print position + the remainder of 90/80).","pos":[0,197],"source":"For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80)."},{"content":"If the difference between the current print position and the output line width is less than <ph id=\"ph1\">`Count`</ph> (or <ph id=\"ph2\">`Count`</ph> <ph id=\"ph3\">`Mod`</ph> <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept>), the <ph id=\"ph4\">`SPC`</ph> function skips to the start of the next line and generates spaces equal to <ph id=\"ph5\">`Count`</ph> – (<bpt id=\"p2\">*</bpt>width<ept id=\"p2\">*</ept> – <bpt id=\"p3\">*</bpt>currentprintposition<ept id=\"p3\">*</ept>).","pos":[198,456],"source":" If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*)."}]},{"pos":[753,837],"content":"[!NOTE]\n Make sure your tabular columns are wide enough to allow for wide letters.","leadings":["","> "],"nodes":[{"content":"Make sure your tabular columns are wide enough to allow for wide letters.","pos":[9,82]}]}],"pos":[379682,380529],"yaml":true,"extradata":"MT"},{"content":"Required. The number of spaces to insert before displaying or printing the next expression in a list.","nodes":[{"pos":[0,101],"content":"Required. The number of spaces to insert before displaying or printing the next expression in a list.","nodes":[{"content":"Required. The number of spaces to insert before displaying or printing the next expression in a list.","pos":[0,101],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"The number of spaces to insert before displaying or printing the next expression in a list.","pos":[10,101]}]}]}],"pos":[380924,381026],"yaml":true},{"content":"Used with the `Print` or `PrintLine` function to position output.","nodes":[{"pos":[0,65],"content":"Used with the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> function to position output.","source":"Used with the `Print` or `PrintLine` function to position output."}],"pos":[381099,381165],"yaml":true},{"content":"Used with the `Print` or `PrintLine` functions to position output.","nodes":[{"pos":[0,66],"content":"Used with the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions to position output.","source":"Used with the `Print` or `PrintLine` functions to position output."}],"pos":[382073,382140],"yaml":true},{"content":"If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line. If `Column` is less than 1, `TAB` moves the print position to column 1. If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:  \n  \n Column Mod width  \n  \n For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80). If `Column` is less than the current print position, printing starts on the next line at the calculated print position. If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.  \n  \n The leftmost print position on an output line is always 1. When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.  \n  \n The `TAB` function can also be used with the `WriteLine` function. It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>.  \n  \n> [!NOTE]\n>  Make sure your tabular columns are wide enough to contain wide letters.","nodes":[{"pos":[0,331],"content":"If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line. If `Column` is less than 1, `TAB` moves the print position to column 1. If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:","nodes":[{"content":"If the current print position on the current line is larger than <ph id=\"ph1\">`Column`</ph>, <ph id=\"ph2\">`TAB`</ph> skips to the column value equal to <ph id=\"ph3\">`Column`</ph> on the next output line.","pos":[0,149],"source":"If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line."},{"content":"If <ph id=\"ph1\">`Column`</ph> is less than 1, <ph id=\"ph2\">`TAB`</ph> moves the print position to column 1.","pos":[150,221],"source":" If `Column` is less than 1, `TAB` moves the print position to column 1."},{"content":"If <ph id=\"ph1\">`Column`</ph> is larger than the output line width, <ph id=\"ph2\">`TAB`</ph> calculates the next print position using the formula:","pos":[222,331],"source":" If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:"}]},{"pos":[338,354],"content":"Column Mod width","nodes":[{"content":"Column Mod width","pos":[0,16]}]},{"pos":[361,745],"content":"For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80). If `Column` is less than the current print position, printing starts on the next line at the calculated print position. If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.","nodes":[{"content":"For example, if <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept> is 80 and you specify <ph id=\"ph1\">`TAB(90)`</ph>, the next print will start at column 10 (the remainder of 90/80).","pos":[0,121],"source":"For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80)."},{"content":"If <ph id=\"ph1\">`Column`</ph> is less than the current print position, printing starts on the next line at the calculated print position.","pos":[122,241],"source":" If `Column` is less than the current print position, printing starts on the next line at the calculated print position."},{"content":"If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.","pos":[242,384]}]},{"pos":[752,999],"content":"The leftmost print position on an output line is always 1. When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.","nodes":[{"content":"The leftmost print position on an output line is always 1.","pos":[0,58]},{"content":"When you use the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions to print to files, the rightmost print position is the current width of the output file, which you can set using the <ph id=\"ph3\">`FileWidth`</ph> function.","pos":[59,247],"source":" When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function."}]},{"pos":[1006,1229],"content":"The `TAB` function can also be used with the `WriteLine` function. It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">`TAB`</ph> function can also be used with the <ph id=\"ph2\">`WriteLine`</ph> function.","pos":[0,66],"source":"The `TAB` function can also be used with the `WriteLine` function."},{"content":"It cannot be used with <ph id=\"ph1\">&lt;xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Console.WriteLine%2A?displayProperty=fullName&gt;</ph>.","pos":[67,223],"source":" It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>."}]},{"pos":[1237,1319],"content":"[!NOTE]\n Make sure your tabular columns are wide enough to contain wide letters.","leadings":["","> "],"nodes":[{"content":"Make sure your tabular columns are wide enough to contain wide letters.","pos":[9,80]}]}],"pos":[382151,383484],"yaml":true,"extradata":"MT"},{"content":"Used with the `Print` or `PrintLine` functions to position output.","nodes":[{"pos":[0,66],"content":"Used with the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions to position output.","source":"Used with the `Print` or `PrintLine` functions to position output."}],"pos":[383884,383951],"yaml":true},{"content":"Used with the `Print` or `PrintLine` functions to position output.","nodes":[{"pos":[0,66],"content":"Used with the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions to position output.","source":"Used with the `Print` or `PrintLine` functions to position output."}],"pos":[384916,384983],"yaml":true},{"content":"If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line. If `Column` is less than 1, `TAB` moves the print position to column 1. If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:  \n  \n Column Mod width  \n  \n For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80). If `Column` is less than the current print position, printing starts on the next line at the calculated print position. If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.  \n  \n The leftmost print position on an output line is always 1. When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.  \n  \n The `TAB` function can also be used with the `WriteLine` function. It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>.  \n  \n> [!NOTE]\n>  Make sure your tabular columns are wide enough to contain wide letters.","nodes":[{"pos":[0,333],"content":"If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line. If `Column` is less than 1, `TAB` moves the print position to column 1. If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:","nodes":[{"content":"If the current print position on the current line is greater than <ph id=\"ph1\">`Column`</ph>, <ph id=\"ph2\">`TAB`</ph> skips to the column value equal to <ph id=\"ph3\">`Column`</ph> on the next output line.","pos":[0,150],"source":"If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line."},{"content":"If <ph id=\"ph1\">`Column`</ph> is less than 1, <ph id=\"ph2\">`TAB`</ph> moves the print position to column 1.","pos":[151,222],"source":" If `Column` is less than 1, `TAB` moves the print position to column 1."},{"content":"If <ph id=\"ph1\">`Column`</ph> is greater than the output line width, <ph id=\"ph2\">`TAB`</ph> calculates the next print position using the formula:","pos":[223,333],"source":" If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:"}]},{"pos":[340,356],"content":"Column Mod width","nodes":[{"content":"Column Mod width","pos":[0,16]}]},{"pos":[363,748],"content":"For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80). If `Column` is less than the current print position, printing starts on the next line at the calculated print position. If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.","nodes":[{"content":"For example, if <bpt id=\"p1\">*</bpt>width<ept id=\"p1\">*</ept> is 80 and you specify <ph id=\"ph1\">`TAB(90)`</ph>, the next print will start at column 10 (the remainder of 90/80).","pos":[0,121],"source":"For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80)."},{"content":"If <ph id=\"ph1\">`Column`</ph> is less than the current print position, printing starts on the next line at the calculated print position.","pos":[122,241],"source":" If `Column` is less than the current print position, printing starts on the next line at the calculated print position."},{"content":"If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.","pos":[242,385]}]},{"pos":[755,1002],"content":"The leftmost print position on an output line is always 1. When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.","nodes":[{"content":"The leftmost print position on an output line is always 1.","pos":[0,58]},{"content":"When you use the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions to print to files, the rightmost print position is the current width of the output file, which you can set using the <ph id=\"ph3\">`FileWidth`</ph> function.","pos":[59,247],"source":" When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function."}]},{"pos":[1009,1232],"content":"The `TAB` function can also be used with the `WriteLine` function. It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">`TAB`</ph> function can also be used with the <ph id=\"ph2\">`WriteLine`</ph> function.","pos":[0,66],"source":"The `TAB` function can also be used with the `WriteLine` function."},{"content":"It cannot be used with <ph id=\"ph1\">&lt;xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Console.WriteLine%2A?displayProperty=fullName&gt;</ph>.","pos":[67,223],"source":" It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>."}]},{"pos":[1240,1322],"content":"[!NOTE]\n Make sure your tabular columns are wide enough to contain wide letters.","leadings":["","> "],"nodes":[{"content":"Make sure your tabular columns are wide enough to contain wide letters.","pos":[9,80]}]}],"pos":[384994,386330],"yaml":true,"extradata":"MT"},{"content":"Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, `TAB` moves the insertion point to the start of the next print zone.","nodes":[{"pos":[0,178],"content":"Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, `TAB` moves the insertion point to the start of the next print zone.","nodes":[{"content":"Optional.","pos":[0,9]},{"content":"The column number moved to before displaying or printing the next expression in a list.","pos":[10,97]},{"content":"If omitted, <ph id=\"ph1\">`TAB`</ph> moves the insertion point to the start of the next print zone.","pos":[98,178],"source":" If omitted, `TAB` moves the insertion point to the start of the next print zone."}]}],"pos":[386727,386906],"yaml":true},{"content":"Used with the `Print` or `PrintLine` functions to position output.","nodes":[{"pos":[0,66],"content":"Used with the <ph id=\"ph1\">`Print`</ph> or <ph id=\"ph2\">`PrintLine`</ph> functions to position output.","source":"Used with the `Print` or `PrintLine` functions to position output."}],"pos":[386979,387046],"yaml":true},{"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,296],"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Controls access by other processes to all or part of a file opened by using the <ph id=\"ph1\">`Open`</ph> function.","pos":[0,96],"source":"Controls access by other processes to all or part of a file opened by using the `Open` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Lock`</ph> and <ph id=\"ph3\">`Unlock`</ph>.","pos":[97,208],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[209,296],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[388029,388326],"yaml":true},{"content":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \n  \n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \n  \n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \n  \n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.","source":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file."},{"pos":[125,236],"content":"`Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.","nodes":[{"content":"<ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are always used in pairs.","pos":[0,55],"source":"`Lock` and `Unlock` functions are always used in pairs."},{"content":"The arguments to <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> must be identical.","pos":[56,111],"source":" The arguments to `Lock` and `Unlock` must be identical."}]},{"pos":[243,415],"content":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.","nodes":[{"content":"If <ph id=\"ph1\">`Record`</ph>, or <ph id=\"ph2\">`FromRecord`</ph> and <ph id=\"ph3\">`ToRecord`</ph> are not supplied, the lock will be for the whole file.","pos":[0,98],"source":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file."},{"content":"If <ph id=\"ph1\">`Record`</ph> alone is specified the single record will be locked/unlocked.","pos":[99,172],"source":" If `Record` alone is specified the single record will be locked/unlocked."}]},{"pos":[422,589],"content":"If the file has been opened for sequential input or output, <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id=\"ph3\">`FromRecord`</ph> and<ph id=\"ph4\">`ToRecord`</ph>.","source":"If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`."}],"pos":[388337,388935],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[389389,389422],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[389577,389599],"yaml":true},{"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,296],"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Controls access by other processes to all or part of a file opened by using the <ph id=\"ph1\">`Open`</ph> function.","pos":[0,96],"source":"Controls access by other processes to all or part of a file opened by using the `Open` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Lock`</ph> and <ph id=\"ph3\">`Unlock`</ph>.","pos":[97,208],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[209,296],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[390575,390872],"yaml":true},{"content":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \n  \n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \n  \n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \n  \n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.","source":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file."},{"pos":[125,236],"content":"`Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.","nodes":[{"content":"<ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are always used in pairs.","pos":[0,55],"source":"`Lock` and `Unlock` functions are always used in pairs."},{"content":"The arguments to <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> must be identical.","pos":[56,111],"source":" The arguments to `Lock` and `Unlock` must be identical."}]},{"pos":[243,415],"content":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.","nodes":[{"content":"If <ph id=\"ph1\">`Record`</ph>, or <ph id=\"ph2\">`FromRecord`</ph> and <ph id=\"ph3\">`ToRecord`</ph> are not supplied, the lock will be for the whole file.","pos":[0,98],"source":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file."},{"content":"If <ph id=\"ph1\">`Record`</ph> alone is specified the single record will be locked/unlocked.","pos":[99,172],"source":" If `Record` alone is specified the single record will be locked/unlocked."}]},{"pos":[422,589],"content":"If the file has been opened for sequential input or output, <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id=\"ph3\">`FromRecord`</ph> and<ph id=\"ph4\">`ToRecord`</ph>.","source":"If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`."}],"pos":[390883,391481],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[391948,391981],"yaml":true},{"content":"Optional. Number of the only record or byte to lock or unlock","nodes":[{"pos":[0,61],"content":"Optional. Number of the only record or byte to lock or unlock","nodes":[{"content":"Optional. Number of the only record or byte to lock or unlock","pos":[0,61],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Number of the only record or byte to lock or unlock","pos":[10,61]}]}]}],"pos":[392042,392104],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[392259,392281],"yaml":true},{"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"pos":[0,296],"content":"Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.","nodes":[{"content":"Controls access by other processes to all or part of a file opened by using the <ph id=\"ph1\">`Open`</ph> function.","pos":[0,96],"source":"Controls access by other processes to all or part of a file opened by using the `Open` function."},{"content":"The <ph id=\"ph1\">`My`</ph> feature gives you better productivity and performance in file I/O operations than <ph id=\"ph2\">`Lock`</ph> and <ph id=\"ph3\">`Unlock`</ph>.","pos":[97,208],"source":" The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"&gt;&lt;/xref&gt;</ph>.","pos":[209,296],"source":" For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>."}]}],"pos":[393317,393614],"yaml":true},{"content":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \n  \n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \n  \n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \n  \n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.","source":"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file."},{"pos":[125,236],"content":"`Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.","nodes":[{"content":"<ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> functions are always used in pairs.","pos":[0,55],"source":"`Lock` and `Unlock` functions are always used in pairs."},{"content":"The arguments to <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> must be identical.","pos":[56,111],"source":" The arguments to `Lock` and `Unlock` must be identical."}]},{"pos":[243,415],"content":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.","nodes":[{"content":"If <ph id=\"ph1\">`Record`</ph>, or <ph id=\"ph2\">`FromRecord`</ph> and <ph id=\"ph3\">`ToRecord`</ph> are not supplied, the lock will be for the whole file.","pos":[0,98],"source":"If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file."},{"content":"If <ph id=\"ph1\">`Record`</ph> alone is specified the single record will be locked/unlocked.","pos":[99,172],"source":" If `Record` alone is specified the single record will be locked/unlocked."}]},{"pos":[422,589],"content":"If the file has been opened for sequential input or output, <ph id=\"ph1\">`Lock`</ph> and <ph id=\"ph2\">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id=\"ph3\">`FromRecord`</ph> and<ph id=\"ph4\">`ToRecord`</ph>.","source":"If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`."}],"pos":[393625,394223],"yaml":true,"extradata":"MT"},{"content":"Required. Any valid file number.","nodes":[{"pos":[0,32],"content":"Required. Any valid file number.","nodes":[{"content":"Required. Any valid file number.","pos":[0,32],"nodes":[{"content":"Required.","pos":[0,9]},{"content":"Any valid file number.","pos":[10,32]}]}]}],"pos":[394709,394742],"yaml":true},{"content":"Optional. Number of the first record or byte to lock or unlock.","nodes":[{"pos":[0,63],"content":"Optional. Number of the first record or byte to lock or unlock.","nodes":[{"content":"Optional. Number of the first record or byte to lock or unlock.","pos":[0,63],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Number of the first record or byte to lock or unlock.","pos":[10,63]}]}]}],"pos":[394807,394871],"yaml":true},{"content":"Optional. Number of the last record or byte to lock or unlock.","nodes":[{"pos":[0,62],"content":"Optional. Number of the last record or byte to lock or unlock.","nodes":[{"content":"Optional. Number of the last record or byte to lock or unlock.","pos":[0,62],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"Number of the last record or byte to lock or unlock.","pos":[10,62]}]}]}],"pos":[394934,394997],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[395152,395174],"yaml":true},{"content":"Writes data to a sequential file. Data written with `Write` is usually read from a file by using `Input`.","nodes":[{"pos":[0,105],"content":"Writes data to a sequential file. Data written with `Write` is usually read from a file by using `Input`.","nodes":[{"content":"Writes data to a sequential file.","pos":[0,33]},{"content":"Data written with <ph id=\"ph1\">`Write`</ph> is usually read from a file by using <ph id=\"ph2\">`Input`</ph>.","pos":[34,105],"source":" Data written with `Write` is usually read from a file by using `Input`."}]}],"pos":[396162,396268],"yaml":true},{"content":"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n If you omit `Output`, a blank line is printed to the file. Multiple expressions can be separated with a comma.  \n  \n Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file. You do not have to put explicit delimiters in the list. When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported. The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:  \n  \n-   Numeric data is always written using the period as the decimal separator.  \n  \n-   For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed. The `True` and `False` keywords are not translated, regardless of locale.  \n  \n-   Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.  \n  \n-   Nothing is written to the file if `Output` data is empty. However, for null data, `#NULL#` is written.  \n  \n-   For `Error` data, the output appears as `#ERROR errorcode#`. The `Error` keyword is not translated, regardless of locale.  \n  \n `WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.  \n  \n You can embed quotation marks in a string by using double quotation marks, or \"\". For example,  \n  \n [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  \n  \n returns a string with the value of `Double quotation marks aren't \"difficult\" to handle`.  \n  \n Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"pos":[0,347],"content":"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Write`</ph> and <ph id=\"ph2\">`WriteLine`</ph> functions are provided for backward compatibility and may affect performance.","pos":[0,105],"source":"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[106,199],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[200,347],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[354,464],"content":"If you omit `Output`, a blank line is printed to the file. Multiple expressions can be separated with a comma.","nodes":[{"content":"If you omit <ph id=\"ph1\">`Output`</ph>, a blank line is printed to the file.","pos":[0,58],"source":"If you omit `Output`, a blank line is printed to the file."},{"content":"Multiple expressions can be separated with a comma.","pos":[59,110]}]},{"pos":[471,939],"content":"Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file. You do not have to put explicit delimiters in the list. When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported. The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:","nodes":[{"content":"Unlike the <ph id=\"ph1\">`Print`</ph> function, the <ph id=\"ph2\">`Write`</ph> function inserts commas between items and quotation marks around strings as they are written to the file.","pos":[0,146],"source":"Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file."},{"content":"You do not have to put explicit delimiters in the list.","pos":[147,202]},{"content":"When <ph id=\"ph1\">`Write`</ph> is used to write data to a file, only numeric, <ph id=\"ph2\">`Boolean`</ph>, date, null, and <ph id=\"ph3\">`Error`</ph> data formats are supported.","pos":[203,325],"source":" When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported."},{"content":"The following universal assumptions are followed so the data can always be read and correctly interpreted using <ph id=\"ph1\">`Input`</ph>, regardless of locale:","pos":[326,468],"source":" The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:"}]},{"pos":[949,1022],"content":"Numeric data is always written using the period as the decimal separator.","nodes":[{"content":"Numeric data is always written using the period as the decimal separator.","pos":[0,73]}]},{"pos":[1032,1166],"content":"For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed. The `True` and `False` keywords are not translated, regardless of locale.","nodes":[{"content":"For <ph id=\"ph1\">`Boolean`</ph> data, either <ph id=\"ph2\">`#TRUE#`</ph> or <ph id=\"ph3\">`#FALSE#`</ph> is printed.","pos":[0,60],"source":"For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed."},{"content":"The <ph id=\"ph1\">`True`</ph> and <ph id=\"ph2\">`False`</ph> keywords are not translated, regardless of locale.","pos":[61,134],"source":" The `True` and `False` keywords are not translated, regardless of locale."}]},{"pos":[1176,1351],"content":"Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.","nodes":[{"content":"Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[0,175],"nodes":[{"content":"Date data is written to the file using the universal date format.","pos":[0,65]},{"content":"When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[66,175]}]}]},{"pos":[1361,1463],"content":"Nothing is written to the file if `Output` data is empty. However, for null data, `#NULL#` is written.","nodes":[{"content":"Nothing is written to the file if <ph id=\"ph1\">`Output`</ph> data is empty.","pos":[0,57],"source":"Nothing is written to the file if `Output` data is empty."},{"content":"However, for null data, <ph id=\"ph1\">`#NULL#`</ph> is written.","pos":[58,102],"source":" However, for null data, `#NULL#` is written."}]},{"pos":[1473,1594],"content":"For `Error` data, the output appears as `#ERROR errorcode#`. The `Error` keyword is not translated, regardless of locale.","nodes":[{"content":"For <ph id=\"ph1\">`Error`</ph> data, the output appears as <ph id=\"ph2\">`#ERROR errorcode#`</ph>.","pos":[0,60],"source":"For `Error` data, the output appears as `#ERROR errorcode#`."},{"content":"The <ph id=\"ph1\">`Error`</ph> keyword is not translated, regardless of locale.","pos":[61,121],"source":" The `Error` keyword is not translated, regardless of locale."}]},{"pos":[1601,1770],"content":"<ph id=\"ph1\">`WriteLine`</ph> inserts a newline character (that is, a carriage return/line feed, or <ph id=\"ph2\">`Chr(13) + Chr(10)`</ph>), after it has written the final character in <ph id=\"ph3\">`Output`</ph> to the file.","source":"`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file."},{"pos":[1777,1871],"content":"You can embed quotation marks in a string by using double quotation marks, or \"\". For example,","nodes":[{"content":"You can embed quotation marks in a string by using double quotation marks, or \"\". For example,","pos":[0,94],"nodes":[{"content":"You can embed quotation marks in a string by using double quotation marks, or \"\".","pos":[0,81]},{"content":"For example,","pos":[82,94]}]}]},{"pos":[1878,1989],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#63<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]"},{"pos":[1996,2085],"content":"returns a string with the value of <ph id=\"ph1\">`Double quotation marks aren't \"difficult\" to handle`</ph>.","source":"returns a string with the value of `Double quotation marks aren't \"difficult\" to handle`."},{"pos":[2092,2313],"content":"Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"content":"Writing to a file by using the <ph id=\"ph1\">`Write`</ph> or <ph id=\"ph2\">`WriteLine`</ph> functions requires <ph id=\"ph3\">`Append`</ph> access from the <ph id=\"ph4\">`FileIOPermissionAccess`</ph> enumeration.","pos":[0,135],"source":"Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .","pos":[136,221],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> ."}]}],"pos":[396279,398623],"yaml":true,"extradata":"MT"},{"content":"Required. An `Integer` expression that contains any valid file number.","nodes":[{"pos":[0,70],"content":"Required. An `Integer` expression that contains any valid file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"An <ph id=\"ph1\">`Integer`</ph> expression that contains any valid file number.","pos":[10,70],"source":" An `Integer` expression that contains any valid file number."}]}],"pos":[399003,399074],"yaml":true},{"content":"Optional. One or more comma-delimited expressions to write to a file.","nodes":[{"pos":[0,69],"content":"Optional. One or more comma-delimited expressions to write to a file.","nodes":[{"content":"Optional. One or more comma-delimited expressions to write to a file.","pos":[0,69],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"One or more comma-delimited expressions to write to a file.","pos":[10,69]}]}]}],"pos":[399138,399208],"yaml":true},{"content":"File mode is invalid.","nodes":[{"pos":[0,21],"content":"File mode is invalid.","nodes":[{"content":"File mode is invalid.","pos":[0,21]}]}],"pos":[399362,399384],"yaml":true},{"content":"Writes data to a sequential file. Data written with `Write` is usually read from a file by using `Input`.","nodes":[{"pos":[0,105],"content":"Writes data to a sequential file. Data written with `Write` is usually read from a file by using `Input`.","nodes":[{"content":"Writes data to a sequential file.","pos":[0,33]},{"content":"Data written with <ph id=\"ph1\">`Write`</ph> is usually read from a file by using <ph id=\"ph2\">`Input`</ph>.","pos":[34,105],"source":" Data written with `Write` is usually read from a file by using `Input`."}]}],"pos":[400396,400502],"yaml":true},{"content":"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \n  \n If you omit `Output`, a blank line is printed to the file. Multiple expressions can be separated with a comma.  \n  \n Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file. You do not have to put explicit delimiters in the list. When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported. The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:  \n  \n-   Numeric data is always written using the period as the decimal separator.  \n  \n-   For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed. The `True` and `False` keywords are not translated, regardless of locale.  \n  \n-   Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.  \n  \n-   Nothing is written to the file if `Output` data is empty. However, for null data, `#NULL#` is written.  \n  \n-   For `Error` data, the output appears as `#ERROR errorcode#`. The `Error` keyword is not translated, regardless of locale.  \n  \n `WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.  \n  \n You can embed quotation marks in a string by using double quotation marks, or \"\". For example,  \n  \n [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  \n  \n returns a string with the value of `Double quotation marks aren't \"difficult\" to handle`.  \n  \n Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"pos":[0,347],"content":"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).","nodes":[{"content":"The <ph id=\"ph1\">`Write`</ph> and <ph id=\"ph2\">`WriteLine`</ph> functions are provided for backward compatibility and may affect performance.","pos":[0,105],"source":"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance."},{"content":"For non-legacy applications, the <ph id=\"ph1\">`My.Computer.FileSystem`</ph> object provides better performance.","pos":[106,199],"source":" For non-legacy applications, the `My.Computer.FileSystem` object provides better performance."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>File Access with Visual Basic<ept id=\"p1\">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.","pos":[200,347],"source":" For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)."}]},{"pos":[354,464],"content":"If you omit `Output`, a blank line is printed to the file. Multiple expressions can be separated with a comma.","nodes":[{"content":"If you omit <ph id=\"ph1\">`Output`</ph>, a blank line is printed to the file.","pos":[0,58],"source":"If you omit `Output`, a blank line is printed to the file."},{"content":"Multiple expressions can be separated with a comma.","pos":[59,110]}]},{"pos":[471,939],"content":"Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file. You do not have to put explicit delimiters in the list. When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported. The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:","nodes":[{"content":"Unlike the <ph id=\"ph1\">`Print`</ph> function, the <ph id=\"ph2\">`Write`</ph> function inserts commas between items and quotation marks around strings as they are written to the file.","pos":[0,146],"source":"Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file."},{"content":"You do not have to put explicit delimiters in the list.","pos":[147,202]},{"content":"When <ph id=\"ph1\">`Write`</ph> is used to write data to a file, only numeric, <ph id=\"ph2\">`Boolean`</ph>, date, null, and <ph id=\"ph3\">`Error`</ph> data formats are supported.","pos":[203,325],"source":" When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported."},{"content":"The following universal assumptions are followed so the data can always be read and correctly interpreted using <ph id=\"ph1\">`Input`</ph>, regardless of locale:","pos":[326,468],"source":" The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:"}]},{"pos":[949,1022],"content":"Numeric data is always written using the period as the decimal separator.","nodes":[{"content":"Numeric data is always written using the period as the decimal separator.","pos":[0,73]}]},{"pos":[1032,1166],"content":"For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed. The `True` and `False` keywords are not translated, regardless of locale.","nodes":[{"content":"For <ph id=\"ph1\">`Boolean`</ph> data, either <ph id=\"ph2\">`#TRUE#`</ph> or <ph id=\"ph3\">`#FALSE#`</ph> is printed.","pos":[0,60],"source":"For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed."},{"content":"The <ph id=\"ph1\">`True`</ph> and <ph id=\"ph2\">`False`</ph> keywords are not translated, regardless of locale.","pos":[61,134],"source":" The `True` and `False` keywords are not translated, regardless of locale."}]},{"pos":[1176,1351],"content":"Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.","nodes":[{"content":"Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[0,175],"nodes":[{"content":"Date data is written to the file using the universal date format.","pos":[0,65]},{"content":"When either the date or the time component is missing or zero, only the part provided is written to the file.","pos":[66,175]}]}]},{"pos":[1361,1463],"content":"Nothing is written to the file if `Output` data is empty. However, for null data, `#NULL#` is written.","nodes":[{"content":"Nothing is written to the file if <ph id=\"ph1\">`Output`</ph> data is empty.","pos":[0,57],"source":"Nothing is written to the file if `Output` data is empty."},{"content":"However, for null data, <ph id=\"ph1\">`#NULL#`</ph> is written.","pos":[58,102],"source":" However, for null data, `#NULL#` is written."}]},{"pos":[1473,1594],"content":"For `Error` data, the output appears as `#ERROR errorcode#`. The `Error` keyword is not translated, regardless of locale.","nodes":[{"content":"For <ph id=\"ph1\">`Error`</ph> data, the output appears as <ph id=\"ph2\">`#ERROR errorcode#`</ph>.","pos":[0,60],"source":"For `Error` data, the output appears as `#ERROR errorcode#`."},{"content":"The <ph id=\"ph1\">`Error`</ph> keyword is not translated, regardless of locale.","pos":[61,121],"source":" The `Error` keyword is not translated, regardless of locale."}]},{"pos":[1601,1770],"content":"<ph id=\"ph1\">`WriteLine`</ph> inserts a newline character (that is, a carriage return/line feed, or <ph id=\"ph2\">`Chr(13) + Chr(10)`</ph>), after it has written the final character in <ph id=\"ph3\">`Output`</ph> to the file.","source":"`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file."},{"pos":[1777,1871],"content":"You can embed quotation marks in a string by using double quotation marks, or \"\". For example,","nodes":[{"content":"You can embed quotation marks in a string by using double quotation marks, or \"\". For example,","pos":[0,94],"nodes":[{"content":"You can embed quotation marks in a string by using double quotation marks, or \"\".","pos":[0,81]},{"content":"For example,","pos":[82,94]}]}]},{"pos":[1878,1989],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrCatRef#63<ept id=\"p2\">](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]"},{"pos":[1996,2085],"content":"returns a string with the value of <ph id=\"ph1\">`Double quotation marks aren't \"difficult\" to handle`</ph>.","source":"returns a string with the value of `Double quotation marks aren't \"difficult\" to handle`."},{"pos":[2092,2313],"content":"Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .","nodes":[{"content":"Writing to a file by using the <ph id=\"ph1\">`Write`</ph> or <ph id=\"ph2\">`WriteLine`</ph> functions requires <ph id=\"ph3\">`Append`</ph> access from the <ph id=\"ph4\">`FileIOPermissionAccess`</ph> enumeration.","pos":[0,135],"source":"Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .","pos":[136,221],"source":" For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> ."}]}],"pos":[400513,402857],"yaml":true,"extradata":"MT"},{"content":"Required. An `Integer` expression that contains any valid file number.","nodes":[{"pos":[0,70],"content":"Required. An `Integer` expression that contains any valid file number.","nodes":[{"content":"Required.","pos":[0,9]},{"content":"An <ph id=\"ph1\">`Integer`</ph> expression that contains any valid file number.","pos":[10,70],"source":" An `Integer` expression that contains any valid file number."}]}],"pos":[403241,403312],"yaml":true},{"content":"Optional. One or more comma-delimited expressions to write to a file.","nodes":[{"pos":[0,69],"content":"Optional. One or more comma-delimited expressions to write to a file.","nodes":[{"content":"Optional. One or more comma-delimited expressions to write to a file.","pos":[0,69],"nodes":[{"content":"Optional.","pos":[0,9]},{"content":"One or more comma-delimited expressions to write to a file.","pos":[10,69]}]}]}],"pos":[403376,403446],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: Microsoft.VisualBasic.FileSystem\n  commentId: T:Microsoft.VisualBasic.FileSystem\n  id: FileSystem\n  children:\n  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)\n  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)\n  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)\n  - Microsoft.VisualBasic.FileSystem.CurDir\n  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)\n  - Microsoft.VisualBasic.FileSystem.Dir\n  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)\n  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])\n  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)\n  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)\n  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)\n  - Microsoft.VisualBasic.FileSystem.FreeFile\n  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)\n  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)\n  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)\n  - Microsoft.VisualBasic.FileSystem.Kill(System.String)\n  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)\n  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])\n  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])\n  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)\n  - Microsoft.VisualBasic.FileSystem.Reset\n  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)\n  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)\n  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)\n  - Microsoft.VisualBasic.FileSystem.TAB\n  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)\n  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)\n  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)\n  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])\n  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])\n  langs:\n  - csharp\n  name: FileSystem\n  nameWithType: FileSystem\n  fullName: Microsoft.VisualBasic.FileSystem\n  type: Class\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: The `FileSystem` module contains the procedures that are used to perform file, directory or folder, and system operations. The `My` feature gives you better productivity and performance in file I/O operations than using the `FileSystem` module. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: This module supports the Visual Basic language keywords and run-time library members that access files and folders.\n  example:\n  - \"This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \\n  \\n [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]\"\n  syntax:\n    content: >-\n      [Microsoft.VisualBasic.CompilerServices.StandardModule]\n\n      [System.Security.SecurityCritical]\n\n      public sealed class FileSystem\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)\n  id: ChDir(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: ChDir(String)\n  nameWithType: FileSystem.ChDir(String)\n  fullName: FileSystem.ChDir(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Changes the current directory or folder. The `My` feature gives you better productivity and performance in file I/O operations than the `ChDir` function. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref> .\n  remarks: \"The `ChDir` function changes the default directory, but not the default drive. For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:  \\n  \\n [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  \\n  \\n You can make relative directory changes is by typing two periods, as follows:  \\n  \\n [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  \\n  \\n> [!IMPORTANT]\\n>  The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and .\"\n  example:\n  - \"This example uses the `ChDir` function to change the current directory or folder.  \\n  \\n [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]\"\n  syntax:\n    content: public static void ChDir (string Path);\n    parameters:\n    - id: Path\n      type: System.String\n      description: Required. A `String` expression that identifies which directory or folder becomes the new default directory or folder. <code>Path</code> may include the drive. If no drive is specified, `ChDir` changes the default directory or folder on the current drive.\n  overload: Microsoft.VisualBasic.FileSystem.ChDir*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>Path</code> is empty.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: Invalid drive is specified, or drive is unavailable.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)\n  commentId: M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)\n  id: ChDrive(System.Char)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: ChDrive(Char)\n  nameWithType: FileSystem.ChDrive(Char)\n  fullName: FileSystem.ChDrive(Char)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Changes the current drive.\n  remarks: The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).\n  example:\n  - \"This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \\n  \\n [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]\"\n  syntax:\n    content: public static void ChDrive (char Drive);\n    parameters:\n    - id: Drive\n      type: System.Char\n      description: Required. String expression that specifies an existing drive. If you supply a zero-length string (\"\"), the current drive does not change. If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter.\n  overload: Microsoft.VisualBasic.FileSystem.ChDrive*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: Invalid drive is specified, or drive is unavailable.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)\n  id: ChDrive(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: ChDrive(String)\n  nameWithType: FileSystem.ChDrive(String)\n  fullName: FileSystem.ChDrive(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Changes the current drive.\n  remarks: The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations. For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).\n  example:\n  - \"This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \\n  \\n [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]\"\n  syntax:\n    content: public static void ChDrive (string Drive);\n    parameters:\n    - id: Drive\n      type: System.String\n      description: Required. String expression that specifies an existing drive. If you supply a zero-length string (\"\"), the current drive does not change. If the <code>Drive</code> argument is a multiple-character string, `ChDrive` uses only the first letter.\n  overload: Microsoft.VisualBasic.FileSystem.ChDrive*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: Invalid drive is specified, or drive is unavailable.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.CurDir\n  commentId: M:Microsoft.VisualBasic.FileSystem.CurDir\n  id: CurDir\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: CurDir()\n  nameWithType: FileSystem.CurDir()\n  fullName: FileSystem.CurDir()\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a string representing the current path. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>.\n  remarks: ''\n  example:\n  - \"This example uses the `CurDir` function to return the current path.  \\n  \\n [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]\"\n  syntax:\n    content: public static string CurDir ();\n    parameters: []\n    return:\n      type: System.String\n      description: A string representing the current path.\n  overload: Microsoft.VisualBasic.FileSystem.CurDir*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)\n  commentId: M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)\n  id: CurDir(System.Char)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: CurDir(Char)\n  nameWithType: FileSystem.CurDir(Char)\n  fullName: FileSystem.CurDir(Char)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a string representing the current path. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `CurDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory\"></xref>.\n  remarks: ''\n  example:\n  - \"This example uses the `CurDir` function to return the current path.  \\n  \\n [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]\"\n  syntax:\n    content: public static string CurDir (char Drive);\n    parameters:\n    - id: Drive\n      type: System.Char\n      description: Optional. `Char` expression that specifies an existing drive. If no drive is specified, or if <code>Drive</code> is a zero-length string (\"\"), `CurDir` returns the path for the current drive.\n    return:\n      type: System.String\n      description: A string representing the current path.\n  overload: Microsoft.VisualBasic.FileSystem.CurDir*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Dir\n  commentId: M:Microsoft.VisualBasic.FileSystem.Dir\n  id: Dir\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Dir()\n  nameWithType: FileSystem.Dir()\n  fullName: FileSystem.Dir()\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information.\n  remarks: \"The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.  \\n  \\n `VbVolume` returns the volume label for the drive instead of a specific file name.  \\n  \\n You must supply a `PathName` the first time that you call the `Dir` function. To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.  \\n  \\n> [!IMPORTANT]\\n>  To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).  \\n  \\n The `Attributes` argument enumeration values are as follows:  \\n  \\n|Value|Constant|Description|  \\n|-|-|-|  \\n|`Normal`|`vbnormal`|Default. Specifies files without attributes.|  \\n|`ReadOnly`|`vbReadOnly`|Specifies read-only files, and also files without attributes.|  \\n|`Hidden`|`vbHidden`|Specifies hidden files, and also files without attributes.|  \\n|`System`|`vbSystem`|Specifies system files, and also files without attributes.|  \\n|`Volume`|`vbVolume`|Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.|  \\n|`Directory`|`vbDirectory`|Specifies directories or folders, and also files without attributes.|  \\n|`Archive`|`vbArchive`|File has changed since last backup.|  \\n|`Alias`|`vbAlias`|File has a different name.|  \\n  \\n> [!NOTE]\\n>  These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.\"\n  example:\n  - \"This example uses the `Dir` function to check if certain files and directories exist.  \\n  \\n [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]\"\n  syntax:\n    content: public static string Dir ();\n    parameters: []\n    return:\n      type: System.String\n      description: A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.\n  overload: Microsoft.VisualBasic.FileSystem.Dir*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)\n  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Dir(String, FileAttribute)\n  nameWithType: FileSystem.Dir(String, FileAttribute)\n  fullName: FileSystem.Dir(String, FileAttribute)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `Dir` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)\"></xref> for more information.\n  remarks: \"The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.  \\n  \\n `VbVolume` returns the volume label for the drive instead of a specific file name.  \\n  \\n You must supply a `PathName` the first time that you call the `Dir` function. To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.  \\n  \\n> [!IMPORTANT]\\n>  To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).  \\n  \\n The `Attributes` argument enumeration values are as follows:  \\n  \\n|Value|Constant|Description|  \\n|-|-|-|  \\n|`Normal`|`vbnormal`|Default. Specifies files that have no attributes.|  \\n|`ReadOnly`|`vbReadOnly`|Specifies read-only files, in addition to files that have no attributes.|  \\n|`Hidden`|`vbHidden`|Specifies hidden files, in addition to files that have no attributes.|  \\n|`System`|`vbSystem`|Specifies system files, in addition to files that have no attributes.|  \\n|`Volume`|`vbVolume`|Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.|  \\n|`Directory`|`vbDirectory`|Specifies directories or folders, in addition to files that have no attributes.|  \\n|`Archive`|`vbArchive`|File has changed since last backup.|  \\n|`Alias`|`vbAlias`|File has a different name.|  \\n  \\n> [!NOTE]\\n>  These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.\"\n  example:\n  - \"This example uses the `Dir` function to check if certain files and directories exist.  \\n  \\n [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]\"\n  syntax:\n    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);\n    parameters:\n    - id: PathName\n      type: System.String\n      description: Optional. `String` expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (`\"\"`) is returned if <code>PathName</code> is not found.\n    - id: Attributes\n      type: Microsoft.VisualBasic.FileAttribute\n      description: Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, `Dir` returns files that match <code>PathName</code> but have no attributes.\n    return:\n      type: System.String\n      description: A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.\n  overload: Microsoft.VisualBasic.FileSystem.Dir*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)\n  id: EOF(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: EOF(Int32)\n  nameWithType: FileSystem.EOF(Int32)\n  fullName: FileSystem.EOF(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a Boolean value `True` when the end of a file opened for `Random` or sequential `Input` has been reached.\n  remarks: \"Use `EOF` to avoid the error generated by attempting to get input past the end of a file.  \\n  \\n The `EOF` function returns `False` until the end of the file has been reached. With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.  \\n  \\n With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error. Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function. With files opened for `Output`, `EOF` always returns `True`.\"\n  example:\n  - \"This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \\n  \\n [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]\"\n  syntax:\n    content: public static bool EOF (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. An `Integer` that contains any valid file number.\n    return:\n      type: System.Boolean\n      description: Returns a Boolean value `True` when the end of a file opened for `Random` or sequential `Input` has been reached.\n  overload: Microsoft.VisualBasic.FileSystem.EOF*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)\n  id: FileAttr(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileAttr(Int32)\n  nameWithType: FileSystem.FileAttr(Int32)\n  fullName: FileSystem.FileAttr(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns an enumeration representing the file mode for files opened using the `FileOpen` function. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than the `FileAttr` function. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref> for more information.\n  remarks: This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.\n  example:\n  - \"This example uses the `FileAttr` function to return the file mode of an open file.  \\n  \\n [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]\"\n  syntax:\n    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. `Integer`. Any valid file number.\n    return:\n      type: Microsoft.VisualBasic.OpenMode\n      description: \"The following enumeration values indicate the file access mode:  \\n  \\n <table><tbody><tr><td> Value  \\n  \\n </td><td> Mode  \\n  \\n </td></tr><tr><td> 1  \\n  \\n </td><td>`OpenMode.Input`</td></tr><tr><td> 2  \\n  \\n </td><td>`OpenMode.Output`</td></tr><tr><td> 4  \\n  \\n </td><td>`OpenMode.Random`</td></tr><tr><td> 8  \\n  \\n </td><td>`OpenMode.Append`</td></tr><tr><td> 32  \\n  \\n </td><td>`OpenMode.Binary`</td></tr></tbody></table>\"\n  overload: Microsoft.VisualBasic.FileSystem.FileAttr*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])\n  id: FileClose(System.Int32[])\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileClose(Int32[])\n  nameWithType: FileSystem.FileClose(Int32[])\n  fullName: FileSystem.FileClose(Int32[])\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Concludes input/output (I/O) to a file opened using the `FileOpen` function. `My` gives you better productivity and performance in file I/O operations. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> for more information.\n  remarks: \"The `FileClose` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  \\n  \\n If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.  \\n  \\n When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file. All buffer space associated with the closed file is released.  \\n  \\n When the `FileClose` function is executed, the association of a file with its file number ends.\"\n  example:\n  - \"This example uses the `FileClose` function to close a file opened for `Input`.  \\n  \\n [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]\"\n  syntax:\n    content: public static void FileClose (int[] FileNumbers);\n    parameters:\n    - id: FileNumbers\n      type: System.Int32[]\n      description: Optional. Parameter array of 0 or more channels to be closed.\n  overload: Microsoft.VisualBasic.FileSystem.FileClose*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: <code>FileNumber</code> does not exist.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)\n  id: FileCopy(System.String,System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileCopy(String, String)\n  nameWithType: FileSystem.FileCopy(String, String)\n  fullName: FileSystem.FileCopy(String, String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Copies a file. The <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> gives you better productivity and performance in file I/O operations than `FileCopy`. See <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)\"></xref> for more information.\n  remarks: \"If you try to use the `FileCopy` function on a currently open file, an error occurs.  \\n  \\n `FileCopy` requires full trust to work on the local drive.\"\n  example:\n  - \"This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \\n  \\n [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]\"\n  syntax:\n    content: public static void FileCopy (string Source, string Destination);\n    parameters:\n    - id: Source\n      type: System.String\n      description: Required. `String` expression that specifies the name of the file to be copied. <code>Source</code> may include the directory or folder, and drive, of the source file.\n    - id: Destination\n      type: System.String\n      description: Required. `String` expression that specifies the destination file name. <code>Destination</code> may include the directory or folder, and drive, of the destination file.\n  overload: Microsoft.VisualBasic.FileSystem.FileCopy*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>Source</code> or <code>Destination</code> is invalid or not specified.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File is already open.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: File does not exist.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)\n  id: FileDateTime(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileDateTime(String)\n  nameWithType: FileSystem.FileDateTime(String)\n  fullName: FileSystem.FileDateTime(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a `Date` value that indicates the date and time a file was written to. The `My` feature gives you better productivity and performance in file I/O operations than `FileDateTime`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>\n  remarks: ''\n  example:\n  - \"This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \\n  \\n [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]\"\n  syntax:\n    content: public static DateTime FileDateTime (string PathName);\n    parameters:\n    - id: PathName\n      type: System.String\n      description: Required. `String` expression that specifies a file name. <code>PathName</code> may include the directory or folder, and the drive.\n    return:\n      type: System.DateTime\n      description: '`Date` value that indicates the date and time a file was created or last modified.'\n  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>PathName</code> is invalid or contains wildcards.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: Target file does not exist.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)\n  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Array, Int64, Boolean, Boolean)\n  nameWithType: FileSystem.FileGet(Int32, Array, Int64, Boolean, Boolean)\n  fullName: FileSystem.FileGet(Int32, Array, Int64, Boolean, Boolean)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Array\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n    - id: ArrayIsDynamic\n      type: System.Boolean\n      description: Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.\n    - id: StringIsFixedLength\n      type: System.Boolean\n      description: Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is `False`.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)\n  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, String, Int64, Boolean)\n  nameWithType: FileSystem.FileGet(Int32, String, Int64, Boolean)\n  fullName: FileSystem.FileGet(Int32, String, Int64, Boolean)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.String\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n    - id: StringIsFixedLength\n      type: System.Boolean\n      description: Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is `False`.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)\n  id: FileGet(System.Int32,System.ValueType@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, ValueType, Int64)\n  nameWithType: FileSystem.FileGet(Int32, ValueType, Int64)\n  fullName: FileSystem.FileGet(Int32, ValueType, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.ValueType\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)\n  id: FileGet(System.Int32,System.Single@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Single, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Single, Int64)\n  fullName: FileSystem.FileGet(Int32, Single, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Single\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)\n  id: FileGet(System.Int32,System.Int64@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Int64, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Int64, Int64)\n  fullName: FileSystem.FileGet(Int32, Int64, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int64\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)\n  id: FileGet(System.Int32,System.Int32@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Int32, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Int32, Int64)\n  fullName: FileSystem.FileGet(Int32, Int32, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int32\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)\n  id: FileGet(System.Int32,System.Decimal@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Decimal, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Decimal, Int64)\n  fullName: FileSystem.FileGet(Int32, Decimal, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Decimal\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)\n  id: FileGet(System.Int32,System.Double@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Double, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Double, Int64)\n  fullName: FileSystem.FileGet(Int32, Double, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Double\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)\n  id: FileGet(System.Int32,System.DateTime@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, DateTime, Int64)\n  nameWithType: FileSystem.FileGet(Int32, DateTime, Int64)\n  fullName: FileSystem.FileGet(Int32, DateTime, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file with `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.DateTime\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)\n  id: FileGet(System.Int32,System.Char@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Char, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Char, Int64)\n  fullName: FileSystem.FileGet(Int32, Char, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file with `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Char\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)\n  id: FileGet(System.Int32,System.Byte@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Byte, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Byte, Int64)\n  fullName: FileSystem.FileGet(Int32, Byte, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file with `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Byte\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)\n  id: FileGet(System.Int32,System.Boolean@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Boolean, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Boolean, Int64)\n  fullName: FileSystem.FileGet(Int32, Boolean, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file with `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Boolean\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)\n  id: FileGet(System.Int32,System.Int16@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGet(Int32, Int16, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Int16, Int64)\n  fullName: FileSystem.FileGet(Int32, Int16, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable. The `My` feature gives you better productivity and performance in file I/O operations than `FileGet`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FileGet` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGet` is usually written to a file by using `FilePut`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \\n  \\n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \\n  \\n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  \\n  \\n     The 218 bytes are distributed as follows:  \\n  \\n    -   18 bytes for the descriptor: (2 + 8 * 2)  \\n  \\n    -   200 bytes for the data: (5 * 10 * 4).  \\n  \\n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \\n  \\n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \\n  \\n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n    > [!IMPORTANT]\\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  syntax:\n    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int16\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGet*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)\n  id: FileGetObject(System.Int32,System.Object@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileGetObject(Int32, Object, Int64)\n  nameWithType: FileSystem.FileGetObject(Int32, Object, Int64)\n  fullName: FileSystem.FileGetObject(Int32, Object, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open disk file into a variable.  The `My` feature gives you better productivity and performance in file I/O operations than `FileGetObject`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \\n  \\n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \\n  \\n `FileGetObject` is valid only in `Random` and `Binary` mode.  \\n  \\n Data read with `FileGetObject` is usually written with `FilePutObject`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \\n  \\n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \\n  \\n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \\n  \\n     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  \\n  \\n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 4).  \\n  \\n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.  \\n  \\n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \\n  \\n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.\"\n  example:\n  - \"The following example reads a record into a test file and then retrieves it.  \\n  \\n [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]\"\n  syntax:\n    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Object\n      description: Required. Valid variable name into which data is read.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which reading starts.\n  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)\n  id: FileLen(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileLen(String)\n  nameWithType: FileSystem.FileLen(String)\n  fullName: FileSystem.FileLen(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a `Long` value that specifies the length of a file in bytes. The `My` feature gives you better productivity and performance in file I/O operations than `FileLen`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)\"></xref>.\n  remarks: \"If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.  \\n  \\n> [!NOTE]\\n>  To obtain the current length of an open file, use the `LOF` function.\"\n  example:\n  - \"This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \\n  \\n [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]\"\n  syntax:\n    content: public static long FileLen (string PathName);\n    parameters:\n    - id: PathName\n      type: System.String\n      description: Required. `String` expression that specifies a file. <code>PathName</code> may include the directory or folder, and the drive.\n    return:\n      type: System.Int64\n      description: '`Long` value that specifies the length of a file in bytes.'\n  overload: Microsoft.VisualBasic.FileSystem.FileLen*\n  exceptions:\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: File does not exist.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)\n  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileOpen(Int32, String, OpenMode, OpenAccess, OpenShare, Int32)\n  nameWithType: FileSystem.FileOpen(Int32, String, OpenMode, OpenAccess, OpenShare, Int32)\n  fullName: FileSystem.FileOpen(Int32, String, OpenMode, OpenAccess, OpenShare, Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Opens a file for input or output. The `My` feature gives you better productivity and performance in file I/O operations than `FileOpen`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `FileOpen` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n You must open a file before any I/O operation can be performed on it. `FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.  \\n  \\n> [!IMPORTANT]\\n>  When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist. To do so, it needs permission for the directory in which the file is to be created. However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself. Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory. To help improve security, write data to user directories instead of to the root directory or the Program Files directory.  \\n  \\n The channel to open can be found by using the `FreeFile()` function.  \\n  \\n> [!IMPORTANT]\\n>  The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \\n  \\n The following code opens the file `TestFile` in `Input` mode.  \\n  \\n [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  \\n  \\n This example opens the file in `Binary` mode for writing operations only.  \\n  \\n [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  \\n  \\n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \\n  \\n [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  \\n  \\n This code example opens the file in `Output` mode; any process can read or write to file.  \\n  \\n [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  \\n  \\n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \\n  \\n [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]\"\n  syntax:\n    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number. Use the `FreeFile` function to obtain the next available file number.\n    - id: FileName\n      type: System.String\n      description: Required. `String` expression that specifies a file name—may include directory or folder, and drive.\n    - id: Mode\n      type: Microsoft.VisualBasic.OpenMode\n      description: 'Required. Enumeration specifying the file mode: `Append`, `Binary`, `Input`, `Output`, or `Random`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenMode\"></xref> .'\n    - id: Access\n      type: Microsoft.VisualBasic.OpenAccess\n      description: 'Optional. Enumeration specifying the operations permitted on the open file: `Read`, `Write`, or `ReadWrite`. Defaults to `ReadWrite`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenAccess\"></xref> .'\n    - id: Share\n      type: Microsoft.VisualBasic.OpenShare\n      description: 'Optional. Enumeration specifying the operations not permitted on the open file by other processes: `Shared`, `Lock Read`, `Lock Write`, and `Lock Read Write`. Defaults to `Lock Read Write`. For more information, see <xref href=\"Microsoft.VisualBasic.OpenShare\"></xref> .'\n    - id: RecordLength\n      type: System.Int32\n      description: Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.\n  overload: Microsoft.VisualBasic.FileSystem.FileOpen*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Record length is negative (and not equal to -1).\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: <code>FileName</code> is already open, or <code>FileName</code> is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)\n  id: FilePut(System.Int32,System.Int64,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Int64, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Int64, Int64)\n  fullName: FileSystem.FilePut(Int32, Int64, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int64\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)\n  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, String, Int64, Boolean)\n  nameWithType: FileSystem.FilePut(Int32, String, Int64, Boolean)\n  fullName: FileSystem.FilePut(Int32, String, Int64, Boolean)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>..\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.String\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n    - id: StringIsFixedLength\n      type: System.Boolean\n      description: Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is `False`.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)\n  id: FilePut(System.Object,System.Object,System.Object)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Object, Object, Object)\n  nameWithType: FileSystem.FilePut(Object, Object, Object)\n  fullName: FileSystem.FilePut(Object, Object, Object)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: >-\n      [System.Obsolete(\"This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202\")]\n\n      public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Object\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Object\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Object\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  attributes:\n  - type: System.ObsoleteAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)\n  id: FilePut(System.Int32,System.ValueType,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, ValueType, Int64)\n  nameWithType: FileSystem.FilePut(Int32, ValueType, Int64)\n  fullName: FileSystem.FilePut(Int32, ValueType, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.ValueType\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)\n  id: FilePut(System.Int32,System.Single,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Single, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Single, Int64)\n  fullName: FileSystem.FilePut(Int32, Single, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Single\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)\n  id: FilePut(System.Int32,System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Int32, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Int32, Int64)\n  fullName: FileSystem.FilePut(Int32, Int32, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int32\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)\n  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Array, Int64, Boolean, Boolean)\n  nameWithType: FileSystem.FilePut(Int32, Array, Int64, Boolean, Boolean)\n  fullName: FileSystem.FilePut(Int32, Array, Int64, Boolean, Boolean)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Array\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n    - id: ArrayIsDynamic\n      type: System.Boolean\n      description: Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.\n    - id: StringIsFixedLength\n      type: System.Boolean\n      description: Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is `False`.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)\n  id: FilePut(System.Int32,System.Double,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Double, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Double, Int64)\n  fullName: FileSystem.FilePut(Int32, Double, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Double\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)\n  id: FilePut(System.Int32,System.Decimal,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Decimal, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Decimal, Int64)\n  fullName: FileSystem.FilePut(Int32, Decimal, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Decimal\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)\n  id: FilePut(System.Int32,System.DateTime,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, DateTime, Int64)\n  nameWithType: FileSystem.FilePut(Int32, DateTime, Int64)\n  fullName: FileSystem.FilePut(Int32, DateTime, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.DateTime\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)\n  id: FilePut(System.Int32,System.Char,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Char, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Char, Int64)\n  fullName: FileSystem.FilePut(Int32, Char, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Char\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)\n  id: FilePut(System.Int32,System.Byte,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Byte, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Byte, Int64)\n  fullName: FileSystem.FilePut(Int32, Byte, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Byte\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)\n  id: FilePut(System.Int32,System.Boolean,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Boolean, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Boolean, Int64)\n  fullName: FileSystem.FilePut(Int32, Boolean, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Boolean\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)\n  id: FilePut(System.Int32,System.Int16,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePut(Int32, Int16, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Int16, Int64)\n  fullName: FileSystem.FilePut(Int32, Int16, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file. The `My` feature gives you better productivity and performance in file I/O operations than `FilePut`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`FilePut` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePut` is usually read from a file by using `FileGet`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePut` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.  \\n  \\n-   If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array. Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array. Visual Basic 2005 defaults to not writing the descriptor. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \\n  \\n     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  \\n  \\n-   If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.  \\n  \\n-   `FilePut` writes elements of structures as if each were written individually, except there is no padding between elements. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.  \\n  \\n    > [!NOTE]\\n    >  String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePut` writes all variables to disk contiguously, that is, without padding between records.  \\n  \\n-   For any array other than an array in a structure, `FilePut` writes only the data. No descriptor is written.  \\n  \\n-   `FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 11 bytes to file number 1:  \\n  \\n     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  \\n  \\n-   Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \\n  \\n [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]\"\n  syntax:\n    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int16\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePut*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>RecordNumber</code> < 1 and not equal to -1.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)\n  id: FilePutObject(System.Int32,System.Object,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FilePutObject(Int32, Object, Int64)\n  nameWithType: FileSystem.FilePutObject(Int32, Object, Int64)\n  fullName: FileSystem.FilePutObject(Int32, Object, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data from a variable to a disk file.  The `My` feature gives you better productivity and performance in file I/O operations than `FilePutObject`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \\n  \\n `FilePutObject` writes and reads descriptors that describe the object. If you intend to write out the `Variant` type, `FilePutObject` is required. When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.  \\n  \\n `FilePutObject` is valid only in `Random` and `Binary` mode.  \\n  \\n Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.  \\n  \\n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).  \\n  \\n The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length. `FilePutObject` does not write the length descriptor when the argument is `True`. If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.  \\n  \\n## Random Mode  \\n For files opened in `Random` mode, the following rules apply:  \\n  \\n-   If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.  \\n  \\n-   If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable. For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.  \\n  \\n-   If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data. The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string. If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \\n  \\n-   If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).  \\n  \\n## Binary Mode  \\n For files opened in `Binary` mode, all the `Random` mode rules apply, except:  \\n  \\n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FilePutObject` writes all variables to disk contiguously, that is, without padding between records.\"\n  example:\n  - \"This example uses the `FilePutObject` function to write a string to a file.  \\n  \\n [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]\"\n  syntax:\n    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Object\n      description: Required. Valid variable name that contains data written to disk.\n    - id: RecordNumber\n      type: System.Int64\n      description: Optional. Record number (`Random` mode files) or byte number (`Binary` mode files) at which writing starts.\n  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)\n  id: FileWidth(System.Int32,System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FileWidth(Int32, Int32)\n  nameWithType: FileSystem.FileWidth(Int32, Int32)\n  fullName: FileSystem.FileWidth(Int32, Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Assigns an output line width to a file opened by using the `FileOpen` function.\n  remarks: ''\n  example:\n  - \"This example uses the `FileWidth` function to set the output line width for a file.  \\n  \\n [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]\"\n  syntax:\n    content: public static void FileWidth (int FileNumber, int RecordWidth);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: RecordWidth\n      type: System.Int32\n      description: Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <code>RecordWidth</code> equals 0, there is no limit to the length of a line. The default value for <code>RecordWidth</code> is 0.\n  overload: Microsoft.VisualBasic.FileSystem.FileWidth*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.FreeFile\n  commentId: M:Microsoft.VisualBasic.FileSystem.FreeFile\n  id: FreeFile\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: FreeFile()\n  nameWithType: FileSystem.FreeFile()\n  fullName: FileSystem.FreeFile()\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns an `Integer` value that represents the next file number available for use by the `FileOpen` function.\n  remarks: Use `FreeFile` to supply a file number that is not already being used.\n  example:\n  - \"This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \\n  \\n [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]\"\n  syntax:\n    content: public static int FreeFile ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: Returns an `Integer` value that represents the next file number available for use by the `FileOpen` function.\n  overload: Microsoft.VisualBasic.FileSystem.FreeFile*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: More than 255 files are in use.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)\n  id: GetAttr(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: GetAttr(String)\n  nameWithType: FileSystem.GetAttr(String)\n  fullName: FileSystem.GetAttr(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a `FileAttribute` value that represents the attributes of a file, directory, or folder. The `My` feature gives you better productivity and performance in file I/O operations than `FileAttribute`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want. If the result is not zero, that attribute is set for the named file. For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:  \\n  \\n```vb  \\nResult = GetAttr(FName) And vbArchive  \\n```  \\n  \\n A nonzero value is returned if the `Archive` attribute is set.\"\n  example:\n  - \"This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \\n  \\n [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]\"\n  syntax:\n    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);\n    parameters:\n    - id: PathName\n      type: System.String\n      description: Required. `String` expression that specifies a file, directory, or folder name. <code>PathName</code> can include the directory or folder, and the drive.\n    return:\n      type: Microsoft.VisualBasic.FileAttribute\n      description: \"The value returned by `GetAttr` is the sum of the following enumeration values:  \\n  \\n <table><tbody><tr><td> Value  \\n  \\n </td><td> Constant  \\n  \\n  Description  \\n  \\n </td></tr><tr><td>`Normal`</td><td>`vbNormal` Normal.  \\n  \\n </td></tr><tr><td>`ReadOnly`</td><td>`vbReadOnly` Read-only.  \\n  \\n </td></tr><tr><td>`Hidden`</td><td>`vbHidden` Hidden.  \\n  \\n </td></tr><tr><td>`System`</td><td>`vbSystem` System file.  \\n  \\n </td></tr><tr><td>`Directory`</td><td>`vbDirectory` Directory or folder.  \\n  \\n </td></tr><tr><td>`Archive`</td><td>`vbArchive` File has changed since last backup.  \\n  \\n </td></tr><tr><td>`Alias`</td><td>`vbAlias` File has a different name.  \\n  \\n </td></tr></tbody></table><block subset=\\\"none\\\" type=\\\"note\\\"><p>  \\n These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  \\n  \\n</p></block>\"\n  overload: Microsoft.VisualBasic.FileSystem.GetAttr*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: <code>Pathname</code> is invalid or contains wildcards.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: Target file does not exist.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)\n  id: Input(System.Int32,System.Object@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Object)\n  nameWithType: FileSystem.Input(Int32, Object)\n  fullName: FileSystem.Input(Int32, Object)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref object Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Object\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)\n  id: Input(System.Int32,System.Int64@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Int64)\n  nameWithType: FileSystem.Input(Int32, Int64)\n  fullName: FileSystem.Input(Int32, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref long Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int64\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)\n  id: Input(System.Int32,System.Int32@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Int32)\n  nameWithType: FileSystem.Input(Int32, Int32)\n  fullName: FileSystem.Input(Int32, Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref int Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int32\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)\n  id: Input(System.Int32,System.Int16@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Int16)\n  nameWithType: FileSystem.Input(Int32, Int16)\n  fullName: FileSystem.Input(Int32, Int16)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref short Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Int16\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)\n  id: Input(System.Int32,System.Double@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Double)\n  nameWithType: FileSystem.Input(Int32, Double)\n  fullName: FileSystem.Input(Int32, Double)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref double Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Double\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)\n  id: Input(System.Int32,System.Boolean@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Boolean)\n  nameWithType: FileSystem.Input(Int32, Boolean)\n  fullName: FileSystem.Input(Int32, Boolean)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref bool Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Boolean\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)\n  id: Input(System.Int32,System.DateTime@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, DateTime)\n  nameWithType: FileSystem.Input(Int32, DateTime)\n  fullName: FileSystem.Input(Int32, DateTime)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref DateTime Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.DateTime\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)\n  id: Input(System.Int32,System.Char@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Char)\n  nameWithType: FileSystem.Input(Int32, Char)\n  fullName: FileSystem.Input(Int32, Char)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref char Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Char\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)\n  id: Input(System.Int32,System.Byte@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Byte)\n  nameWithType: FileSystem.Input(Int32, Byte)\n  fullName: FileSystem.Input(Int32, Byte)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref byte Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Byte\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)\n  id: Input(System.Int32,System.Single@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Single)\n  nameWithType: FileSystem.Input(Int32, Single)\n  fullName: FileSystem.Input(Int32, Single)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref float Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Single\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)\n  id: Input(System.Int32,System.Decimal@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, Decimal)\n  nameWithType: FileSystem.Input(Int32, Decimal)\n  fullName: FileSystem.Input(Int32, Decimal)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref decimal Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.Decimal\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)\n  id: Input(System.Int32,System.String@)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Input(Int32, String)\n  nameWithType: FileSystem.Input(Int32, String)\n  fullName: FileSystem.Input(Int32, String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads data from an open sequential file and assigns the data to variables.\n  remarks: \"The `Input` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `Input` is usually written to a file by using `Write`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of the file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.  \\n  \\n When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data is treated.  \\n  \\n|Data|Value assigned to variable|  \\n|-|-|  \\n|Delimiting comma or blank line|Empty|  \\n|#NULL#|`DBNull`|  \\n|#TRUE# or #FALSE#|`True` or `False`|  \\n|#`yyyy-mm-dd hh:mm:ss`#|The date and/or time represented by the expression|  \\n|#ERROR `errornumber`#|`errornumber` (variable is an object tagged as an error)|  \\n  \\n If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.  \\n  \\n> [!NOTE]\\n>  The `Input` function is not localized. For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.\"\n  example:\n  - \"This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\\\"Hello\\\", 234).  \\n  \\n [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]\"\n  syntax:\n    content: public static void Input (int FileNumber, ref string Value);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Value\n      type: System.String\n      description: Required. Variable that is assigned the values read from the file—cannot be an array or object variable.\n  overload: Microsoft.VisualBasic.FileSystem.Input*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)\n  id: InputString(System.Int32,System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: InputString(Int32, Int32)\n  nameWithType: FileSystem.InputString(Int32, Int32)\n  fullName: FileSystem.InputString(Int32, Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode. The `My` feature gives you better productivity and performance in file I/O operations than `InputString`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `InputString` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`. Use this function only with files opened in `Input` or `Binary` mode.  \\n  \\n Unlike the `Input` function, the `InputString` function returns all the characters it reads. This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.  \\n  \\n With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error. Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.  \\n  \\n> [!NOTE]\\n>  When reading from files, do not make security decisions about the contents of the file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file.\"\n  example:\n  - \"This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \\n  \\n [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]\"\n  syntax:\n    content: public static string InputString (int FileNumber, int CharCount);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: CharCount\n      type: System.Int32\n      description: Required. Any valid numeric expression specifying the number of characters to read.\n    return:\n      type: System.String\n      description: Returns `String` value that contains characters from a file opened in `Input` or `Binary` mode. The `My` feature gives you better productivity and performance in file I/O operations than `InputString`.\n  overload: Microsoft.VisualBasic.FileSystem.InputString*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: <code>FileNumber</code> does not exist.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>CharCount</code> < 0 or > 214.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Kill(System.String)\n  id: Kill(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Kill(String)\n  nameWithType: FileSystem.Kill(String)\n  fullName: FileSystem.Kill(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Deletes files from a disk. The `My` feature gives you better productivity and performance in file I/O operations than `Kill`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref> .\n  remarks: \"`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.  \\n  \\n **Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code. For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)\"\n  example:\n  - \"This example uses the `Kill` function to delete a file from a disk.  \\n  \\n [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]\"\n  syntax:\n    content: public static void Kill (string PathName);\n    parameters:\n    - id: PathName\n      type: System.String\n      description: Required. `String` expression that specifies one or more file names to be deleted. <code>PathName</code> can include the directory or folder, and the drive.\n  overload: Microsoft.VisualBasic.FileSystem.Kill*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: Target file(s) open.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: Target file(s) not found.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: Permission denied.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)\n  id: LineInput(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: LineInput(Int32)\n  nameWithType: FileSystem.LineInput(Int32)\n  fullName: FileSystem.LineInput(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Reads a single line from an open sequential file and assigns it to a `String` variable.\n  remarks: \"The `LineInput` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n Data read with `LineInput` is usually written to a file by using `Print`.  \\n  \\n> [!IMPORTANT]\\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \\n  \\n The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence. Carriage return/line feed sequences are skipped instead of appended to the character string.  \\n  \\n> [!IMPORTANT]\\n>  Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.\"\n  example:\n  - \"This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \\n  \\n [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]\"\n  syntax:\n    content: public static string LineInput (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    return:\n      type: System.String\n      description: Reads a single line from an open sequential file and assigns it to a `String` variable.\n  overload: Microsoft.VisualBasic.FileSystem.LineInput*\n  exceptions:\n  - type: System.IO.EndOfStreamException\n    commentId: T:System.IO.EndOfStreamException\n    description: End of file reached.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: <code>FileNumber</code> does not exist.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)\n  id: Loc(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Loc(Int32)\n  nameWithType: FileSystem.Loc(Int32)\n  fullName: FileSystem.Loc(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a `Long` value that specifies the current read/write position in an open file.\n  remarks: \"The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.  \\n  \\n The `Loc` function is provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n The following describes the return value for each file access mode:  \\n  \\n|Mode|Return value|  \\n|-|-|  \\n|`Random`|Number of the last record read from or written to the file.|  \\n|`Sequential`|Current byte position in the file divided by 128. However, information returned by `Loc` for sequential files is neither used nor required.|  \\n|`Binary`|Position of the last byte read or written.|\"\n  example:\n  - \"This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \\n  \\n [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]\"\n  syntax:\n    content: public static long Loc (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid `Integer` file number.\n    return:\n      type: System.Int64\n      description: Returns a `Long` value that specifies the current read/write position in an open file.\n  overload: Microsoft.VisualBasic.FileSystem.Loc*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)\n  id: Lock(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Lock(Int32)\n  nameWithType: FileSystem.Lock(Int32)\n  fullName: FileSystem.Lock(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \\n  \\n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \\n  \\n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \\n  \\n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.\"\n  example:\n  - \"This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \\n  \\n [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]\"\n  syntax:\n    content: public static void Lock (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n  overload: Microsoft.VisualBasic.FileSystem.Lock*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)\n  id: Lock(System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Lock(Int32, Int64)\n  nameWithType: FileSystem.Lock(Int32, Int64)\n  fullName: FileSystem.Lock(Int32, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \\n  \\n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \\n  \\n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \\n  \\n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.\"\n  example:\n  - \"This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \\n  \\n [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]\"\n  syntax:\n    content: public static void Lock (int FileNumber, long Record);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Record\n      type: System.Int64\n      description: Optional. Number of the only record or byte to lock or unlock\n  overload: Microsoft.VisualBasic.FileSystem.Lock*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)\n  id: Lock(System.Int32,System.Int64,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Lock(Int32, Int64, Int64)\n  nameWithType: FileSystem.Lock(Int32, Int64, Int64)\n  fullName: FileSystem.Lock(Int32, Int64, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \\n  \\n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \\n  \\n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \\n  \\n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.\"\n  example:\n  - \"This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \\n  \\n [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]\"\n  syntax:\n    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: FromRecord\n      type: System.Int64\n      description: Optional. Number of the first record or byte to lock or unlock.\n    - id: ToRecord\n      type: System.Int64\n      description: Optional. Number of the last record or byte to lock or unlock.\n  overload: Microsoft.VisualBasic.FileSystem.Lock*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)\n  id: LOF(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: LOF(Int32)\n  nameWithType: FileSystem.LOF(Int32)\n  fullName: FileSystem.LOF(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `LOF`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: Use the `FileLen` function to obtain the length of a file that is not open.\n  example:\n  - \"This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \\n  \\n [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]\"\n  syntax:\n    content: public static long LOF (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. An `Integer` that contains a valid file number.\n    return:\n      type: System.Int64\n      description: Returns a `Long` representing the size, in bytes, of a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `LOF`.\n  overload: Microsoft.VisualBasic.FileSystem.LOF*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)\n  id: MkDir(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: MkDir(String)\n  nameWithType: FileSystem.MkDir(String)\n  fullName: FileSystem.MkDir(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Creates a new directory. The `My` feature gives you better productivity and performance in file I/O operations than `MkDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)\"></xref>.\n  remarks: This function creates a new directory.\n  example:\n  - \"This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \\n  \\n [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]\"\n  syntax:\n    content: public static void MkDir (string Path);\n    parameters:\n    - id: Path\n      type: System.String\n      description: Required. `String` expression that identifies the directory to be created. The <code>Path</code> may include the drive. If no drive is specified, `MkDir` creates the new directory on the current drive.\n  overload: Microsoft.VisualBasic.FileSystem.MkDir*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>Path</code> is not specified or is empty.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: Permission denied.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: Directory already exists.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])\n  commentId: M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])\n  id: Print(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Print(Int32, Object[])\n  nameWithType: FileSystem.Print(Int32, Object[])\n  fullName: FileSystem.Print(Int32, Object[])\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes display-formatted data to a sequential file.\n  remarks: \"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n `Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.  \\n  \\n Data written with `Print` is usually read from a file by using `LineInput` or `Input`.  \\n  \\n If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.  \\n  \\n For `Boolean` data, either `True` or `False` is printed. The `True` and `False` keywords are not translated, regardless of the locale.  \\n  \\n Date data is written to the file by using the standard short date format recognized by your system. When either the date or the time component is missing or zero, only the part provided is written to the file.  \\n  \\n Nothing is written to the file if `Output` data is empty. However, if `Output` list data is `DBNull`, `Null` is written to the file.  \\n  \\n For `Error` data, the output appears as `Error errorcode`. The `Error` keyword is not translated regardless of the locale.  \\n  \\n All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, `Write` should be used.  \\n  \\n Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .\"\n  example:\n  - \"This example uses the `Print` and `PrintLine` functions to write data to a file.  \\n  \\n [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]\"\n  syntax:\n    content: public static void Print (int FileNumber, object[] Output);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Output\n      type: System.Object[]\n      description: \"Optional. Zero or more comma-delimited expressions to write to a file.  \\n  \\n The <code>Output</code> argument settings are:  \\n  \\n `T:System.IO.IOException`: File mode is invalid.  \\n  \\n `T:System.IO.IOException`: <code>FileNumber</code> does not exist.\"\n  overload: Microsoft.VisualBasic.FileSystem.Print*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])\n  commentId: M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])\n  id: PrintLine(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: PrintLine(Int32, Object[])\n  nameWithType: FileSystem.PrintLine(Int32, Object[])\n  fullName: FileSystem.PrintLine(Int32, Object[])\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes display-formatted data to a sequential file.\n  remarks: \"The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n `Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.  \\n  \\n Data written with `Print` is usually read from a file by using `LineInput` or `Input`.  \\n  \\n If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.  \\n  \\n For `Boolean` data, either `True` or `False` is printed. The `True` and `False` keywords are not translated, regardless of the locale.  \\n  \\n Date data is written to the file by using the standard short date format recognized by the system. When either the date or the time component is missing or zero, only the part provided is written to the file.  \\n  \\n Nothing is written to the file if `Output` data is empty. However, if `Output` list data is `DBNull`, `Null` is written to the file.  \\n  \\n For `Error` data, the output appears as `Error errorcode`. The `Error` keyword is not translated regardless of the locale.  \\n  \\n All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, `Write` should be used.  \\n  \\n Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .\"\n  example:\n  - \"This example uses the `Print` and `PrintLine` functions to write data to a file.  \\n  \\n [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]\"\n  syntax:\n    content: public static void PrintLine (int FileNumber, object[] Output);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Output\n      type: System.Object[]\n      description: \"Optional. Zero or more comma-delimited expressions to write to a file.  \\n  \\n The <code>Output</code> argument settings are:  \\n  \\n `T:System.IO.IOException`: File mode is invalid.  \\n  \\n `T:System.IO.IOException`: <code>FileNumber</code> does not exist.\"\n  overload: Microsoft.VisualBasic.FileSystem.PrintLine*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)\n  id: Rename(System.String,System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Rename(String, String)\n  nameWithType: FileSystem.Rename(String, String)\n  fullName: FileSystem.Rename(String, String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Renames a disk file or directory. The `My` feature gives you better productivity and performance in file I/O operations than `Rename`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The`Rename` function renames a file and moves it to a different directory, if it is required. The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive. `Rename` cannot create a new file or directory.  \\n  \\n Using the `Rename` function on an open file produces an error. You must close an open file before renaming it. `Rename` arguments cannot include multiple-character (*) and single-character (?) wildcards.  \\n  \\n> [!IMPORTANT]\\n>  When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights. Check to make sure that you are not introducing a possible security risk.\"\n  example:\n  - \"This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \\n  \\n [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]\"\n  syntax:\n    content: public static void Rename (string OldPath, string NewPath);\n    parameters:\n    - id: OldPath\n      type: System.String\n      description: Required. `String` expression that specifies the existing file name and location. <code>OldPath</code> may include the directory, and drive, of the file.\n    - id: NewPath\n      type: System.String\n      description: Required. `String` expression that specifies the new file name and location. <code>NewPath</code> may include directory and drive of the destination location. The file name specified by <code>NewPath</code> cannot already exist.\n  overload: Microsoft.VisualBasic.FileSystem.Rename*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Path is invalid.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: <code>OldPath</code> file does not exist.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: Cannot rename to different device.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Reset\n  commentId: M:Microsoft.VisualBasic.FileSystem.Reset\n  id: Reset\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Reset()\n  nameWithType: FileSystem.Reset()\n  fullName: FileSystem.Reset()\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Closes all disk files opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Reset`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.\n  example:\n  - \"This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \\n  \\n [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]\"\n  syntax:\n    content: public static void Reset ();\n    parameters: []\n  overload: Microsoft.VisualBasic.FileSystem.Reset*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)\n  commentId: M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)\n  id: RmDir(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: RmDir(String)\n  nameWithType: FileSystem.RmDir(String)\n  fullName: FileSystem.RmDir(String)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Removes an existing directory. The `My` feature gives you better productivity and performance in file I/O operations than `RmDir`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*\"></xref>.\n  remarks: An error occurs if you try to use `RmDir` on a directory that contains files. Use the `Kill` function to delete all files before you try to remove a directory.\n  example:\n  - \"This example uses the `RmDir` function to remove an existing directory.  \\n  \\n [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]\"\n  syntax:\n    content: public static void RmDir (string Path);\n    parameters:\n    - id: Path\n      type: System.String\n      description: Required. `String` expression that identifies the directory or folder to be removed. <code>Path</code> can include the drive. If no drive is specified, `RmDir` removes the directory on the current drive.\n  overload: Microsoft.VisualBasic.FileSystem.RmDir*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>Path</code> is not specified or is empty.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: Target directory contains files.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: Directory does not exist.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)\n  id: Seek(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Seek(Int32)\n  nameWithType: FileSystem.Seek(Int32)\n  fullName: FileSystem.Seek(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Seek`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.  \\n  \\n The following describes the return values for each file access mode:  \\n  \\n|Mode|Return Value|  \\n|-|-|  \\n|`Random`|Number of the next record read or written|  \\n|`Binary`, `Input`, `Output`, `Append`|Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.|\"\n  example:\n  - \"This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \\n  \\n [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  \\n  \\n For files opened in `Random` mode, `Seek` returns the number of next record.  \\n  \\n [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  \\n  \\n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \\n  \\n [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  \\n  \\n This example uses the `Seek` function to set the position for the next read or write in a file.  \\n  \\n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \\n  \\n [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]\"\n  syntax:\n    content: public static long Seek (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. An `Integer` that contains a valid file number.\n    return:\n      type: System.Int64\n      description: Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function.\n  overload: Microsoft.VisualBasic.FileSystem.Seek*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)\n  id: Seek(System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Seek(Int32, Int64)\n  nameWithType: FileSystem.Seek(Int32, Int64)\n  fullName: FileSystem.Seek(Int32, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Returns a `Long` specifying the current read/write position in a file opened by using the `FileOpen` function, or sets the position for the next read/write operation in a file opened by using the `FileOpen` function. The `My` feature gives you better productivity and performance in file I/O operations than `Seek`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.  \\n  \\n The following describes the return values for each file access mode:  \\n  \\n|Mode|Return Value|  \\n|-|-|  \\n|`Random`|Number of the next record read or written|  \\n|`Binary`, `Input`, `Output`, `Append`|Byte position at which the next operation occurs. The first byte in a file is at position 1, the second byte is at position 2, and so on.|\"\n  example:\n  - \"This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \\n  \\n [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  \\n  \\n For files opened in `Random` mode, `Seek` returns the number of next record.  \\n  \\n [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  \\n  \\n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \\n  \\n [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  \\n  \\n This example uses the `Seek` function to set the position for the next read or write in a file.  \\n  \\n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \\n  \\n [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]\"\n  syntax:\n    content: public static void Seek (int FileNumber, long Position);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. An `Integer` that contains a valid file number.\n    - id: Position\n      type: System.Int64\n      description: Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.\n  overload: Microsoft.VisualBasic.FileSystem.Seek*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)\n  commentId: M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)\n  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: SetAttr(String, FileAttribute)\n  nameWithType: FileSystem.SetAttr(String, FileAttribute)\n  fullName: FileSystem.SetAttr(String, FileAttribute)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Sets attribute information for a file. The `My` feature gives you better productivity and performance in file I/O operations than `SetAttr`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"A run-time error occurs if you try to set the attributes of an open file.  \\n  \\n The `Attributes` argument enumeration values are as follows:  \\n  \\n|Value|Constant|Description|  \\n|-|-|-|  \\n|`Normal`|`vbNormal`|Normal (default).|  \\n|`ReadOnly`|`vbReadOnly`|Read-only.|  \\n|`Hidden`|`vbHidden`|Hidden.|  \\n|`System`|`vbSystem`|System file.|  \\n|`Volume`|`vbVolume`|Volume label|  \\n|`Directory`|`vbDirectory`|Directory or folder.|  \\n|`Archive`|`vbArchive`|File has changed since last backup.|  \\n|`Alias`|`vbAlias`|File has a different name.|  \\n  \\n> [!NOTE]\\n>  These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code instead of the actual values.\"\n  example:\n  - \"This example uses the `SetAttr` function to set attributes for a file.  \\n  \\n [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]\"\n  syntax:\n    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);\n    parameters:\n    - id: PathName\n      type: System.String\n      description: Required. `String` expression that specifies a file name. <code>PathName</code> can include directory or folder, and drive.\n    - id: Attributes\n      type: Microsoft.VisualBasic.FileAttribute\n      description: Required. Constant or numeric expression, whose sum specifies file attributes.\n  overload: Microsoft.VisualBasic.FileSystem.SetAttr*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>Attribute</code> type is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)\n  commentId: M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)\n  id: SPC(System.Int16)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: SPC(Int16)\n  nameWithType: FileSystem.SPC(Int16)\n  fullName: FileSystem.SPC(Int16)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Used with the `Print` or `PrintLine` function to position output.\n  remarks: \"If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed. If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:  \\n  \\n `currentprintposition`(+(`Count``Mod``width`))  \\n  \\n For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80). If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).  \\n  \\n> [!NOTE]\\n>  Make sure your tabular columns are wide enough to allow for wide letters.\"\n  example:\n  - \"This example uses the `SPC` function to position output in a file and in the **Output** window.  \\n  \\n [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]\"\n  syntax:\n    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);\n    parameters:\n    - id: Count\n      type: System.Int16\n      description: Required. The number of spaces to insert before displaying or printing the next expression in a list.\n    return:\n      type: Microsoft.VisualBasic.SpcInfo\n      description: Used with the `Print` or `PrintLine` function to position output.\n  overload: Microsoft.VisualBasic.FileSystem.SPC*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.TAB\n  commentId: M:Microsoft.VisualBasic.FileSystem.TAB\n  id: TAB\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: TAB()\n  nameWithType: FileSystem.TAB()\n  fullName: FileSystem.TAB()\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Used with the `Print` or `PrintLine` functions to position output.\n  remarks: \"If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line. If `Column` is less than 1, `TAB` moves the print position to column 1. If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:  \\n  \\n Column Mod width  \\n  \\n For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80). If `Column` is less than the current print position, printing starts on the next line at the calculated print position. If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.  \\n  \\n The leftmost print position on an output line is always 1. When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.  \\n  \\n The `TAB` function can also be used with the `WriteLine` function. It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>.  \\n  \\n> [!NOTE]\\n>  Make sure your tabular columns are wide enough to contain wide letters.\"\n  example:\n  - \"This example uses the `TAB` function to position output in a file and in the **Output** window.  \\n  \\n [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]\"\n  syntax:\n    content: public static Microsoft.VisualBasic.TabInfo TAB ();\n    parameters: []\n    return:\n      type: Microsoft.VisualBasic.TabInfo\n      description: Used with the `Print` or `PrintLine` functions to position output.\n  overload: Microsoft.VisualBasic.FileSystem.TAB*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)\n  commentId: M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)\n  id: TAB(System.Int16)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: TAB(Int16)\n  nameWithType: FileSystem.TAB(Int16)\n  fullName: FileSystem.TAB(Int16)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Used with the `Print` or `PrintLine` functions to position output.\n  remarks: \"If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line. If `Column` is less than 1, `TAB` moves the print position to column 1. If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:  \\n  \\n Column Mod width  \\n  \\n For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80). If `Column` is less than the current print position, printing starts on the next line at the calculated print position. If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.  \\n  \\n The leftmost print position on an output line is always 1. When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.  \\n  \\n The `TAB` function can also be used with the `WriteLine` function. It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> or <xref:System.Console.WriteLine%2A?displayProperty=fullName>.  \\n  \\n> [!NOTE]\\n>  Make sure your tabular columns are wide enough to contain wide letters.\"\n  example:\n  - \"This example uses the `TAB` function to position output in a file and in the **Output** window.  \\n  \\n [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]\"\n  syntax:\n    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);\n    parameters:\n    - id: Column\n      type: System.Int16\n      description: Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, `TAB` moves the insertion point to the start of the next print zone.\n    return:\n      type: Microsoft.VisualBasic.TabInfo\n      description: Used with the `Print` or `PrintLine` functions to position output.\n  overload: Microsoft.VisualBasic.FileSystem.TAB*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)\n  id: Unlock(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Unlock(Int32)\n  nameWithType: FileSystem.Unlock(Int32)\n  fullName: FileSystem.Unlock(Int32)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \\n  \\n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \\n  \\n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \\n  \\n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.\"\n  example:\n  - \"This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \\n  \\n [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]\"\n  syntax:\n    content: public static void Unlock (int FileNumber);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n  overload: Microsoft.VisualBasic.FileSystem.Unlock*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)\n  id: Unlock(System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Unlock(Int32, Int64)\n  nameWithType: FileSystem.Unlock(Int32, Int64)\n  fullName: FileSystem.Unlock(Int32, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \\n  \\n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \\n  \\n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \\n  \\n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.\"\n  example:\n  - \"This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \\n  \\n [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]\"\n  syntax:\n    content: public static void Unlock (int FileNumber, long Record);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: Record\n      type: System.Int64\n      description: Optional. Number of the only record or byte to lock or unlock\n  overload: Microsoft.VisualBasic.FileSystem.Unlock*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)\n  commentId: M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)\n  id: Unlock(System.Int32,System.Int64,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Unlock(Int32, Int64, Int64)\n  nameWithType: FileSystem.Unlock(Int32, Int64, Int64)\n  fullName: FileSystem.Unlock(Int32, Int64, Int64)\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Controls access by other processes to all or part of a file opened by using the `Open` function. The `My` feature gives you better productivity and performance in file I/O operations than `Lock` and `Unlock`. For more information, see <xref href=\"Microsoft.VisualBasic.FileIO.FileSystem\"></xref>.\n  remarks: \"The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.  \\n  \\n `Lock` and `Unlock` functions are always used in pairs. The arguments to `Lock` and `Unlock` must be identical.  \\n  \\n If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file. If `Record` alone is specified the single record will be locked/unlocked.  \\n  \\n If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.\"\n  example:\n  - \"This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \\n  \\n [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]\"\n  syntax:\n    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. Any valid file number.\n    - id: FromRecord\n      type: System.Int64\n      description: Optional. Number of the first record or byte to lock or unlock.\n    - id: ToRecord\n      type: System.Int64\n      description: Optional. Number of the last record or byte to lock or unlock.\n  overload: Microsoft.VisualBasic.FileSystem.Unlock*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])\n  commentId: M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])\n  id: Write(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: Write(Int32, Object[])\n  nameWithType: FileSystem.Write(Int32, Object[])\n  fullName: FileSystem.Write(Int32, Object[])\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data to a sequential file. Data written with `Write` is usually read from a file by using `Input`.\n  remarks: \"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n If you omit `Output`, a blank line is printed to the file. Multiple expressions can be separated with a comma.  \\n  \\n Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file. You do not have to put explicit delimiters in the list. When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported. The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:  \\n  \\n-   Numeric data is always written using the period as the decimal separator.  \\n  \\n-   For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed. The `True` and `False` keywords are not translated, regardless of locale.  \\n  \\n-   Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.  \\n  \\n-   Nothing is written to the file if `Output` data is empty. However, for null data, `#NULL#` is written.  \\n  \\n-   For `Error` data, the output appears as `#ERROR errorcode#`. The `Error` keyword is not translated, regardless of locale.  \\n  \\n `WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.  \\n  \\n You can embed quotation marks in a string by using double quotation marks, or \\\"\\\". For example,  \\n  \\n [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  \\n  \\n returns a string with the value of `Double quotation marks aren't \\\"difficult\\\" to handle`.  \\n  \\n Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .\"\n  example:\n  - \"This example uses the `Write` function to write raw data to a sequential file.  \\n  \\n [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]\"\n  syntax:\n    content: public static void Write (int FileNumber, object[] Output);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. An `Integer` expression that contains any valid file number.\n    - id: Output\n      type: System.Object[]\n      description: Optional. One or more comma-delimited expressions to write to a file.\n  overload: Microsoft.VisualBasic.FileSystem.Write*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: File mode is invalid.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])\n  commentId: M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])\n  id: WriteLine(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  langs:\n  - csharp\n  name: WriteLine(Int32, Object[])\n  nameWithType: FileSystem.WriteLine(Int32, Object[])\n  fullName: FileSystem.WriteLine(Int32, Object[])\n  type: Method\n  assemblies:\n  - Microsoft.VisualBasic\n  namespace: Microsoft.VisualBasic\n  summary: Writes data to a sequential file. Data written with `Write` is usually read from a file by using `Input`.\n  remarks: \"The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance. For non-legacy applications, the `My.Computer.FileSystem` object provides better performance. For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  \\n  \\n If you omit `Output`, a blank line is printed to the file. Multiple expressions can be separated with a comma.  \\n  \\n Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file. You do not have to put explicit delimiters in the list. When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported. The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:  \\n  \\n-   Numeric data is always written using the period as the decimal separator.  \\n  \\n-   For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed. The `True` and `False` keywords are not translated, regardless of locale.  \\n  \\n-   Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided is written to the file.  \\n  \\n-   Nothing is written to the file if `Output` data is empty. However, for null data, `#NULL#` is written.  \\n  \\n-   For `Error` data, the output appears as `#ERROR errorcode#`. The `Error` keyword is not translated, regardless of locale.  \\n  \\n `WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.  \\n  \\n You can embed quotation marks in a string by using double quotation marks, or \\\"\\\". For example,  \\n  \\n [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  \\n  \\n returns a string with the value of `Double quotation marks aren't \\\"difficult\\\" to handle`.  \\n  \\n Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration. For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .\"\n  example:\n  - \"This example uses the `Write` function to write raw data to a sequential file.  \\n  \\n [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]\"\n  syntax:\n    content: public static void WriteLine (int FileNumber, object[] Output);\n    parameters:\n    - id: FileNumber\n      type: System.Int32\n      description: Required. An `Integer` expression that contains any valid file number.\n    - id: Output\n      type: System.Object[]\n      description: Optional. One or more comma-delimited expressions to write to a file.\n  overload: Microsoft.VisualBasic.FileSystem.WriteLine*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.IO.FileNotFoundException\n  parent: System.IO\n  isExternal: false\n  name: FileNotFoundException\n  nameWithType: FileNotFoundException\n  fullName: System.IO.FileNotFoundException\n- uid: System.IO.IOException\n  parent: System.IO\n  isExternal: false\n  name: IOException\n  nameWithType: IOException\n  fullName: System.IO.IOException\n- uid: System.Security.SecurityException\n  parent: System.Security\n  isExternal: false\n  name: SecurityException\n  nameWithType: SecurityException\n  fullName: System.Security.SecurityException\n- uid: System.IO.EndOfStreamException\n  parent: System.IO\n  isExternal: false\n  name: EndOfStreamException\n  nameWithType: EndOfStreamException\n  fullName: System.IO.EndOfStreamException\n- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: ChDir(String)\n  nameWithType: FileSystem.ChDir(String)\n  fullName: FileSystem.ChDir(String)\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: ChDrive(Char)\n  nameWithType: FileSystem.ChDrive(Char)\n  fullName: FileSystem.ChDrive(Char)\n- uid: System.Char\n  parent: System\n  isExternal: false\n  name: Char\n  nameWithType: Char\n  fullName: System.Char\n- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: ChDrive(String)\n  nameWithType: FileSystem.ChDrive(String)\n  fullName: FileSystem.ChDrive(String)\n- uid: Microsoft.VisualBasic.FileSystem.CurDir\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: CurDir()\n  nameWithType: FileSystem.CurDir()\n  fullName: FileSystem.CurDir()\n- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: CurDir(Char)\n  nameWithType: FileSystem.CurDir(Char)\n  fullName: FileSystem.CurDir(Char)\n- uid: Microsoft.VisualBasic.FileSystem.Dir\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Dir()\n  nameWithType: FileSystem.Dir()\n  fullName: FileSystem.Dir()\n- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Dir(String, FileAttribute)\n  nameWithType: FileSystem.Dir(String, FileAttribute)\n  fullName: FileSystem.Dir(String, FileAttribute)\n- uid: Microsoft.VisualBasic.FileAttribute\n  parent: Microsoft.VisualBasic\n  isExternal: false\n  name: FileAttribute\n  nameWithType: FileAttribute\n  fullName: Microsoft.VisualBasic.FileAttribute\n- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: EOF(Int32)\n  nameWithType: FileSystem.EOF(Int32)\n  fullName: FileSystem.EOF(Int32)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileAttr(Int32)\n  nameWithType: FileSystem.FileAttr(Int32)\n  fullName: FileSystem.FileAttr(Int32)\n- uid: Microsoft.VisualBasic.OpenMode\n  parent: Microsoft.VisualBasic\n  isExternal: false\n  name: OpenMode\n  nameWithType: OpenMode\n  fullName: Microsoft.VisualBasic.OpenMode\n- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileClose(Int32[])\n  nameWithType: FileSystem.FileClose(Int32[])\n  fullName: FileSystem.FileClose(Int32[])\n- uid: System.Int32[]\n  parent: System\n  isExternal: false\n  name: Int32[]\n  nameWithType: Int32[]\n  fullName: System.Int32[]\n  spec.csharp:\n  - uid: System.Int32\n    name: Int32\n    nameWithType: Int32\n    fullName: System.Int32\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileCopy(String, String)\n  nameWithType: FileSystem.FileCopy(String, String)\n  fullName: FileSystem.FileCopy(String, String)\n- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileDateTime(String)\n  nameWithType: FileSystem.FileDateTime(String)\n  fullName: FileSystem.FileDateTime(String)\n- uid: System.DateTime\n  parent: System\n  isExternal: false\n  name: DateTime\n  nameWithType: DateTime\n  fullName: System.DateTime\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Array, Int64, Boolean, Boolean)\n  nameWithType: FileSystem.FileGet(Int32, Array, Int64, Boolean, Boolean)\n  fullName: FileSystem.FileGet(Int32, Array, Int64, Boolean, Boolean)\n- uid: System.Array\n  parent: System\n  isExternal: false\n  name: Array\n  nameWithType: Array\n  fullName: System.Array\n- uid: System.Int64\n  parent: System\n  isExternal: false\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, String, Int64, Boolean)\n  nameWithType: FileSystem.FileGet(Int32, String, Int64, Boolean)\n  fullName: FileSystem.FileGet(Int32, String, Int64, Boolean)\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, ValueType, Int64)\n  nameWithType: FileSystem.FileGet(Int32, ValueType, Int64)\n  fullName: FileSystem.FileGet(Int32, ValueType, Int64)\n- uid: System.ValueType\n  parent: System\n  isExternal: false\n  name: ValueType\n  nameWithType: ValueType\n  fullName: System.ValueType\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Single, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Single, Int64)\n  fullName: FileSystem.FileGet(Int32, Single, Int64)\n- uid: System.Single\n  parent: System\n  isExternal: false\n  name: Single\n  nameWithType: Single\n  fullName: System.Single\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Int64, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Int64, Int64)\n  fullName: FileSystem.FileGet(Int32, Int64, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Int32, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Int32, Int64)\n  fullName: FileSystem.FileGet(Int32, Int32, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Decimal, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Decimal, Int64)\n  fullName: FileSystem.FileGet(Int32, Decimal, Int64)\n- uid: System.Decimal\n  parent: System\n  isExternal: false\n  name: Decimal\n  nameWithType: Decimal\n  fullName: System.Decimal\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Double, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Double, Int64)\n  fullName: FileSystem.FileGet(Int32, Double, Int64)\n- uid: System.Double\n  parent: System\n  isExternal: false\n  name: Double\n  nameWithType: Double\n  fullName: System.Double\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, DateTime, Int64)\n  nameWithType: FileSystem.FileGet(Int32, DateTime, Int64)\n  fullName: FileSystem.FileGet(Int32, DateTime, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Char, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Char, Int64)\n  fullName: FileSystem.FileGet(Int32, Char, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Byte, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Byte, Int64)\n  fullName: FileSystem.FileGet(Int32, Byte, Int64)\n- uid: System.Byte\n  parent: System\n  isExternal: false\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Boolean, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Boolean, Int64)\n  fullName: FileSystem.FileGet(Int32, Boolean, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet(Int32, Int16, Int64)\n  nameWithType: FileSystem.FileGet(Int32, Int16, Int64)\n  fullName: FileSystem.FileGet(Int32, Int16, Int64)\n- uid: System.Int16\n  parent: System\n  isExternal: false\n  name: Int16\n  nameWithType: Int16\n  fullName: System.Int16\n- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGetObject(Int32, Object, Int64)\n  nameWithType: FileSystem.FileGetObject(Int32, Object, Int64)\n  fullName: FileSystem.FileGetObject(Int32, Object, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileLen(String)\n  nameWithType: FileSystem.FileLen(String)\n  fullName: FileSystem.FileLen(String)\n- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileOpen(Int32, String, OpenMode, OpenAccess, OpenShare, Int32)\n  nameWithType: FileSystem.FileOpen(Int32, String, OpenMode, OpenAccess, OpenShare, Int32)\n  fullName: FileSystem.FileOpen(Int32, String, OpenMode, OpenAccess, OpenShare, Int32)\n- uid: Microsoft.VisualBasic.OpenAccess\n  parent: Microsoft.VisualBasic\n  isExternal: false\n  name: OpenAccess\n  nameWithType: OpenAccess\n  fullName: Microsoft.VisualBasic.OpenAccess\n- uid: Microsoft.VisualBasic.OpenShare\n  parent: Microsoft.VisualBasic\n  isExternal: false\n  name: OpenShare\n  nameWithType: OpenShare\n  fullName: Microsoft.VisualBasic.OpenShare\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Int64, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Int64, Int64)\n  fullName: FileSystem.FilePut(Int32, Int64, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, String, Int64, Boolean)\n  nameWithType: FileSystem.FilePut(Int32, String, Int64, Boolean)\n  fullName: FileSystem.FilePut(Int32, String, Int64, Boolean)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Object, Object, Object)\n  nameWithType: FileSystem.FilePut(Object, Object, Object)\n  fullName: FileSystem.FilePut(Object, Object, Object)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, ValueType, Int64)\n  nameWithType: FileSystem.FilePut(Int32, ValueType, Int64)\n  fullName: FileSystem.FilePut(Int32, ValueType, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Single, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Single, Int64)\n  fullName: FileSystem.FilePut(Int32, Single, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Int32, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Int32, Int64)\n  fullName: FileSystem.FilePut(Int32, Int32, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Array, Int64, Boolean, Boolean)\n  nameWithType: FileSystem.FilePut(Int32, Array, Int64, Boolean, Boolean)\n  fullName: FileSystem.FilePut(Int32, Array, Int64, Boolean, Boolean)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Double, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Double, Int64)\n  fullName: FileSystem.FilePut(Int32, Double, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Decimal, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Decimal, Int64)\n  fullName: FileSystem.FilePut(Int32, Decimal, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, DateTime, Int64)\n  nameWithType: FileSystem.FilePut(Int32, DateTime, Int64)\n  fullName: FileSystem.FilePut(Int32, DateTime, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Char, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Char, Int64)\n  fullName: FileSystem.FilePut(Int32, Char, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Byte, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Byte, Int64)\n  fullName: FileSystem.FilePut(Int32, Byte, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Boolean, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Boolean, Int64)\n  fullName: FileSystem.FilePut(Int32, Boolean, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut(Int32, Int16, Int64)\n  nameWithType: FileSystem.FilePut(Int32, Int16, Int64)\n  fullName: FileSystem.FilePut(Int32, Int16, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePutObject(Int32, Object, Int64)\n  nameWithType: FileSystem.FilePutObject(Int32, Object, Int64)\n  fullName: FileSystem.FilePutObject(Int32, Object, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileWidth(Int32, Int32)\n  nameWithType: FileSystem.FileWidth(Int32, Int32)\n  fullName: FileSystem.FileWidth(Int32, Int32)\n- uid: Microsoft.VisualBasic.FileSystem.FreeFile\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FreeFile()\n  nameWithType: FileSystem.FreeFile()\n  fullName: FileSystem.FreeFile()\n- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: GetAttr(String)\n  nameWithType: FileSystem.GetAttr(String)\n  fullName: FileSystem.GetAttr(String)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Object)\n  nameWithType: FileSystem.Input(Int32, Object)\n  fullName: FileSystem.Input(Int32, Object)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Int64)\n  nameWithType: FileSystem.Input(Int32, Int64)\n  fullName: FileSystem.Input(Int32, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Int32)\n  nameWithType: FileSystem.Input(Int32, Int32)\n  fullName: FileSystem.Input(Int32, Int32)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Int16)\n  nameWithType: FileSystem.Input(Int32, Int16)\n  fullName: FileSystem.Input(Int32, Int16)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Double)\n  nameWithType: FileSystem.Input(Int32, Double)\n  fullName: FileSystem.Input(Int32, Double)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Boolean)\n  nameWithType: FileSystem.Input(Int32, Boolean)\n  fullName: FileSystem.Input(Int32, Boolean)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, DateTime)\n  nameWithType: FileSystem.Input(Int32, DateTime)\n  fullName: FileSystem.Input(Int32, DateTime)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Char)\n  nameWithType: FileSystem.Input(Int32, Char)\n  fullName: FileSystem.Input(Int32, Char)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Byte)\n  nameWithType: FileSystem.Input(Int32, Byte)\n  fullName: FileSystem.Input(Int32, Byte)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Single)\n  nameWithType: FileSystem.Input(Int32, Single)\n  fullName: FileSystem.Input(Int32, Single)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, Decimal)\n  nameWithType: FileSystem.Input(Int32, Decimal)\n  fullName: FileSystem.Input(Int32, Decimal)\n- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input(Int32, String)\n  nameWithType: FileSystem.Input(Int32, String)\n  fullName: FileSystem.Input(Int32, String)\n- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: InputString(Int32, Int32)\n  nameWithType: FileSystem.InputString(Int32, Int32)\n  fullName: FileSystem.InputString(Int32, Int32)\n- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Kill(String)\n  nameWithType: FileSystem.Kill(String)\n  fullName: FileSystem.Kill(String)\n- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: LineInput(Int32)\n  nameWithType: FileSystem.LineInput(Int32)\n  fullName: FileSystem.LineInput(Int32)\n- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Loc(Int32)\n  nameWithType: FileSystem.Loc(Int32)\n  fullName: FileSystem.Loc(Int32)\n- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Lock(Int32)\n  nameWithType: FileSystem.Lock(Int32)\n  fullName: FileSystem.Lock(Int32)\n- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Lock(Int32, Int64)\n  nameWithType: FileSystem.Lock(Int32, Int64)\n  fullName: FileSystem.Lock(Int32, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Lock(Int32, Int64, Int64)\n  nameWithType: FileSystem.Lock(Int32, Int64, Int64)\n  fullName: FileSystem.Lock(Int32, Int64, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: LOF(Int32)\n  nameWithType: FileSystem.LOF(Int32)\n  fullName: FileSystem.LOF(Int32)\n- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: MkDir(String)\n  nameWithType: FileSystem.MkDir(String)\n  fullName: FileSystem.MkDir(String)\n- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Print(Int32, Object[])\n  nameWithType: FileSystem.Print(Int32, Object[])\n  fullName: FileSystem.Print(Int32, Object[])\n- uid: System.Object[]\n  parent: System\n  isExternal: false\n  name: Object[]\n  nameWithType: Object[]\n  fullName: System.Object[]\n  spec.csharp:\n  - uid: System.Object\n    name: Object\n    nameWithType: Object\n    fullName: System.Object\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: PrintLine(Int32, Object[])\n  nameWithType: FileSystem.PrintLine(Int32, Object[])\n  fullName: FileSystem.PrintLine(Int32, Object[])\n- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Rename(String, String)\n  nameWithType: FileSystem.Rename(String, String)\n  fullName: FileSystem.Rename(String, String)\n- uid: Microsoft.VisualBasic.FileSystem.Reset\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Reset()\n  nameWithType: FileSystem.Reset()\n  fullName: FileSystem.Reset()\n- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: RmDir(String)\n  nameWithType: FileSystem.RmDir(String)\n  fullName: FileSystem.RmDir(String)\n- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Seek(Int32)\n  nameWithType: FileSystem.Seek(Int32)\n  fullName: FileSystem.Seek(Int32)\n- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Seek(Int32, Int64)\n  nameWithType: FileSystem.Seek(Int32, Int64)\n  fullName: FileSystem.Seek(Int32, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: SetAttr(String, FileAttribute)\n  nameWithType: FileSystem.SetAttr(String, FileAttribute)\n  fullName: FileSystem.SetAttr(String, FileAttribute)\n- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: SPC(Int16)\n  nameWithType: FileSystem.SPC(Int16)\n  fullName: FileSystem.SPC(Int16)\n- uid: Microsoft.VisualBasic.SpcInfo\n  parent: Microsoft.VisualBasic\n  isExternal: false\n  name: SpcInfo\n  nameWithType: SpcInfo\n  fullName: Microsoft.VisualBasic.SpcInfo\n- uid: Microsoft.VisualBasic.FileSystem.TAB\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: TAB()\n  nameWithType: FileSystem.TAB()\n  fullName: FileSystem.TAB()\n- uid: Microsoft.VisualBasic.TabInfo\n  parent: Microsoft.VisualBasic\n  isExternal: false\n  name: TabInfo\n  nameWithType: TabInfo\n  fullName: Microsoft.VisualBasic.TabInfo\n- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: TAB(Int16)\n  nameWithType: FileSystem.TAB(Int16)\n  fullName: FileSystem.TAB(Int16)\n- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Unlock(Int32)\n  nameWithType: FileSystem.Unlock(Int32)\n  fullName: FileSystem.Unlock(Int32)\n- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Unlock(Int32, Int64)\n  nameWithType: FileSystem.Unlock(Int32, Int64)\n  fullName: FileSystem.Unlock(Int32, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Unlock(Int32, Int64, Int64)\n  nameWithType: FileSystem.Unlock(Int32, Int64, Int64)\n  fullName: FileSystem.Unlock(Int32, Int64, Int64)\n- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Write(Int32, Object[])\n  nameWithType: FileSystem.Write(Int32, Object[])\n  fullName: FileSystem.Write(Int32, Object[])\n- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: WriteLine(Int32, Object[])\n  nameWithType: FileSystem.WriteLine(Int32, Object[])\n  fullName: FileSystem.WriteLine(Int32, Object[])\n- uid: Microsoft.VisualBasic.FileSystem.ChDir*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: ChDir\n  nameWithType: FileSystem.ChDir\n  fullName: FileSystem.ChDir\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.ChDrive*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: ChDrive\n  nameWithType: FileSystem.ChDrive\n  fullName: FileSystem.ChDrive\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.CurDir*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: CurDir\n  nameWithType: FileSystem.CurDir\n  fullName: FileSystem.CurDir\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Dir*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Dir\n  nameWithType: FileSystem.Dir\n  fullName: FileSystem.Dir\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.EOF*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: EOF\n  nameWithType: FileSystem.EOF\n  fullName: FileSystem.EOF\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileAttr*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileAttr\n  nameWithType: FileSystem.FileAttr\n  fullName: FileSystem.FileAttr\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileClose*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileClose\n  nameWithType: FileSystem.FileClose\n  fullName: FileSystem.FileClose\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileCopy*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileCopy\n  nameWithType: FileSystem.FileCopy\n  fullName: FileSystem.FileCopy\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileDateTime\n  nameWithType: FileSystem.FileDateTime\n  fullName: FileSystem.FileDateTime\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileGet*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGet\n  nameWithType: FileSystem.FileGet\n  fullName: FileSystem.FileGet\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileGetObject\n  nameWithType: FileSystem.FileGetObject\n  fullName: FileSystem.FileGetObject\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileLen*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileLen\n  nameWithType: FileSystem.FileLen\n  fullName: FileSystem.FileLen\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileOpen*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileOpen\n  nameWithType: FileSystem.FileOpen\n  fullName: FileSystem.FileOpen\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FilePut*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePut\n  nameWithType: FileSystem.FilePut\n  fullName: FileSystem.FilePut\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FilePutObject\n  nameWithType: FileSystem.FilePutObject\n  fullName: FileSystem.FilePutObject\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FileWidth*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FileWidth\n  nameWithType: FileSystem.FileWidth\n  fullName: FileSystem.FileWidth\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.FreeFile*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: FreeFile\n  nameWithType: FileSystem.FreeFile\n  fullName: FileSystem.FreeFile\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.GetAttr*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: GetAttr\n  nameWithType: FileSystem.GetAttr\n  fullName: FileSystem.GetAttr\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Input*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Input\n  nameWithType: FileSystem.Input\n  fullName: FileSystem.Input\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.InputString*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: InputString\n  nameWithType: FileSystem.InputString\n  fullName: FileSystem.InputString\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Kill*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Kill\n  nameWithType: FileSystem.Kill\n  fullName: FileSystem.Kill\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.LineInput*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: LineInput\n  nameWithType: FileSystem.LineInput\n  fullName: FileSystem.LineInput\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Loc*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Loc\n  nameWithType: FileSystem.Loc\n  fullName: FileSystem.Loc\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Lock*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Lock\n  nameWithType: FileSystem.Lock\n  fullName: FileSystem.Lock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.LOF*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: LOF\n  nameWithType: FileSystem.LOF\n  fullName: FileSystem.LOF\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.MkDir*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: MkDir\n  nameWithType: FileSystem.MkDir\n  fullName: FileSystem.MkDir\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Print*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Print\n  nameWithType: FileSystem.Print\n  fullName: FileSystem.Print\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.PrintLine*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: PrintLine\n  nameWithType: FileSystem.PrintLine\n  fullName: FileSystem.PrintLine\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Rename*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Rename\n  nameWithType: FileSystem.Rename\n  fullName: FileSystem.Rename\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Reset*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Reset\n  nameWithType: FileSystem.Reset\n  fullName: FileSystem.Reset\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.RmDir*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: RmDir\n  nameWithType: FileSystem.RmDir\n  fullName: FileSystem.RmDir\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Seek*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Seek\n  nameWithType: FileSystem.Seek\n  fullName: FileSystem.Seek\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.SetAttr*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: SetAttr\n  nameWithType: FileSystem.SetAttr\n  fullName: FileSystem.SetAttr\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.SPC*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: SPC\n  nameWithType: FileSystem.SPC\n  fullName: FileSystem.SPC\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.TAB*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: TAB\n  nameWithType: FileSystem.TAB\n  fullName: FileSystem.TAB\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Unlock*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Unlock\n  nameWithType: FileSystem.Unlock\n  fullName: FileSystem.Unlock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.Write*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: Write\n  nameWithType: FileSystem.Write\n  fullName: FileSystem.Write\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: Microsoft.VisualBasic.FileSystem.WriteLine*\n  parent: Microsoft.VisualBasic.FileSystem\n  isExternal: false\n  name: WriteLine\n  nameWithType: FileSystem.WriteLine\n  fullName: FileSystem.WriteLine\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/Microsoft.VisualBasic/FileSystem.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}