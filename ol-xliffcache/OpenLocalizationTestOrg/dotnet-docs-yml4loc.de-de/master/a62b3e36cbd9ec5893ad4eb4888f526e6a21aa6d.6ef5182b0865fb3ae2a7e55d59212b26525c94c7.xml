{"nodes":[{"content":"Specifies how a <xref href=\"System.Lazy`1\"></xref> instance synchronizes access among multiple threads.","nodes":[{"pos":[0,103],"content":"Specifies how a <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance synchronizes access among multiple threads.","source":"Specifies how a <xref href=\"System.Lazy`1\"></xref> instance synchronizes access among multiple threads."}],"pos":[596,700],"yaml":true},{"content":"Use this enumeration to specify the `mode` parameter of <xref:System.Lazy%601> constructors. The effects of all constructors on thread synchronization can be described in terms of this enumeration, whether or not they have `mode` parameters.  \n  \n A <xref:System.Lazy%601> instance is initialized either by a user-specified initialization method or by the default constructor for `T`. The initialization method is specified by the `valueFactory` parameter of a <xref:System.Lazy%601> constructor. The method returns an instance of `T`, which is the type that is lazily instantiated by the instance of <xref:System.Lazy%601>. If a constructor does not have a `valueFactory` parameter, the default constructor for `T` is used to initialize the <xref:System.Lazy%601> instance. In either case, initialization occurs the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property.  \n  \n In addition to specifying the thread safety of a <xref:System.Lazy%601> instance, this enumeration affects exception caching. When exceptions are cached for a <xref:System.Lazy%601> instance, you get only one chance to initialize the instance. If an exception is thrown the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property, that exception is cached and rethrown on all subsequent calls to the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property. The advantage of caching exceptions is that any two threads always get the same result, even when errors occur.  \n  \n When you specify the PublicationOnly mode, exceptions are never cached. When you specify None or ExecutionAndPublication, caching depends on whether you specify an initialization method or allow the default constructor for `T` to be used. Specifying an initialization method enables exception caching for these two modes. The initialization method can be very simple. For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic. If you use a constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached. The following table summarizes exception caching behavior.  \n  \n|Mode|Using initialization method|Using default constructor for `T`|  \n|----------|---------------------------------|---------------------------------------|  \n|None|Cached|Not cached|  \n|PublicationOnly|Not cached|Not cached|  \n|ExecutionAndPublication|Cached|Not cached|","nodes":[{"pos":[0,241],"content":"Use this enumeration to specify the `mode` parameter of <xref:System.Lazy%601> constructors. The effects of all constructors on thread synchronization can be described in terms of this enumeration, whether or not they have `mode` parameters.","nodes":[{"content":"Use this enumeration to specify the <ph id=\"ph1\">`mode`</ph> parameter of <ph id=\"ph2\">&lt;xref:System.Lazy%601&gt;</ph> constructors.","pos":[0,92],"source":"Use this enumeration to specify the `mode` parameter of <xref:System.Lazy%601> constructors."},{"content":"The effects of all constructors on thread synchronization can be described in terms of this enumeration, whether or not they have <ph id=\"ph1\">`mode`</ph> parameters.","pos":[93,241],"source":" The effects of all constructors on thread synchronization can be described in terms of this enumeration, whether or not they have `mode` parameters."}]},{"pos":[248,907],"content":"A <xref:System.Lazy%601> instance is initialized either by a user-specified initialization method or by the default constructor for `T`. The initialization method is specified by the `valueFactory` parameter of a <xref:System.Lazy%601> constructor. The method returns an instance of `T`, which is the type that is lazily instantiated by the instance of <xref:System.Lazy%601>. If a constructor does not have a `valueFactory` parameter, the default constructor for `T` is used to initialize the <xref:System.Lazy%601> instance. In either case, initialization occurs the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref:System.Lazy%601&gt;</ph> instance is initialized either by a user-specified initialization method or by the default constructor for <ph id=\"ph2\">`T`</ph>.","pos":[0,136],"source":"A <xref:System.Lazy%601> instance is initialized either by a user-specified initialization method or by the default constructor for `T`."},{"content":"The initialization method is specified by the <ph id=\"ph1\">`valueFactory`</ph> parameter of a <ph id=\"ph2\">&lt;xref:System.Lazy%601&gt;</ph> constructor.","pos":[137,248],"source":" The initialization method is specified by the `valueFactory` parameter of a <xref:System.Lazy%601> constructor."},{"content":"The method returns an instance of <ph id=\"ph1\">`T`</ph>, which is the type that is lazily instantiated by the instance of <ph id=\"ph2\">&lt;xref:System.Lazy%601&gt;</ph>.","pos":[249,376],"source":" The method returns an instance of `T`, which is the type that is lazily instantiated by the instance of <xref:System.Lazy%601>."},{"content":"If a constructor does not have a <ph id=\"ph1\">`valueFactory`</ph> parameter, the default constructor for <ph id=\"ph2\">`T`</ph> is used to initialize the <ph id=\"ph3\">&lt;xref:System.Lazy%601&gt;</ph> instance.","pos":[377,526],"source":" If a constructor does not have a `valueFactory` parameter, the default constructor for `T` is used to initialize the <xref:System.Lazy%601> instance."},{"content":"In either case, initialization occurs the first time you call the <ph id=\"ph1\">&lt;xref:System.Lazy%601.Value%2A?displayProperty=fullName&gt;</ph> property.","pos":[527,659],"source":" In either case, initialization occurs the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property."}]},{"pos":[914,1526],"content":"In addition to specifying the thread safety of a <xref:System.Lazy%601> instance, this enumeration affects exception caching. When exceptions are cached for a <xref:System.Lazy%601> instance, you get only one chance to initialize the instance. If an exception is thrown the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property, that exception is cached and rethrown on all subsequent calls to the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property. The advantage of caching exceptions is that any two threads always get the same result, even when errors occur.","nodes":[{"content":"In addition to specifying the thread safety of a <xref:System.Lazy%601> instance, this enumeration affects exception caching. When exceptions are cached for a <xref:System.Lazy%601> instance, you get only one chance to initialize the instance. If an exception is thrown the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property, that exception is cached and rethrown on all subsequent calls to the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property. The advantage of caching exceptions is that any two threads always get the same result, even when errors occur.","pos":[0,612],"nodes":[{"content":"In addition to specifying the thread safety of a <ph id=\"ph1\">&lt;xref:System.Lazy%601&gt;</ph> instance, this enumeration affects exception caching.","pos":[0,125],"source":"In addition to specifying the thread safety of a <xref:System.Lazy%601> instance, this enumeration affects exception caching."},{"content":"When exceptions are cached for a <ph id=\"ph1\">&lt;xref:System.Lazy%601&gt;</ph> instance, you get only one chance to initialize the instance.","pos":[126,243],"source":" When exceptions are cached for a <xref:System.Lazy%601> instance, you get only one chance to initialize the instance."},{"content":"If an exception is thrown the first time you call the <ph id=\"ph1\">&lt;xref:System.Lazy%601.Value%2A?displayProperty=fullName&gt;</ph> property, that exception is cached and rethrown on all subsequent calls to the <ph id=\"ph2\">&lt;xref:System.Lazy%601.Value%2A?displayProperty=fullName&gt;</ph> property.","pos":[244,500],"source":" If an exception is thrown the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property, that exception is cached and rethrown on all subsequent calls to the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property."},{"content":"The advantage of caching exceptions is that any two threads always get the same result, even when errors occur.","pos":[501,612]}]}]},{"pos":[1533,2297],"content":"When you specify the PublicationOnly mode, exceptions are never cached. When you specify None or ExecutionAndPublication, caching depends on whether you specify an initialization method or allow the default constructor for `T` to be used. Specifying an initialization method enables exception caching for these two modes. The initialization method can be very simple. For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic. If you use a constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached. The following table summarizes exception caching behavior.","nodes":[{"content":"When you specify the PublicationOnly mode, exceptions are never cached.","pos":[0,71]},{"content":"When you specify None or ExecutionAndPublication, caching depends on whether you specify an initialization method or allow the default constructor for <ph id=\"ph1\">`T`</ph> to be used.","pos":[72,238],"source":" When you specify None or ExecutionAndPublication, caching depends on whether you specify an initialization method or allow the default constructor for `T` to be used."},{"content":"Specifying an initialization method enables exception caching for these two modes.","pos":[239,321]},{"content":"The initialization method can be very simple.","pos":[322,367]},{"content":"For example, it might call the default constructor for <ph id=\"ph1\">`T`</ph>: <ph id=\"ph2\">`new Lazy&lt;Contents&gt;(() =&gt; new Contents(), mode)`</ph> in C#, or <ph id=\"ph3\">`New Lazy(Of Contents)(Function() New Contents())`</ph> in Visual Basic.","pos":[368,554],"source":" For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic."},{"content":"If you use a constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <ph id=\"ph1\">`T`</ph> are not cached.","pos":[555,705],"source":" If you use a constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached."},{"content":"The following table summarizes exception caching behavior.","pos":[706,764]}]},{"pos":[2304,2308],"content":"Mode","nodes":[{"content":"Mode","pos":[0,4]}]},{"pos":[2309,2336],"content":"Using initialization method","nodes":[{"content":"Using initialization method","pos":[0,27]}]},{"pos":[2337,2370],"content":"Using default constructor for <ph id=\"ph1\">`T`</ph>","source":"Using default constructor for `T`"},{"pos":[2464,2468],"content":"None","nodes":[{"content":"None","pos":[0,4]}]},{"pos":[2469,2475],"content":"Cached","nodes":[{"content":"Cached","pos":[0,6]}]},{"pos":[2476,2486],"content":"Not cached","nodes":[{"content":"Not cached","pos":[0,10]}]},{"pos":[2491,2506],"content":"PublicationOnly","nodes":[{"content":"PublicationOnly","pos":[0,15]}]},{"pos":[2507,2517],"content":"Not cached","nodes":[{"content":"Not cached","pos":[0,10]}]},{"pos":[2518,2528],"content":"Not cached","nodes":[{"content":"Not cached","pos":[0,10]}]},{"pos":[2533,2556],"content":"ExecutionAndPublication","nodes":[{"content":"ExecutionAndPublication","pos":[0,23]}]},{"pos":[2557,2563],"content":"Cached","nodes":[{"content":"Cached","pos":[0,6]}]},{"pos":[2564,2574],"content":"Not cached","nodes":[{"content":"Not cached","pos":[0,10]}]}],"pos":[711,3301],"yaml":true,"extradata":"MT"},{"content":"Locks are used to ensure that only a single thread can initialize a <xref href=\"System.Lazy`1\"></xref> instance in a thread-safe manner. If the initialization method (or the default constructor, if there is no initialization method) uses locks internally, deadlocks can occur. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached. In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown.","nodes":[{"pos":[0,1295],"content":"Locks are used to ensure that only a single thread can initialize a <xref href=\"System.Lazy`1\"></xref> instance in a thread-safe manner. If the initialization method (or the default constructor, if there is no initialization method) uses locks internally, deadlocks can occur. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached. In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown.","nodes":[{"content":"Locks are used to ensure that only a single thread can initialize a <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance in a thread-safe manner.","pos":[0,136],"source":"Locks are used to ensure that only a single thread can initialize a <xref href=\"System.Lazy`1\"></xref> instance in a thread-safe manner."},{"content":"If the initialization method (or the default constructor, if there is no initialization method) uses locks internally, deadlocks can occur.","pos":[137,276]},{"content":"If you use a <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> constructor that specifies an initialization method (<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">valueFactory</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <ph id=\"ph3\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property, then the exception is cached and thrown again on subsequent calls to the <ph id=\"ph4\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property.","pos":[277,706],"source":" If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property."},{"content":"If you use a <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">T</ph><ept id=\"p1\">&lt;/code&gt;</ept> are not cached.","pos":[707,903],"source":" If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached."},{"content":"In that case, a subsequent call to the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property might successfully initialize the <ph id=\"ph2\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance.","pos":[904,1071],"source":" In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance."},{"content":"If the initialization method recursively accesses the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property of the <ph id=\"ph2\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance, an <ph id=\"ph3\">&lt;xref href=\"System.InvalidOperationException\"&gt;&lt;/xref&gt;</ph> is thrown.","pos":[1072,1295],"source":" If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown."}]}],"pos":[5016,6312],"yaml":true},{"content":"The <xref href=\"System.Lazy`1\"></xref> instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined. Use this mode only when high performance is crucial and the <xref href=\"System.Lazy`1\"></xref> instance is guaranteed never to be initialized from more than one thread. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached. In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown.","nodes":[{"pos":[0,1333],"content":"The <xref href=\"System.Lazy`1\"></xref> instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined. Use this mode only when high performance is crucial and the <xref href=\"System.Lazy`1\"></xref> instance is guaranteed never to be initialized from more than one thread. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached. In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined.","pos":[0,145],"source":"The <xref href=\"System.Lazy`1\"></xref> instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined."},{"content":"Use this mode only when high performance is crucial and the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance is guaranteed never to be initialized from more than one thread.","pos":[146,314],"source":" Use this mode only when high performance is crucial and the <xref href=\"System.Lazy`1\"></xref> instance is guaranteed never to be initialized from more than one thread."},{"content":"If you use a <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> constructor that specifies an initialization method (<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">valueFactory</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <ph id=\"ph3\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property, then the exception is cached and thrown again on subsequent calls to the <ph id=\"ph4\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property.","pos":[315,744],"source":" If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property."},{"content":"If you use a <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">T</ph><ept id=\"p1\">&lt;/code&gt;</ept> are not cached.","pos":[745,941],"source":" If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached."},{"content":"In that case, a subsequent call to the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property might successfully initialize the <ph id=\"ph2\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance.","pos":[942,1109],"source":" In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance."},{"content":"If the initialization method recursively accesses the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property of the <ph id=\"ph2\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance, an <ph id=\"ph3\">&lt;xref href=\"System.InvalidOperationException\"&gt;&lt;/xref&gt;</ph> is thrown.","pos":[1110,1333],"source":" If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown."}]}],"pos":[7838,9172],"yaml":true},{"content":"When multiple threads try to initialize a <xref href=\"System.Lazy`1\"></xref> instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method). The first thread to complete initialization sets the value of the <xref href=\"System.Lazy`1\"></xref> instance. That value is returned to any other threads that were simultaneously running the initialization method, unless the initialization method throws exceptions on those threads. Any instances of <code>T</code> that were created by the competing threads are discarded. If the initialization method throws an exception on any thread, the exception is propagated out of the <xref href=\"System.Lazy`1.Value\"></xref> property on that thread. The exception is not cached. The value of the <xref href=\"System.Lazy`1.IsValueCreated\"></xref> property remains `false`, and subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, no exception is thrown.","nodes":[{"pos":[0,1269],"content":"When multiple threads try to initialize a <xref href=\"System.Lazy`1\"></xref> instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method). The first thread to complete initialization sets the value of the <xref href=\"System.Lazy`1\"></xref> instance. That value is returned to any other threads that were simultaneously running the initialization method, unless the initialization method throws exceptions on those threads. Any instances of <code>T</code> that were created by the competing threads are discarded. If the initialization method throws an exception on any thread, the exception is propagated out of the <xref href=\"System.Lazy`1.Value\"></xref> property on that thread. The exception is not cached. The value of the <xref href=\"System.Lazy`1.IsValueCreated\"></xref> property remains `false`, and subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, no exception is thrown.","nodes":[{"content":"When multiple threads try to initialize a <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method).","pos":[0,226],"source":"When multiple threads try to initialize a <xref href=\"System.Lazy`1\"></xref> instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method)."},{"content":"The first thread to complete initialization sets the value of the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance.","pos":[227,337],"source":" The first thread to complete initialization sets the value of the <xref href=\"System.Lazy`1\"></xref> instance."},{"content":"That value is returned to any other threads that were simultaneously running the initialization method, unless the initialization method throws exceptions on those threads.","pos":[338,510]},{"content":"Any instances of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">T</ph><ept id=\"p1\">&lt;/code&gt;</ept> that were created by the competing threads are discarded.","pos":[511,600],"source":" Any instances of <code>T</code> that were created by the competing threads are discarded."},{"content":"If the initialization method throws an exception on any thread, the exception is propagated out of the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property on that thread.","pos":[601,769],"source":" If the initialization method throws an exception on any thread, the exception is propagated out of the <xref href=\"System.Lazy`1.Value\"></xref> property on that thread."},{"content":"The exception is not cached.","pos":[770,798]},{"content":"The value of the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1.IsValueCreated\"&gt;&lt;/xref&gt;</ph> property remains <ph id=\"ph2\">`false`</ph>, and subsequent calls to the <ph id=\"ph3\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again.","pos":[799,1089],"source":" The value of the <xref href=\"System.Lazy`1.IsValueCreated\"></xref> property remains `false`, and subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again."},{"content":"If the initialization method recursively accesses the <ph id=\"ph1\">&lt;xref href=\"System.Lazy`1.Value\"&gt;&lt;/xref&gt;</ph> property of the <ph id=\"ph2\">&lt;xref href=\"System.Lazy`1\"&gt;&lt;/xref&gt;</ph> instance, no exception is thrown.","pos":[1090,1269],"source":" If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, no exception is thrown."}]}],"pos":[10745,12015],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.LazyThreadSafetyMode\n  commentId: T:System.Threading.LazyThreadSafetyMode\n  id: LazyThreadSafetyMode\n  children:\n  - System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\n  - System.Threading.LazyThreadSafetyMode.None\n  - System.Threading.LazyThreadSafetyMode.PublicationOnly\n  langs:\n  - csharp\n  name: LazyThreadSafetyMode\n  nameWithType: LazyThreadSafetyMode\n  fullName: System.Threading.LazyThreadSafetyMode\n  type: Enum\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Specifies how a <xref href=\"System.Lazy`1\"></xref> instance synchronizes access among multiple threads.\n  remarks: \"Use this enumeration to specify the `mode` parameter of <xref:System.Lazy%601> constructors. The effects of all constructors on thread synchronization can be described in terms of this enumeration, whether or not they have `mode` parameters.  \\n  \\n A <xref:System.Lazy%601> instance is initialized either by a user-specified initialization method or by the default constructor for `T`. The initialization method is specified by the `valueFactory` parameter of a <xref:System.Lazy%601> constructor. The method returns an instance of `T`, which is the type that is lazily instantiated by the instance of <xref:System.Lazy%601>. If a constructor does not have a `valueFactory` parameter, the default constructor for `T` is used to initialize the <xref:System.Lazy%601> instance. In either case, initialization occurs the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property.  \\n  \\n In addition to specifying the thread safety of a <xref:System.Lazy%601> instance, this enumeration affects exception caching. When exceptions are cached for a <xref:System.Lazy%601> instance, you get only one chance to initialize the instance. If an exception is thrown the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property, that exception is cached and rethrown on all subsequent calls to the <xref:System.Lazy%601.Value%2A?displayProperty=fullName> property. The advantage of caching exceptions is that any two threads always get the same result, even when errors occur.  \\n  \\n When you specify the PublicationOnly mode, exceptions are never cached. When you specify None or ExecutionAndPublication, caching depends on whether you specify an initialization method or allow the default constructor for `T` to be used. Specifying an initialization method enables exception caching for these two modes. The initialization method can be very simple. For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic. If you use a constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached. The following table summarizes exception caching behavior.  \\n  \\n|Mode|Using initialization method|Using default constructor for `T`|  \\n|----------|---------------------------------|---------------------------------------|  \\n|None|Cached|Not cached|  \\n|PublicationOnly|Not cached|Not cached|  \\n|ExecutionAndPublication|Cached|Not cached|\"\n  syntax:\n    content: public enum LazyThreadSafetyMode\n  inheritance:\n  - System.Object\n  - System.ValueType\n  - System.Enum\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/LazyThreadSafetyMode.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\n  commentId: F:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\n  id: ExecutionAndPublication\n  parent: System.Threading.LazyThreadSafetyMode\n  langs:\n  - csharp\n  name: ExecutionAndPublication\n  nameWithType: LazyThreadSafetyMode.ExecutionAndPublication\n  fullName: LazyThreadSafetyMode.ExecutionAndPublication\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Locks are used to ensure that only a single thread can initialize a <xref href=\"System.Lazy`1\"></xref> instance in a thread-safe manner. If the initialization method (or the default constructor, if there is no initialization method) uses locks internally, deadlocks can occur. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached. In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown.\n  syntax:\n    content: ExecutionAndPublication\n    return:\n      type: System.Threading.LazyThreadSafetyMode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/LazyThreadSafetyMode.xml\n- uid: System.Threading.LazyThreadSafetyMode.None\n  commentId: F:System.Threading.LazyThreadSafetyMode.None\n  id: None\n  parent: System.Threading.LazyThreadSafetyMode\n  langs:\n  - csharp\n  name: None\n  nameWithType: LazyThreadSafetyMode.None\n  fullName: LazyThreadSafetyMode.None\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: The <xref href=\"System.Lazy`1\"></xref> instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined. Use this mode only when high performance is crucial and the <xref href=\"System.Lazy`1\"></xref> instance is guaranteed never to be initialized from more than one thread. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that specifies an initialization method (<code>valueFactory</code> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <xref href=\"System.Lazy`1.Value\"></xref> property, then the exception is cached and thrown again on subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property. If you use a <xref href=\"System.Lazy`1\"></xref> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <code>T</code> are not cached. In that case, a subsequent call to the <xref href=\"System.Lazy`1.Value\"></xref> property might successfully initialize the <xref href=\"System.Lazy`1\"></xref> instance. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, an <xref href=\"System.InvalidOperationException\"></xref> is thrown.\n  syntax:\n    content: None\n    return:\n      type: System.Threading.LazyThreadSafetyMode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/LazyThreadSafetyMode.xml\n- uid: System.Threading.LazyThreadSafetyMode.PublicationOnly\n  commentId: F:System.Threading.LazyThreadSafetyMode.PublicationOnly\n  id: PublicationOnly\n  parent: System.Threading.LazyThreadSafetyMode\n  langs:\n  - csharp\n  name: PublicationOnly\n  nameWithType: LazyThreadSafetyMode.PublicationOnly\n  fullName: LazyThreadSafetyMode.PublicationOnly\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: When multiple threads try to initialize a <xref href=\"System.Lazy`1\"></xref> instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method). The first thread to complete initialization sets the value of the <xref href=\"System.Lazy`1\"></xref> instance. That value is returned to any other threads that were simultaneously running the initialization method, unless the initialization method throws exceptions on those threads. Any instances of <code>T</code> that were created by the competing threads are discarded. If the initialization method throws an exception on any thread, the exception is propagated out of the <xref href=\"System.Lazy`1.Value\"></xref> property on that thread. The exception is not cached. The value of the <xref href=\"System.Lazy`1.IsValueCreated\"></xref> property remains `false`, and subsequent calls to the <xref href=\"System.Lazy`1.Value\"></xref> property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again. If the initialization method recursively accesses the <xref href=\"System.Lazy`1.Value\"></xref> property of the <xref href=\"System.Lazy`1\"></xref> instance, no exception is thrown.\n  syntax:\n    content: PublicationOnly\n    return:\n      type: System.Threading.LazyThreadSafetyMode\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/LazyThreadSafetyMode.xml\nreferences:\n- uid: System.Enum\n  parent: System\n  isExternal: false\n  name: Enum\n  nameWithType: Enum\n  fullName: System.Enum\n- uid: System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\n  parent: System.Threading.LazyThreadSafetyMode\n  isExternal: false\n  name: ExecutionAndPublication\n  nameWithType: LazyThreadSafetyMode.ExecutionAndPublication\n  fullName: LazyThreadSafetyMode.ExecutionAndPublication\n- uid: System.Threading.LazyThreadSafetyMode\n  parent: System.Threading\n  isExternal: false\n  name: LazyThreadSafetyMode\n  nameWithType: LazyThreadSafetyMode\n  fullName: System.Threading.LazyThreadSafetyMode\n- uid: System.Threading.LazyThreadSafetyMode.None\n  parent: System.Threading.LazyThreadSafetyMode\n  isExternal: false\n  name: None\n  nameWithType: LazyThreadSafetyMode.None\n  fullName: LazyThreadSafetyMode.None\n- uid: System.Threading.LazyThreadSafetyMode.PublicationOnly\n  parent: System.Threading.LazyThreadSafetyMode\n  isExternal: false\n  name: PublicationOnly\n  nameWithType: LazyThreadSafetyMode.PublicationOnly\n  fullName: LazyThreadSafetyMode.PublicationOnly\n"}