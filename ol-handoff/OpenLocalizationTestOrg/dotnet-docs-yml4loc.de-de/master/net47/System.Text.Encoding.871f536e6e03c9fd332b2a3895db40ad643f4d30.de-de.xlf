<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">614fc6045523d65b3fd198cc4b9136e3585f55b7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Text.Encoding.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7852712df5a1ef84a9f93d3b5d229b4725b14d3e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9f7ba650f94e3ee5472f997d221b481c8ec9d3eb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a character encoding.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25)</ept>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides the following implementations of the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class to support current Unicode encodings and other encodings:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> encodes Unicode characters as single 7-bit ASCII characters.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>This encoding only supports character values between U+0000 and U+007F.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code page 20127.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.UTF7Encoding&gt;</ph> encodes Unicode characters using the UTF-7 encoding.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This encoding supports all Unicode character values.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code page 65000.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF7%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encodes Unicode characters using the UTF-8 encoding.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>This encoding supports all Unicode character values.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code page 65001.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> encodes Unicode characters using the UTF-16 encoding.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both little endian and big endian byte orders are supported.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.Unicode%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> encodes Unicode characters using the UTF-32 encoding.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF32%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class is primarily intended to convert between different encodings and Unicode.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Often one of the derived Unicode classes is the correct choice for your app.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method to obtain other encodings, and call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get a list of all encodings.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the encodings supported by the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>It lists each encoding's code page number and the values of the encoding's <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that code pages whose <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName&gt;</ph> property corresponds to an international standard do not necessarily comply in full with that standard.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code page</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Display name</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>.NET Framework support</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>37</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM037</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (US-Canada)</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>437</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM437</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>OEM United States</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>500</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM500</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (International)</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>708</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>ASMO-708</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arabic (ASMO 708)</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>720</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>DOS-720</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arabic (DOS)</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>737</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>ibm737</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Greek (DOS)</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>775</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>ibm775</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Baltic (DOS)</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>850</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>ibm850</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Western European (DOS)</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>852</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>ibm852</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Central European (DOS)</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>855</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM855</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>OEM Cyrillic</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>857</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>ibm857</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Turkish (DOS)</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>858</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM00858</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>OEM Multilingual Latin I</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>860</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM860</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Portuguese (DOS)</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>861</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>ibm861</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Icelandic (DOS)</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>862</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>DOS-862</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hebrew (DOS)</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>863</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM863</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>French Canadian (DOS)</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>864</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM864</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arabic (864)</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>865</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM865</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nordic (DOS)</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>866</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>cp866</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cyrillic (DOS)</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>869</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>ibm869</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>Greek, Modern (DOS)</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>870</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM870</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Multilingual Latin-2)</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>874</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-874</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thai (Windows)</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>875</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>cp875</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Greek Modern)</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>932</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>shift_jis</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>Japanese (Shift-JIS)</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>936</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>gb2312</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Simplified (GB2312)</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>949</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>ks_c_5601-1987</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>Korean</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>950</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>big5</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Traditional (Big5)</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>1026</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM1026</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Turkish Latin-5)</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>1047</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01047</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM Latin-1</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>1140</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01140</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (US-Canada-Euro)</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>1141</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01141</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Germany-Euro)</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>1142</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01142</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Denmark-Norway-Euro)</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>1143</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01143</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Finland-Sweden-Euro)</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>1144</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01144</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Italy-Euro)</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>1145</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01145</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Spain-Euro)</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>1146</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01146</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (UK-Euro)</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>1147</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01147</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (France-Euro)</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>1148</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01148</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (International-Euro)</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>1149</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM01149</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Icelandic-Euro)</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>1200</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>utf-16</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unicode</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>1201</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>unicodeFFFE</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unicode (Big endian)</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>1250</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1250</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>Central European (Windows)</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>1251</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1251</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cyrillic (Windows)</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>1252</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>Windows-1252</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>Western European (Windows)</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>1253</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1253</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>Greek (Windows)</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>1254</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1254</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>Turkish (Windows)</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>1255</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1255</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hebrew (Windows)</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>1256</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1256</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arabic (Windows)</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>1257</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1257</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>Baltic (Windows)</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>1258</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>windows-1258</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Vietnamese (Windows)</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>1361</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>Johab</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Korean (Johab)</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>10000</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>macintosh</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Western European (Mac)</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>10001</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-japanese</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>Japanese (Mac)</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>10002</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-chinesetrad</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Traditional (Mac)</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>10003</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-korean</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Korean (Mac)</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>10004</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-arabic</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arabic (Mac)</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>10005</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-hebrew</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hebrew (Mac)</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>10006</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-greek</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>Greek (Mac)</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>10007</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-cyrillic</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cyrillic (Mac)</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>10008</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-chinesesimp</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Simplified (Mac)</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>10010</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-romanian</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>Romanian (Mac)</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>10017</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-ukrainian</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ukrainian (Mac)</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>10021</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-thai</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thai (Mac)</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>10029</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-ce</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>Central European (Mac)</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>10079</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-icelandic</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>Icelandic (Mac)</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>10081</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-turkish</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>Turkish (Mac)</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>10082</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-mac-croatian</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>Croatian (Mac)</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>12000</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>utf-32</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unicode (UTF-32)</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>12001</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>utf-32BE</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unicode (UTF-32 Big endian)</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>20000</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-Chinese-CNS</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Traditional (CNS)</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>20001</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20001</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>TCA Taiwan</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>20002</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-Chinese-Eten</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Traditional (Eten)</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>20003</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20003</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM5550 Taiwan</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>20004</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20004</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>TeleText Taiwan</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>20005</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20005</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>Wang Taiwan</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>20105</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-IA5</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>Western European (IA5)</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>20106</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-IA5-German</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>German (IA5)</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>20107</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-IA5-Swedish</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Swedish (IA5)</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>20108</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-IA5-Norwegian</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Norwegian (IA5)</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>20127</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>us-ascii</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>US-ASCII</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>20261</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20261</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>T.61</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>20269</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20269</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISO-6937</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>20273</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM273</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Germany)</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>20277</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM277</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Denmark-Norway)</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>20278</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM278</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Finland-Sweden)</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>20280</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM280</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Italy)</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>20284</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM284</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Spain)</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>20285</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM285</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (UK)</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>20290</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM290</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Japanese katakana)</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>20297</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM297</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (France)</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>20420</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM420</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Arabic)</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>20423</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM423</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Greek)</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>20424</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM424</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Hebrew)</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>20833</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-EBCDIC-KoreanExtended</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Korean Extended)</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>20838</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM-Thai</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Thai)</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>20866</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>koi8-r</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cyrillic (KOI8-R)</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>20871</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM871</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Icelandic)</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>20880</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM880</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Cyrillic Russian)</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>20905</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM905</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Turkish)</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>20924</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM00924</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM Latin-1</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>20932</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>EUC-JP</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Japanese (JIS 0208-1990 and 0212-1990)</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>20936</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20936</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Simplified (GB2312-80)</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>20949</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp20949</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>Korean Wansung</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>21025</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>cp1025</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>IBM EBCDIC (Cyrillic Serbian-Bulgarian)</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>21866</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>koi8-u</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cyrillic (KOI8-U)</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>28591</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-1</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>Western European (ISO)</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>28592</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-2</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>Central European (ISO)</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>28593</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-3</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>Latin 3 (ISO)</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>28594</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-4</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>Baltic (ISO)</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>28595</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-5</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cyrillic (ISO)</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>28596</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-6</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arabic (ISO)</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>28597</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-7</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>Greek (ISO)</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>28598</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-8</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hebrew (ISO-Visual)</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>28599</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-9</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Turkish (ISO)</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>28603</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-13</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>Estonian (ISO)</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>28605</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-15</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>Latin 9 (ISO)</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>29001</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-Europa</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Europa</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>38598</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-8859-8-i</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hebrew (ISO-Logical)</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>50220</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-2022-jp</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>Japanese (JIS)</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>50221</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>csISO2022JP</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>Japanese (JIS-Allow 1 byte Kana)</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>50222</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-2022-jp</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>Japanese (JIS-Allow 1 byte Kana - SO/SI)</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>50225</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>iso-2022-kr</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>Korean (ISO)</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>50227</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-cp50227</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Simplified (ISO-2022)</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>51932</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>euc-jp</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>Japanese (EUC)</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>51936</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>EUC-CN</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Simplified (EUC)</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>51949</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>euc-kr</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>Korean (EUC)</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>52936</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>hz-gb-2312</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Simplified (HZ)</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>54936</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>GB18030</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>Chinese Simplified (GB18030)</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>57002</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-de</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Devanagari</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>57003</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-be</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Bengali</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>57004</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-ta</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Tamil</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>57005</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-te</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Telugu</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT">
          <source>57006</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-as</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Assamese</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>57007</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-or</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Oriya</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>57008</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-ka</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Kannada</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>57009</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-ma</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Malayalam</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>57010</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-gu</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Gujarati</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>57011</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>x-iscii-pa</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>ISCII Punjabi</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>65000</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>utf-7</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unicode (UTF-7)</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>65001</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>utf-8</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unicode (UTF-8)</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>✓</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> methods to get the Greek (Windows) code page encoding.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>It compares the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Text.Encoding#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Text.Encoding#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-16 big endian byte order: 00 41</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-16 little endian byte order: 41 00</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-32 big endian byte order: 00 00 00 41</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-32 little endian byte order: 41 00 00 00</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is generally more efficient to store Unicode characters using the native byte order.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetPreamble%2A&gt;</ph> method retrieves an array of bytes that includes the byte order mark (BOM).</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the encoding classes allow errors to:</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>Silently change to a "?" character.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use a "best fit" character.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Change to an application-specific behavior through use of the <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph> classes with the U+FFFD Unicode replacement character.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should throw an exception on any data stream error.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>An app either uses a "throwonerror" flag when applicable or uses the <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>For ANSI encodings, the best fit behavior is the default.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>Derived classes override this constructor.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> class that corresponds to the specified code page.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>Derived classes override this constructor.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calls to this constructor from a derived class create an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object that uses best-fit fallback for both encoding and decoding operations.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both the <ph id="ph1">&lt;xref:System.Text.Encoding.DecoderFallback%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.EncoderFallback%2A&gt;</ph> properties are read-only and cannot be modified.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>To control the fallback strategy for a class derived from <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>The code page identifier of the preferred encoding.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>0, to use the default encoding.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codePage&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is <ph id="ph1">`protected`</ph>; derived classes override it.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>You call this constructor from a derived class to control the fallback encoding and decoding strategies.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>If either <ph id="ph1">`encoderFallback`</ph> or <ph id="ph2">`decoderFallback`</ph> is null, best-fit fallback is used as the corresponding fallback strategy.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>The encoding code page identifier.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codePage&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Gets an encoding for the ASCII (7-bit) character set.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>When selecting the ASCII encoding for your app, consider the following:</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ASCII encoding is usually appropriate for protocols that require ASCII.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> method to instantiate an <ph id="ph2">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Text.Encoding.ASCII#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Text.Encoding.ASCII#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>An  encoding for the ASCII (7-bit) character set.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>Gets an encoding for the UTF-16 format that uses the big endian byte order.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a big endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Text.Encoding.BigEndianUnicode#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Text.Encoding.BigEndianUnicode#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object has <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> properties, which yield the name "unicodeFFFE".</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>An encoding object for the UTF-16 format that uses the big endian byte order.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need an encoding for a body name, you should call <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>Often the method retrieves a different encoding from the test encoding furnished in the call.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, the value of the <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>This doesn't mean that the implementation complies in full with that standard.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>A name for the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> that can be used with mail agent body tags.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>An empty string (""), if the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> cannot be used.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, creates a shallow copy of the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>The clone is writable even if the original <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object is read-only.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the properties of the clone can be modified.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of an object is a copy of the object only.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>It refers to the original objects instead.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>A copy of the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets the code page identifier of the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The code page identifier of the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Converts a range of bytes in a byte array from one encoding to another.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The encoding of the source array, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bytes</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The encoding of the output array.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The array of bytes to convert.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>The index of the first element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bytes</ph><ept id="p1">&lt;/code&gt;</ept> to convert.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>The number of bytes to convert.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> containing the result of converting a range of bytes in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">bytes</ph><ept id="p1">&lt;/code&gt;</ept> from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">srcEncoding</ph><ept id="p2">&lt;/code&gt;</ept> to <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">dstEncoding</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;srcEncoding&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dstEncoding&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid range in the byte array.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>Converts an entire byte array from one encoding to another.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The encoding format of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bytes</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>The target encoding format.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The bytes to convert.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> containing the results of converting <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">bytes</ph><ept id="p1">&lt;/code&gt;</ept> from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">srcEncoding</ph><ept id="p2">&lt;/code&gt;</ept> to <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">dstEncoding</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;srcEncoding&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dstEncoding&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>Gets or sets the <ph id="ph1">&lt;xref href="System.Text.DecoderFallback"&gt;&lt;/xref&gt;</ph> object for the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any one of the following handler types is supported:</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes one replacement fallback handler, <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception fallback handler, which throws an exception when bytes cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes one exception fallback handler, <ph id="ph1">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph>, which throws a <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> when bytes cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>The decoder fallback object for the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>The value in a set operation is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>A value cannot be assigned in a set operation because the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object is read-only.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>Gets an encoding for the operating system's current ANSI code page.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>Different computers can use different encodings as the default, and the default encoding can even change on a single computer.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the encoding returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>For these two reasons, using the default encoding is generally not recommended.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, with a preamble.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>Another option is to use a higher-level protocol to ensure that the same format is used for encoding and decoding.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system ANSI code page defined by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because all <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encodings lose data, you might use <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> instead.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-8 is often identical in the U+00 to U+7F range, but can encode other characters without loss.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>An encoding for the operating system's current ANSI code page.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>Gets or sets the <ph id="ph1">&lt;xref href="System.Text.EncoderFallback"&gt;&lt;/xref&gt;</ph> object for the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any one of the following handler types is supported:</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT">
          <source>A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes one replacement fallback handler, <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception fallback handler, which throws an exception when characters cannot be encoded.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes one exception fallback handler, <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph>, which throws an <ph id="ph2">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> when characters cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>The encoder fallback object for the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>The value in a set operation is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>A value cannot be assigned in a set operation because the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object is read-only.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets the human-readable description of the current encoding.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> property is intended for display.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>To find a name that can be passed to the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>The human-readable description of the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>Determines whether the specified <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> is equal to the current instance.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two instances of <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> are considered equal if they correspond to the same code page and their <ph id="ph2">`EncoderFallback`</ph> and <ph id="ph3">`DecoderFallback`</ph> objects are equal.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, derived code pages all have a code page of 0 and their fallbacks are normally <ph id="ph1">`null`</ph> (<ph id="ph2">`Nothing`</ph> in Visual Basic .NET).</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus they are all considered equal to one another.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>One consequence is that when <ph id="ph1">&lt;xref:System.Text.Encoding.Equals%2A&gt;</ph> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> to compare with the current instance.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> is an instance of <ph id="ph3">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> and is equal to the current instance; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>The character array containing the set of characters to encode.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>The index of the first character to encode.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The number of characters to encode.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>The number of bytes produced by encoding the specified characters.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;chars&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should use the string versions of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, you should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>The character array containing the characters to encode.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The number of bytes produced by encoding all the characters in the specified character array.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The string containing the set of characters to encode.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The number of bytes produced by encoding the specified characters.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some considerations for using these methods:</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app may need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should use the string version of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>A pointer to the first character to encode.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>The number of characters to encode.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The number of bytes produced by encoding the specified characters.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should call the string version of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The character array containing the characters to encode.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The string containing the characters to encode.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>The character array containing the set of characters to encode.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>The index of the first character to encode.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>The number of characters to encode.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;chars&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>A pointer to the first character to encode.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The number of characters to encode.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to write.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>The actual number of bytes written at the location indicated by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bytes</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than the resulting number of bytes.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>The character array containing the set of characters to encode.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>The index of the first character to encode.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The number of characters to encode.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The byte array to contain the resulting sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>The actual number of bytes written into <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bytes</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id="ph3">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;charCount&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;chars&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is not a valid index in <ph id="ph2">&lt;code&gt;bytes&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;code&gt;byteIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>The string containing the set of characters to encode.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>The index of the first character to encode.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>The number of characters to encode.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>The byte array to contain the resulting sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>The actual number of bytes written into <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bytes</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id="ph3">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;charCount&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;chars&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is not a valid index in <ph id="ph2">&lt;code&gt;bytes&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;code&gt;byteIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the  <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> method performs the actual decoding.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string outputs, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source>The byte array containing the sequence of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>A pointer to the first byte to decode.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>The byte array containing the sequence of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>The index of the first byte to decode.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;bytes&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt; gets characters from an input byte sequence.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt; is different than <ph id="ph3">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id="ph4">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph5">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, part of an ISO-2022 shift sequence may end one [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call and continue at the beginning of the next [<ph id="ph3">\]</ph>, Int32, Int32, Char<ph id="ph4">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt; will call the fallback for those incomplete sequences, but <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string outputs, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve">
          <source>The byte array containing the sequence of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source>The index of the first byte to decode.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>The character array to contain the resulting set of characters.</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source>The index at which to start writing the resulting set of characters.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>The actual number of characters written into <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">chars</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;byteCount&lt;/code&gt;</ph> or <ph id="ph3">&lt;code&gt;charIndex&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteindex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;byteCount&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;bytes&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charIndex&lt;/code&gt;</ph> is not a valid index in <ph id="ph2">&lt;code&gt;chars&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;code&gt;charIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> gets characters from an input byte sequence.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string outputs, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve">
          <source>A pointer to the first byte to decode.</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve">
          <source>The maximum number of characters to write.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve">
          <source>The actual number of characters written at the location indicated by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">chars</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteCount&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than the resulting number of characters.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> gets characters from an input byte sequence.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve">
          <source>The byte array containing the sequence of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve">
          <source>The index of the first byte to decode.</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve">
          <source>A character array containing the results of decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;bytes&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> gets characters from an input byte sequence.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method, which handles multiple passes on a single input stream.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following are some programming considerations for use of these methods:</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve">
          <source>The byte array containing the sequence of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve">
          <source>A character array containing the results of decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method of this class.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it correctly decodes byte sequences that span blocks.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Text.Decoder"&gt;&lt;/xref&gt;</ph> that converts an encoded sequence of bytes into a sequence of characters.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method of this class.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it correctly encodes character sequences that span blocks.</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Text.Encoder"&gt;&lt;/xref&gt;</ph> that converts a sequence of Unicode characters into an encoded sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>Returns the encoding associated with the specified code page identifier.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fallback handler depends on the encoding type of <ph id="ph1">`codepage`</ph>.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`codepage`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, a replacement fallback handler is used.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT">
          <source>These fallback handlers may not be appropriate for your app.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify the fallback handler used by the encoding specified by <ph id="ph1">`codepage`</ph>, you can call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the .NET Framework natively supports some encodings.</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get an array of <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objects that contains information about all encodings.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value 0 for the <ph id="ph1">`codepage`</ph> argument or, on the full .NET Framework on the Windows desktop, retrieve the value of the <ph id="ph2">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the default code pages used on the system, use the Windows <bpt id="p1">[</bpt>GetSystemDefaultLangID<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx)</ept> function.</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the current ANSI code page, call the Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the full .NET Framework on the Windows desktop.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some unsupported code pages cause the exception <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, your code must catch all exceptions indicated in the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this reason, encoding and decoding data using the default code page returned by <ph id="ph1">`Encoding.GetEncoding(0)`</ph> is not recommended.</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve">
          <source>The code page identifier of the preferred encoding.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve">
          <source>Possible values are listed in the Code Page column of the table that appears in the <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve">
          <source>0 (zero), to use the default encoding.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve">
          <source>The encoding that is associated with the specified code page.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codepage&lt;/code&gt;</ph> is less than zero or greater than 65535.</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source>Returns the encoding associated with the specified code page name.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fallback handler depends on the encoding type of <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`name`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, a replacement fallback handler is used.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT">
          <source>These fallback handlers may not be appropriate for your app.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify the fallback handler used by the encoding specified by <ph id="ph1">`name`</ph>, you can call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`GetEncoding`</ph> method relies on the underlying platform to support most code pages.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the .NET Framework natively supports some encodings.</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method in the full .NET Framework on the Windows desktop to get a list of all encodings.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve">
          <source>The code page name of the preferred encoding.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve">
          <source>Any value returned by the <ph id="ph1">&lt;xref href="System.Text.Encoding.WebName"&gt;&lt;/xref&gt;</ph> property is valid.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve">
          <source>Possible values are listed in the Name column of the table that appears in the <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve">
          <source>The encoding  associated with the specified code page.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is not a valid code page name.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve">
          <source>The code page indicated by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is not supported by the underlying platform.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve">
          <source>Returns the encoding associated with the specified code page identifier.</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve">
          <source>Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some unsupported code pages cause the exception <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, your code must catch all exceptions indicated in the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the .NET Framework natively supports some encodings.</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this reason, encoding and decoding data using the default code page returned by <ph id="ph1">`Encoding.GetEncoding(0)`</ph> is not recommended.</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method in the full .NET Framework on the Windows desktop to get a list of all encodings.</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value of 0 for the <ph id="ph1">`codepage`</ph> argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <ph id="ph2">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the default code pages used on the system, use the Windows <bpt id="p1">[</bpt>GetSystemDefaultLangID<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx)</ept> function.</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the current ANSI code page, call the Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the full .NET Framework on the Windows desktop.</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve">
          <source>The code page identifier of the preferred encoding.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve">
          <source>Possible values are listed in the Code Page column of the table that appears in the <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve">
          <source>0 (zero), to use the default encoding.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve">
          <source>The encoding that is associated with the specified code page.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codepage&lt;/code&gt;</ph> is less than zero or greater than 65535.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;codepage&lt;/code&gt;</ph> is not supported by the underlying platform.</source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve">
          <source>Returns the encoding associated with the specified code page name.</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve">
          <source>Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`GetEncoding`</ph> method relies on the underlying platform to support most code pages.</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the .NET Framework natively supports some encodings.</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method on the full .NET Framework on the Windows desktop to get a list of all encodings.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve">
          <source>The code page name of the preferred encoding.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve">
          <source>Any value returned by the <ph id="ph1">&lt;xref href="System.Text.Encoding.WebName"&gt;&lt;/xref&gt;</ph> property is valid.</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve">
          <source>Possible values are listed in the Name column of the table that appears in the <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve">
          <source>The encoding that is associated with the specified code page.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is not a valid code page name.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve">
          <source>The code page indicated by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is not supported by the underlying platform.</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve">
          <source>Returns an array that contains all encodings.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns a list of supported encodings, uniquely distinguished by code page.</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a table that lists the supported encodings, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT">
          <source>The list of supported encodings returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method does not include any additional encodings made available by any <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> implementations that were registered by calls to the <ph id="ph3">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT">
          <source>Encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT">
          <source>Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get a specific encoding, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> is sometimes used to present the user with a list of encodings in a File <bpt id="p1">**</bpt>Save as<ept id="p1">**</ept> dialog box.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using UTF-8 or UTF-16 as the default.</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve">
          <source>An array that contains all encodings.</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve">
          <source>Returns the hash code for the current instance.</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve">
          <source>The hash code for the current instance.</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`charCount`</ph> parameter actually specifies the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consequently, most Unicode characters can be represented by one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object, but a Unicode character represented by a surrogate pair, for example, requires two <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, this can happen for ISO-2022-JP.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the blog entry "<bpt id="p1">[</bpt>What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=153702)</ept>"</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT">
          <source>(http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, this method retrieves reasonable values for small strings.</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT">
          <source>When using <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the output buffer is constrained in size, you might use the <ph id="ph1">&lt;xref:System.Text.Encoding.Convert%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> considers potential leftover surrogates from a previous decoder operation.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.IsSingleByte%2A&gt;</ph> property if this information is necessary.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve">
          <source>The number of characters to encode.</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.EncoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.EncoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves large values.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, this method retrieves reasonable numbers for small strings.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>, you should use <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT">
          <source>When using <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the output buffer is constrained in size, you might use the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> considers the worst case for leftover bytes from a previous encoder operation.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-8: EF BB BF</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-16 big endian byte order: FE FF</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-16 little endian byte order: FF FE</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-32 big endian byte order: 00 00 FE FF</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-32 little endian byte order: FF FE 00 00</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT">
          <source>Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it can be used to help a server send the correct encoding header.</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are some disadvantages to using a BOM.</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, most encodings do not provide a preamble.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, or <ph id="ph3">&lt;xref:System.Text.UTF32Encoding&gt;</ph>, with a preamble.</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve">
          <source>A byte array containing a sequence of bytes that specifies the encoding used.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve">
          <source>A byte array of length zero, if a preamble is not required.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the precise behavior of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Choosing a Fallback Strategy" section of the <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve">
          <source>The byte array containing the sequence of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve">
          <source>The byte array contains invalid Unicode code points.</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is designed to optimize performance when you have a native pointer to a byte array.</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the precise behavior of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Choosing a Fallback Strategy" section of the <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve">
          <source>A pointer to a byte array.</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is a null pointer.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve">
          <source>A   fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)</source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve">
          <source>The byte array containing the sequence of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve">
          <source>The index of the first byte to decode.</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve">
          <source>The number of bytes to decode.</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve">
          <source>The byte array contains invalid Unicode code points.</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;code&gt;bytes&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Text.Encoding.DecoderFallback"&gt;&lt;/xref&gt;</ph> is set to <ph id="ph2">&lt;xref href="System.Text.DecoderExceptionFallback"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need an encoding for a header name, you should call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT">
          <source>Often the method retrieves a different encoding from the test encoding furnished in the call.</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generally only e-mail applications need to retrieve such an encoding.</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, the value of the <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT">
          <source>This doesn't mean that the implementation complies in full with that standard.</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns the name to use to describe an encoding.</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for an e-mail application, for example.</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, use of the property to define the encoding is not recommended.</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve">
          <source>A name for the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> to use with mail agent header tags.</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve">
          <source>An empty string (""), if the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> cannot be used.</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default normalization form is <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> is always normalized; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default normalization form is <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Text.NormalizationForm"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object is always normalized using the specified <ph id="ph3">&lt;xref href="System.Text.NormalizationForm"&gt;&lt;/xref&gt;</ph> value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> can be used by browser clients for displaying content; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> can be used by browser clients for saving content; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> can be used by mail and news clients for displaying content; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> can be used by mail and news clients for saving content; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> is read-only; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a single-byte encoding, for example, <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>, this property retrieves <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should be careful in what your application does with the value for <ph id="ph1">&lt;xref:System.Text.Encoding.IsSingleByte%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assumption of how an Encoding will proceed may still be wrong.</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, Windows-1252 has a value of <ph id="ph1">`true`</ph> for <ph id="ph2">&lt;xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName&gt;</ph>, but Encoding.GetMaxByteCount(1) returns 2.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the method considers potential leftover surrogates from a previous decoder operation.</source>
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> uses single-byte code points; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve">
          <source>Registers an encoding provider.</source>
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method allows you to register a class derived from <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> that makes character encodings available on a platform that does not otherwise support them.</source>
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> includes one encoding provider, <ph id="ph2">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, that makes the encodings available that are present in the full .NET Framework but are not available in <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> only supports the Unicode encodings, ASCII, and code page 28591.</source>
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the same encoding provider is used in multiple calls to the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method, only the first method call registers the provider.</source>
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent calls are ignored.</source>
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</source>
        </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any previously registered providers are ignored.</source>
        </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve">
          <source>A subclass of <ph id="ph1">&lt;xref href="System.Text.EncodingProvider"&gt;&lt;/xref&gt;</ph> that provides access to additional character encodings.</source>
        </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;provider&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve">
          <source>Gets an encoding for the UTF-16 format using the little endian byte order.</source>
        </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
        </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
        </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a little endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Text.Encoding.Unicode#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Text.Encoding.Unicode#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve">
          <source>An encoding for the UTF-16 format using the little endian byte order.</source>
        </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve">
          <source>Gets an encoding for the UTF-32 format using the little endian byte order.</source>
        </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
        </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</source>
        </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Text.Encoding.UTF32#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Text.Encoding.UTF32#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a discussion of little endian byte order, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve">
          <source>An  encoding object for the UTF-32 format using the little endian byte order.</source>
        </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve">
          <source>Gets an encoding for the UTF-7 format.</source>
        </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</source>
        </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</source>
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve">
          <source>An encoding for the UTF-7 format.</source>
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve">
          <source>Gets an encoding for the UTF-8 format.</source>
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</source>
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.</source>
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT">
          <source>It returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that provides a Unicode byte order mark (BOM).</source>
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT">
          <source>To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%2A&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT">
          <source>It returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</source>
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Text.Encoding.UTF8#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Text.Encoding.UTF8#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve">
          <source>An encoding for the UTF-8 format.</source>
        </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</source>
        </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property is the same as the <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns an IANA-registered name for the encoding.</source>
        </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT">
          <source>When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</source>
        </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for e-mail headers.</source>
        </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, most apps should use <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead.</source>
        </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on the IANA, go to <bpt id="p1">[</bpt>www.iana.org<ept id="p1">](http://www.iana.org/)</ept>.</source>
        </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A?displayProperty=fullName&gt;</ph> is the same as the <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName&gt;</ph> returned by <ph id="ph3">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some of the web names are duplicates; see the remarks for <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve">
          <source>The IANA name for the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</source>
        </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</source>
        </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT">
          <source>For globalization, using one of the Unicode encodings is recommended instead.</source>
        </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is also recommended to use <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Text.Encoding.WindowsCodePage%2A&gt;</ph> to identify the code page.</source>
        </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve">
          <source>The Windows operating system code page that most closely corresponds to the current <ph id="ph1">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>