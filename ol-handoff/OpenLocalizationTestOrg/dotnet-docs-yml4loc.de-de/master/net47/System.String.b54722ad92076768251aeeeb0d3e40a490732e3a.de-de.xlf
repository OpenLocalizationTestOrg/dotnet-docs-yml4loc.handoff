<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2bf72c31748056716b803190cf09c37ccf036bf4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.String.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d0e12dbb6973bff88225b65a12ff2c58f7ca1ea8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">acc184e1f248d8a2e6c38083370da46fbcbaef7f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents text as a sequence of UTF-16 code units.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c)</ept>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string is a sequential collection of characters that is used to represent text.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is a sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=fullName&gt;</ph> objects that represent a string; a <ph id="ph3">&lt;xref:System.Char?displayProperty=fullName&gt;</ph> object corresponds to a UTF-16 code unit.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object is the content of the sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=fullName&gt;</ph> objects, and that value is immutable (that is, it is read-only).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the immutability of strings, see the <bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept> section later in this topic.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The maximum size of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in memory is 2GB, or about 1 billion characters.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Instantiating a String object<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Char objects and Unicode characters<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Strings and The Unicode Standard<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Strings and embedded null characters<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Strings and indexes<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Null strings and empty strings<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Ordinal vs. culture-sensitive operations<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Normalization<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>String operations by category<ept id="p1">](#ByCategory)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instantiating a String object</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in the following ways:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>By assigning a string literal to a <ph id="ph1">&lt;xref:System.String&gt;</ph> variable.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the most commonly used method for creating a string.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses assignment to create several strings.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that in C#, because the backslash (<ph id="ph1">\\</ph>) is an escape character, literal backslashes in a string must be escaped or the entire string must be <ph id="ph2">@-quoted</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Instantiate#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Instantiate#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Instantiate#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>By calling a <ph id="ph1">&lt;xref:System.String&gt;</ph> class constructor.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example instantiates strings by calling several class constructors.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic does not support calls to these constructors.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Instantiate#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Instantiate#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Instantiate#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>By using the string concatenation operator (+ in C# and &amp; or + in Visual Basic) to create a single string from any combination of <ph id="ph1">&lt;xref:System.String&gt;</ph> instances and string literals.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the use of the string concatenation operator.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Instantiate#3<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Instantiate#3<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Instantiate#3<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>By retrieving a property or calling a method that returns a string.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the methods of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class to extract a substring from a larger string.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Instantiate#4<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Instantiate#4<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Instantiate#4<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>By calling a formatting method to convert a value or object to its string representation.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the                <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature to embed the string representation of two objects into a string.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Instantiate#5<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Instantiate#5<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Instantiate#5<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char objects and Unicode characters</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that, because a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that is not a well-formed Unicode string.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although some methods, such as the methods of encoding and decoding objects in the <ph id="ph1">&lt;xref:System.Text&gt;</ph> namespace, may performs checks to ensure that strings are well-formed, <ph id="ph2">&lt;xref:System.String&gt;</ph> class members do not ensure that a string is well-formed.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>A single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object usually represents a single code point; that is, the numeric value of the <ph id="ph2">&lt;xref:System.Char&gt;</ph> equals the code point.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the code point for the character "a" is U+0061.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a code point might require more than one encoded element (more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object).</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode standard defines two types of characters that correspond to multiple <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>A grapheme is represented by a base character followed by one or more combining characters.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the character ä is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is U+0061 followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is U+0308.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>This character can also be defined by a single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object that has a code point of U+00E4.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For more information on normalizing strings, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section.)</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>A Unicode supplementary code point (a surrogate pair) is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is a high surrogate followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is a low surrogate.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code units of high surrogates range from U+D800 to U+DBFF.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code units of low surrogates range from U+DC00 to U+DFFF.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example creates a surrogate character and passes it to the <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=fullName&gt;</ph> method to determine whether it is a surrogate pair.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#3<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#3<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#3<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Strings and The Unicode Standard</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Characters in a string are represented by UTF-16 encoded code units, which correspond to <ph id="ph1">&lt;xref:System.Char&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>The category of a character or a surrogate pair can be determined by calling the <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework maintains its own table of characters and their corresponding categories, which ensures that a version of the .NET Framework running on different platforms returns identical character category information.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which their character categories are based.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>.NET Framework version</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Version of the Unicode Standard</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework 2.0</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>In versions of the .NET Framework through the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the .NET Framework maintains its own table of string data.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is also true of versions of the .NET Framework starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Windows 7.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>.NET Framework version</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>Version of the Unicode Standard</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework 2.0</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 7</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 8 and later Windows operating systems</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>Strings and embedded null characters</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework, a <ph id="ph1">&lt;xref:System.String&gt;</ph> object can include embedded null characters, which count as a part of the string's length.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <ph id="ph1">&lt;xref:System.String&gt;</ph> objects:</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value returned by the <ph id="ph1">`strlen`</ph> or <ph id="ph2">`wcslen`</ph> functions does not necessarily equal <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string created by the <ph id="ph1">`strcpy_s`</ph> or <ph id="ph2">`wcscpy_s`</ph> functions is not necessarily identical to the string created by the <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should ensure that native C and C++ code that instantiates <ph id="ph1">&lt;xref:System.String&gt;</ph> objects, and code that is passed <ph id="ph2">&lt;xref:System.String&gt;</ph> objects through platform invoke, do not assume that an embedded null character marks the end of the string.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>They are considered only for ordinal or case-insensitive ordinal comparisons.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the other hand, embedded null characters are always considered when searching a string with methods such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Strings and indexes</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index is the position of a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object (not a Unicode character) in a <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>A number of search methods, such as <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, return the index of a character or substring in the string instance.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property lets you access individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects by their index position in the string.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in a string by using code such as the following.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>This code looks for white space or punctuation characters in a string to determine how many words the string contains.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#4<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#4<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#4<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">&lt;xref:System.String&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface, you can also iterate through the <ph id="ph3">&lt;xref:System.Char&gt;</ph> objects in a string by using a <ph id="ph4">`foreach`</ph> construct, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#5<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#5<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#5<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>To work with Unicode characters instead of <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects, use the <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between code that works with <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects and code that works with Unicode characters.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>It compares the number of characters or text elements in each word of a sentence.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string includes two sequences of a base character followed by a combining character.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#6<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#6<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#6<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>This example works with text elements by using the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=fullName&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> class to enumerate all the text elements in a string.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also retrieve an array that contains the starting index of each text element by calling the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about working with units of text rather than individual <ph id="ph1">&lt;xref:System.Char&gt;</ph> values, see the <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Null strings and empty strings</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string that has been declared but has not been assigned a value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to call methods on that string throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>A null string is different from an empty string, which is a string whose value is "" or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, passing a null string to the <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=fullName&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, and passing an empty string throws a <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other cases, a method argument can be either a null string or an empty string.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are providing an <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following two convenience methods that enable you to test whether a string is <ph id="ph2">`null`</ph> or empty:</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, which indicates whether a string is either <ph id="ph2">`null`</ph> or is equal to  <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method eliminates the need to use code such as the following:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Null#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Null#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Null#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, which indicates whether a string is <ph id="ph2">`null`</ph>, equals <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, or consists exclusively of white-space characters.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method eliminates the need to use code such as the following:</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Null#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Null#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Null#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method in the <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=fullName&gt;</ph> implementation of a custom <ph id="ph3">`Temperature`</ph> class.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method supports the "G", "C", "F", and "K" format strings.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an empty format string or a format string whose value is <ph id="ph1">`null`</ph> is passed to the method, its value is changed to the "G" format string.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class.Null#3<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class.Null#3<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class.Null#3<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>Immutability and the StringBuilder class</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is called immutable (read-only), because its value cannot be modified after it has been created.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods that appear to modify a <ph id="ph1">&lt;xref:System.String&gt;</ph> object actually return a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains the modification.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the code appears to use string concatenation to append a new character to the existing string named <ph id="ph1">`str`</ph>, it actually creates a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each concatenation operation.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#15<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#15<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#15<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class instead of the <ph id="ph2">&lt;xref:System.String&gt;</ph> class for operations that make multiple changes to the value of a string.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike instances of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class, <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you have finished modifying the value of a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object, you can call its <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=fullName&gt;</ph> method to convert it to a string.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example replaces the <ph id="ph1">&lt;xref:System.String&gt;</ph> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#16<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#16<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#16<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinal vs. culture-sensitive operations</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class perform either ordinal or culture-sensitive (linguistic) operations on a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ordinal operation acts on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-sensitive operation acts on the value of the <ph id="ph1">&lt;xref:System.String&gt;</ph>object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>The two kinds of operations can produce very different results when they are performed on the same string.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph>), which is loosely based on the culture settings of the English language independent of region.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike other <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=fullName&gt;</ph> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most methods that perform string operations include an overload that has a parameter of type <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>In general, you should call this overload to make the intent of your method call clear.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>For best practices and guidance for using ordinal and culture-sensitive operations on strings, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>Operations for <bpt id="p1">[</bpt>casing<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>parsing and formatting<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>comparison and sorting<ept id="p3">](#comparison)</ept>, and <bpt id="p4">[</bpt>testing for equality<ept id="p4">](#equality)</ept> can be either ordinal or culture-sensitive.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following sections discuss each category of operation.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should always call a method overload that makes the intent of your method call clear.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, instead of calling the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with a value of <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>Casing</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Often, a casing operation is performed before a string comparison.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can convert the characters in a string to lowercase by calling the <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method, and you can convert them to uppercase by calling the <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=fullName&gt;</ph> method to convert a string to title case.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual differences in casing are of three kinds:</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>(The casing conventions of the invariant culture should have been used.)</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Class#17<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Class#17<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>Differences in case mappings between the invariant culture and all other cultures.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>For all other cultures, it returns a different character.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some of the affected characters are listed in the following table.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changed to</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>Returns</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>MICRON SIGN (U+00B5)</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Uppercase</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>GREEK CAPITAL LETTER MU (U+-39C)</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Lowercase</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN SMALL LETTER I (U+0069)</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN SMALL LETTER DOTLESS I (U+0131)</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>Uppercase</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN CAPITAL LETTER I (U+0049)</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN SMALL LETTER LONG S (U+017F)</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>Uppercase</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN CAPITAL LETTER S (U+0053)</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Lowercase</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>LATIN SMALL LETTER DZ WITH CARON (U+01C6)</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>COMBINING GREEK YPOGEGRAMMENI (U+0345)</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>Uppercase</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>GREEK CAPITAL LETTER IOTA (U+0399)</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>"aA" in the da-DK (Danish (Denmark)) culture.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#7<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#7<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#7<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Parsing and formatting</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>Formatting and parsing are inverse operations.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both formatting and parsing rules are dependent on cultural conventions.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#8<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#8<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#8<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#9<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#9<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#9<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>String comparison and sorting</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conventions for comparing and sorting strings vary from culture to culture.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the sort order may be based on phonetics or on the visual representation of characters.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>In East Asian languages, characters are sorted by the stroke and radical of ideographs.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sorting also depends on the order languages and cultures use for the alphabet.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName&gt;</ph> method compares two strings based on the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the parameter value is <ph id="ph1">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <ph id="ph2">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, the method performs an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName&gt;</ph> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#10<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#10<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#10<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework supports word, string, and ordinal sort rules:</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph>methods that compare two strings using word sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string sort also performs a culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two strings can be compared using string sort rules by calling the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=fullName&gt;</ph> method overloads that have an <ph id="ph2">`options`</ph> parameter that is supplied a value of <ph id="ph3">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ordinal sort compares strings based on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if case is not important, you can specify an ordinal comparison that ignores case.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using ordinal sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object, including the invariant culture that is specified by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implicit culture is the current culture, which is specified by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=fullName&gt;</ph> property returns <ph id="ph2">`true`</ph>) across cultures.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object to a string comparison method such as <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <ph id="ph1">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, or any member of the <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration other than <ph id="ph4">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> or <ph id="ph5">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> to an appropriate overload of the <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between culture-sensitive and ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method is called).</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Class#21<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Class#21<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the following general guidelines to choose an appropriate sorting or string comparison method:</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the user's culture changes, the order of sorted strings will also change accordingly.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a thesaurus application should always sort words based on the user's culture.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to a comparison method.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on the <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>On other operating systems, it conforms to the Unicode 5.0 standard.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sort rules, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> topic.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional recommendations on when to use each rule, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, you do not call string comparison methods such as <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> directly to determine the sort order of strings.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, comparison methods are called by sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that each type of sort produces a unique ordering of strings in its array.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#12<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#12<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#12<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sort key, represented by the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class, provides a repository of these weights for a particular string.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a sort or comparison operation is required, you use the sort keys instead of the strings.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you don't specify a string comparison convention, sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=fullName&gt;</ph> perform a culture-sensitive, case-sensitive sort on strings.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates how changing the current culture affects the order of sorted strings in an array.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>It creates an array of three strings.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>First, it sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to en-US and calls the <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting sort order is based on sorting conventions for the English (United States) culture.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>Next, the example sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to da-DK and calls the <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph> method again.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Strings.Comparing#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.Strings.Comparing#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your primary purpose in comparing strings is to determine whether they are equal, you should call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, you should use <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> to perform an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=fullName&gt;</ph> method is intended primarily to sort strings.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=fullName&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> and finds a match at the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ordinal search, on the other hand, does not find a match in either case.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#13<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#13<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#13<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Searching Strings</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=fullName&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search methods in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class that search for an individual character, such as the<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method, or one of a set of characters,   such as the <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, all perform an ordinal search.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search for a character, you must call a <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> method such as <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName&gt;</ph> methods when searching for an individual character.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Class#22<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Class#22<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the other hand, <ph id="ph1">&lt;xref:System.String&gt;</ph> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sole exception is <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, which performs an ordinal search.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>Testing for equality</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=fullName&gt;</ph> method to determine the relationship of two strings in the sort order.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, this is a culture-sensitive operation.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=fullName&gt;</ph> method to test for equality.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is possible to test for equality by calling the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=fullName&gt;</ph> method and determining whether the return value is zero.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, this practice is not recommended.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether two strings are equal, you should call one of the overloads of the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>The preferred overload to call is either the instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method or the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, because both methods include a <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> parameter that explicitly specifies the type of comparison.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a result, file system access is inadvertently permitted.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#11<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#11<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#11<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalization</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some Unicode characters have multiple representations.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>U+1EAF</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>U+0103 U+0301</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>U+0061 U+0306 U+0301</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalization can use several algorithms, called normalization forms, that follow different rules.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects in each string.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.String&gt;</ph> class includes a number of methods that can perform an ordinal comparison, including the following:</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>,  <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>,and <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> methods that includes a <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method performs an ordinal comparison if you supply a value of <ph id="ph1">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> for this parameter.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods that use ordinal comparison by default, such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods that search for a <ph id="ph1">&lt;xref:System.Char&gt;</ph>value or for the elements in a <ph id="ph2">&lt;xref:System.Char&gt;</ph> arrayin a string instance.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such methods include <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine whether a string is normalized to normalization form C by calling the <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=fullName&gt;</ph> method, or you can call the <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=fullName&gt;</ph> method to determine whether a string is normalized to a specified normalization form.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also call the <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=fullName&gt;</ph> method to convert a string to normalization form C, or you can call the <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=fullName&gt;</ph> method to convert a string to a specified normalization form.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>For step-by-step information about normalizing and comparing strings, see the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following simple example illustrates string normalization.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>In each case, the second test for equality shows that the strings are equal.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#14<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#14<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#14<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about normalization and normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=fullName&gt;</ph>, as well as <bpt id="p1">[</bpt>Unicode Standard Annex #15: Unicode Normalization Forms<ept id="p1">](http://unicode.org/reports/tr15/)</ept> and the <bpt id="p2">[</bpt>Normalization FAQ<ept id="p2">](http://www.unicode.org/faq/normalization.html)</ept> on the unicode.org website.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>String operations by category</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparing strings</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can compare strings to determine their relative position in the sort order by using the following <ph id="ph1">&lt;xref:System.String&gt;</ph>methods:</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string in the sort order.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method provides the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> and <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementations for the <ph id="ph4">&lt;xref:System.String&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>Testing strings for equality</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method to determine whether two strings are equal.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>The instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> and the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>Finding characters in a string</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes two kinds of search methods:</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods that return a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> value to indicate whether a particular substring is present in a string instance.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>These include the <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods that indicate the starting position of a substring in a string instance.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>These include the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>Modifying a string</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following methods that appear to modify the value of a string:</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> inserts a string into the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> inserts one or more occurrences of a specified character at the beginning of a string.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> inserts one or more occurrences of a specified character at the beginning of a string.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> deletes a substring from the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> replaces a substring with another substring in the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> convert all the characters in a string to lowercase.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> convert all the characters in a string to uppercase.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> removes all occurrences of a character from the beginning and end of a string.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> removes all occurrences of a character from the end of a string.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> removes all occurrences of a character from the beginning of a string.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>All string modification methods return a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>They do not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extracting substrings from a string</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=fullName&gt;</ph> method separates a single string into multiple strings.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Combining strings</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods can be used for string concatenation:</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> combines one or more substrings into a single string.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> concatenates one or more substrings into a single element and adds a separator between each substring.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>Formatting values</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=fullName&gt;</ph> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is often used to do the following:</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source>To embed the string representation of a numeric value in a string.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>To embed the string representation of a date and time value in a string.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>To embed the string representation of an enumeration value in a string.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>To embed the string representation of some object that supports the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface in a string.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>To right-justify or left-justify a substring in a field within a larger string.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about formatting operations and examples, see the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>Copying a string</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods to make a copy of a string:</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> returns a reference to an existing <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> creates a copy of an existing string.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> copies a portion of a string to a character array.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalizing a string</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Unicode, a single character can have multiple code points.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalization converts these equivalent characters into the same binary representation.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=fullName&gt;</ph> method performs the normalization, and the <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=fullName&gt;</ph> method determines whether a string is normalized.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and an example, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section earlier in this topic.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>A pointer to a null-terminated array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The current process does not have read access to all the addressed characters.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;code&gt;value&lt;/code&gt;</ph> specifies an address less than 64000.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by an array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>An array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by a pointer to an array of 8-bit signed integers.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>A pointer to a null-terminated array of 8-bit signed integers.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;xref href="System.Text.Encoding.Default"&gt;&lt;/xref&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>A new instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> could not be initialized using <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>, assuming <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p2">&lt;/code&gt;</ept> is encoded in ANSI.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>The length of the new string to initialize, which is determined by the null termination character of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>, is too large to allocate.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> specifies an invalid address.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by a specified Unicode character repeated a specified number of times.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>A Unicode character.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The number of times <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">c</ph><ept id="p1">&lt;/code&gt;</ept> occurs.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>A pointer to an array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The starting position within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The number of characters within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to use.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero, <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph><ph id="ph4"> + &lt;code&gt;startIndex&lt;/code&gt;</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;code&gt;value&lt;/code&gt;</ph><ph id="ph3"> + &lt;code&gt;startIndex&lt;/code&gt;</ph> specifies an address less than 64000.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>An array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The starting position within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>The number of characters within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to use.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">length</ph><ept id="p2">&lt;/code&gt;</ept> is greater than the number of elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>A pointer to an array of 8-bit signed integers.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;xref href="System.Text.Encoding.Default"&gt;&lt;/xref&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>The starting position within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The number of characters within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to use.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The address specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2"> + </ph><bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> is too large for the current platform; that is, the address calculation overflowed.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The length of the new string to initialize is too large to allocate.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The address specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2"> + </ph><bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> is less than 64K.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>A new instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> could not be initialized using <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>, assuming <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p2">&lt;/code&gt;</ept> is encoded in ANSI.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>, and <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> collectively specify an invalid address.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph2">&lt;xref href="System.Text.Encoding"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>A pointer to an array of 8-bit signed integers.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The starting position within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>The number of characters within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to use.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>An object that specifies how the array referenced by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is encoded.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">enc</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, ANSI encoding is assumed.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>The address specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2"> + </ph><bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> is too large for the current platform; that is, the address calculation overflowed.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>The length of the new string to initialize is too large to allocate.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>The address specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2"> + </ph><bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> is less than 64K.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>A new instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> could not be initialized using <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>, assuming <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p2">&lt;/code&gt;</ept> is encoded as specified by <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">enc</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>, and <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> collectively specify an invalid address.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Char"&gt;&lt;/xref&gt;</ph> object at a specified position in the current <ph id="ph2">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`index`</ph> parameter is zero-based.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns the <ph id="ph1">&lt;xref:System.Char&gt;</ph> object at the position specified by the <ph id="ph2">`index`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=fullName&gt;</ph> class to work with Unicode characters instead of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Char Objects and Unicode Characters" section in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class overview.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is an indexer.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Visual Basic, it is the default property of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string can be accessed by using code such as the following.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Chars#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Chars#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>A position in the current string.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The object at position <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is greater than or equal to the length of this object or less than zero.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>Returns a reference to this instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is not an independent copy of this instance; it is simply another view of the same data.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> method to create a separate <ph id="ph3">&lt;xref:System.String&gt;</ph> object with the same value as this instance.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> method simply returns the existing string instance, there is little reason to call it directly.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>This instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Compares substrings of two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison is performed using word sort rules.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#6<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#6<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#6<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows:</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#7<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#7<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#7<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The first string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>The second string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strB</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The maximum number of characters in the substrings to compare.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to ignore case during the comparison; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific comparison information.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strA&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexB&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;indexB&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">strB</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">length</ph><ept id="p3">&lt;/code&gt;</ept> is greater than zero.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;culture&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>Compares substrings of two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#8<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#8<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#8<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows:</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#9<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#9<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#9<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The first string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>The second string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strB</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The maximum number of characters in the substrings to compare.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The substrings occur in the same position in the sort order, or the <ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> parameter is zero.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follllows the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strA&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexB&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;indexB&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">indexA</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">indexB</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">length</ph><ept id="p3">&lt;/code&gt;</ept> is greater than zero.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>Compares substrings of two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison is performed using word sort rules.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#4<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#4<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#4<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>The path name needs to be compared in an invariant manner.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#5<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#5<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#5<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The first string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>The second string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strB</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The maximum number of characters in the substrings to compare.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to ignore case during the comparison; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strA&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexB&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;indexB&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">indexA</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">indexB</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">length</ph><ept id="p3">&lt;/code&gt;</ept> is greater than zero.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Compares substrings of two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison is performed using word sort rules.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows:</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#3<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#3<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#3<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The first string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>The second string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>The position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strB</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>The maximum number of characters in the substrings to compare.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strA&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexB&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.<ph id="ph3">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;indexB&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">indexA</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">indexB</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">length</ph><ept id="p3">&lt;/code&gt;</ept> is greater than zero.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>Compares two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison is performed using word sort rules.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>When comparing strings, you should call the<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#10<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#10<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#10<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows:</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#11<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#11<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#11<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The first string to compare.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>The second string to compare.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> occurs in the same position as <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>Compares two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison is performed using word sort rules.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#14<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#14<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#14<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows:</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#15<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#15<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#15<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>The first string to compare.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>The second string to compare.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to ignore case during the comparison; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific comparison information.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> occurs in the same position as <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;culture&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Compares two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#16<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#16<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#16<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows:</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#17<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#17<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#17<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>The first string to compare.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>The second string to compare.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> is in the same position as <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>Compares two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison is performed using word sort rules.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#12<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#12<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#12<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>The correct code to do this is as follows:</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Compare#13<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Compare#13<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Compare#13<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>The first string to compare.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>The second string to compare.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to ignore case during the comparison; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> occurs in the same position as <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>Compares substrings of two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at position <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at position <ph id="ph4">`indexB`</ph>.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the first substring is the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph>.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of the second substring is the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph>.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or both of <ph id="ph1">`strA`</ph> and <ph id="ph2">`strB`</ph> can be <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> values have no effect.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the result of the last comparison performed.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>The first string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>The starting position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>The second string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>The starting position of the substring within <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strB</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>The maximum number of characters in the substrings to compare.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific comparison information.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.CompareOptions"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strA&lt;/code&gt;</ph><ph id="ph3">`.Length`</ph>.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexB&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph><ph id="ph3">`.Length`</ph>.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;indexB&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">strB</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">length</ph><ept id="p3">&lt;/code&gt;</ept> is greater than zero.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;culture&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>Compares two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> values have no effect.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Either or both comparands can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>The first string to compare.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>The second string to compare.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>The culture that supplies culture-specific comparison information.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">strB</ph><ept id="p2">&lt;/code&gt;</ept>, as shown in the following table</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> precedes <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> occurs in the same position as <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> follows <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> in the sort order.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.CompareOptions"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;culture&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>Compares substrings of two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;xref href="System.Char"&gt;&lt;/xref&gt;</ph> objects in each substring.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of characters compared is the lesser of the length of <ph id="ph1">`strA`</ph> less <ph id="ph2">`indexA`</ph>, the length of <ph id="ph3">`strB`</ph> less <ph id="ph4">`indexB`</ph>, and <ph id="ph5">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph>method with the <ph id="ph2">`comparisonType`</ph> argument set to<ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>The first string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>The starting index of the substring in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strA</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>The second string to use in the comparison.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>The starting index of the substring in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strB</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The maximum number of characters in the substrings to compare.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> is less than the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>The substrings are equal, or <ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>The substring in <ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> is greater than the substring in <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">&lt;code&gt;indexA&lt;/code&gt;</ph> is greater than <ph id="ph4">&lt;code&gt;strA&lt;/code&gt;</ph>.<ph id="ph5">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strB&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">&lt;code&gt;indexB&lt;/code&gt;</ph> is greater than <ph id="ph4">&lt;code&gt;strB&lt;/code&gt;</ph>.<ph id="ph5">&lt;xref href="System.String.Length"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indexA&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;indexB&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>Compares two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;xref href="System.Char"&gt;&lt;/xref&gt;</ph> objects in each string.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph>is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>The first string to compare.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>The second string to compare.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> is less than <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph> are equal.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strA&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;strB&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>Compares this instance with a specified <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <ph id="ph2">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> must be a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>An object that evaluates to a <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>This instance precedes <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>This instance has the same position in the sort order as <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>This instance follows <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>Compares this instance with a specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=fullName&gt;</ph> interface and performs slightly better than the <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=fullName&gt;</ph> method, because it does not have to determine whether the <ph id="ph3">`strB`</ph> argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <ph id="ph4">&lt;xref:System.Object&gt;</ph>to a<ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>The string to compare with this instance.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">strB</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>This instance precedes <ph id="ph1">&lt;code&gt;strB&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>This instance has the same position in the sort order as <ph id="ph1">&lt;code&gt;strB&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>This instance follows <ph id="ph1">&lt;code&gt;strB&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;strB&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>Concatenates four specified instances of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, and <ph id="ph4">`str3`</ph>; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT">
          <source>, to concatenate strings.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>The first string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>The second string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>The third string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>The fourth string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>The concatenation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">str0</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">str1</ph><ept id="p2">&lt;/code&gt;</ept>, <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">str2</ph><ept id="p3">&lt;/code&gt;</ept>, and <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">str3</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>This API is not CLS-compliant.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLS-compliant alternative is <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT">
          <source>The C# and Visual Basic compilers automatically resolve a call to this method as a call to <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates each object in the parameter list by calling its parameterless <ph id="ph1">`ToString`</ph> method; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph> is used in place of any null argument.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT">
          <source>The last parameter of the  <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method is an optional comma-delimited list of one or more additional objects to concatenate.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source>The first object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>The second object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>The third object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>The fourth object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>The concatenated string representation of each value in the parameter list.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>Concatenates the string representations of three specified objects.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, and <ph id="ph3">`arg2`</ph> by calling the parameterless <ph id="ph4">`ToString`</ph> method of each object; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String?displayProperty=fullName&gt;</ph> is used in place of any null argument.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source>The first object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>The second object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>The third object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>The concatenated string representations of the values of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">arg0</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg1</ph><ept id="p2">&lt;/code&gt;</ept>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">arg2</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source>Concatenates two specified instances of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates <ph id="ph1">`str0`</ph> and <ph id="ph2">`str1`</ph>; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT">
          <source>, to concatenate strings.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>The first string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>The second string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve">
          <source>The concatenation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">str0</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">str1</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>Concatenates three specified instances of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, and <ph id="ph3">`str2`</ph>; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT">
          <source>, to concatenate strings.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source>The first string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>The second string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve">
          <source>The third string to concatenate.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>The concatenation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">str0</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">str1</ph><ept id="p2">&lt;/code&gt;</ept>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">str2</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>Concatenates the elements of a specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> array.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>An array of string instances.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source>The concatenated elements of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;values&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>Out of memory.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>Concatenates the string representations of the elements in a specified <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> array.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates each object in <ph id="ph1">`args`</ph> by calling the parameterless <ph id="ph2">`ToString`</ph> method of that object; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String?displayProperty=fullName&gt;</ph> is used in place of any null object in the array.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>An object array that contains the elements to concatenate.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source>The concatenated string representations of the values of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;args&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>Out of memory.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>Creates the string  representation of a specified object.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> method represents <ph id="ph2">`arg0`</ph> as a string by calling its parameterless <ph id="ph3">`ToString`</ph> method.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>The object to represent, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>The string representation of the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">arg0</ph><ept id="p1">&lt;/code&gt;</ept>, or <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">arg0</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> collection of type <ph id="ph2">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify a delimiter between each member of <ph id="ph1">`values`</ph>, call the <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null element in <ph id="ph2">`values`</ph>.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`values`</ph> is an empty <ph id="ph2">`IEnumerable(Of String)`</ph>, the method returns <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection that is returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Concat#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Concat#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source>A collection object that implements <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> and whose generic type argument is <ph id="ph2">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve">
          <source>The concatenated strings in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept>, or <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">values</ph><ept id="p2">&lt;/code&gt;</ept> is an empty <ph id="ph4">`IEnumerable(Of String)`</ph>.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;values&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve">
          <source>Concatenates the string representations of two specified objects.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates <ph id="ph1">`arg0`</ph> and <ph id="ph2">`arg1`</ph> by calling the parameterless <ph id="ph3">`ToString`</ph> method of <ph id="ph4">`arg0`</ph> and <ph id="ph5">`arg1`</ph>; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String?displayProperty=fullName&gt;</ph> is used in place of any null argument.</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT">
          <source>If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve">
          <source>The first object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve">
          <source>The second object to concatenate.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve">
          <source>The concatenated string representations of the values of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">arg0</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg1</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve">
          <source>Concatenates the members of an <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting the elements to strings.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source>A collection object that implements the <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>The type of the members of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>The concatenated members in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;values&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>Returns a value indicating whether a specified substring occurs within this string.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the first character position of this string and continues through the last character position.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates one such approach.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a <ph id="ph1">&lt;xref:System.String&gt;</ph> extension method  that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Contains#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Contains#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example then calls the <ph id="ph1">`Contains`</ph> extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Contains#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Contains#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are interested in the position of the substring <ph id="ph1">`value`</ph> in the current instance, you can call the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to get the starting position of its first occurrence, or you can call the <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to get the starting position of its last occurrence.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example includes a call to the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method if a substring is found in a string instance.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter occurs within this string, or if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p2">&lt;/code&gt;</ept> is the empty string (""); otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve">
          <source>Creates a new instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> with the same value as a specified <ph id="ph2">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that has the same value as the original string but represents a different object reference.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT">
          <source>It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example illustrates the difference.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve">
          <source>The string to copy.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve">
          <source>A new string with the same value as <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">str</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;str&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source>Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies <ph id="ph1">`count`</ph> characters from the <ph id="ph2">`sourceIndex`</ph> position of this instance to the <ph id="ph3">`destinationIndex`</ph> position of <ph id="ph4">`destination`</ph> character array.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not resize the <ph id="ph1">`destination`</ph> character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`sourceIndex`</ph> and <ph id="ph2">`destinationIndex`</ph> are zero-based.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve">
          <source>The index of the first character in this instance to copy.</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve">
          <source>An array of Unicode characters to which characters in this instance are copied.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source>The index in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">destination</ph><ept id="p1">&lt;/code&gt;</ept> at which the copy operation begins.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve">
          <source>The number of characters in this instance to copy to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">destination</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destination&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceIndex&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destinationIndex&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;count&lt;/code&gt;</ph> is negative</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceIndex&lt;/code&gt;</ph> does not identify a position in the current instance.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> does not identify a valid index in the <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph> array.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is greater than the length of the substring from <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph> to the end of this instance</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is greater than the length of the subarray from <ph id="ph2">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> to the end of the <ph id="ph3">&lt;code&gt;destination&lt;/code&gt;</ph> array.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve">
          <source>Represents the empty string.</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this field is the zero-length string, "".</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT">
          <source>In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT">
          <source>To test whether the value of a string is either <ph id="ph1">`null`</ph> or <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, use the <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified culture.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the end of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this string.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (culture-sensitive) comparison using the specified casing and culture.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve">
          <source>The string to compare to the substring at the end of this instance.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to ignore case during the comparison; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve">
          <source>Cultural information that determines how this instance and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> are compared.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">culture</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, the current culture is used.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter matches the end of this string; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the end of this string.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve">
          <source>The string to compare to the substring at the end of this instance.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> are compared.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter matches the end of this string; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve">
          <source>Determines whether the end of this string instance matches the specified string.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the end of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this instance.</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve">
          <source>The string to compare to the substring at the end of this instance.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> matches the end of this instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve">
          <source>Determines whether this instance and a specified object, which must also be a <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object, have the same value.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve">
          <source>The string to compare to this instance.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> is a <ph id="ph3">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> and its value is the same as this instance; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, the method returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve">
          <source>Determines whether this instance and another specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object have the same value.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve">
          <source>The string to compare to this instance.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter is the same as the value of this instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, the method returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve">
          <source>Determines whether two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects have the same value.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve">
          <source>The first string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve">
          <source>The second string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">a</ph><ept id="p1">&lt;/code&gt;</ept> is the same as the value of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">b</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve">
          <source>If both <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">a</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">b</ph><ept id="p2">&lt;/code&gt;</ept> are <ph id="ph3">`null`</ph>, the method returns <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve">
          <source>Determines whether this string and a specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object have the same value.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve">
          <source>The string to compare to this instance.</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies how the strings will be compared.</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter is the same as this string; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve">
          <source>Determines whether two specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> objects have the same value.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve">
          <source>The first string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve">
          <source>The second string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules for the comparison.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">a</ph><ept id="p1">&lt;/code&gt;</ept> parameter is equal to the value of the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">b</ph><ept id="p2">&lt;/code&gt;</ept> parameter; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve">
          <source>Replaces the format items in a specified string with the string representation of three specified objects.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve">
          <source>An parameter supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve">
          <source>The first object to format.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve">
          <source>The second object to format.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve">
          <source>The third object to format.</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which the format items have been replaced by the string representations of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg0</ph><ept id="p2">&lt;/code&gt;</ept>, <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">arg1</ph><ept id="p3">&lt;/code&gt;</ept>, and <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">arg2</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;arg0&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;arg1&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;arg2&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve">
          <source>The index of a format item is less than zero, or greater than or equal to three.</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve">
          <source>Replaces the format items in a specified string with the string representation of three specified objects.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve">
          <source>The first object to format.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve">
          <source>The second object to format.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve">
          <source>The third object to format.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which the format items have been replaced by the string representations of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg0</ph><ept id="p2">&lt;/code&gt;</ept>, <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">arg1</ph><ept id="p3">&lt;/code&gt;</ept>, and <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">arg2</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve">
          <source>The index of a format item is less than zero, or greater than two.</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve">
          <source>Replaces the format items in a specified string with the string representation of two specified objects.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve">
          <source>A parameter supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve">
          <source>The first object to format.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve">
          <source>The second object to format.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which format items are replaced by the string representations of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg0</ph><ept id="p2">&lt;/code&gt;</ept> and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">arg1</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;arg0&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;arg1&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve">
          <source>The index of a format item is less than zero, or greater than or equal to two.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve">
          <source>Replaces the format items in a specified string with the string representation of two specified objects.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve">
          <source>The first object to format.</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve">
          <source>The second object to format.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which format items are replaced by the string representations of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg0</ph><ept id="p2">&lt;/code&gt;</ept> and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">arg1</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve">
          <source>The index of a format item is not zero or one.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve">
          <source>Replaces the format item or items in a specified string with the string representation of the corresponding object.</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve">
          <source>A parameter supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve">
          <source>The object to format.</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which the format item or items have been replaced by the string representation of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg0</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;arg0&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve">
          <source>The index of a format item is less than zero, or greater than or equal to one.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source>Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve">
          <source>An object array that contains zero or more objects to format.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which the format items have been replaced by the string representation of the corresponding objects in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">args</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;args&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve">
          <source>Replaces one or more format items in a specified string with the string representation of a specified object.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve">
          <source>The object to format.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which any format items are replaced by the string representation of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">arg0</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve">
          <source>The format item in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> is invalid.</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve">
          <source>The index of a format item is not zero.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve">
          <source>Replaces the format items in a specified string with the string representations of corresponding objects in a specified array.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve">
          <source>A parameter supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Format`</ph> method, see the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve">
          <source>An object array that contains zero or more objects to format.</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve">
          <source>A copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> in which the format items have been replaced by the string representation of the corresponding objects in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">args</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;args&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve">
          <source>Retrieves an object that can iterate through the individual characters in this string.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Rather than calling the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> in C#,                  <bpt id="p2">[</bpt>for each<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> in C++/CLR, and                  <bpt id="p3">[</bpt>For Each<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables you to iterate the individual characters in a string.</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the Visual Basic <ph id="ph1">`For Each`</ph> and C# <ph id="ph2">`foreach`</ph> statements invoke this method to return a <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> object that can provide read-only access to the characters in this string instance.</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve">
          <source>An enumerator object.</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve">
          <source>Returns the hash code for this string.</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> is dependent on its implementation, which might change from one version of the common language runtime to another.</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT">
          <source>A reason why this might happen is to improve the performance of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two string objects are equal, the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method returns identical values.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, there is not a unique hash code value for each unique string value.</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT">
          <source>Different strings can return the same hash code.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code itself is not guaranteed to be stable.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, they can even differ by application domain.</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implies two subsequent runs of the same program may return different hash codes.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT">
          <source>Finally, do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about hash codes, see <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT">
          <source>In desktop apps, you can use the             <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> to generate unique hash codes on a per application domain basis.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows how to use the                <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a  to generate unique hash codes on a per application domain basis.</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows how to use the .</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a <ph id="ph1">`DisplayString`</ph> class that includes a private string constant, <ph id="ph2">`s`</ph>, whose value is "This is a string."</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also includes a <ph id="ph1">`ShowStringHashCode`</ph> method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.GetHashCode#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.GetHashCode#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you run the example without supplying a configuration file, it displays output similar to the following.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the hash codes for the string are identical in the two application domains.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the configuration file is present, the example displays the following output:</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, hash codes do not uniquely identify strings.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT">
          <source>Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information about the use of hash codes and the <ph id="ph1">`GetHashCode`</ph> method, see <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer hash code.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">&lt;xref href="System.TypeCode"&gt;&lt;/xref&gt;</ph> for class <ph id="ph2">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve">
          <source>The enumerated constant, <ph id="ph1">&lt;xref href="System.TypeCode.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from 0 (zero).</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one of the strings contains the required substring.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.IndexOf#23<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.IndexOf#23<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> from the start of the current instance if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is greater than the length of this string.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve">
          <source>Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from 0 (zero).</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules for the search.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve">
          <source>The zero-based index position of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is greater than the length of this instance.</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve">
          <source>Parameters specify the starting search position in the current string and the type of search to use for the specified string.</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from 0.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules for the search.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve">
          <source>The zero-based index position of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified character in this instance.</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from 0 (zero).</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve">
          <source>A Unicode character to seek.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> from the start of the string if that character is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is greater than the length of this string.</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the first character position of this instance and continues until the last character position.</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the<ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one of the strings contains a soft hyphen.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT">
          <source>When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.IndexOf#21<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.IndexOf#21<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is 0.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position.</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from 0.</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and continues until the last character position.</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one of the strings contains the required substring.</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.IndexOf#22<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.IndexOf#22<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> from the start of the current instance if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position.</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from 0.</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve">
          <source>A Unicode character to seek.</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> from the start of the string if that character is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is less than 0 (zero) or greater than the length of the string.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve">
          <source>A parameter specifies the type of search to use for the specified string.</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules for the search.</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve">
          <source>The index position of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is 0.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve">
          <source>A Unicode character to seek.</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that character is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`anyOf`</ph> is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve">
          <source>A Unicode character array containing one or more characters to seek.</source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve">
          <source>The zero-based index position of the first occurrence in this instance where any character in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">anyOf</ph><ept id="p1">&lt;/code&gt;</ept> was found; -1 if no character in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">anyOf</ph><ept id="p2">&lt;/code&gt;</ept> was found.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;anyOf&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position.</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve">
          <source>A Unicode character array containing one or more characters to seek.</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve">
          <source>The zero-based index position of the first occurrence in this instance where any character in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">anyOf</ph><ept id="p1">&lt;/code&gt;</ept> was found; -1 if no character in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">anyOf</ph><ept id="p2">&lt;/code&gt;</ept> was found.</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;anyOf&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is greater than the number of characters in this instance.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve">
          <source>A Unicode character array containing one or more characters to seek.</source>
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve">
          <source>The zero-based index position of the first occurrence in this instance where any character in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">anyOf</ph><ept id="p1">&lt;/code&gt;</ept> was found; -1 if no character in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">anyOf</ph><ept id="p2">&lt;/code&gt;</ept> was found.</source>
        </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;anyOf&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph><ph id="ph2"> + &lt;code&gt;startIndex&lt;/code&gt;</ph> is greater than the number of characters in this instance.</source>
        </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve">
          <source>Returns a new string in which a specified string is inserted at a specified index position in this instance.</source>
        </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to the length of this instance, <ph id="ph2">`value`</ph> is appended to the end of this instance.</source>
        </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which <ph id="ph1">`value`</ph> is inserted into the current instance.</source>
        </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the return value of <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> is "abXYZc".</source>
        </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve">
          <source>The zero-based index position of the insertion.</source>
        </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve">
          <source>The string to insert.</source>
        </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve">
          <source>A new string that is equivalent to this instance, but with <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> inserted at position <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is negative or greater than the length of this instance.</source>
        </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve">
          <source>Retrieves the system's reference to the specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</source>
        </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consequently, an instance of a literal string with a particular value only exists once in the system.</source>
        </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</source>
        </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method uses the intern pool to search for a string equal to the value of <ph id="ph2">`str`</ph>.</source>
        </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT">
          <source>If such a string exists, its reference in the intern pool is returned.</source>
        </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the string does not exist, a reference to <ph id="ph1">`str`</ph> is added to the intern pool, then that reference is returned.</source>
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</source>
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=fullName&gt;</ph> class generates a new string object that has the same value as s1.</source>
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT">
          <source>A reference to that string is assigned to s2.</source>
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method searches for a string that has the same value as s2.</source>
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because such a string exists, the method returns the same reference that is assigned to s1.</source>
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT">
          <source>That reference is then assigned to s3.</source>
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT">
          <source>References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</source>
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Intern#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Intern#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT">
          <source>Version Considerations</source>
        </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</source>
        </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the variable <ph id="ph1">`str1`</ph> is assigned a reference to <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, and the variable <ph id="ph3">`str2`</ph> is assigned the reference to <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> that is returned by calling the <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> method after converting a <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> object whose value is <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> to a string.</source>
        </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then the references contained in <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph> are compared for equality.</source>
        </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Intern#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Intern#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> and <ph id="ph5">`str2`</ph> are equal.</source>
        </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> are not equal.</source>
        </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</source>
        </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT">
          <source>First, the memory allocated for interned <ph id="ph1">&lt;xref:System.String&gt;</ph> objects is not likely be released until the common language runtime (CLR) terminates.</source>
        </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reason is that the CLR's reference to the interned <ph id="ph1">&lt;xref:System.String&gt;</ph> object can persist after your application, or even your application domain, terminates.</source>
        </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Second, to intern a string, you must first create the string.</source>
        </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT">
          <source>The memory used by the <ph id="ph1">&lt;xref:System.String&gt;</ph> object must still be allocated, even though the memory will eventually be garbage collected.</source>
        </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework version 2.0 introduces the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations?displayProperty=fullName&gt;</ph>enumeration member.</source>
        </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> member marks an assembly as not requiring string-literal interning.</source>
        </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> to an assembly using the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to compile an assembly in advance of run time, strings are not interned across modules.</source>
        </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve">
          <source>A string to search for in the intern pool.</source>
        </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve">
          <source>The system's reference to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">str</ph><ept id="p1">&lt;/code&gt;</ept>, if it is interned; otherwise, a new reference to a string with the value of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">str</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;str&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve">
          <source>Retrieves a reference to a specified <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <ph id="ph1">&lt;xref:System.String&gt;</ph> you add programmatically by calling the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT">
          <source>The intern pool conserves string storage.</source>
        </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <ph id="ph1">&lt;xref:System.String&gt;</ph> that have identical values.</source>
        </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method looks up <ph id="ph1">`str`</ph> in the intern pool.</source>
        </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`str`</ph> has already been interned, a reference to that instance is returned; otherwise, <ph id="ph2">`null`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not return a Boolean value.</source>
        </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</source>
        </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.IsInterned#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.IsInterned#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to install an assembly to the native image cache on a local computer.</source>
        </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see Performance Considerations in the Remarks section for the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve">
          <source>The string to search for in the intern pool.</source>
        </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve">
          <source>A reference to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">str</ph><ept id="p1">&lt;/code&gt;</ept> if it is in the common language runtime intern pool; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;str&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve">
          <source>Indicates whether this string is in Unicode normalization form C.</source>
        </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
        </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
        </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
        </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
        </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this string is in normalization form C; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve">
          <source>The current instance contains invalid Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve">
          <source>Indicates whether this string is in the specified Unicode normalization form.</source>
        </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
        </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
        </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
        </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
        </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve">
          <source>A Unicode normalization form.</source>
        </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this string is in the normalization form specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">normalizationForm</ph><ept id="p1">&lt;/code&gt;</ept> parameter; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve">
          <source>The current instance contains invalid Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve">
          <source>Indicates whether the specified string is <ph id="ph1">`null`</ph> or an <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> string.</source>
        </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> is a convenience method that enables you to simultaneously test whether a <ph id="ph2">&lt;xref:System.String&gt;</ph> is <ph id="ph3">`null`</ph> or its value is <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is equivalent to the following code:</source>
        </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.IsNullOrEmpty#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.IsNullOrEmpty#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.IsNullOrEmpty#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method to test whether a string is <ph id="ph2">`null`</ph>, its value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>,  or it consists only of white-space characters.</source>
        </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT">
          <source>What is a null string?</source>
        </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string is <ph id="ph1">`null`</ph> if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.IsNullOrEmpty#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.IsNullOrEmpty#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.IsNullOrEmpty#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT">
          <source>What is an empty string?</source>
        </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string is empty if it  is explicitly assigned an empty string ("") or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT">
          <source>An empty string has a <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> of 0.</source>
        </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example creates an empty string and displays its value and its length.</source>
        </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.IsNullOrEmpty#3<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.IsNullOrEmpty#3<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.IsNullOrEmpty#3<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve">
          <source>The string to test.</source>
        </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph3">`null`</ph> or an empty string (""); otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve">
          <source>Indicates whether a specified string is <ph id="ph1">`null`</ph>, empty, or consists only of white-space characters.</source>
        </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> is a convenience method that is similar to the following  code, except that it offers superior performance:</source>
        </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.IsNullOrWhitespace#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.IsNullOrWhitespace#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard.</source>
        </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method interprets any character that returns a value of <ph id="ph2">`true`</ph> when it is passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method as a white-space character.</source>
        </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve">
          <source>The string to test.</source>
        </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph3">`null`</ph> or <ph id="ph4">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, or if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph5">value</ph><ept id="p2">&lt;/code&gt;</ept> consists exclusively of white-space characters.</source>
        </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve">
          <source>Concatenates the specified elements of a string array, using the specified separator between each element.</source>
        </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value, 1, 2)`</ph> returns "orange, grape".</source>
        </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String?displayProperty=fullName&gt;</ph>) is used instead.</source>
        </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
        </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve">
          <source>The string to use as a separator.</source>
        </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> has more than one element.</source>
        </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve">
          <source>An array that contains the elements to concatenate.</source>
        </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve">
          <source>The first element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to use.</source>
        </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve">
          <source>The number of elements of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to use.</source>
        </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve">
          <source>A string that consists of the strings in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> delimited by the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">separator</ph><ept id="p2">&lt;/code&gt;</ept> string.</source>
        </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p1">&lt;/code&gt;</ept> is zero, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p2">&lt;/code&gt;</ept> has no elements, or <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">separator</ph><ept id="p3">&lt;/code&gt;</ept> and all the elements of <bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">value</ph><ept id="p4">&lt;/code&gt;</ept> are <ph id="ph6">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> plus <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve">
          <source>Out of memory.</source>
        </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve">
          <source>Concatenates all the elements of a string array, using the specified separator between each element.</source>
        </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value)`</ph> returns "apple, orange, grape, pear".</source>
        </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String?displayProperty=fullName&gt;</ph>) is used instead.</source>
        </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
        </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve">
          <source>The string to use as a separator.</source>
        </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> has more than one element.</source>
        </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve">
          <source>An array that contains the elements to concatenate.</source>
        </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve">
          <source>A string that consists of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> delimited by the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">separator</ph><ept id="p2">&lt;/code&gt;</ept> string.</source>
        </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is an empty array, the method returns <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve">
          <source>Concatenates the elements of an object array, using the specified separator between each element.</source>
        </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph> or if any element of <ph id="ph3">`values`</ph> other than the first element is <ph id="ph4">`null`</ph>, an empty string (<ph id="ph5">&lt;xref:System.String?displayProperty=fullName&gt;</ph>) is used instead.</source>
        </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the Notes for Callers section if the first element of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</source>
        </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string representation of each object in the array is derived by calling that object's <ph id="ph1">`ToString`</ph> method.</source>
        </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve">
          <source>The string to use as a separator.</source>
        </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">values</ph><ept id="p2">&lt;/code&gt;</ept> has more than one element.</source>
        </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve">
          <source>An array that contains the elements to concatenate.</source>
        </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve">
          <source>A string that consists of the elements of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> delimited by the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">separator</ph><ept id="p2">&lt;/code&gt;</ept> string.</source>
        </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> is an empty array, the method returns <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;values&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> collection of type <ph id="ph2">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>, using the specified separator between each member.</source>
        </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String?displayProperty=fullName&gt;</ph>) is used instead.</source>
        </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
        </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
        </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
        </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
        </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
        </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Join#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Join#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve">
          <source>The string to use as a separator.<bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept></source>
        </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve">
          <source>is included in the returned string only if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> has more than one element.</source>
        </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve">
          <source>A collection that contains the strings to concatenate.</source>
        </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve">
          <source>A string that consists of the members of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> delimited by the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">separator</ph><ept id="p2">&lt;/code&gt;</ept> string.</source>
        </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> has no members, the method returns <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;values&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve">
          <source>Concatenates the members of a collection, using the specified separator between each member.</source>
        </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String?displayProperty=fullName&gt;</ph>) is used instead.</source>
        </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
        </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each member of an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting them to strings.</source>
        </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
        </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is particular useful with Language-Integrated Query (LINQ) query expressions.</source>
        </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the following code defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
        </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object that contains a number of <ph id="ph2">`Animal`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
        </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Join#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Join#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve">
          <source>The string to use as a separator.<bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept></source>
        </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve">
          <source>is included in the returned string only if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> has more than one element.</source>
        </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve">
          <source>A collection that contains the objects to concatenate.</source>
        </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve">
          <source>The type of the members of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve">
          <source>A string that consists of the members of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> delimited by the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">separator</ph><ept id="p2">&lt;/code&gt;</ept> string.</source>
        </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">values</ph><ept id="p1">&lt;/code&gt;</ept> has no members, the method returns <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;values&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
        </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</source>
        </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
        </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
        </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
        </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
        </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules for the search.</source>
        </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve">
          <source>The zero-based starting index position of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is the smaller of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> and the last index position in this instance.</source>
        </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is negative.</source>
        </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is greater than the length of this instance.</source>
        </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> + 1 - <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">count</ph><ept id="p2">&lt;/code&gt;</ept> specifies a position that is not within this instance.</source>
        </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">start</ph><ept id="p1">&lt;/code&gt;</ept> is less than -1 or greater than zero.</source>
        </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p1">&lt;/code&gt;</ept> is greater than 1.</source>
        </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
        </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
        </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
        </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules for the search.</source>
        </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve">
          <source>The zero-based starting index position of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is the smaller of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> and the last index position in this instance.</source>
        </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is less than zero or greater than the length of the current instance.</source>
        </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is less than -1 or greater than zero.</source>
        </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</source>
        </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
        </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward toward the beginning of this instance until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
        </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
        </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
        </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve">
          <source>The Unicode character to seek.</source>
        </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve">
          <source>The starting position of the search.</source>
        </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is less than zero or greater than or equal to the length of this instance.</source>
        </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3"> - </ph><bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">count</ph><ept id="p2">&lt;/code&gt;</ept> + 1 is less than zero.</source>
        </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve">
          <source>A parameter specifies the type of search to use for the specified string.</source>
        </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
        </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that specifies the rules for the search.</source>
        </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve">
          <source>The zero-based starting index position of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is the last index position in this instance.</source>
        </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
        </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
        </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
        </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
        </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
        </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
        </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
        </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</source>
        </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one of the strings contains the required substring.</source>
        </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
        </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.LastIndexOf#23<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.LastIndexOf#23<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve">
          <source>The zero-based starting index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is the smaller of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> and the last index position in this instance.</source>
        </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is negative.</source>
        </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is greater than the length of this instance.</source>
        </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3"> - </ph><bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">count</ph><ept id="p2">&lt;/code&gt;</ept>+ 1 specifies a position that is not within this instance.</source>
        </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">start</ph><ept id="p1">&lt;/code&gt;</ept> is less than -1 or greater than zero.</source>
        </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p1">&lt;/code&gt;</ept> is greater than 1.</source>
        </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
        </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.This method begins searching at the <ph id="ph2">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning of the current instance until either <ph id="ph3">`value`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
        </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve">
          <source>The Unicode character to seek.</source>
        </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve">
          <source>The starting position of the search.</source>
        </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is less than zero or greater than or equal to the length of this instance.</source>
        </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
        </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
        </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
        </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method always returns <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=fullName&gt;</ph> – 1, which represents the last index position in the current instance.</source>
        </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
        </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only one of the strings contains a soft hyphen.</source>
        </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT">
          <source>When searching for a soft hyphen only, the method returns 6 and 5.</source>
        </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT">
          <source>These values correspond to the index of the last character in the two strings.</source>
        </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.LastIndexOf#21<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.LastIndexOf#21<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve">
          <source>The zero-based starting index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that string is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is the last index position in this instance.</source>
        </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
        </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve">
          <source>The Unicode character to seek.</source>
        </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve">
          <source>The zero-based index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that character is found, or -1 if it is not.</source>
        </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
        </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
        </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
        </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
        </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
        </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</source>
        </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</source>
        </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of <ph id="ph1">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.LastIndexOf#22<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.LastIndexOf#22<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve">
          <source>The string to seek.</source>
        </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve">
          <source>The zero-based starting index position of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, the return value is the smaller of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> and the last index position in this instance.</source>
        </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is less than zero or greater than the length of the current instance.</source>
        </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> is less than -1 or greater than zero.</source>
        </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
        </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph1">`anyOf`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve">
          <source>A Unicode character array containing one or more characters to seek.</source>
        </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve">
          <source>The index position of the last occurrence in this instance where any character in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">anyOf</ph><ept id="p1">&lt;/code&gt;</ept> was found; -1 if no character in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">anyOf</ph><ept id="p2">&lt;/code&gt;</ept> was found.</source>
        </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;anyOf&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
        </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or the first character position has been examined.</source>
        </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve">
          <source>A Unicode character array containing one or more characters to seek.</source>
        </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve">
          <source>The index position of the last occurrence in this instance where any character in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">anyOf</ph><ept id="p1">&lt;/code&gt;</ept> was found; -1 if no character in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">anyOf</ph><ept id="p2">&lt;/code&gt;</ept> was found or if the current instance equals <ph id="ph3">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;anyOf&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> specifies a position that is not within this instance.</source>
        </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
        </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
        </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index numbering starts from zero.</source>
        </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
        </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
        </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
        </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve">
          <source>A Unicode character array containing one or more characters to seek.</source>
        </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve">
          <source>The search starting position.</source>
        </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve">
          <source>The search proceeds from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> toward the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve">
          <source>The number of character positions to examine.</source>
        </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve">
          <source>The index position of the last occurrence in this instance where any character in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">anyOf</ph><ept id="p1">&lt;/code&gt;</ept> was found; -1 if no character in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">anyOf</ph><ept id="p2">&lt;/code&gt;</ept> was found or if the current instance equals <ph id="ph3">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;anyOf&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> is negative.</source>
        </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve">
          <source>The current instance does not equal <ph id="ph1">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> minus <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">count</ph><ept id="p2">&lt;/code&gt;</ept> + 1 is less than zero.</source>
        </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve">
          <source>Gets the number of characters in the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in this instance, not the number of Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reason is that a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=fullName&gt;</ph> class to work with each Unicode character instead of each <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some languages, such as C and C++, a null character indicates the end of a string.</source>
        </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework, a null character can be embedded in a string.</source>
        </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a string includes one or more null characters, they are included in the length of the total string.</source>
        </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in the following string, the substrings "abc" and "def" are separated by a null character.</source>
        </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</source>
        </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.String.Class#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.String.Class#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.String.Class#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve">
          <source>The number of characters in the current string.</source>
        </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</source>
        </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
        </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
        </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
        </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT">
          <source>To normalize and compare two strings, do the following:</source>
        </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
        </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> method to normalize the strings to a specified normalization form.</source>
        </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
        </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
        </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve">
          <source>A Unicode normalization form.</source>
        </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve">
          <source>A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">normalizationForm</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve">
          <source>The current instance contains invalid Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</source>
        </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
        </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT">
          <source>U+1EAF</source>
        </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT">
          <source>U+0103 U+0301</source>
        </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT">
          <source>U+0061 U+0306 U+0301</source>
        </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
        </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
        </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
        </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT">
          <source>To normalize and compare two strings, do the following:</source>
        </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
        </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> method to normalize the strings to normalization form C.</source>
        </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
        </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
        </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve">
          <source>A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</source>
        </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve">
          <source>The current instance contains invalid Unicode characters.</source>
        </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve">
          <source>Determines whether two specified strings have the same value.</source>
        </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method defines the operation of the equality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as that shown in the Example section.</source>
        </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operator, in turn, calls the static <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
        </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Visual Basic compiler does not resolve the equality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the equality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve">
          <source>The first string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve">
          <source>The second string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">a</ph><ept id="p1">&lt;/code&gt;</ept> is the same as the value of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">b</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve">
          <source>Determines whether two specified strings have different values.</source>
        </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as that shown in the Examples section.</source>
        </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> operator in turn calls the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
        </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Visual Basic compiler does not resolve the inequality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the inequality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve">
          <source>The first string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve">
          <source>The second string to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">a</ph><ept id="p1">&lt;/code&gt;</ept> is different from the value of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">b</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve">
          <source>Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</source>
        </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
        </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> method pads the beginning of the returned string.</source>
        </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
        </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph>method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string that is padded with leading white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
        </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
        </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve">
          <source>However, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is less than the length of this instance, the method returns a reference to the existing instance.</source>
        </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
        </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;totalWidth&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve">
          <source>Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</source>
        </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the beginning of the returned string.</source>
        </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
        </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string that is padded with leading <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
        </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
        </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve">
          <source>A Unicode padding character.</source>
        </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">paddingChar</ph><ept id="p1">&lt;/code&gt;</ept> characters as needed to create a length of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">totalWidth</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve">
          <source>However, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is less than the length of this instance, the method returns a reference to the existing instance.</source>
        </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
        </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;totalWidth&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve">
          <source>Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</source>
        </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
        </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> method pads the end of the returned string.</source>
        </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
        </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the<ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string that is padded with trailing white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
        </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
        </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve">
          <source>However, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is less than the length of this instance, the method returns a reference to the existing instance.</source>
        </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
        </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;totalWidth&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve">
          <source>Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</source>
        </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the end of the returned string.</source>
        </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
        </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string that is padded with trailing <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
        </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
        </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve">
          <source>A Unicode padding character.</source>
        </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">paddingChar</ph><ept id="p1">&lt;/code&gt;</ept> characters as needed to create a length of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">totalWidth</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve">
          <source>However, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is less than the length of this instance, the method returns a reference to the existing instance.</source>
        </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">totalWidth</ph><ept id="p1">&lt;/code&gt;</ept> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
        </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;totalWidth&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve">
          <source>Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</source>
        </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
        </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all characters from position <ph id="ph1">`startIndex`</ph> to the end of the original string have been removed.</source>
        </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve">
          <source>The zero-based position to begin deleting characters.</source>
        </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve">
          <source>A new string that is equivalent to this string except for the removed characters.</source>
        </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> specifies a position that is not within this string.</source>
        </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve">
          <source>Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</source>
        </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
        </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
        </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which the number of characters specified by the <ph id="ph1">`count`</ph> parameter have been removed.</source>
        </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT">
          <source>The characters are removed at the position specified by <ph id="ph1">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve">
          <source>The zero-based position to begin deleting characters.</source>
        </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve">
          <source>The number of characters to delete.</source>
        </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve">
          <source>A new string that is equivalent to this instance except for the removed characters.</source>
        </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p2">&lt;/code&gt;</ept> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> plus <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> specify a position outside this instance.</source>
        </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve">
          <source>Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</source>
        </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldChar`</ph>.</source>
        </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldChar`</ph> are replaced by <ph id="ph2">`newChar`</ph>.</source>
        </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
        </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method calls are executed from left to right.</source>
        </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Replace#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Replace#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve">
          <source>The Unicode character to be replaced.</source>
        </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve">
          <source>The Unicode character to replace all occurrences of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">oldChar</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve">
          <source>A string that is equivalent to this instance except that all instances of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">oldChar</ph><ept id="p1">&lt;/code&gt;</ept> are replaced with <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">newChar</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">oldChar</ph><ept id="p1">&lt;/code&gt;</ept> is not found in the current instance, the method returns the current instance unchanged.</source>
        </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve">
          <source>Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</source>
        </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`newValue`</ph> is <ph id="ph2">`null`</ph>, all occurrences of <ph id="ph3">`oldValue`</ph> are removed.</source>
        </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldValue`</ph> are replaced by <ph id="ph2">`newValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
        </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method calls are executed from left to right.</source>
        </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Replace#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Replace#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve">
          <source>The string to be replaced.</source>
        </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve">
          <source>The string to replace all occurrences of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">oldValue</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve">
          <source>A string that is equivalent to the current string except that all instances of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">oldValue</ph><ept id="p1">&lt;/code&gt;</ept> are replaced with <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">newValue</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">oldValue</ph><ept id="p1">&lt;/code&gt;</ept> is not found in the current instance, the method returns the current instance unchanged.</source>
        </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;oldValue&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;oldValue&lt;/code&gt;</ph> is the empty string ("").</source>
        </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve">
          <source>Splits a string into a maximum number of substrings based on the strings in an array.</source>
        </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve">
          <source>You can specify whether the substrings include empty array elements.</source>
        </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value details</source>
        </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
        </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
        </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
        </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
        </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
        </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
        </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
        </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
        </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
        </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The separator array</source>
        </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
        </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
        </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT">
          <source>returns this four-element array: { "This", "is", "a", "string."</source>
        </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT">
          <source>}.</source>
        </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparison details</source>
        </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
        </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
        </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
        </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
        </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider an instance whose value is "abcdef".</source>
        </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</source>
        </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
        </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</source>
        </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
        </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</source>
        </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance considerations</source>
        </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
        </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
        </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
        </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
        </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
        </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
        </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT">
          <source>This significantly reduces the additional overhead of each method call.</source>
        </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return.</source>
        </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.StringSplitOptions.RemoveEmptyEntries"&gt;&lt;/xref&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;xref href="System.StringSplitOptions.None"&gt;&lt;/xref&gt;</ph> to include empty array elements in the array returned.</source>
        </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve">
          <source>For more information, see the Remarks section.</source>
        </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph> is not one of the <ph id="ph2">&lt;xref href="System.StringSplitOptions"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
        </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
        </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
        </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
        </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
        </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT">
          <source>To unambiguously identify the called method, your code must indicate the type of the null.</source>
        </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
        </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
        </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
        </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
        </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
        </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
        </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
        </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
        </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
        </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
        </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
        </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT">
          <source>This significantly reduces the additional overhead of each method call.</source>
        </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return.</source>
        </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.StringSplitOptions.RemoveEmptyEntries"&gt;&lt;/xref&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;xref href="System.StringSplitOptions.None"&gt;&lt;/xref&gt;</ph> to include empty array elements in the array returned.</source>
        </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve">
          <source>For more information, see the Remarks section.</source>
        </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph> is not one of the <ph id="ph2">&lt;xref href="System.StringSplitOptions"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve">
          <source>Splits a string into substrings based on the strings in an array.</source>
        </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve">
          <source>You can specify whether the substrings include empty array elements.</source>
        </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a string is delimited by a known set of strings, you can use the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method to separate it into substrings.</source>
        </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value details</source>
        </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
        </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
        </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
        </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
        </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
        </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "_", the value of the string instance is "-_aa-<ph id="ph2">\_</ph>", and the value of   the <ph id="ph3">`options`</ph> argument is <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a sting array with the following five elements:</source>
        </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string that precedes the "-" substring at index 0.</source>
        </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</source>
        </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT">
          <source>"aa",</source>
        </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string that follows the "_" substring at index 4.</source>
        </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string that follows the "-" substring at index 5.</source>
        </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The separator array</source>
        </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
        </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
        </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT">
          <source>returns the following four-element array: { "This", "is", "a", "string."</source>
        </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT">
          <source>}.</source>
        </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
        </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
        </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
        </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparison details</source>
        </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
        </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
        </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
        </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
        </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider an instance whose value is "abcdef".</source>
        </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</source>
        </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
        </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</source>
        </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
        </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</source>
        </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance considerations</source>
        </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
        </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
        </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
        </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
        </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
        </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
        </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT">
          <source>This significantly reduces the additional overhead of each method call.</source>
        </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.StringSplitOptions.RemoveEmptyEntries"&gt;&lt;/xref&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;xref href="System.StringSplitOptions.None"&gt;&lt;/xref&gt;</ph> to include empty array elements in the array returned.</source>
        </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve">
          <source>For more information, see the Remarks section.</source>
        </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph> is not one of the <ph id="ph2">&lt;xref href="System.StringSplitOptions"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve">
          <source>Splits a string into substrings based on the characters in an array.</source>
        </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve">
          <source>You can specify whether the substrings include empty array elements.</source>
        </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value details</source>
        </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter characters (the characters in the <ph id="ph1">`separator`</ph> array) are not included in the elements of the returned array.</source>
        </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
        </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
        </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
        </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of a single character.</source>
        </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "_", the value of the string instance is "-_aa-<ph id="ph2">\_</ph>", and the value of   the <ph id="ph3">`options`</ph> argument is <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a string array with the following five elements:</source>
        </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string that precedes the "-" character at index 0.</source>
        </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</source>
        </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT">
          <source>"aa",</source>
        </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string that follows the "_" character at index 4.</source>
        </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph>, which represents the empty string that follows the "-" character at index 5.</source>
        </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT">
          <source>The separator array</source>
        </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
        </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
        </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
        </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparison details</source>
        </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
        </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
        </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
        </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
        </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
        </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
        </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
        </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT">
          <source>This significantly reduces the additional overhead of each method call.</source>
        </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.StringSplitOptions.RemoveEmptyEntries"&gt;&lt;/xref&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;xref href="System.StringSplitOptions.None"&gt;&lt;/xref&gt;</ph> to include empty array elements in the array returned.</source>
        </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve">
          <source>For more information, see the Remarks section.</source>
        </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;options&lt;/code&gt;</ph> is not one of the <ph id="ph2">&lt;xref href="System.StringSplitOptions"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
        </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve">
          <source>You also specify the maximum number of substrings to return.</source>
        </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
        </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
        </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`count`</ph> is zero, an empty array is returned.</source>
        </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
        </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
        </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
        </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
        </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table provides examples.</source>
        </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT">
          <source>String value</source>
        </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT">
          <source>Separator</source>
        </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Count</source>
        </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT">
          <source>Returned array</source>
        </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT">
          <source>"42, 12, 19"</source>
        </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {',', ' '} (C#)</source>
        </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {","c, " "c} (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT">
          <source>2</source>
        </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"42", " 12, 19"}</source>
        </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT">
          <source>"42..12..19"</source>
        </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {'.'}</source>
        </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT">
          <source>(C#)</source>
        </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {"."c} (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT">
          <source>4</source>
        </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"42", "", "12", ".19"}</source>
        </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Banana"</source>
        </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {'.'}</source>
        </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT">
          <source>(C#)</source>
        </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {"."c} (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT">
          <source>2</source>
        </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"Banana"}</source>
        </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb\nSmarba" (C#)</source>
        </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {} (C#)</source>
        </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {} (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"Darb\nSmarba"} (C#)</source>
        </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb\nSmarba" (C#)</source>
        </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] null (C#)</source>
        </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = Nothing</source>
        </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT">
          <source>2</source>
        </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"Darb", "Smarba"}</source>
        </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb\nSmarba" (C#)</source>
        </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] null (C#)</source>
        </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = Nothing</source>
        </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT">
          <source>100</source>
        </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"Darb", "Smarba"}</source>
        </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
        </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
        </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
        </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
        </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
        </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
        </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT">
          <source>This significantly reduces the additional overhead of each method call.</source>
        </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return.</source>
        </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve">
          <source>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve">
          <source>For more information, see the Remarks section.</source>
        </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve">
          <source>Splits a string into substrings that are based on the characters in an array.</source>
        </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a string is delimited by a known set of characters, you can use the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate it into substrings.</source>
        </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT">
          <source>For other ways to extract substrings from a string, see the <bpt id="p1">[</bpt>Alternatives to String.Split<ept id="p1">](#Alternatives)</ept> section.</source>
        </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value details</source>
        </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
        </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
        </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
        </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
        </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT">
          <source>Here are some examples:</source>
        </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT">
          <source>String value</source>
        </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT">
          <source>Separator</source>
        </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT">
          <source>Returned array</source>
        </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT">
          <source>"42, 12, 19"</source>
        </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {',', ' '} (C#)</source>
        </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {","c, " "c}) (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"42", "", "12", "", "19"}</source>
        </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT">
          <source>"42..12..19"</source>
        </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {'.'}</source>
        </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT">
          <source>(C#)</source>
        </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {"."c} (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"42", "", "12", "", "19"}</source>
        </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Banana"</source>
        </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {'.'}</source>
        </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT">
          <source>(C#)</source>
        </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {"."c} (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"Banana"}</source>
        </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb\nSmarba" (C#)</source>
        </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT">
          <source>new Char[] {} (C#)</source>
        </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char() = {} (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"Darb", "Smarba"}</source>
        </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb\nSmarba" (C#)</source>
        </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT">
          <source>null (C#)</source>
        </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nothing (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT">
          <source>{"Darb", "Smarba"}</source>
        </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT">
          <source>The separator array</source>
        </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of separator defines a separate delimiter that consists of a single character.</source>
        </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`separator`</ph> argument is <ph id="ph2">`null`</ph> or contains no characters, the method treats white-space characters as the delimiters.</source>
        </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard; they return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT">
          <source>String.Split(Char[]) and compiler overload resolution</source>
        </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the single parameter for this overload of <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=fullName&gt;</ph> is a character array, you can call it with a single character, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#12<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#12<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">`separator`</ph> parameter is decorated  with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, compilers will interpret a single character as a single-element character array.</source>
        </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is not the case for other <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=fullName&gt;</ph> overloads that include a <ph id="ph2">`separator`</ph> parameter; you must explicitly pass these overloads a character array as the <ph id="ph3">`separator`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparison details</source>
        </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> array, and returns those substrings as elements of an array.</source>
        </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
        </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatives to String.Split</source>
        </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
        </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
        </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Regular expressions</source>
        </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
        </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
        </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Here's an example:</source>
        </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#8<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#8<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
        </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match one or more decimal digits.</source>
        </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match one or more whitespace characters.</source>
        </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
        </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the second capturing group.</source>
        </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match one or more whitespace characters.</source>
        </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match one or more decimal digits.</source>
        </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the third capturing group.</source>
        </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
        </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a common scenario when either of these conditions occurs:</source>
        </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
        </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they do not always serve as delimiters.</source>
        </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT">
          <source>A regular expression can split this string easily, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#9<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#9<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
        </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match an opening bracket.</source>
        </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
        </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match a closing bracket.</source>
        </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=fullName&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
        </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName&gt;</ph>method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
        </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#10<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#10<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
        </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match a whitespace character followed by a hyphen.</source>
        </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match zero or one whitespace character.</source>
        </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match zero or one occurrence of either the + or * character.</source>
        </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match zero or one whitespace character.</source>
        </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Match a hyphen followed by a whitespace character.</source>
        </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Search methods and the Substring method</source>
        </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
        </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
        </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string comparison methods include:</source>
        </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
        </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
        </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
        </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
        </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
        </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
        </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Split#11<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Split#11<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
        </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT">
          <source>You also have the option of using the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to locate a substring within a string.</source>
        </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT">
          <source>To split a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
        </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT">
          <source>To split a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
        </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
        </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
        </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT">
          <source>This significantly reduces the additional overhead of each method call.</source>
        </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve">
          <source>An array whose elements contain the substrings from this instance that are delimited by one or more characters in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">separator</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve">
          <source>For more information, see the Remarks section.</source>
        </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</source>
        </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the beginning of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
        </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String?displayProperty=fullName&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a comparison using the specified casing and culture.</source>
        </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve">
          <source>The string to compare.</source>
        </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to ignore case during the comparison; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve">
          <source>Cultural information that determines how this string and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> are compared.</source>
        </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">culture</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, the current culture is used.</source>
        </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter matches the beginning of this string; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</source>
        </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</source>
        </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</source>
        </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison can use the conventions of the current culture (<ph id="ph1">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>) or the invariant culture (<ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> and <ph id="ph4">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>), or it can consist of a character-by-character comparison of code points (<ph id="ph5">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> or <ph id="ph6">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparison can also be case-sensitive (<ph id="ph1">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>), or it can ignore case (<ph id="ph4">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve">
          <source>The string to compare.</source>
        </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> are compared.</source>
        </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this instance begins with <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparisonType&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.StringComparison"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve">
          <source>Determines whether the beginning of this string instance matches the specified string.</source>
        </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the beginning of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
        </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String?displayProperty=fullName&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
        </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
        </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve">
          <source>The string to compare.</source>
        </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> matches the beginning of this string; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve">
          <source>Retrieves a substring from this instance.</source>
        </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve">
          <source>The substring starts at a specified character position and continues to the end of the string.</source>
        </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</source>
        </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
        </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT">
          <source>To extract a substring that begins at a specified character position and ends before to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string that begins at the <ph id="ph1">`startIndex`</ph> position in the current string.</source>
        </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT">
          <source>The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</source>
        </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero, the method returns the original string unchanged.</source>
        </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve">
          <source>The zero-based starting character position of a substring in this instance.</source>
        </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve">
          <source>A string that is equivalent to the substring that begins at <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">startIndex</ph><ept id="p1">&lt;/code&gt;</ept> in this instance, or <ph id="ph2">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> is equal to the length of this instance.</source>
        </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is less than zero or greater than the length of this instance.</source>
        </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve">
          <source>Retrieves a substring from this instance.</source>
        </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve">
          <source>The substring starts at a specified character position and has a specified length.</source>
        </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</source>
        </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
        </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT">
          <source>To extract a substring that begins at a specified character position and continues to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string with <ph id="ph1">`length`</ph> characters starting from the <ph id="ph2">`startIndex`</ph> position in the current string.</source>
        </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`length`</ph> parameter represents the total number of characters to extract from the current string instance.</source>
        </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT">
          <source>This includes the starting character found at index  <ph id="ph1">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method attempts to extract characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> - 1.</source>
        </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the substring extends from <ph id="ph1">`startIndex`</ph> to a specified character sequence, you can call a method such as  <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the index of the ending character or character sequence.</source>
        </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then convert that value to an index position in the string as follows:</source>
        </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you've searched for a single character that is to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph> + 1, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example extracts a continuous block of "b" characters from a string.</source>
        </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Substring#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Substring#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you've searched for multiple characters that are to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`endMatchLength`</ph><ph id="ph5"> - </ph><ph id="ph6">`startIndex`</ph>, where <ph id="ph7">`endIndex`</ph> is the return value of the <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> method., and <ph id="ph10">`endMatchLength`</ph> is the length of the character sequence that marks the end of the substring.</source>
        </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example extracts a block of text that contains an XML <ph id="ph1">`&lt;definition&gt;`</ph> element.</source>
        </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.String.Substring#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.String.Substring#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the character or character sequence is not included in the end of the substring, the <ph id="ph1">`length`</ph> parameter equals <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph>, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</source>
        </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve">
          <source>The zero-based starting character position of a substring in this instance.</source>
        </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve">
          <source>The number of characters in the substring.</source>
        </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve">
          <source>A string that is equivalent to the substring of length <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">length</ph><ept id="p1">&lt;/code&gt;</ept> that begins at <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p2">&lt;/code&gt;</ept> in this instance, or <ph id="ph3">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph> if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">startIndex</ph><ept id="p3">&lt;/code&gt;</ept> is equal to the length of this instance and <bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">length</ph><ept id="p4">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> plus <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> indicates a position not within this instance.</source>
        </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve">
          <source>Copies the characters in a specified substring in this instance to a Unicode character array.</source>
        </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies the characters in a portion of a string to a character array.</source>
        </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a string from a range of characters in a character array, call the  <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`startIndex`</ph> parameter is zero-based.</source>
        </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the index of the first character in the string instance is zero.</source>
        </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`length`</ph> is zero, the returned array is empty and has a zero length.</source>
        </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this instance is <ph id="ph1">`null`</ph> or an empty string (""), the returned array is empty and has a zero length.</source>
        </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
        </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT">
          <source>Encoding</source>
        </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT">
          <source>Object</source>
        </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT">
          <source>ASCII</source>
        </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-7</source>
        </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-8</source>
        </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-16</source>
        </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-32</source>
        </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve">
          <source>The starting position of a substring in this instance.</source>
        </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve">
          <source>The length of the substring in this instance.</source>
        </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve">
          <source>A Unicode character array whose elements are the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">length</ph><ept id="p1">&lt;/code&gt;</ept> number of characters in this instance starting from character position <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">startIndex</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> plus <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the length of this instance.</source>
        </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve">
          <source>Copies the characters in this instance to a Unicode character array.</source>
        </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies each character (that is, each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object) in a string to a character array.</source>
        </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first character copied is at index zero of the returned character array; the last character copied is at index <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph> – 1.</source>
        </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a string from the characters in a character array, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a byte array that contains the encoded characters in a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
        </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT">
          <source>Encoding</source>
        </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT">
          <source>Object</source>
        </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT">
          <source>ASCII</source>
        </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-7</source>
        </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-8</source>
        </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-16</source>
        </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT">
          <source>UTF-32</source>
        </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve">
          <source>A Unicode character array whose elements are the individual characters of this instance.</source>
        </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve">
          <source>If this instance is an empty string, the returned array is empty and has a zero length.</source>
        </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve">
          <source>Returns a copy of this string converted to lowercase.</source>
        </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method takes into account the casing rules of the current culture.</source>
        </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
        </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security Considerations</source>
        </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method takes the casing conventions of the current culture into account.</source>
        </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method) and performs more efficiently.</source>
        </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve">
          <source>A string in lowercase.</source>
        </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve">
          <source>Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</source>
        </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of the string is changed.</source>
        </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
        </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security Considerations</source>
        </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
        </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT">
          <source>This produces the same result in every culture and performs more efficiently.</source>
        </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve">
          <source>The lowercase equivalent of the current string.</source>
        </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;culture&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve">
          <source>Returns a copy of this <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object converted to lowercase using the casing rules of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
        </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is associated with the English language but not with a specific country or region.</source>
        </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</source>
        </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
        </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
        </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security Considerations</source>
        </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve">
          <source>The lowercase equivalent of the current string.</source>
        </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve">
          <source>Returns this instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>; no actual conversion is performed.</source>
        </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
        </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is usually called implicitly in a composite formatting operation, as the example shows.</source>
        </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve">
          <source>The current string.</source>
        </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve">
          <source>Returns this instance of <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>; no actual conversion is performed.</source>
        </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`provider`</ph> is reserved, and does not currently participate in this operation.</source>
        </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
        </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve">
          <source>(Reserved) An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve">
          <source>The current string.</source>
        </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve">
          <source>Returns a copy of this string converted to uppercase.</source>
        </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</source>
        </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</source>
        </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
        </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</source>
        </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT">
          <source>A better method to perform case-insensitive comparison is to call a string comparison method that has a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter whose value you set to <ph id="ph2">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> for a culture-sensitive, case-insensitive comparison.</source>
        </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security Considerations</source>
        </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method takes the casing conventions of the current culture into account.</source>
        </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method) and performs more efficiently.</source>
        </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve">
          <source>The uppercase equivalent of the current string.</source>
        </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve">
          <source>Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</source>
        </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of a string is changed.</source>
        </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
        </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security Considerations</source>
        </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
        </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT">
          <source>This produces the same result in every culture and performs more efficiently.</source>
        </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific casing rules.</source>
        </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve">
          <source>The uppercase equivalent of the current string.</source>
        </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;culture&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve">
          <source>Returns a copy of this <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object converted to uppercase using the casing rules of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
        </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is associated with the English language but not with a specific country or region.</source>
        </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</source>
        </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
        </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
        </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security Considerations</source>
        </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve">
          <source>The uppercase equivalent of the current string.</source>
        </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve">
          <source>Removes all leading and trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each leading and trailing trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
        </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc456xyz".</source>
        </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all leading and trailing <ph id="ph1">`trimChars`</ph> characters found in the current instance are removed.</source>
        </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of characters in the <ph id="ph2">`trimChars`</ph> array, the method returns <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`trimChars`</ph> is <ph id="ph2">`null`</ph> or an empty array, this method removes any leading or trailing characters that result in the method returning <ph id="ph3">`true`</ph> when they are passed to the <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method,</source>
        </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve">
          <source>An array of Unicode characters to remove, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve">
          <source>The string that remains after all occurrences of the characters in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">trimChars</ph><ept id="p1">&lt;/code&gt;</ept> parameter are removed from the start and end of the current string.</source>
        </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">trimChars</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph> or an empty array, white-space characters are removed instead.</source>
        </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
        </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve">
          <source>Removes all leading and trailing white-space characters from the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing white-space characters.</source>
        </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each leading and trailing trim operation stops when a non-white-space character is encountered.</source>
        </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current string is "   abc   xyz   ", the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc   xyz".</source>
        </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT">
          <source>To remove white-space characters between words in a string, use a <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</source>
        </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of white-space characters, the method returns <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT">
          <source>White-space characters are defined by the Unicode standard.</source>
        </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> method removes any leading and trailing characters that produce a return value of <ph id="ph2">`true`</ph> when they are passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve">
          <source>The string that remains after all white-space characters are removed from the start and end of the current string.</source>
        </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
        </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve">
          <source>Removes all trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes from the current string all trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT">
          <source>The trim operation stops when the first character that is not in <ph id="ph1">`trimChars`</ph> is encountered at the end of the string.</source>
        </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method returns "123abc456xyz".</source>
        </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all trailing characters found in <ph id="ph1">`trimChars`</ph> are removed from the current string.</source>
        </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve">
          <source>An array of Unicode characters to remove, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve">
          <source>The string that remains after all occurrences of the characters in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">trimChars</ph><ept id="p1">&lt;/code&gt;</ept> parameter are removed from the end of the current string.</source>
        </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">trimChars</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph> or an empty array, Unicode white-space characters are removed instead.</source>
        </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
        </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve">
          <source>Removes all leading occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes from the current string all leading characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT">
          <source>The trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
        </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> method returns "abc456xyz789".</source>
        </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
        </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</source>
        </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve">
          <source>An array of Unicode characters to remove, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve">
          <source>The string that remains after all occurrences of characters in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">trimChars</ph><ept id="p1">&lt;/code&gt;</ept> parameter are removed from the start of the current string.</source>
        </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">trimChars</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph> or an empty array, white-space characters are removed instead.</source>
        </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface object.</source>
        </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve">
          <source>A strongly-typed enumerator that can be used to iterate through the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve">
          <source>An enumerator that can be used to iterate through the current string.</source>
        </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToBoolean(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the current string is <ph id="ph2">&lt;xref href="System.Boolean.TrueString"&gt;&lt;/xref&gt;</ph>; <ph id="ph3">`false`</ph> if the value of the current string is <ph id="ph4">&lt;xref href="System.Boolean.FalseString"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve">
          <source>The value of the current string is not <ph id="ph1">&lt;xref href="System.Boolean.TrueString"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Boolean.FalseString"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToByte(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be parsed.</source>
        </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object is a number greater than <ph id="ph2">&lt;xref href="System.Byte.MaxValue"&gt;&lt;/xref&gt;</ph> or less than <ph id="ph3">&lt;xref href="System.Byte.MinValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToChar(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve">
          <source>The character at index 0 in the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToDateTime(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToDecimal(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be parsed.</source>
        </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object is a number less than <ph id="ph2">&lt;xref href="System.Decimal.MinValue"&gt;&lt;/xref&gt;</ph> or than <ph id="ph3">&lt;xref href="System.Decimal.MaxValue"&gt;&lt;/xref&gt;</ph> greater.</source>
        </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToDouble(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be parsed.</source>
        </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object is a number less than <ph id="ph2">&lt;xref href="System.Double.MinValue"&gt;&lt;/xref&gt;</ph> or greater than <ph id="ph3">&lt;xref href="System.Double.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToInt16(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be parsed.</source>
        </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object is a number greater than <ph id="ph2">&lt;xref href="System.Int16.MaxValue"&gt;&lt;/xref&gt;</ph> or less than <ph id="ph3">&lt;xref href="System.Int16.MinValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToInt32(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToInt64(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToSByte(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be parsed.</source>
        </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object is a number greater than <ph id="ph2">&lt;xref href="System.SByte.MaxValue"&gt;&lt;/xref&gt;</ph> or less than <ph id="ph3">&lt;xref href="System.SByte.MinValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToSingle(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToType(System.Type,System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve">
          <source>The type of the returned object.</source>
        </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be converted to the type specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToUInt16(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be parsed.</source>
        </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object is a number greater than <ph id="ph2">&lt;xref href="System.UInt16.MaxValue"&gt;&lt;/xref&gt;</ph> or less than <ph id="ph3">&lt;xref href="System.UInt16.MinValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToUInt32(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object cannot be parsed.</source>
        </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object is a number greater <ph id="ph2">&lt;xref href="System.UInt32.MaxValue"&gt;&lt;/xref&gt;</ph> or less than <ph id="ph3">&lt;xref href="System.UInt32.MinValue"&gt;&lt;/xref&gt;</ph></source>
        </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToUInt64(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve">
          <source>The converted value of the current <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>