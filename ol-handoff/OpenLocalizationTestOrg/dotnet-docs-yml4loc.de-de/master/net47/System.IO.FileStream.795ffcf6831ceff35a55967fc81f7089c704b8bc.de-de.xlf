<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fdbb0aec985f047b7f9e5bd20ce85b5f02056c8c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.IO.FileStream.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b2029c4f976119af4dc480eedcff15b43c76e902</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7488d5b50b75555ec11f87c26956db0dda575a57</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides a <ph id="ph1">&lt;xref href="System.IO.Stream"&gt;&lt;/xref&gt;</ph> for a file, supporting both synchronous and asynchronous read and write operations.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)</ept>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.CopyTo%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> methods to perform synchronous operations, or the <ph id="ph5">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph8">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> methods to perform asynchronous operations.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> buffers input and output for better performance.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property detects whether the file handle was opened asynchronously.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> method supports random access to files.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> allows the read/write position to be moved to any position within the file.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is done with byte offset reference point parameters.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disk files always support random access.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>At the time of construction, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is set to <ph id="ph2">`true`</ph> or <ph id="ph3">`false`</ph> depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <ph id="ph4">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph5">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>For directory operations and other file operations, see the <ph id="ph1">&lt;xref:System.IO.File&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.Path&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.File&gt;</ph> class is a utility class that has static methods primarily for the creation of <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objects based on file paths.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class creates a stream from a byte array and is similar to the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Detection of Stream Position Changes</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the cached position in the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and the cached data in the buffer could be compromised.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph> method, the contents of the buffer are discarded and an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> exception is thrown.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object will not have an exclusive hold on its handle when either the <ph id="ph2">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property is accessed to expose the handle or the <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> object is given the <ph id="ph4">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property in its constructor.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A file handle for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A constant that sets the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;access&lt;/code&gt;</ph> is not a field of <ph id="ph2">&lt;xref href="System.IO.FileAccess"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>An I/O error, such as a disk error, occurred.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified file handle, such as when <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">access</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`Write`</ph> or <ph id="ph4">`ReadWrite`</ph> and the file handle is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file will be shared by processes.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A constant that specifies additional file options.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A constant that determines the access control and audit security for the file.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is negative or zero.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;access&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;share&lt;/code&gt;</ph> contain an invalid value.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p2">&lt;/code&gt;</ept>, such as when <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">access</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph4">`Write`</ph> or <ph id="ph5">`ReadWrite`</ph> and the file or directory is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileOptions.Encrypted"&gt;&lt;/xref&gt;</ph> is specified for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">options</ph><ept id="p1">&lt;/code&gt;</ept>, but file encryption is not supported on the current platform.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">path</ph><ept id="p1">&lt;/code&gt;</ept>, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The current operating system is not Windows NT or later.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file will be shared by processes.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A constant that specifies additional file options.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is negative or zero.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;access&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;share&lt;/code&gt;</ph> contain an invalid value.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The current operating system is not Windows NT or later.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p2">&lt;/code&gt;</ept>, such as when <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">access</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph4">`Write`</ph> or <ph id="ph5">`ReadWrite`</ph> and the file or directory is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileOptions.Encrypted"&gt;&lt;/xref&gt;</ph> is specified for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">options</ph><ept id="p1">&lt;/code&gt;</ept>, but file encryption is not supported on the current platform.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">path</ph><ept id="p1">&lt;/code&gt;</ept>, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>This also determines the values returned by the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.CanSeek"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">path</ph><ept id="p1">&lt;/code&gt;</ept> specifies a disk file.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file will be shared by processes.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>A value that specifies additional file options.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is negative or zero.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;access&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;share&lt;/code&gt;</ph> contain an invalid value.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p2">&lt;/code&gt;</ept>, such as when <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">access</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph4">`Write`</ph> or <ph id="ph5">`ReadWrite`</ph> and the file or directory is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileOptions.Encrypted"&gt;&lt;/xref&gt;</ph> is specified for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">options</ph><ept id="p1">&lt;/code&gt;</ept>, but file encryption is not supported on the current platform.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>This also determines the values returned by the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.CanSeek"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">path</ph><ept id="p1">&lt;/code&gt;</ept> specifies a disk file.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file will be shared by processes.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096..</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Specifies whether to use asynchronous I/O or synchronous I/O.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>However, note that the underlying operating system might not support asynchronous I/O, so when specifying <ph id="ph1">`true`</ph>, the handle might be opened synchronously depending on the platform.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>When opened asynchronously, the <ph id="ph1">&lt;xref href="System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> methods perform better on large reads or writes, but they might be much slower for small reads or writes.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>If the application is designed to take advantage of asynchronous I/O, set the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">useAsync</ph><ept id="p1">&lt;/code&gt;</ept> parameter to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is negative or zero.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;access&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;share&lt;/code&gt;</ph> contain an invalid value.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">share</ph><ept id="p1">&lt;/code&gt;</ept> is set to <ph id="ph2">`FileShare.Delete`</ph>.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p2">&lt;/code&gt;</ept>, such as when <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">access</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph4">`Write`</ph> or <ph id="ph5">`ReadWrite`</ph> and the file or directory is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">`FileStream`</ph> instance ownership, buffer size, and synchronous or asynchronous state.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ownership of the handle will be as specified.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, the file's handle count is decremented.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>A file handle for the file that this <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>A constant that sets the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the file handle will be owned by this <ph id="ph2">`FileStream`</ph> instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;access&lt;/code&gt;</ph> is less than <ph id="ph2">`FileAccess.Read`</ph> or greater than <ph id="ph3">`FileAccess.ReadWrite`</ph> or <ph id="ph4">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is less than or equal to 0.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The handle is invalid.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>An I/O error, such as a disk error, occurred.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified file handle, such as when <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">access</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`Write`</ph> or <ph id="ph4">`ReadWrite`</ph> and the file handle is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path, creation mode, read/write permission, and sharing permission.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>This also determines the values returned by the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.CanSeek"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">path</ph><ept id="p1">&lt;/code&gt;</ept> specifies a disk file.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file will be shared by processes.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">share</ph><ept id="p1">&lt;/code&gt;</ept> is set to <ph id="ph2">`FileShare.Delete`</ph>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p2">&lt;/code&gt;</ept>, such as when <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">access</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph4">`Write`</ph> or <ph id="ph5">`ReadWrite`</ph> and the file or directory is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph> contains an invalid value.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>This also determines the values returned by the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.CanSeek"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">path</ph><ept id="p1">&lt;/code&gt;</ept> specifies a disk file.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file will be shared by processes.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is negative or zero.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;access&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;share&lt;/code&gt;</ph> contain an invalid value.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">share</ph><ept id="p1">&lt;/code&gt;</ept> is set to <ph id="ph2">`FileShare.Delete`</ph>.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p2">&lt;/code&gt;</ept>, such as when <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">access</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph4">`Write`</ph> or <ph id="ph5">`ReadWrite`</ph> and the file or directory is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>You set the <ph id="ph1">`isAsync`</ph> parameter to <ph id="ph2">`true`</ph> to open the file handle asynchronously.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the parameter is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the parameter does not have to be <ph id="ph1">`true`</ph> to call the <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">`isAsync`</ph> parameter is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>A file handle for the file that this <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>A constant that sets the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">handle</ph><ept id="p1">&lt;/code&gt;</ept> parameter is an invalid handle.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">handle</ph><ept id="p1">&lt;/code&gt;</ept> parameter is a synchronous handle and it was used asynchronously.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bufferSize</ph><ept id="p1">&lt;/code&gt;</ept> parameter is negative.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>An I/O error, such as a disk error, occurred.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified file handle, such as when <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">access</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`Write`</ph> or <ph id="ph4">`ReadWrite`</ph> and the file handle is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path, creation mode, and read/write permission.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>This also determines the values returned by the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.CanSeek"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">path</ph><ept id="p1">&lt;/code&gt;</ept> specifies a disk file.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p2">&lt;/code&gt;</ept>, such as when <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">access</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph4">`Write`</ph> or <ph id="ph5">`ReadWrite`</ph> and the file or directory is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph> contains an invalid value.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class for the specified file handle, with the specified read/write permission and <ph id="ph2">`FileStream`</ph> instance ownership.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ownership of the handle will be as specified.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this process owns the handle, a call to the <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle and the file's handle count is decremented.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the default buffer size of 4096 bytes.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>A file handle for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>A constant that sets the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the file handle will be owned by this <ph id="ph2">`FileStream`</ph> instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;access&lt;/code&gt;</ph> is not a field of <ph id="ph2">&lt;xref href="System.IO.FileAccess"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>An I/O error, such as a disk error, occurred.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified file handle, such as when <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">access</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`Write`</ph> or <ph id="ph4">`ReadWrite`</ph> and the file handle is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class for the specified file handle, with the specified read/write permission, and buffer size.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>A file handle for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.IO.FileAccess"&gt;&lt;/xref&gt;</ph> constant that sets the <ph id="ph2">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph3">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph4">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">handle</ph><ept id="p1">&lt;/code&gt;</ept> parameter is an invalid handle.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">handle</ph><ept id="p1">&lt;/code&gt;</ept> parameter is a synchronous handle and it was used asynchronously.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">bufferSize</ph><ept id="p1">&lt;/code&gt;</ept> parameter is negative.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>An I/O error, such as a disk error, occurred.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified file handle, such as when <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">access</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`Write`</ph> or <ph id="ph4">`ReadWrite`</ph> and the file handle is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class with the specified path and creation mode.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a <ph id="ph1">`FileAccess`</ph> parameter with the value set to <ph id="ph2">`FileAccess.Read`</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, depending on the system, this class can access a physical device.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>For constructors without a <ph id="ph1">&lt;xref:System.IO.FileAccess&gt;</ph> parameter, if the <ph id="ph2">`mode`</ph> parameter is set to <ph id="ph3">&lt;xref:System.IO.FileMode.Append&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileAccess.Write&gt;</ph> is the default access.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the access is set to <ph id="ph1">&lt;xref:System.IO.FileAccess.ReadWrite&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>A relative or absolute path for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>A constant that determines how to open or create the file.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;path&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>The file cannot be found, such as when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`FileMode.Truncate`</ph> or <ph id="ph3">`FileMode.Open`</ph>, and the file specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">path</ph><ept id="p2">&lt;/code&gt;</ept> does not exist.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>The file must already exist in these modes.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>An I/O error, such as specifying <ph id="ph1">`FileMode.CreateNew`</ph> when the file specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">path</ph><ept id="p1">&lt;/code&gt;</ept> already exists, occurred.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mode&lt;/code&gt;</ph> contains an invalid value.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>A file handle for the file that the current <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>A constant that sets the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;access&lt;/code&gt;</ph> is not a field of <ph id="ph2">&lt;xref href="System.IO.FileAccess"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>An I/O error, such as a disk error, occurred.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified file handle, such as when <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">access</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`Write`</ph> or <ph id="ph4">`ReadWrite`</ph> and the file handle is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">`FileStream`</ph> instance ownership, and buffer size.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ownership of the handle will be as specified.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, the file's handle count is decremented.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>A file handle for the file that this <ph id="ph1">`FileStream`</ph> object will encapsulate.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>A constant that sets the <ph id="ph1">&lt;xref href="System.IO.FileStream.CanRead"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.IO.FileStream.CanWrite"&gt;&lt;/xref&gt;</ph> properties of the <ph id="ph3">`FileStream`</ph> object.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the file handle will be owned by this <ph id="ph2">`FileStream`</ph> instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>A positive <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value greater than 0 indicating the buffer size.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>An I/O error, such as a disk error, occurred.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>The stream has been closed.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">access</ph><ept id="p1">&lt;/code&gt;</ept> requested is not permitted by the operating system for the specified file handle, such as when <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">access</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`Write`</ph> or <ph id="ph4">`ReadWrite`</ph> and the file handle is set for read-only access.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous read operation.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>(Consider using <ph id="ph1">&lt;xref href="System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"&gt;&lt;/xref&gt;</ph> instead.)</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly once for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Windows, this slows down asynchronous methods.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occur during an asynchronous read request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> must be called with this <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to find out how many bytes were read.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>The buffer to read data into.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>The byte offset in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which to begin reading.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to read.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>The method to be called when the asynchronous read operation is completed.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous read request from other requests.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>An object that references the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The array length minus <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">numBytes</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;numBytes&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>An asynchronous read was attempted past the end of the file.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous write operation.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>(Consider using <ph id="ph1">&lt;xref href="System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"&gt;&lt;/xref&gt;</ph> instead.)</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Windows, this slows down asynchronous methods.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>The buffer containing data to write to the current stream.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>The zero-based byte offset in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which to begin copying bytes to the current stream.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to write.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The method to be called when the asynchronous write operation is completed.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>A user-provided object that distinguishes this particular asynchronous write request from other requests.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>An object that references the asynchronous write.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> length minus <ph id="ph2">&lt;code&gt;offset&lt;/code&gt;</ph> is less than <ph id="ph3">&lt;code&gt;numBytes&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;numBytes&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The stream does not support writing.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The stream is closed.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>An I/O error occurred.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current stream supports reading.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.ReadByte%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> methods throw a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the stream supports reading; <ph id="ph2">`false`</ph> if the stream is closed or was opened with write-only access.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the stream supports seeking; <ph id="ph2">`false`</ph> if the stream is closed or if the <ph id="ph3">`FileStream`</ph> was constructed from an operating-system handle such as a pipe or output to the console.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current stream supports writing.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.FileStream.WriteByte%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the stream supports writing; <ph id="ph2">`false`</ph> if the stream is closed or was opened with read-only access.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> and optionally releases the managed resources.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> references.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to release both managed and unmanaged resources; <ph id="ph2">`false`</ph> to release only unmanaged resources.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Waits for the pending asynchronous read operation to complete.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>(Consider using <ph id="ph1">&lt;xref href="System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"&gt;&lt;/xref&gt;</ph> instead.)</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> can be called on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> tells you how many bytes were read from the stream.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> will block until the I/O operation has completed.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The reference to the pending asynchronous request to wait for.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The number of bytes read from the stream, between 0 and the number of bytes you requested.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object was not created by calling <ph id="ph2">&lt;xref href="System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> on this class.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.EndRead(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> is called multiple times.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>The stream is closed or an internal error has occurred.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>Ends an asynchronous write operation and blocks until the I/O operation is complete.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>(Consider using <ph id="ph1">&lt;xref href="System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"&gt;&lt;/xref&gt;</ph> instead.)</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>The pending asynchronous I/O request.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object was not created by calling <ph id="ph2">&lt;xref href="System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> on this class.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.EndWrite(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> is called multiple times.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>The stream is closed or an internal error has occurred.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">`FileStream`</ph>.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls <ph id="ph1">`Finalize`</ph> when the current object is ready to be finalized.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Finalize`</ph> closes the <ph id="ph2">`FileStream`</ph>.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A?displayProperty=fullName&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>A stream’s encoder is not flushed unless you explicitly call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> or dispose of the object.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName&gt;</ph> to <ph id="ph2">`true`</ph> means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because a buffer can be used for either reading or writing, <ph id="ph1">&lt;xref:System.IO.FileStream.Flush&gt;</ph> performs the following two functions:</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName&gt;</ph> is <ph id="ph2">`true`</ph> and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer is then cleared.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%28System.Boolean%29&gt;</ph> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>An I/O error occurred.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>The stream is closed.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to flush all intermediate file buffers; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>The token to monitor for cancellation requests.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>A task that represents the asynchronous flush operation.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>The stream has been disposed.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Security.AccessControl.FileSecurity"&gt;&lt;/xref&gt;</ph> object that encapsulates the access control list (ACL) entries for the file described by the current <ph id="ph2">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <ph id="ph3">&lt;xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName&gt;</ph> method, as it is easier to use.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to retrieve the ACL entries for a file.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>An object that encapsulates the access control settings for the file described by the current <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>The file is closed.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>An I/O error occurred while opening the file.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>The file could not be found.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>This operation is not supported on the current platform.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>Gets the operating system file handle for the file that the current <ph id="ph1">`FileStream`</ph> object encapsulates.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is an operating system handle for use with operating-system-provided system calls (such as <ph id="ph1">`ReadFile`</ph> on Windows).</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>It will not work with C library functions that expect a file descriptor, such as <ph id="ph1">`fread`</ph>.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system handle might have been opened synchronously or asynchronously, depending on which <ph id="ph1">`FileStream`</ph> constructor was called.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property to discover whether this handle was opened asynchronously.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to <ph id="ph1">`ReadFile`</ph> and <ph id="ph2">`WriteFile`</ph>.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data corruption might occur if a <ph id="ph1">`FileStream`</ph> is created, its handle is passed, some operation moves the handle's file pointer, and then the <ph id="ph2">`FileStream`</ph> is used again.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple threads cannot safely write to the same file simultaneously, and <ph id="ph1">`FileStream`</ph> buffering code assumes that it exclusively controls the handle.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`FileStream`</ph> might throw an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if <ph id="ph3">`FileStream`</ph> detects that some other process has moved the file pointer.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid this, do not write any data into a portion of the file that <ph id="ph1">`FileStream`</ph> might have buffered, and restore the file pointer to the location it had when methods were last called on <ph id="ph2">`FileStream`</ph>.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>The operating system file handle for the file encapsulated by this <ph id="ph1">`FileStream`</ph> object, or -1 if the <ph id="ph2">`FileStream`</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">`FileStream`</ph> was opened asynchronously or synchronously.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`IsAsync`</ph> property detects whether the <ph id="ph2">`FileStream`</ph> handle was opened asynchronously, enabling your code to use the <ph id="ph3">&lt;xref:System.IO.FileStream.Handle%2A&gt;</ph> property correctly.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Win32, <ph id="ph1">`IsAsync`</ph> being true means the handle was opened for overlapped I/O, and thus requires different parameters to <ph id="ph2">`ReadFile`</ph> and <ph id="ph3">`WriteFile`</ph>.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">`FileStream`</ph> was opened asynchronously; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>Gets the length in bytes of the stream.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>A long value representing the length of the stream in bytes.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.IO.FileStream.CanSeek"&gt;&lt;/xref&gt;</ph> for this stream is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>An I/O error, such as the file being closed, occurred.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Prevents other processes from reading from or writing to the <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>The beginning of the range to lock.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>The value of this parameter must be equal to or greater than zero (0).</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The range to be locked.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;position&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>The file is closed.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>The process cannot access the file because another process has locked a portion of the file.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>Gets the name of the <ph id="ph1">`FileStream`</ph> that was passed to the constructor.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>A string that is the name of the <ph id="ph1">`FileStream`</ph>.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>Gets or sets the current position of this stream.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you seek beyond the length of the file, the file size grows.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>The current position of this stream.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>The stream does not support seeking.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>An I/O error occurred.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>The position was set to a very large value beyond the end of the stream in Windows 98 or earlier.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>Attempted to set the position to a negative value.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>Attempted seeking past the end of a stream that does not support this.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>Reads a block of bytes from the stream and writes the data in a given buffer.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin reading, and the <ph id="ph3">`count`</ph> parameter gives the maximum number of bytes to be read from this stream.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method returns zero only after reaching the end of the stream.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> always reads at least one byte from the stream before returning.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available from the stream upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, the method will block until at least one byte of data can be returned.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not interrupt a thread that is performing a read operation.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept> and (<bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">offset</ph><ept id="p2">&lt;/code&gt;</ept><ph id="ph3"> + </ph><bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">count</ph><ept id="p3">&lt;/code&gt;</ept> - 1<bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">)</ph><ept id="p4">&lt;/code&gt;</ept> replaced by the bytes read from the current source.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>The byte offset in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which the read bytes will be placed.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to read.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>The total number of bytes read into the buffer.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>The stream does not support reading.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>An I/O error occurred.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> describe an invalid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>Methods were called after the stream was closed.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>The buffer to write the data into.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The byte offset in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> at which to begin writing data from the stream.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to read.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>The token to monitor for cancellation requests.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>A task that represents the asynchronous read operation.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>The value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">TResult</ph><ept id="p1">&lt;/code&gt;</ept> parameter contains the total number of bytes read into the buffer.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p2">&lt;/code&gt;</ept> is larger than the buffer length.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>The stream does not support reading.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>The stream has been disposed.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The stream is currently in use by a previous read operation.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Reads a byte from the file and advances the read position one byte.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>The byte, cast to an <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph>, or -1 if the end of the stream has been reached.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>The current stream does not support reading.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>The current stream is closed.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="Microsoft.Win32.SafeHandles.SafeFileHandle"&gt;&lt;/xref&gt;</ph> object that represents the operating system file handle for the file that the current <ph id="ph2">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> object encapsulates.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property automatically flushes the stream and sets the current stream position to 0.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows the file to be moved or the stream position to be reset by another stream using the <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> returned by this property.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>An object that represents the operating system file handle for the file that the current <ph id="ph1">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> object encapsulates.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>Sets the current position of this stream to the given value.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName&gt;</ph> property to determine whether the current instance supports seeking.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can seek to any location beyond the length of the stream.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you seek beyond the length of the file, the file size grows.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Windows NT and later versions, data added to the end of the file is set to zero.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>The point relative to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">origin</ph><ept id="p1">&lt;/code&gt;</ept> from which to begin seeking.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Specifies the beginning, the end, or the current position as a reference point for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept>, using a value of type <ph id="ph2">&lt;xref href="System.IO.SeekOrigin"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>The new position in the stream.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>An I/O error occurred.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The stream does not support seeking, such as if the <ph id="ph1">`FileStream`</ph> is constructed from a pipe or console output.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>Seeking is attempted before the beginning of the stream.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Methods were called after the stream was closed.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>Applies access control list (ACL) entries described by a <ph id="ph1">&lt;xref href="System.Security.AccessControl.FileSecurity"&gt;&lt;/xref&gt;</ph> object to the file described by the current <ph id="ph2">&lt;xref href="System.IO.FileStream"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> can be used on an existing file, consider using the <ph id="ph3">&lt;xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName&gt;</ph> method as it is easier to use.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> method applies access control list (ACL) entries to a file that represents the noninherited ACL list.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>The ACL specified for the <ph id="ph1">`fileSecurity`</ph> parameter replaces the existing ACL for the file.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>To add permissions for a new user, use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to obtain the existing ACL, modify it, and then use <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> to apply it back to the file.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>An object that describes an ACL entry to apply to the current file.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>The file is closed.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileSecurity</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The file could not be found or modified.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The current process does not have access to open the file.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Sets the length of this stream to the given value.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the given value is less than the current length of the stream, the stream is truncated.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this scenario, if the current position is greater than the new length, the current position is moved to the last byte of the stream.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the given value is larger than the current length of the stream, the stream is expanded, and the current position remains the same.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the stream is expanded, the contents of the stream between the old and the new length are undefined.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>A stream must support both writing and seeking for <ph id="ph1">`SetLength`</ph> to work.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing, and the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property to determine whether seeking is supported.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>The new length of the stream.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>An I/O error has occurred.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>The stream does not support both writing and seeking.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>Attempted to set the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter to less than 0.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>Allows access by other processes to all or part of a file that was previously locked.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>The beginning of the range to unlock.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>The range to be unlocked.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;position&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>Writes a block of bytes to the file stream.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin copying, and the <ph id="ph3">`count`</ph> parameter gives the number of bytes that will be written to the stream.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the write operation is successful, the current position of the stream is advanced by the number of bytes written.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not interrupt a thread that is performing a write operation.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>The buffer containing data to write to the stream.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>The zero-based byte offset in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> from which to begin copying bytes to the stream.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to write.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> describe an invalid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>An I/O error occurred.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>Another thread may have caused an unexpected change in the position of the operating system's file handle.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>The stream is closed.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>The current stream instance does not support writing.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>The buffer to write data from.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>The zero-based byte offset in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> from which to begin copying bytes to the stream.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to write.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>The token to monitor for cancellation requests.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>A task that represents the asynchronous write operation.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">offset</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">count</ph><ept id="p2">&lt;/code&gt;</ept> is larger than the buffer length.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>The stream does not support writing.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>The stream has been disposed.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>The stream is currently in use by a previous write operation.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>Writes a byte to the current position in the file stream.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">`WriteByte`</ph> to write a byte to a <ph id="ph2">`FileStream`</ph> efficiently.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the stream is closed or not writable, an exception will be thrown.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>A byte to write to the stream.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>The stream is closed.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>The stream does not support writing.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>