<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">286947152d04f47cb374a84fa1e3bd78269d79e6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Reflection.Emit.TypeBuilder.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f2395988a581894e51e66d05b6bd94f4f723f61c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8be1659e2023b5f3df680067fd46c65b527e7d8a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines and creates new instances of classes during run time.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is the root class used to control the creation of dynamic classes in the runtime.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>A new <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be created from a dynamic module by calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=fullName&gt;</ph> method, which returns a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection emit provides the following options for defining types:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Define a class or interface with the given name.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Define a class or interface with the given name and attributes.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Define a class with the given name, attributes, and base class.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Define a class with the given name, attributes, base class, and packing size.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Define a class with the given name, attributes, base class, and the class size as a whole.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create an array type, pointer type, or byref type for an incomplete type that is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method, <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method, respectively.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before a type is used, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=fullName&gt;</ph> method must be called.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> completes the creation of the type.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Following the call to <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, the caller can instantiate the type by using the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=fullName&gt;</ph> method, and invoke members of the type by using the <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is an error to invoke methods that change the implementation of a type after <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> has been called.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the common language runtime throws an exception if the caller tries to add new members to a type.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>A class initializer is created by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> returns a <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested types are defined by calling one of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attributes</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class uses the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration to further specify the characteristics of the type to be created:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Interfaces are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> attributes.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Concrete classes (classes that cannot be extended) are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several attributes determine type visibility.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is specified, the class loader lays out fields in the order they are read from metadata.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The class loader considers the specified packing size but ignores any specified field offsets.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The metadata preserves the order in which the field definitions are emitted.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even across a merge, the metadata will not reorder the field definitions.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The loader will honor the specified field offsets only if <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is specified.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Known Issues</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Type&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Type&gt;</ph> class are not fully implemented in the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calls to these <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> methods throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>The desired functionality can be obtained by retrieving the created type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and reflecting on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Adds declarative security to this type.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`AddDeclarativeSecurity`</ph> may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The security action to be taken such as Demand, Assert, and so on.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The set of permissions the action applies to.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">action</ph><ept id="p1">&lt;/code&gt;</ept> is invalid (<ph id="ph2">`RequestMinimum`</ph>, <ph id="ph3">`RequestOptional`</ph>, and <ph id="ph4">`RequestRefuse`</ph> are invalid).</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The containing type has been created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The permission set <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">pset</ph><ept id="p1">&lt;/code&gt;</ept> contains an action that was added earlier by <ph id="ph2">`AddDeclarativeSecurity`</ph>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;pset&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Adds an interface that this type implements.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The interface that this type implements.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;interfaceType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Returns the full name of this type qualified by the display name of the assembly.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The format of the returned string is the concatenation of the full name of the type (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) and the display name of the assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=fullName&gt;</ph>), separated by a comma and a space.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Version Information</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The full name of this type qualified by the display name of the assembly.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Retrieves the base type of this type.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Retrieves the base type of this type.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Creates a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object for the class.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>After defining fields and methods on the class, <ph id="ph1">`CreateType`</ph> is called in order to load its <ph id="ph2">`Type`</ph> object.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this type is a nested type, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method must be called on the enclosing type before it is called on the nested type.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current type derives from an incomplete type or implements incomplete interfaces, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the parent type and the interface types before calling it on the current type.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the enclosing type will generate a <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=fullName&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller should define a handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event to complete the definition of the nested type by calling <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the nested type.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code example for this topic shows how to define such an event handler.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type is created only once, no matter how many times the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>All calls return the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Returns the new <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object for this class.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The enclosing type has not been created.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This type is non-abstract and contains an abstract method.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This type is not an abstract class or an interface and has a method without a method body.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The type contains invalid Microsoft intermediate language (MSIL) code.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The type cannot be loaded.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For example, it contains a <ph id="ph1">`static`</ph> method that has the calling convention <ph id="ph2">&lt;xref href="System.Reflection.CallingConventions.HasThis"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Reflection.TypeInfo"&gt;&lt;/xref&gt;</ph> object that represents this type.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>An object that represents this type.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Gets the method that declared the current generic type parameter.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Returns the type that declared this type.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The type that declared this type.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Adds a new constructor to the type, with the given attributes and signature.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you define a constructor for your dynamic type, a default constructor is not provided.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have the following options for providing a default constructor in addition to the constructor you defined:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want a default constructor that simply calls the default constructor of the base class, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> method to create one (and optionally restrict access to it).</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not provide an implementation for this default constructor.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do, an exception is thrown when you try to use the constructor.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown when the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=fullName&gt;</ph> method to create one, and provide your own implementation.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The attributes of the constructor.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The calling convention of the constructor.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The parameter types of the constructor.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The defined constructor.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload is provided for designers of managed compilers.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The attributes of the constructor.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The calling convention of the constructor.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The parameter types of the constructor.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The defined constructor.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The size of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">requiredCustomModifiers</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">optionalCustomModifiers</ph><ept id="p2">&lt;/code&gt;</ept> does not equal the size of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">parameterTypes</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Defines the default constructor.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The constructor defined here will simply call the default constructor of the parent.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>You want to set the attributes on the default constructor to something other than <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, and <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`MethodAttributes`</ph> object representing the attributes to be applied to the constructor.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Returns the constructor.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The parent type (base type) does not have a default constructor.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Adds a new event to the type, with the given name, attributes and event type.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The name of the event.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The attributes of the event.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The type of the event.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The defined event.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;eventtype&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Adds a new field to the type, with the given name, attributes, and field type.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The name of the field.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fieldName</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The type of the field</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The attributes of the field.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The defined field.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fieldName</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is System.Void.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>A total size was specified for the parent class of this field.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;fieldName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload is provided for designers of managed compilers.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The name of the field.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fieldName</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The type of the field</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>An array of types representing the required custom modifiers for the field, such as <ph id="ph1">&lt;xref href="Microsoft.VisualC.IsConstModifier"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>An array of types representing the optional custom modifiers for the field, such as <ph id="ph1">&lt;xref href="Microsoft.VisualC.IsConstModifier"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The attributes of the field.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The defined field.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fieldName</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is System.Void.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>A total size was specified for the parent class of this field.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;fieldName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <ph id="ph1">&lt;xref href="System.Reflection.Emit.GenericTypeParameterBuilder"&gt;&lt;/xref&gt;</ph> objects that can be used to set their constraints.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method makes the current type a generic type.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method is called again on the same type, an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>An array of names for the generic type parameters.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.Emit.GenericTypeParameterBuilder"&gt;&lt;/xref&gt;</ph> objects that can be used to define the constraints of the generic type parameters for the current type.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Generic type parameters have already been defined for this type.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;names&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>An element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">names</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;names&lt;/code&gt;</ph> is an empty array.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Defines initialized data field in the .sdata section of the portable executable (PE) file.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The name used to refer to the data.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The blob of data.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The attributes for the field.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>A field to reference the data.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;data&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph> has been previously called.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Adds a new method to the type, with the specified name and method attributes.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload defines a method with <ph id="ph1">&lt;xref:System.Reflection.CallingConventions?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to define a method without a signature, with a different calling convention, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The name of the method.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.Emit.MethodBuilder"&gt;&lt;/xref&gt;</ph> representing the newly defined method.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Adds a new method to the type, with the specified name, method attributes, and calling convention.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The name of the method.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The calling convention of the method.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.Emit.MethodBuilder"&gt;&lt;/xref&gt;</ph> representing the newly defined method.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The type of the parent of this method is an interface and this method is not virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Adds a new method to the type, with the specified name, method attributes, and method signature.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The name of the method.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The return type of the method.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the method.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The defined method.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The name of the method.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The calling convention of the method.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The return type of the method.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the method.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.Emit.MethodBuilder"&gt;&lt;/xref&gt;</ph> representing the newly defined method.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this overload if you need to specify custom modifiers.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overloads to define the method and then use the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName&gt;</ph> method to define the parameter and return types with custom modifiers.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The name of the method.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The calling convention of the method.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The return type of the method.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the method.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the method.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the method.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.Emit.MethodBuilder"&gt;&lt;/xref&gt;</ph> object representing the newly added method.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>The size of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameterTypeRequiredCustomModifiers</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">parameterTypeOptionalCustomModifiers</ph><ept id="p2">&lt;/code&gt;</ept> does not equal the size of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">parameterTypes</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Specifies a given method body that implements a given method declaration, potentially with a different name.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use this method to emit method overrides or interface implementations.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is used when a method body and a method declaration have different names.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`DefineMethodOverride`</ph> defines a <ph id="ph2">`methodimpl`</ph>, which consists of a pair of metadata tokens.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>One token points to an implementation, and the other token points to a declaration that the body implements.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>The body must be defined on the type the method impl is defined on, and the body must be virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the declaration is on an interface only, the slot defined for the interface is altered.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The overridden method cannot be the actual method that is declared.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about method impls, see <ph id="ph1">`MethodImpl`</ph> in the ECMA Partition II Metadata documentation.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is called, some features of <ph id="ph2">`methodInfoBody`</ph> cannot be changed.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you cannot apply an attribute to a generic type parameter of <ph id="ph1">`methodInfoBody`</ph> by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method, do so after all characteristics of <ph id="ph2">`methodInfoBody`</ph> have been defined.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The method body to be used.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>This should be a <ph id="ph1">`MethodBuilder`</ph> object.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The method whose declaration is to be used.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;methodInfoBody&lt;/code&gt;</ph> does not belong to this class.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;methodInfoBody&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;methodInfoDeclaration&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The declaring type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">methodInfoBody</ph><ept id="p1">&lt;/code&gt;</ept> is not the type represented by this <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Defines a nested type, given its name, attributes, size, and the type that it extends.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The short name of the type.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded null values.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The attributes of the type.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>The type that the nested type extends.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The packing size of the type.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The total size of the type.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>The defined nested type.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The short name of the type.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>The attributes of the type.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The type that the nested type extends.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The interfaces that the nested type implements.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The defined nested type.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>The nested attribute is not specified.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>This type is sealed.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>This type is an array.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>This type is an interface, but the nested type is not an interface.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero or greater than 1023.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.FullName"&gt;&lt;/xref&gt;</ph> in the current assembly.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>An element of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">interfaces</ph><ept id="p1">&lt;/code&gt;</ept> array is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The short name of the type.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The attributes of the type.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>The type that the nested type extends.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The total size of the type.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>The defined nested type.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>The nested attribute is not specified.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>This type is sealed.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>This type is an array.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>This type is an interface, but the nested type is not an interface.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero or greater than 1023.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.FullName"&gt;&lt;/xref&gt;</ph> in the current assembly.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The short name of the type.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>The attributes of the type.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The type that the nested type extends.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>The packing size of the type.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The defined nested type.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>The nested attribute is not specified.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>This type is sealed.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>This type is an array.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>This type is an interface, but the nested type is not an interface.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero or greater than 1023.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.FullName"&gt;&lt;/xref&gt;</ph> in the current assembly.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Defines a nested type, given its name and attributes.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>The short name of the type.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The attributes of the type.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>The defined nested type.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The nested attribute is not specified.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>This type is sealed.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>This type is an array.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>This type is an interface, but the nested type is not an interface.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero or greater than 1023.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.FullName"&gt;&lt;/xref&gt;</ph> in the current assembly.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Defines a nested type, given its name.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>The short name of the type.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>The defined nested type.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero or greater than 1023.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.FullName"&gt;&lt;/xref&gt;</ph> in the current assembly.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>Defines a nested type, given its name, attributes, and the type that it extends.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>The short name of the type.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>The attributes of the type.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The type that the nested type extends.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The defined nested type.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The nested attribute is not specified.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>This type is sealed.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>This type is an array.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>This type is an interface, but the nested type is not an interface.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero or greater than 1023.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.FullName"&gt;&lt;/xref&gt;</ph> in the current assembly.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>Defines a <ph id="ph1">`PInvoke`</ph> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">`PInvoke`</ph> flags.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes?displayProperty=fullName&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example shows how to do this.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The name of the <ph id="ph1">`PInvoke`</ph> method.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The name of the DLL in which the <ph id="ph1">`PInvoke`</ph> method is defined.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>The method's calling convention.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>The method's return type.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>The types of the method's parameters.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>The native calling convention.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The method's native character set.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>The defined <ph id="ph1">`PInvoke`</ph> method.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>The method is not static.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>The parent type is an interface.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The method is abstract.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>The method was previously defined.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">dllName</ph><ept id="p2">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;dllName&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The containing type has been previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>Defines a <ph id="ph1">`PInvoke`</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">`PInvoke`</ph> flags.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes?displayProperty=fullName&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example shows how to do this.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>The name of the <ph id="ph1">`PInvoke`</ph> method.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The name of the DLL in which the <ph id="ph1">`PInvoke`</ph> method is defined.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>The name of the entry point in the DLL.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The method's calling convention.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>The method's return type.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>The types of the method's parameters.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The native calling convention.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>The method's native character set.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>The defined <ph id="ph1">`PInvoke`</ph> method.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>The method is not static.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The parent type is an interface.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The method is abstract.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>The method was previously defined.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">dllName</ph><ept id="p2">&lt;/code&gt;</ept>, or <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">entryName</ph><ept id="p3">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;dllName&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;entryName&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>The containing type has been previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Defines a <ph id="ph1">`PInvoke`</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <ph id="ph2">`PInvoke`</ph> flags, and custom modifiers for the parameters and return type.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes?displayProperty=fullName&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example shows how to do this.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>The name of the <ph id="ph1">`PInvoke`</ph> method.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The name of the DLL in which the <ph id="ph1">`PInvoke`</ph> method is defined.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>The name of the entry point in the DLL.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>The attributes of the method.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>The method's calling convention.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The method's return type.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the method.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the method.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The types of the method's parameters.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>The native calling convention.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The method's native character set.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.Emit.MethodBuilder"&gt;&lt;/xref&gt;</ph> representing the defined <ph id="ph2">`PInvoke`</ph> method.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>The method is not static.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The parent type is an interface.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>The method is abstract.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The method was previously defined.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">dllName</ph><ept id="p2">&lt;/code&gt;</ept>, or <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">entryName</ph><ept id="p3">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The size of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameterTypeRequiredCustomModifiers</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">parameterTypeOptionalCustomModifiers</ph><ept id="p2">&lt;/code&gt;</ept> does not equal the size of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">parameterTypes</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;dllName&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;entryName&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Adds a new property to the type, with the given name and property signature.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The attributes of the property.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the property.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>The defined property.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>Any of the elements of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameterTypes</ph><ept id="p1">&lt;/code&gt;</ept> array is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>The attributes of the property.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>The calling convention of the property accessors.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the property.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>The defined property.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Any of the elements of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameterTypes</ph><ept id="p1">&lt;/code&gt;</ept> array is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Adds a new property to the type, with the given name, property signature, and custom modifiers.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload is provided for designers of managed compilers.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>The attributes of the property.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the property.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the property.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the property.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The defined property.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph></source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>Any of the elements of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameterTypes</ph><ept id="p1">&lt;/code&gt;</ept> array is <ph id="ph2">`null`</ph></source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload is provided for designers of managed compilers.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>The attributes of the property.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>The calling convention of the property accessors.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the property.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>, for the return type of the property.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the property.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>An array of arrays of types.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;xref href="System.Runtime.CompilerServices.IsConst"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of types.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">`null`</ph> instead of an array of arrays.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>The defined property.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Any of the elements of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameterTypes</ph><ept id="p1">&lt;/code&gt;</ept> array is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>Defines the initializer for this type.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initializer created is always public.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>Returns a type initializer.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>The containing type has been previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>Defines an uninitialized data field in the <ph id="ph1">`.sdata`</ph> section of the portable executable (PE) file.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The name used to refer to the data.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> cannot contain embedded nulls.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>The size of the data field.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>The attributes for the field.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>A field to reference the data.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>Length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>Retrieves the full path of this type.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>Retrieves the full path of this type.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates the covariance and special constraints of the current generic type parameter.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>A bitwise combination of <ph id="ph1">&lt;xref href="System.Reflection.GenericParameterAttributes"&gt;&lt;/xref&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent a generic type parameter, the value of this property is undefined.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>If the current <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents a constructor of <ph id="ph6">`G&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order to emit the code to create an instance of the constructed type, you need a <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents the constructor of this constructed type  in other words, that creates an instance of <ph id="ph2">`G&lt;U&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents the constructor of <ph id="ph5">`G&lt;U&gt;`</ph> as parameter <ph id="ph6">`constructor`</ph>.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object you need to emit the function call.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code example demonstrates this scenario.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>The constructed generic type whose constructor is returned.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>A constructor on the generic type definition of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">type</ph><ept id="p1">&lt;/code&gt;</ept>, which specifies which constructor of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p2">&lt;/code&gt;</ept> to return.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> object that represents the constructor of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> corresponding to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">constructor</ph><ept id="p2">&lt;/code&gt;</ept>, which specifies a constructor belonging to the generic type definition of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">type</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not represent a generic type.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not of type <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>The declaring type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">constructor</ph><ept id="p1">&lt;/code&gt;</ept> is not a generic type definition.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>The declaring type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">constructor</ph><ept id="p1">&lt;/code&gt;</ept> is not the generic type definition of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> objects representing the public and non-public constructors defined for this class, as specified.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> as in <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> objects representing the specified constructors defined for this class.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>If no constructors are defined, an empty array is returned.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>Returns all the custom attributes defined for this type.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>Returns an array of objects representing all the custom attributes of this type.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>This method is not currently supported for incomplete types.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Retrieve the type using <ph id="ph1">&lt;xref href="System.Type.GetType"&gt;&lt;/xref&gt;</ph> and call <ph id="ph2">&lt;xref href="System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)"&gt;&lt;/xref&gt;</ph> on the returned <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>Returns all the custom attributes of the current type that are assignable to a specified type.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>The type of attribute to search for.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>Only attributes that are assignable to this type are returned.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>An array of custom attributes defined on the current type.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>This method is not currently supported for incomplete types.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>Retrieve the type using <ph id="ph1">&lt;xref href="System.Type.GetType"&gt;&lt;/xref&gt;</ph> and call <ph id="ph2">&lt;xref href="System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)"&gt;&lt;/xref&gt;</ph> on the returned <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;attributeType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>The type must be a type provided by the underlying runtime system.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>Calling this method always throws <ph id="ph1">&lt;xref href="System.NotSupportedException"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>This method is not supported.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>No value is returned.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>This method is not supported.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>Returns the event with the specified name.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>The name of the event to search for.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>A bitwise combination of <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> values that limits the search.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph> object representing the event declared or inherited by this type with the specified name, or <ph id="ph2">`null`</ph> if there are no matches.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>Returns the public events declared or inherited by this type.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph> objects representing the public events declared or inherited by this type.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>An empty array is returned if there are no public events.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Returns the public and non-public events that are declared by this type.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>A bitwise combination of <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> values that limits the search.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph> objects representing the events declared or inherited by this type that match the specified binding flags.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>An empty array is returned if there are no matching events.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>Returns the field specified by the given name.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>The name of the field to get.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> as in <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">&lt;xref href="System.Reflection.FieldInfo"&gt;&lt;/xref&gt;</ph> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>If there are no matches then <ph id="ph1">`null`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents a field of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents a field <ph id="ph6">`public T F`</ph> in C# syntax (<ph id="ph7">`Public F As T`</ph> in Visual Basic, <ph id="ph8">`public: T F`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls field <ph id="ph4">`F`</ph> on that instance.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents <ph id="ph2">`F`</ph> on the constructed type  in other words, that is of type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents <ph id="ph5">`F`</ph> as parameter <ph id="ph6">`field`</ph>.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object you need to emit the function call.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code example demonstrates this scenario.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>The constructed generic type whose field is returned.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>A field on the generic type definition of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">type</ph><ept id="p1">&lt;/code&gt;</ept>, which specifies which field of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p2">&lt;/code&gt;</ept> to return.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.FieldInfo"&gt;&lt;/xref&gt;</ph> object that represents the field of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> corresponding to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">field</ph><ept id="p2">&lt;/code&gt;</ept>, which specifies a field belonging to the generic type definition of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">type</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not represent a generic type.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not of type <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>The declaring type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">field</ph><ept id="p1">&lt;/code&gt;</ept> is not a generic type definition.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>The declaring type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">field</ph><ept id="p1">&lt;/code&gt;</ept> is not the generic type definition of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Returns the public and non-public fields that are declared by this type.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> : <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.FieldInfo"&gt;&lt;/xref&gt;</ph> objects representing the public and non-public fields declared or inherited by this type.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>An empty array is returned if there are no fields, as specified.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method retrieves the <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objects that represent the generic type parameters.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents a generic type definition from which the current type can be obtained.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object for which the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> property returns the current instance.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type is always a generic type definition.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you used the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method to construct a generic type from a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents a generic type definition, using the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=fullName&gt;</ph> method on the constructed type gets back the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the generic type definition.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing a generic type definition from which the current type can be obtained.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>The current type is not generic.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>The name of the interface.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`true`</ph>, the search is case-insensitive.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`false`</ph>, the search is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing the implemented interface.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>Returns null if no interface matching name is found.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>Returns an interface mapping for the requested interface.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the interface for which the mapping is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>Returns the requested interface mapping.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>Returns an array of all the interfaces implemented on this type and its base types.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the implemented interfaces.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>If none are defined, an empty array is returned.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>Returns all the public and non-public members declared or inherited by this type, as specified.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>The type of the member to return.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph>, as in <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing the public and non-public members defined on this type if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">nonPublic</ph><ept id="p1">&lt;/code&gt;</ept> is used; otherwise, only the public members are returned.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>Returns the members for the public and non-public members declared or inherited by this type.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph>, such as <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing the public and non-public members declared or inherited by this type.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>An empty array is returned if there are no matching members.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a method of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents a method <ph id="ph6">`T M()`</ph> in C# syntax (<ph id="ph7">`Function M() As T`</ph> in Visual Basic, <ph id="ph8">`T M()`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls method <ph id="ph4">`M`</ph> on that instance.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph2">`M`</ph> on the constructed type  in other words, that returns type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents <ph id="ph5">`T M()`</ph> as parameter <ph id="ph6">`method`</ph>.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object you need to emit the function call.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code example demonstrates a scenario similar to this.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>The constructed generic type whose method is returned.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>A method on the generic type definition of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">type</ph><ept id="p1">&lt;/code&gt;</ept>, which specifies which method of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p2">&lt;/code&gt;</ept> to return.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object that represents the method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> corresponding to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">method</ph><ept id="p2">&lt;/code&gt;</ept>, which specifies a method belonging to the generic type definition of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">type</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is a generic method that is not a generic method definition.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not represent a generic type.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not of type <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>The declaring type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept> is not a generic type definition.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>The declaring type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept> is not the generic type definition of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>Returns all the public and non-public methods declared or inherited by this type, as specified.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> as in <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> objects representing the public and non-public methods defined on this type if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">nonPublic</ph><ept id="p1">&lt;/code&gt;</ept> is used; otherwise, only the public methods are returned.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>Returns the public and non-public nested types that are declared by this type.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> containing the name of the nested type to get.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>Zero, to conduct a case-sensitive search for public methods.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>Returns the public and non-public nested types that are declared or inherited by this type.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph>, as in <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing all the types nested within the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if no types are nested within the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, or if none of the nested types match the binding constraints.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>Returns all the public and non-public properties declared or inherited by this type, as specified.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>This invocation attribute.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> : <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`NonPublic`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">`PropertyInfo`</ph> objects representing the public and non-public properties defined on this type if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">nonPublic</ph><ept id="p1">&lt;/code&gt;</ept> is used; otherwise, only the public properties are returned.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>This method is not implemented for incomplete types.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>Retrieves the GUID of this type.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>Retrieves the GUID of this type</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>This method is not currently supported for incomplete types.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Invokes the specified member.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>The binder will find all of the matching methods.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the method is selected, it will be invoked.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accessibility is checked at that point.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`IBinder.BindToMethod`</ph> method is responsible for selecting the method to be invoked.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default binder selects the most specific match.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>Access restrictions are ignored for fully trusted code.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is not currently supported.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>The name of the member to invoke.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>This can be a constructor, method, property, or field.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>A suitable invocation attribute must be specified.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>The invocation attribute.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>This must be a bit flag from <ph id="ph1">`BindingFlags`</ph>.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">`MemberInfo`</ph> objects using reflection.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>If binder is <ph id="ph1">`null`</ph>, the default binder is used.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>See <ph id="ph1">&lt;xref href="System.Reflection.Binder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>The object on which to invoke the specified member.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>If the member is static, this parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>An argument list.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>If there are no parameters this should be null.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>An array of the same length as <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>A parameter has attributes associated with it in the metadata.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>They are used by various interoperability services.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>See the metadata specs for more details.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>An instance of <ph id="ph1">`CultureInfo`</ph> used to govern the coercion of types.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>If this is null, the <ph id="ph1">`CultureInfo`</ph> for the current thread is used.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Each parameter in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">namedParameters</ph><ept id="p1">&lt;/code&gt;</ept> array gets the value in the corresponding element in the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">args</ph><ept id="p2">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>If the length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> is greater than the length of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">namedParameters</ph><ept id="p2">&lt;/code&gt;</ept>, the remaining argument values are passed in order.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>Returns the return value of the invoked member.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>This method is not currently supported for incomplete types.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;xref href="System.Reflection.TypeInfo"&gt;&lt;/xref&gt;</ph> object can be assigned to this object.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>The object to test.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeInfo</ph><ept id="p1">&lt;/code&gt;</ept> can be assigned to this object; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> can be assigned to this object.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>The object to test.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">c</ph><ept id="p1">&lt;/code&gt;</ept> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">c</ph><ept id="p2">&lt;/code&gt;</ept>, or if the current type is an interface that <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">c</ph><ept id="p3">&lt;/code&gt;</ept> supports.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> if none of these conditions are valid, or if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">c</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the current dynamic type has been created.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called, the type represented by the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object is complete.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph> method has been called; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>Determines whether a custom attribute is applied to the current type.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is not supported for incomplete generic type parameters.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>The type of attribute to search for.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>Only attributes that are assignable to this type are returned.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if one or more instances of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">attributeType</ph><ept id="p1">&lt;/code&gt;</ept>, or an attribute derived from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">attributeType</ph><ept id="p2">&lt;/code&gt;</ept>, is defined on this type; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>This method is not currently supported for incomplete types.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>Retrieve the type using <ph id="ph1">&lt;xref href="System.Type.GetType"&gt;&lt;/xref&gt;</ph> and call <ph id="ph2">&lt;xref href="System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)"&gt;&lt;/xref&gt;</ph> on the returned <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;attributeType&lt;/code&gt;</ph> is not defined.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;attributeType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current type is a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> object represents a generic type parameter; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current type is a generic type.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the type represented by the current <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> object is generic; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> represents a generic type definition from which other generic types can be constructed.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be used to build generic type definitions, but not constructed generic types.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get a constructed generic type, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combinations of these properties are shown in the following table:</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security level</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityCritical</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecuritySafeCritical</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityTransparent</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT">
          <source>Critical</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT">
          <source>Safe-critical</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT">
          <source>Transparent</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph> method overload and specifying security attributes.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT">
          <source>No attributes are applied to the dynamic assembly.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to add security attributes, you must apply them yourself.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current type is security-critical or security-safe-critical; <ph id="ph2">`false`</ph> if it is transparent.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combinations of these properties are shown in the following table:</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security level</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityCritical</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecuritySafeCritical</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityTransparent</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source>Critical</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT">
          <source>Safe-critical</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT">
          <source>Transparent</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph> method overload and specifying security attributes.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>No attributes are applied to the dynamic assembly.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to add security attributes, you must apply them yourself.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current type is security-safe-critical; <ph id="ph2">`false`</ph> if it is security-critical or transparent.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combinations of these properties are shown in the following table:</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security level</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityCritical</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecuritySafeCritical</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityTransparent</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT">
          <source>Critical</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT">
          <source>Safe-critical</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT">
          <source>Transparent</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName&gt;</ph> method overload and specifying security attributes.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT">
          <source>No attributes are applied to the dynamic assembly.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to add security attributes, you must apply them yourself.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the type is security-transparent; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source>Determines whether this type is derived from a specified type.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that is to be checked.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if this type is the same as the type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">c</ph><ept id="p1">&lt;/code&gt;</ept>, or is a subtype of type <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">c</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents a one-dimensional array of the current type, with a lower bound of zero.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents an array of the current type, with the specified number of dimensions.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>The number of dimensions for the array.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents a one-dimensional array of the current type.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;rank&lt;/code&gt;</ph> is not a valid array dimension.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the current type when passed as a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType&amp;`</ph>.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the current type when passed as a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method when your emitted code requires a type constructed from the current generic type definition.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method before calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent the definition of a generic type, an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is an instance of a class derived from <ph id="ph1">&lt;xref:System.Type&gt;</ph> that has limited capabilities.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular:</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get methods, fields, and constructors for these constructed generic types, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two instances that represent the same constructed type do not compare as equal.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in the following code <ph id="ph1">`t1.Equals(t2)`</ph> returns <ph id="ph2">`false`</ph>:</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Reflection.Emit.TypeBuilder.MakeGenericType#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Reflection.Emit.TypeBuilder.MakeGenericType#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Reflection.Emit.TypeBuilder.MakeGenericType#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source>An array of types to be substituted for the type parameters of the current generic type definition.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> representing the constructed type formed by substituting the elements of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> for the type parameters of the current generic type.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>The current type does not represent the definition of a generic type.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeArguments&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>Any element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type.Module"&gt;&lt;/xref&gt;</ph> property of any element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Reflection.Module.Assembly"&gt;&lt;/xref&gt;</ph> property of the module of any element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType*`</ph>.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>Retrieves the dynamic module that contains this type definition.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve">
          <source>Retrieves the dynamic module that contains this type definition.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source>Retrieves the name of this type.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve">
          <source>Retrieves the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> name of this type.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve">
          <source>Retrieves the namespace where this <ph id="ph1">`TypeBuilder`</ph> is defined.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve">
          <source>Retrieves the namespace where this <ph id="ph1">`TypeBuilder`</ph> is defined.</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve">
          <source>Retrieves the packing size of this type.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve">
          <source>Retrieves the packing size of this type.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve">
          <source>Returns the type that was used to obtain this type.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve">
          <source>The type that was used to obtain this type.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve">
          <source>Set a custom attribute using a custom attribute builder.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve">
          <source>An instance of a helper class to define the custom attribute.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;customBuilder&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve">
          <source>The constructor for the custom attribute.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve">
          <source>A byte blob representing the attributes.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;con&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;binaryAttribute&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve">
          <source>Sets the base type of the type currently under construction.</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`parent`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> is used as the base type.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, no exception is thrown if <ph id="ph1">`parent`</ph> is an interface type, but a <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> is thrown when the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> method does not check for most invalid parent types.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT">
          <source>In all these cases, exceptions are thrown by the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve">
          <source>The new base type.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;parent&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and the current instance represents an interface whose attributes do not include <ph id="ph3">&lt;xref href="System.Reflection.TypeAttributes.Abstract"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve">
          <source>For the current dynamic type, the <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericType"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>, but the <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> property is <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;parent&lt;/code&gt;</ph> is an interface.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve">
          <source>This exception condition is new in the .NET Framework version 2.0.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source>Retrieves the total size of a type.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve">
          <source>Retrieves this types total size.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve">
          <source>Returns the name of the type excluding the namespace.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve">
          <source>The name of the type excluding the namespace.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source>Not supported in dynamic modules.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> and use reflection on the retrieved type.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve">
          <source>Not supported in dynamic modules.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve">
          <source>Returns the type token of this type.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">`TypeToken`</ph> of this type.</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve">
          <source>The type was previously created using <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve">
          <source>Returns the underlying system type for this <ph id="ph1">`TypeBuilder`</ph>.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve">
          <source>Returns the underlying system type.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve">
          <source>This type is an enumeration, but there is no underlying system type.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve">
          <source>Represents that total size for the type is not specified.</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>