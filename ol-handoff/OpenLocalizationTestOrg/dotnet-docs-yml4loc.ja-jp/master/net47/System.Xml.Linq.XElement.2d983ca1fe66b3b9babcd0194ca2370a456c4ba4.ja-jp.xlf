<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67e306cecf1f7f9f640ffb225b0485993121f96b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Xml.Linq.XElement.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">00df823d9af7736133df254c823b6a2d75641a36</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">26be1a746660b0d06297242880c2035af60a6148</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents an XML element.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>XElement Class Overview<ept id="p1">](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)</ept> and the Remarks section on this page for usage information and examples.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#System.Xml.Linq/XLinq.cs#3367036406d1344a)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>This class represents an XML element, the fundamental XML construct.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <bpt id="p1">[</bpt>XElement Class Overview<ept id="p1">](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)</ept> for other usage information.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>An element has an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, optionally one or more attributes, and can optionally contain content (for more information, see <ph id="ph2">&lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> can contain the following types of content:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content of an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> derives from <ph id="ph2">&lt;xref:System.Xml.Linq.XContainer&gt;</ph>, which derives from <ph id="ph3">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> methods can be used from XAML.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>LINQ to XML Dynamic Properties<ept id="p1">](http://msdn.microsoft.com/library/0455f47c-4a68-4f2e-a3f8-dd1d85b99012)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> class from another <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor makes a deep copy of an element.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> object to copy from.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> class with the specified name.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor creates an element with no content and no attributes.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is an implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typical use of this constructor is to specify a string as the parameter instead of creating a new <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>When creating an element in a namespace, typical use is to use the addition operator overload with an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> and a string to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> that contains the name of the element.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> class from an <ph id="ph2">&lt;xref href="System.Xml.Linq.XStreamingElement"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor iterates through the contents of the specified <ph id="ph1">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph>, and creates an element with its contents.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XStreamingElement"&gt;&lt;/xref&gt;</ph> that contains unevaluated queries that will be iterated for the contents of this <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> class with the specified name and content.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor creates an element with the specified content and attributes.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is an implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typical use of this constructor is to specify a string as the parameter instead of creating a new <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>When creating an element in a namespace, typical use is to use the addition operator overload with an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> and a string to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this constructor, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> that contains the element name.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The contents of the element.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> class with the specified name and content.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor creates an element with the specified content and attributes.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is an implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typical use of this constructor is to specify a string as the parameter instead of creating a new <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>When creating an element in a namespace, typical use is to use the addition operator overload with an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> and a string to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this constructor, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> that contains the element name.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The initial content of the element.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Returns a collection of elements that contain this element, and the ancestors of this element.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements in the returned collection are in reverse document order.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of elements that contain this element, and the ancestors of this element.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Returns a filtered collection of elements that contain this element, and the ancestors of this element.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements in the returned collection are in reverse document order.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> to match.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contain this element, and the ancestors of this element.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">&lt;xref href="System.Xml.Linq.XAttribute"&gt;&lt;/xref&gt;</ph> of this <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that has the specified <ph id="ph3">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some  return collections of elements or attributes.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns only a single attribute.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sometimes this is referred to as a <bpt id="p1">*</bpt>singleton<ept id="p1">*</ept> (in contrast to a <bpt id="p2">*</bpt>collection<ept id="p2">*</ept>).</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic users can use the integrated attribute axis to retrieve the value of an attribute with a specified name.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> of the <ph id="ph2">&lt;xref href="System.Xml.Linq.XAttribute"&gt;&lt;/xref&gt;</ph> to get.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XAttribute"&gt;&lt;/xref&gt;</ph> that has the specified <ph id="ph2">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph>; <ph id="ph3">`null`</ph> if there is no attribute with the specified name.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Returns a collection of attributes of this element.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The attributes in the returned collection are in the order that they were added to the element.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the XML tree was parsed from XML, the attributes are returned in document order.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XAttribute"&gt;&lt;/xref&gt;</ph> of attributes of this element.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Returns a filtered collection of attributes of this element.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attribute names must be unique within an element.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, this  can return either a collection that contains only one attribute, or it can return an empty collection.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> to match.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XAttribute"&gt;&lt;/xref&gt;</ph> that contains the attributes of this element.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Returns a collection of nodes that contain this element, and all descendant nodes of this element, in document order.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> that contain this element, and all descendant nodes of this element, in document order.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Returns a filtered collection of elements that contain this element, and all descendant elements of this element, in document order.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> to match.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contain this element, and all descendant elements of this element, in document order.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Returns a collection of elements that contain this element, and all descendant elements of this element, in document order.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of elements that contain this element, and all descendant elements of this element, in document order.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Gets an empty collection of elements.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is typically used by class implementers when writing a method that returns a collection of elements.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method must return no elements, it can use this property to get an empty collection of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contains an empty collection.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Gets the first attribute of this element.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attributes are stored in the element in the order that they were added to the element.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XAttribute"&gt;&lt;/xref&gt;</ph> that contains the first attribute of this element.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Gets the default <ph id="ph1">&lt;xref href="System.Xml.Linq.XNamespace"&gt;&lt;/xref&gt;</ph> of this <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Namespace declarations may be persisted as attributes in the XML tree.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>These special attributes declare namespaces, including default namespaces.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method finds the namespace declaration that declares the default namespace, if there is one, and returns the <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> for the default namespace.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no attribute that declares the default namespace, then this method returns <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>When creating XML trees using C#, even if an XML tree would be serialized with a default namespace, if the namespace is not persisted in the XML tree as an attribute, this method will not report the namespace as the default namespace.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>When creating XML trees using Visual Basic and XML literals, if you create the XML in a default namespace using the Imports statement, then a namespace attribute will be created in the tree by the Visual Basic compiler, and this method will report that namespace.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XNamespace"&gt;&lt;/xref&gt;</ph> that contains the default namespace of this <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Gets the namespace associated with a particular prefix for this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method looks through the XML tree for namespace attributes that are in scope for this element.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Namespace prefixes are specified in namespace attributes that are in the XML tree.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>A string that contains the namespace prefix to look up.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XNamespace"&gt;&lt;/xref&gt;</ph> for the namespace associated with the prefix for this <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Gets the prefix associated with a namespace for this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method looks through the XML tree for namespace attributes that are in scope for this element.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Namespace prefixes are specified in namespace attributes that are in the XML tree.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the namespace is the default namespace, and there is no prefix for the namespace, then this method returns null.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XNamespace"&gt;&lt;/xref&gt;</ph> to look up.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains the namespace prefix.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether this element has at least one attribute.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this element has at least one attribute; otherwise <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether this element has at least one child element.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this element has at least one child element; otherwise <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether this element contains no content.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that an element that contains a start and end tag with no content between the tags is not considered to be an empty element.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has content with no length.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only an element that contains only a start tag, and is expressed as a terminated empty element, is considered to be empty.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this element contains no content; otherwise <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Gets the last attribute of this element.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attributes are stored in the element in the order that they were added to the element.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XAttribute"&gt;&lt;/xref&gt;</ph> that contains the last attribute of this element.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Loads an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from a <ph id="ph2">&lt;xref href="System.IO.TextReader"&gt;&lt;/xref&gt;</ph>, optionally preserving white space and retaining line information.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to read all white space in the source XML.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nodes of type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> are created for both significant and insignificant white space.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is indented, not setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to ignore all of the insignificant white space in the source XML.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML tree is created without any text nodes for insignificant white space.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is not indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> has no effect.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a string that contains XML.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> will have no effect when loading from a <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The line information is accurate immediately after loading the XML document.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you modify the XML tree after loading the document, the line information may become meaningless.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.IO.TextReader"&gt;&lt;/xref&gt;</ph> that will be read for the <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> content.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.LoadOptions"&gt;&lt;/xref&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;xref href="System.IO.TextReader"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Loads an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from an <ph id="ph2">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph>, optionally preserving white space, setting the base URI, and retaining line information.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>By creating an <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> from a DOM document, and then using the <ph id="ph2">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> to create an <ph id="ph3">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a string that contains XML.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> is not valid when loading from a <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> will be configured to either read whitespace or not.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>The LINQ to XML tree will be populated with the whitespace nodes that the reader surfaces.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will be the behavior regardless of whether <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> is set or not.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> may have a valid base URI or not.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you set <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph>, the base URI will be set in the XML tree from the base URI that is reported by the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> may have a valid line information or not.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you set <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph>, the line information will be set in the XML tree from the line information that is reported by the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>The line information is accurate immediately after loading the XML document.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you modify the XML tree after loading the document, the line information may become meaningless.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> that will be read for the content of the <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.LoadOptions"&gt;&lt;/xref&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Loads an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from a file, optionally preserving white space, setting the base URI, and retaining line information.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to read all white space in the source XML.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nodes of type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> are created for both significant and insignificant white space.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is indented, not setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to ignore all of the insignificant white space in the source XML.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML tree is created without any text nodes for insignificant white space.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is not indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> has no effect.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a string that contains XML.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flags.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>The base URI and the line information are accurate immediately after loading the XML document.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you modify the XML tree after loading the document, the base URI and line information may become meaningless.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A URI string referencing the file to load into an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.LoadOptions"&gt;&lt;/xref&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contains the contents of the specified file.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Creates a new <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> instance by using the specified stream, optionally preserving white space, setting the base URI, and retaining line information.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have to modify <ph id="ph1">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph>, following these steps:</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by calling one of the <ph id="ph2">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> overloads that take <ph id="ph3">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> to one of the <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>'s <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> overloads that takes <ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The stream containing the XML data.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.LoadOptions"&gt;&lt;/xref&gt;</ph> object that specifies whether to load base URI and line information.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> object used to read the data that the stream contains.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Loads an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from a <ph id="ph2">&lt;xref href="System.IO.TextReader"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method reads the raw XML into the XML tree.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>It discards all insignificant white space in the file.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.IO.TextReader"&gt;&lt;/xref&gt;</ph> that will be read for the <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> content.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;xref href="System.IO.TextReader"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Loads an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from a file.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method reads the raw XML into the XML tree.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>It discards all insignificant white space in the file.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>A URI string referencing the file to load into a new <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contains the contents of the specified file.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Creates a new <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> instance by using the specified stream.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to control load options, use the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> overload that takes <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have to modify <ph id="ph1">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph>, following these steps:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by calling one of the <ph id="ph2">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> overloads that take <ph id="ph3">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> to one of the <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>'s <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> overloads that takes <ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The stream that contains the XML data.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> object used to read the data that is contained in the stream.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Loads an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from an <ph id="ph2">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>By creating an <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> from a DOM document, and then using the <ph id="ph2">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> to create an <ph id="ph3">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> that will be read for the content of the <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of this element.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting this property will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> that contains the name of this element.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Gets the node type for this node.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because all classes that derive from <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> contain a <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.NodeType%2A&gt;</ph> property, you can write code that operates on collections of concrete subclass of <ph id="ph3">&lt;xref:System.Xml.Linq.XObject&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code can then test for the node type of each node in the collection.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The node type.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> objects, this value is <ph id="ph2">&lt;xref href="System.Xml.XmlNodeType.Element"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Load an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from a string that contains XML.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not preserve white space.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to preserve white space in the XML tree, use the overload of the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> method that takes <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains XML.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> populated from the string that contains XML.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Load an <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> from a string that contains XML, optionally preserving white space and retaining line information.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to read all white space in the source XML.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nodes of type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> are created for both significant and insignificant white space.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is indented, not setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to ignore all of the insignificant white space in the source XML.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The XML tree is created without any text nodes for insignificant white space.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the source XML is not indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> has no effect.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> will have no effect when parsing from a <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> may have a valid line information or not.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you set <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph>, the line information will be set in the XML tree from the line information that is reported by the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>The line information is accurate immediately after loading the XML document.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you modify the XML tree after loading the document, the line information may become meaningless.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains XML.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.LoadOptions"&gt;&lt;/xref&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> populated from the string that contains XML.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Removes nodes and attributes from this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Removes the attributes of this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Replaces the child nodes and the attributes of this element with the specified content.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method first removes existing content and attributes.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses snapshot semantics—that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that you can query the contents of the current element and use the results of the query as the specified new content.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The content that will replace the child nodes and attributes of this element.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Replaces the child nodes and the attributes of this element with the specified content.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method first removes existing content and attributes.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses snapshot semantics—that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that you can query the contents of the current element and use the results of the query as the specified new content.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>A parameter list of content objects.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Replaces the attributes of this element with the specified content.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method first removes existing attributes.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>A parameter list of content objects.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Replaces the attributes of this element with the specified content.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method first removes existing attributes.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>The content that will replace the attributes of this element.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Outputs this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> to the specified <ph id="ph2">&lt;xref href="System.IO.Stream"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The serialized XML will be indented.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of this method is that insignificant white space will not be preserved.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to control white space, use the overload of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> that takes <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> option to save unindented XML.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will cause the writer to write all white spaces exactly as represented in the XML tree.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces&gt;</ph> option if you want to remove duplicate namespace declarations.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>The stream to output this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> to.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Serialize this element to a <ph id="ph1">&lt;xref href="System.IO.TextWriter"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>The serialized XML will be indented.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of this method is that white space will not be preserved.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to control white space, use the overload of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> that allows you to specify <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.IO.TextWriter"&gt;&lt;/xref&gt;</ph> that the <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> will be written to.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Serialize this element to a file.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>The serialized XML will be indented.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to control white space, use the overload of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> that allows you to specify <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains the name of the file.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Serialize this element to an <ph id="ph1">&lt;xref href="System.Xml.XmlWriter"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.XmlWriter"&gt;&lt;/xref&gt;</ph> that the <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> will be written to.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Outputs this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> to the specified <ph id="ph2">&lt;xref href="System.IO.Stream"&gt;&lt;/xref&gt;</ph>, optionally specifying formatting behavior.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default the <ph id="ph1">`options`</ph> are set to <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions.None&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to save unindented XML, specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will cause the writer to write all white spaces exactly as represented in the XML tree.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces&gt;</ph> option if you want to remove duplicate namespace declarations.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The stream to output this <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> to.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.SaveOptions"&gt;&lt;/xref&gt;</ph> object that specifies formatting behavior.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Serialize this element to a <ph id="ph1">&lt;xref href="System.IO.TextWriter"&gt;&lt;/xref&gt;</ph>, optionally disabling formatting.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to save unindented XML, specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will cause the writer to write all white space exactly as represented in the XML tree.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to save indented XML, do not specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the default behavior, and the behavior of the overloads of the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> methods that do not take <ph id="ph2">`options`</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.IO.TextWriter"&gt;&lt;/xref&gt;</ph> to output the XML to.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.SaveOptions"&gt;&lt;/xref&gt;</ph> that specifies formatting behavior.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>Serialize this element to a file, optionally disabling formatting.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to save unindented XML, specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will cause the writer to write all white space exactly as represented in the XML tree.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to save indented XML, do not specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the default behavior, and the behavior of the overloads of the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> methods that do not take <ph id="ph2">`options`</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains the name of the file.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.SaveOptions"&gt;&lt;/xref&gt;</ph> that specifies formatting behavior.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Sets the value of an attribute, adds an attribute, or removes an attribute.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is designed to make it easy to maintain a list of name/value pairs as a set of attributes.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>When maintaining the list, you need to add pairs, modify pairs, or delete pairs.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call this method passing a name that does not exist as an attribute, this method creates an attribute for you.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call this method passing the name of an existing attribute, this method modifies the value of the attribute to the value that you specify.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you pass <ph id="ph1">`null`</ph> for <ph id="ph2">`value`</ph>, this method removes the attribute.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is assigned to the attribute with the specified name.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no attribute with the specified name exists, a new attribute is added.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is <ph id="ph1">`null`</ph>, the attribute with the specified name, if any, is deleted.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Maintaining Name/Value Pairs<ept id="p1">](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)</ept>.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> that contains the name of the attribute to change.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>The value to assign to the attribute.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>The attribute is removed if the value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Otherwise, the value is converted to its string representation and assigned to the <ph id="ph1">&lt;xref href="System.Xml.Linq.XAttribute.Value"&gt;&lt;/xref&gt;</ph> property of the attribute.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is an instance of <ph id="ph2">&lt;xref href="System.Xml.Linq.XObject"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Sets the value of a child element, adds a child element, or removes a child element.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is designed to make it easy to maintain a list of name/value pairs as a set of children elements.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>When maintaining the list, you need to add pairs, modify pairs, or delete pairs.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call this method passing a name that does not exist as a child element, this method creates a child element for you.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call this method passing the name of an existing child element, this method modifies the value of the child element to the value that you specify.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you pass <ph id="ph1">`null`</ph> for <ph id="ph2">`value`</ph>, this method removes the child element.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise events.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is assigned to the first child element with the specified name.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no child element with the specified name exists, a new child element is added.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is null, the first child element with the specified name, if any, is deleted.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not add child nodes or attributes to the specified child element.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method throws an exception if any object that derives from <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> is passed as <ph id="ph2">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Maintaining Name/Value Pairs<ept id="p1">](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)</ept>.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> that contains the name of the child element to change.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The value to assign to the child element.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>The child element is removed if the value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Otherwise, the value is converted to its string representation and assigned to the <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement.Value"&gt;&lt;/xref&gt;</ph> property of the child element.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is an instance of <ph id="ph2">&lt;xref href="System.Xml.Linq.XObject"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Sets the value of this element.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is invalid to pass an instance of a class that derives from <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>, such as <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The value to assign to this element.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The value is converted to its string representation and assigned to the <ph id="ph1">&lt;xref href="System.Xml.Linq.XElement.Value"&gt;&lt;/xref&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is an <ph id="ph2">&lt;xref href="System.Xml.Linq.XObject"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Gets or sets the concatenated text contents of this element.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this property, you can get or set the value of an element.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting this property will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to get the value of an element but you are not sure that it exists, it is more convenient to use the explicit conversion operators, and assign the element to a nullable type such as <ph id="ph1">`string`</ph> or <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph3">&lt;xref:System.Int32&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the element does not exist, the nullable type is set to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, if you want to use this property, you must make sure that the <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer.Element%2A&gt;</ph> method does not return <ph id="ph2">`null`</ph> before you access this property.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains all of the text content of this element.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>If there are multiple text nodes, they will be concatenated.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Write this element to an <ph id="ph1">&lt;xref href="System.Xml.XmlWriter"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.XmlWriter"&gt;&lt;/xref&gt;</ph> into which this method will write.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Gets an XML schema definition that describes the XML representation of this object.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is part of implementation of the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used internally for serializing object graphs that contain LINQ to XML objects.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example of serializing an object graph that contains LINQ to XML objects, see <bpt id="p1">[</bpt>Serializing Object Graphs that Contain XElement Objects<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Schema.XmlSchema"&gt;&lt;/xref&gt;</ph> that describes the XML representation of the object that is produced by the <ph id="ph2">&lt;xref href="System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)"&gt;&lt;/xref&gt;</ph> method and consumed by the <ph id="ph3">&lt;xref href="System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Generates an object from its XML representation.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is part of implementation of the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used internally for serializing object graphs that contain LINQ to XML objects.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example of serializing an object graph that contains LINQ to XML objects, see <bpt id="p1">[</bpt>Serializing Object Graphs that Contain XElement Objects<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> from which the object is deserialized.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Converts an object into its XML representation.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used internally for marshaling object graphs that contain LINQ to XML objects.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example of serializing an object graph that contains LINQ to XML objects, see <bpt id="p1">[</bpt>Serializing Object Graphs that Contain XElement Objects<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.XmlWriter"&gt;&lt;/xref&gt;</ph> to which this object is serialized.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>