<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4f81a007885b51eb87210527d941cf453d667521</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Array.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e3628c6a7774a77590a677f4e5e5c3e784352abe</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">af81609e5a54e3f86d486ead0a8056efd6350945</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/array.cs#156e066ecc4ccedf)</ept>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is not part of the <ph id="ph2">&lt;xref:System.Collections&gt;</ph> namespaces.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is still considered a collection because it is based on the <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is the base class for language implementations that support arrays.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Users should employ the array constructs provided by the language.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>An element is a value in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the total number of elements it can contain.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The lower bound of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the index of its first element.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound, but it has a lower bound of zero by default.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>A different lower bound can be defined when creating an instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class using <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>.A multidimensional <ph id="ph3">&lt;xref:System.Array&gt;</ph> can have different bounds for each dimension.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>An array can have a maximum of 32 dimensions.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike the classes in the <ph id="ph1">&lt;xref:System.Collections&gt;</ph> namespaces, <ph id="ph2">&lt;xref:System.Array&gt;</ph> has a fixed capacity.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase the capacity, you must create a new <ph id="ph1">&lt;xref:System.Array&gt;</ph> object with the required capacity, copy the elements from the old <ph id="ph2">&lt;xref:System.Array&gt;</ph> object to the new one, and delete the old <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the maximum size of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is 2 gigabytes (GB).</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a 64-bit environment, you can avoid the size restriction by setting the <ph id="ph1">`enabled`</ph> attribute of the <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Single-dimensional arrays implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=fullName&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=fullName&gt;</ph> generic interfaces.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects provide information about array type declarations.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> objects with the same array type share the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=fullName&gt;</ph> might not return the expected results with <ph id="ph3">&lt;xref:System.Array&gt;</ph> because if an array is cast to the type <ph id="ph4">&lt;xref:System.Array&gt;</ph>, the result is an object, not an array.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, <ph id="ph1">`typeof(System.Array).IsArray`</ph> returns <ph id="ph2">`false`</ph>, and <ph id="ph3">`typeof(System.Array).GetElementType`</ph> returns <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=fullName&gt;</ph> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some methods, such as <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> return 64-bit integers indicating the length of the array.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not guaranteed to be sorted.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Array&gt;</ph> prior to performing operations (such as <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to be sorted.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using an <ph id="ph1">&lt;xref:System.Array&gt;</ph> object of pointers in native code is not supported and will throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> for several methods.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Returns a read-only wrapper for the specified array.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>To prevent any modifications to the array, expose the array only through this wrapper.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based array to wrap in a read-only <ph id="ph1">&lt;xref href="System.Collections.ObjectModel.ReadOnlyCollection`1"&gt;&lt;/xref&gt;</ph> wrapper.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A read-only <ph id="ph1">&lt;xref href="System.Collections.ObjectModel.ReadOnlyCollection`1"&gt;&lt;/xref&gt;</ph> wrapper for the specified array.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface implemented by each element of the array and by the specified object.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>If<ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> does not implement the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer customizes how the elements are compared.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>If<ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph> does not implement the <ph id="ph4">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface implemented by each element of the array and by the specified value.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The starting index of the range to search.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The length of the range to search.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> does not implement the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer customizes how the elements are compared.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The starting index of the range to search.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The length of the range to search.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph> does not implement the <ph id="ph4">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> and by the specified object.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`array`</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> does not implement the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer customizes how the elements are compared.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided by <ph id="ph4">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> before the search begins.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;T&lt;/code&gt;</ph> does not implement the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> and by the specified value.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The starting index of the range to search.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The length of the range to search.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> does not implement the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not support searching arrays that contain negative indexes.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer customizes how the elements are compared.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided for type <ph id="ph4">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicate elements are allowed.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>The starting index of the range to search.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The length of the range to search.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>The index of the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the specified <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found; otherwise, a negative number.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is less than one or more elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of the index of the first element that is larger than <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not found and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is greater than all elements in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>If this method is called with a non-sorted <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>, the return value can be incorrect and a negative number could be returned, even if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is present in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;T&lt;/code&gt;</ph> does not implement the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Sets a range of elements in an array to the default value of each element type.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method resets each element in an array to the element type's default value.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>It sets elements of reference types (including <ph id="ph1">&lt;xref:System.String&gt;</ph> elements) to <ph id="ph2">`null`</ph>, and sets elements of value types to the default values shown in the following table.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>All integral and floating point numeric types</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>0 (zero)</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>Other value types</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default value of the type's fields</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The range of cleared elements wrap from row to row in a multi-dimensional array.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method only clears the values of the elements; it does not delete the elements themselves.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>An array has a fixed size; therefore, elements cannot be added or removed.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The array whose elements need to be cleared.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The starting index of the range of elements to clear.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The number of elements to clear.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">length</ph><ept id="p2">&lt;/code&gt;</ept> is greater than the size of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies only the elements of the <ph id="ph2">&lt;xref:System.Array&gt;</ph>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>The references in the new <ph id="ph1">&lt;xref:System.Array&gt;</ph> point to the same objects that the references in the original <ph id="ph2">&lt;xref:System.Array&gt;</ph> point to.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>The clone is of the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> as the original <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>A shallow copy of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Copies a range of elements from an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the specified destination index.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Guarantees that all changes are undone if the copy does not succeed completely.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`sourceArray`</ph> type must be the same as or derived from the <ph id="ph2">`destinationArray`</ph> type; otherwise, an <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> verifies the compatibility of the array types before performing any operation.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>[C++]</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method throws an exception while copying, the <ph id="ph1">`destinationArray`</ph> remains unchanged; therefore, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> can be used within a constrained execution region (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the data to copy.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that receives the data.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">destinationArray</ph><ept id="p1">&lt;/code&gt;</ept> at which storing begins.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> have different ranks.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> type is neither the same as nor derived from the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">destinationArray</ph><ept id="p2">&lt;/code&gt;</ept> type.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>At least one element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> cannot be cast to the type of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">destinationArray</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceIndex&lt;/code&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;code&gt;sourceIndex&lt;/code&gt;</ph> to the end of <ph id="ph3">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> to the end of <ph id="ph3">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>Converts an array of one type to an array of another type.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, and the converted elements are saved in the new array.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>The source <ph id="ph1">`array`</ph> remains unchanged.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to convert to a target type.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Converter`2"&gt;&lt;/xref&gt;</ph> that converts each element from one type to another type.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>The type of the elements of the source array.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>The type of the elements of the target array.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>An array of the target type containing the converted elements from the source array.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;converter&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Copies a range of elements from an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the specified destination index.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The length and the indexes are specified as 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>[C++]</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type downcasting is performed, as required.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph>containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type compatibility is defined as follows:</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type is compatible with itself.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disconnected types are not compatible.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the data to copy.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that receives the data.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">destinationArray</ph><ept id="p1">&lt;/code&gt;</ept> at which storing begins.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>The integer must be between zero and <ph id="ph1">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph>, inclusive.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> have different ranks.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>At least one element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> cannot be cast to the type of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">destinationArray</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceIndex&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;code&gt;sourceIndex&lt;/code&gt;</ph> to the end of <ph id="ph3">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> to the end of <ph id="ph3">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>Copies a range of elements from an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the specified destination index.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The length and the indexes are specified as 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>[C++]</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type downcasting is performed, as required.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type compatibility is defined as follows:</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type is compatible with itself.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disconnected types are not compatible.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the data to copy.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that receives the data.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">destinationArray</ph><ept id="p1">&lt;/code&gt;</ept> at which storing begins.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> have different ranks.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>At least one element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> cannot be cast to the type of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">destinationArray</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceIndex&lt;/code&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;code&gt;sourceIndex&lt;/code&gt;</ph> to the end of <ph id="ph3">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;code&gt;destinationIndex&lt;/code&gt;</ph> to the end of <ph id="ph3">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>Copies a range of elements from an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the first element.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The length is specified as a 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>[C++]</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type downcasting is performed, as required.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type compatibility is defined as follows:</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type is compatible with itself.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disconnected types are not compatible.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the data to copy.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that receives the data.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>The integer must be between zero and <ph id="ph1">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph>, inclusive.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> have different ranks.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>At least one element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> cannot be cast to the type of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">destinationArray</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Copies a range of elements from an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> starting at the first element.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>The length is specified as a 32-bit integer.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>[C++]</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type downcasting is performed, as required.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type compatibility is defined as follows:</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type is compatible with itself.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disconnected types are not compatible.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the data to copy.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that receives the data.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;destinationArray&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> have different ranks.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;sourceArray&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph> are of incompatible types.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>At least one element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">sourceArray</ph><ept id="p1">&lt;/code&gt;</ept> cannot be cast to the type of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">destinationArray</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;code&gt;sourceArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;code&gt;destinationArray&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The index is specified as a 32-bit integer.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the method throws an exception.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=fullName&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=fullName&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the index in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>The number of elements in the source array is greater than the available number of elements from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index</ph><ept id="p1">&lt;/code&gt;</ept> to the end of the destination <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>The type of the source <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> cannot be cast automatically to the type of the destination <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>The source array is multidimensional.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>At least one element in the source <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> cannot be cast to the type of destination <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>The index is specified as a 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the method throws an exception.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=fullName&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=fullName&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the index in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>The number of elements in the source array is greater than the available number of elements from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index</ph><ept id="p1">&lt;/code&gt;</ept> to the end of the destination <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>The type of the source <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> cannot be cast automatically to the type of the destination <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>The source <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>At least one element in the source <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> cannot be cast to the type of destination <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>Creates a one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> and length, with zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value-type elements are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>The size of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>A new one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified length, using zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>Creates a multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> and dimension lengths, with zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>The dimension lengths are specified in an array of 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value-type elements are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>An array of 32-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>A new multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;lengths&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lengths</ph><ept id="p1">&lt;/code&gt;</ept> array contains less than one element.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Any value in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lengths</ph><ept id="p1">&lt;/code&gt;</ept> is less than zero.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>Creates a multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> and dimension lengths, with zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>The dimension lengths are specified in an array of 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value-type elements are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>An array of 64-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>Each integer in the array must be between zero and <ph id="ph1">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph>, inclusive.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>A new multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;lengths&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lengths</ph><ept id="p1">&lt;/code&gt;</ept> array contains less than one element.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>Any value in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lengths</ph><ept id="p1">&lt;/code&gt;</ept> is less than zero or greater than <ph id="ph2">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>Creates a two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> and dimension lengths, with zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the<ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value-type elements are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph> and <ph id="ph4">`length2`</ph>.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The size of the first dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The size of the second dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>A new two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length1&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length2&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>Creates a multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> and dimension lengths, with the specified lower bounds.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`lengths`</ph> and <ph id="ph2">`lowerBounds`</ph> arrays must have the same number of elements.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of the <ph id="ph1">`lowerBounds`</ph> array must specify the lower bound of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value-type elements are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>A one-dimensional array that contains the size of each dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>A one-dimensional array that contains the lower bound (starting index) of each dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>A new multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified length and lower bound for each dimension.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;lengths&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;lowerBounds&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lengths</ph><ept id="p1">&lt;/code&gt;</ept> array contains less than one element.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lengths</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">lowerBounds</ph><ept id="p2">&lt;/code&gt;</ept> arrays do not contain the same number of elements.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>Any value in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lengths</ph><ept id="p1">&lt;/code&gt;</ept> is less than zero.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>Any value in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">lowerBounds</ph><ept id="p1">&lt;/code&gt;</ept> is very large, such that the sum of a dimension's lower bound and length is greater than <ph id="ph2">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>Creates a three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> and dimension lengths, with zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value-type elements are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, and <ph id="ph5">`length3`</ph>.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>The size of the first dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>The size of the second dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>The size of the third dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to create.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>A new three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> is not supported.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;elementType&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length1&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length2&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length3&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>Returns an empty array.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>Returns an empty <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when a match is found.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate explicitly.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the elements to search for.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method or a lambda expression that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate or lambda expression.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, starting with the first element and ending with the last element.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>Processing is stopped when a match is found.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based array to search.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>The predicate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">T</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and the elements that match the conditions are saved in the returned array.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the elements to search for.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, -1.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that extends from the specified index to the last element.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, -1.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, -1.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, moving backward in the <ph id="ph3">&lt;xref:System.Array&gt;</ph>, starting with the last element and ending with the first element.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>Processing is stopped when a match is found.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">T</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that extends from the first element to the specified index.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>Performs the specified action on each element of the specified array.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> on whose elements the action is to be performed.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Action`1"&gt;&lt;/xref&gt;</ph> to perform on each element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;action&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>Returns an <ph id="ph1">&lt;xref href="System.Collections.IEnumerator"&gt;&lt;/xref&gt;</ph> for the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>[Visual Basic, C#]</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.IEnumerator"&gt;&lt;/xref&gt;</ph> for the <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> is <ph id="ph2">`GetLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>A zero-based dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> whose length needs to be determined.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the number of elements in the specified dimension.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is equal to or greater than <ph id="ph2">&lt;xref href="System.Array.Rank"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> is <ph id="ph2">`GetLongLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>A zero-based dimension of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> whose length needs to be determined.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the number of elements in the specified dimension.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is equal to or greater than <ph id="ph2">&lt;xref href="System.Array.Rank"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>Gets the index of the first element of the specified dimension in the array.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetLowerBound(0)`</ph> returns the starting index of the first dimension of the array, and <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> returns the starting index of the last dimension of the array.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that, although most arrays in the .NET Framework are zero-based (that is, the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such arrays can be created with the <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> method, and can also be returned from unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>A zero-based dimension of the array whose starting index needs to be determined.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>The index of the first element of the specified dimension in the array.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is equal to or greater than <ph id="ph2">&lt;xref href="System.Array.Rank"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>Gets the index of the last element of the specified dimension in the array.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetUpperBound(0)`</ph> returns the last index in the first dimension of the array, and <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> returns the last index of the last dimension of the array.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>A zero-based dimension of the array whose upper bound needs to be determined.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;dimension&lt;/code&gt;</ph> is equal to or greater than <ph id="ph2">&lt;xref href="System.Array.Rank"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly three dimensions.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index1&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;index2&lt;/code&gt;</ph> or <ph id="ph3">&lt;code&gt;index3&lt;/code&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly three dimensions.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index1&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;index2&lt;/code&gt;</ph> or <ph id="ph3">&lt;code&gt;index3&lt;/code&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly two dimensions.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index1</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">index2</ph><ept id="p2">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly two dimensions.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index1</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">index2</ph><ept id="p2">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>The index is specified as a 32-bit integer.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly one dimension.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>The index is specified as a 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly one dimension.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>The indexes are specified as an array of 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indices&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is not equal to the number of elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">indices</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>Any element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">indices</ph><ept id="p1">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>The indexes are specified as an array of 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to get.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indices&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is not equal to the number of elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">indices</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>Any element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">indices</ph><ept id="p1">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method searches all the elements of a one-dimensional arrayfor <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling each element's <ph id="ph3">`Equals`</ph> method until it finds a match.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method, that override is called.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if<ph id="ph1">`value`</ph> isn’t found.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=fullName&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph> (0x7FFFFFFF).</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to search.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>The index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if found; otherwise, the lower bound of the array minus 1.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve">
          <source>The range extends from a specified index to the end of the array.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method searches a one-dimensional array from the element at index <ph id="ph1">`startIndex`</ph> to the last element.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method, that override is called.</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if <ph id="ph1">`value`</ph> isn’t found.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=fullName&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph> (0x7FFFFFFF).</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph>,the method returns -1.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to search.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve">
          <source>The starting index of the search.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve">
          <source>0 (zero) is valid in an empty array.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve">
          <source>The index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>, if it’s found, within the range of elements in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> that extends from <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p3">&lt;/code&gt;</ept> to the last element; otherwise, the lower bound of the array minus 1.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>The range extends from a specified index for a specified number of elements.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method searches the elements of a one-dimensional arrayfrom <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method, that override is called.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Becausemost arrays have a lower bound of zero, this method generally returns –1 when <ph id="ph1">`value`</ph> isn’t found.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=fullName&gt;</ph> (0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph> (0x7FFFFFFF).</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startindex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph>, the method returns -1.</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to search.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve">
          <source>The starting index of the search.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve">
          <source>0 (zero) is valid in an empty array.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve">
          <source>The number of elements to search.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve">
          <source>The index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>, if it’s found in the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> from index <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p3">&lt;/code&gt;</ept> to <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">startIndex</ph><ept id="p4">&lt;/code&gt;</ept><ph id="ph5"> + </ph><bpt id="p5">&lt;code&gt;</bpt><ph id="ph6">count</ph><ept id="p5">&lt;/code&gt;</ept> - 1; otherwise, the lower bound of the array minus 1.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve">
          <source>The range extends from a specified index for a specified number of elements.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method searchesthe elements of a one-dimensional array from <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph>, the method returns -1.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based array to search.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve">
          <source>0 (zero) is valid in an empty array.</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> that starts at <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p3">&lt;/code&gt;</ept> and contains the number of elements specified in <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">count</ph><ept id="p4">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method searches all the elements of a one-dimensional array for <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based array to search.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in the entire <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve">
          <source>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve">
          <source>The range extends from a specified index to the end of the array.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method searches a one-dimensional array from the element at <ph id="ph1">`startIndex`</ph> to the end of the array.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>,the method returns -1.If <ph id="ph3">`startIndex`</ph> is greater than <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph>, the method throws an <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based array to search.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve">
          <source>0 (zero) is valid in an empty array.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> that extends from <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p3">&lt;/code&gt;</ept> to the last element, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve">
          <source>Initializes every element of the value-type <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> by calling the default constructor of the value type.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is designed to help compilers support value-type arrays; most users do not need this method.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT">
          <source>It must not be used on reference-type arrays.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not a value-type <ph id="ph2">&lt;xref:System.Array&gt;</ph> or if the value type does not have a default constructor, the <ph id="ph3">&lt;xref:System.Array&gt;</ph> is not modified.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value-type <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound and any number of dimensions.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=fullName&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT">
          <source>An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve">
          <source>This property is always <ph id="ph1">`true`</ph> for all arrays.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=fullName&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT">
          <source>An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you require a read-only collection, use a <ph id="ph1">&lt;xref:System.Collections&gt;</ph> class that implements the <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=fullName&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you cast or convert an array to an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface object, the <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=fullName&gt;</ph> property returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if you cast or convert an array to a <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interface, the <ph id="ph2">`IsReadOnly`</ph> property returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve">
          <source>This property is always <ph id="ph1">`false`</ph> for all arrays.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is synchronized (thread safe).</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=fullName&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve">
          <source>This property is always <ph id="ph1">`false`</ph> for all arrays.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=fullName&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph2">`item`</ph> parameter on the objects in the collection.</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the entire <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if found; otherwise, the lower bound of the array minus 1.</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that extends from the first element to the specified index.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=fullName&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>The starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> that extends from the first element to <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p3">&lt;/code&gt;</ept>, if found; otherwise, the lower bound of the array minus 1.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the element type is a nonintrinsic (user-defined) type, the<ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=fullName&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve">
          <source>The starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> that contains the number of elements specified in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">count</ph><ept id="p3">&lt;/code&gt;</ept> and ends at <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">startIndex</ph><ept id="p4">&lt;/code&gt;</ept>, if found; otherwise, the lower bound of the array minus 1.</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the entire <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that extends from the first element to the specified index.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> that extends from the first element to <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">startIndex</ph><ept id="p3">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to search.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve">
          <source>The object to locate in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p2">&lt;/code&gt;</ept> that contains the number of elements specified in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">count</ph><ept id="p3">&lt;/code&gt;</ept> and ends at <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">startIndex</ph><ept id="p4">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve">
          <source>Gets the total number of elements in all the dimensions of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve">
          <source>The total number of elements in all the dimensions of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>; zero if there are no elements in the array.</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve">
          <source>The array is multidimensional and contains more than <ph id="ph1">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph> elements.</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve">
          <source>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve">
          <source>Gets the rank (number of dimensions) of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve">
          <source>For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the Visual Basic code</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT">
          <source>and the C# code</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT">
          <source>create an array of three dimensions with a <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property whose value is 3.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT">
          <source>A jagged array (an array of arrays) is a one-dimensional array; the value of its <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property is 1.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve">
          <source>The rank (number of dimensions) of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve">
          <source>Changes the number of elements of a one-dimensional array to the specified new size.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.<ph id="ph1">`array`</ph></source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT">
          <source>must be a one-dimensional array.</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`array`</ph> is <ph id="ph2">`null`</ph>, this method creates a new array with the specified size.</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`newSize`</ph> is greater than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`newSize`</ph> is less than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`newSize`</ph> is equal to the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, this method does nothing.</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`newSize`</ph>.</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> method resizes a one-dimensional array only.</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class does not include a method for resizing multi-dimensional arrays.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, you must either provide your own code or call a special-purpose method in a third-party library.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code illustrates one possible implementation for a method that resizes an array of <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> dimensions.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Array.Resize#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Array.Resize#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based array to resize, or <ph id="ph1">`null`</ph> to create a new array with the specified size.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve">
          <source>The size of the new array.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;newSize&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve">
          <source>Reverses the sequence of the elements in a range of elements in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to reverse.</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve">
          <source>The starting index of the section to reverse.</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to reverse.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve">
          <source>Reverses the sequence of the elements in the entire one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the following example shows, the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT">
          <source>It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element contains an array with as many elements as that month has days.</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example displays the contents of the array, calls the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method, and then displays the contents of the reversed array.</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Array.Reverse#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Array.Reverse#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to reverse.</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve">
          <source>The index is specified as a 32-bit integer.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly one dimension.</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve">
          <source>The indexes are specified as an array of 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indices&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is not equal to the number of elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">indices</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve">
          <source>Any element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">indices</ph><ept id="p1">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve">
          <source>The index is specified as a 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly one dimension.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve">
          <source>The indexes are specified as an array of 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;indices&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is not equal to the number of elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">indices</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve">
          <source>Any element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">indices</ph><ept id="p1">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly two dimensions.</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index1</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">index2</ph><ept id="p2">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly two dimensions.</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve">
          <source>Either <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index1</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">index2</ph><ept id="p2">&lt;/code&gt;</ept> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly three dimensions.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index1&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;index2&lt;/code&gt;</ph> or <ph id="ph3">&lt;code&gt;index3&lt;/code&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve">
          <source>The indexes are specified as 64-bit integers.</source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve">
          <source>The new value for the specified element.</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> element to set.</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly three dimensions.</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index1&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;index2&lt;/code&gt;</ph> or <ph id="ph3">&lt;code&gt;index3&lt;/code&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph2">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implementation</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort.</source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph> do not implement the <ph id="ph4">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph3">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implementation</source>
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example does this by defining a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
        </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to sort only the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">items</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;keys&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the lower bound of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;code&gt;items&lt;/code&gt;</ph><ph id="ph6">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element of the <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort.</source>
        </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve">
          <source>One or more elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> do not implement the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each key.</source>
        </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to sort only the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">items</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;keys&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;code&gt;items&lt;/code&gt;</ph><ph id="ph6">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve">
          <source>One or more elements in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve">
          <source>Sorts the elements in a one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph2">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
        </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implementation</source>
        </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
        </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
        </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
        </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to sort.</source>
        </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve">
          <source>The implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph> do not implement the <ph id="ph4">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph3">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
        </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implementation</source>
        </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
        </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
        </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example does this by defining an <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
        </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
        </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to sort only the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">items</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each key.</source>
        </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
        </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to sort only the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">items</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve">
          <source>One or more elements in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve">
          <source>Sorts the elements in an entire one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> implementation of each element of the <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an<bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort.</source>
        </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve">
          <source>One or more elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> do not implement the <ph id="ph2">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve">
          <source>Sorts the elements in an entire <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort.</source>
        </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve">
          <source>One or more elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> do not implement the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve">
          <source>Sorts the elements in an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph2">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-base <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort</source>
        </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">`null`</ph> to use the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph> do not implement the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve">
          <source>Sorts the elements in an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph2">&lt;xref href="System.Comparison`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort</source>
        </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Comparison`1"&gt;&lt;/xref&gt;</ph> to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparison&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparison</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparison</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort</source>
        </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve">
          <source>One or more elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> do not implement the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph2">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to sort.</source>
        </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">`null`</ph> to use the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in <ph id="ph3">&lt;code&gt;array&lt;/code&gt;</ph> do not implement the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve">
          <source>Sorts a pair of <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each key.</source>
        </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an<ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept>, or <ph id="ph3">`null`</ph> to sort only <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">keys</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve">
          <source>The type of the elements of the key array.</source>
        </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve">
          <source>The type of the elements of the items array.</source>
        </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the lower bound of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve">
          <source>One or more elements in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve">
          <source>Sorts a pair of <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph3">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept>, or <ph id="ph3">`null`</ph> to sort only <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">keys</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">`null`</ph> to use the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve">
          <source>The type of the elements of the key array.</source>
        </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve">
          <source>The type of the elements of the items array.</source>
        </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the lower bound of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph5">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each key.</source>
        </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept>, or <ph id="ph3">`null`</ph> to sort only <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">keys</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve">
          <source>The type of the elements of the key array.</source>
        </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve">
          <source>The type of the elements of the items array.</source>
        </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;keys&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the lower bound of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;code&gt;items&lt;/code&gt;</ph><ph id="ph6">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve">
          <source>One or more elements in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">keys</ph><ept id="p1">&lt;/code&gt;</ept><ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph3">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
        </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
        </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
        </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the sort is not successfully completed, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
        </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
        </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the keys to sort.</source>
        </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">keys</ph><ept id="p1">&lt;/code&gt;</ept>, or <ph id="ph3">`null`</ph> to sort only <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">keys</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve">
          <source>The starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to sort.</source>
        </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">`null`</ph> to use the <ph id="ph3">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface implementation of each element.</source>
        </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve">
          <source>The type of the elements of the key array.</source>
        </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve">
          <source>The type of the elements of the items array.</source>
        </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;keys&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;code&gt;keys&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;length&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the lower bound of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and the length of <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph> is greater than the length of <ph id="ph4">&lt;code&gt;items&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;items&lt;/code&gt;</ph> is not <ph id="ph2">`null`</ph>, and <ph id="ph3">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;code&gt;items&lt;/code&gt;</ph><ph id="ph6">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and one or more elements in the <ph id="ph3">&lt;code&gt;keys&lt;/code&gt;</ph><ph id="ph4">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> do not implement the <ph id="ph5">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property implements the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=fullName&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
        </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
        </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
        </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
        </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
        </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
        </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
        </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve">
          <source>Determines whether every element in the array matches the conditions defined by the specified predicate.</source>
        </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns<ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
        </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> to check against the conditions.</source>
        </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve">
          <source>The predicate that defines the conditions to check against the elements.</source>
        </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array.</source>
        </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if every element in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve">
          <source>If there are no elements in the array, the return value is <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve">
          <source>The number of elements contained in the collection.</source>
        </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve">
          <source>Calling this method always throws a <ph id="ph1">&lt;xref href="System.NotSupportedException"&gt;&lt;/xref&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, an <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=fullName&gt;</ph> implementation adds a member to a collection.</source>
        </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because arrays have a fixed size (the <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property always returns <ph id="ph2">`true`</ph>), this method always throws a <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve">
          <source>The object to be added to the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve">
          <source>Adding a value to an array is not supported.</source>
        </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve">
          <source>No value is returned.</source>
        </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve">
          <source>Removes all items from the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve">
          <source>Determines whether an element is in the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve">
          <source>The object to locate in the current list.</source>
        </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve">
          <source>The element to locate can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> is found in the <ph id="ph3">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve">
          <source>The object to locate in the current list.</source>
        </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve">
          <source>The index of value if found in the list; otherwise, -1.</source>
        </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve">
          <source>Inserts an item to the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> at the specified index.</source>
        </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve">
          <source>The index at which <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> should be inserted.</source>
        </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve">
          <source>The object to insert.</source>
        </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is not a valid index in the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is null reference in the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve">
          <source>Gets or sets the element at the specified index.</source>
        </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an<ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve">
          <source>The index of the element to get or set.</source>
        </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve">
          <source>The element at the specified index.</source>
        </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is equal to or greater than <ph id="ph2">&lt;xref href="System.Collections.ICollection.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> does not have exactly one dimension.</source>
        </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve">
          <source>The object to remove from the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve">
          <source>Removes the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> item at the specified index.</source>
        </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve">
          <source>The index of the element to remove.</source>
        </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve">
          <source>index is not a valid index in the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve">
          <source>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</source>
        </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve">
          <source>The object to compare with the current instance.</source>
        </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve">
          <source>An object that compares the current object and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve">
          <source>An integer that indicates the relationship of the current collection object to other, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve">
          <source>-1</source>
        </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve">
          <source>The current instance precedes <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve">
          <source>The current instance and <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph> are equal.</source>
        </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve">
          <source>The current instance follows <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve">
          <source>Determines whether an object is equal to the current instance.</source>
        </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an<ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>interface.</source>
        </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve">
          <source>The object to compare with the current instance.</source>
        </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve">
          <source>An object that determines whether the current instance and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept> are equal.</source>
        </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the two objects are equal; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current instance.</source>
        </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an<ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>interface.</source>
        </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve">
          <source>An object that computes the hash code of the current object.</source>
        </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve">
          <source>The hash code for the current instance.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>