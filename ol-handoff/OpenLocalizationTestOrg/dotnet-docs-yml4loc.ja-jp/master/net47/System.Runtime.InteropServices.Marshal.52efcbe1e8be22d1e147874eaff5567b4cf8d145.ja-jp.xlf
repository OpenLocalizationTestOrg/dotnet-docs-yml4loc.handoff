<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f2871338fc191f333a1628416882652e803977d6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Runtime.InteropServices.Marshal.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6f1e169b7d0e64f23eade84b04fb2f85b0bee9c3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">272e4c0400d37e8b59811b2e286d7e9febe9adc2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`static`</ph> methods defined on the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class are essential to working with unmanaged code.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also allocates the target heap of the right size.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime provides specific marshaling capabilities.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details on marshaling behavior, see <bpt id="p1">[</bpt>Interop Marshaling<ept id="p1">](~/docs/framework/interop/interop-marshaling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Read`</ph> and <ph id="ph2">`Write`</ph> methods in the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class support both aligned and unaligned access.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Increments the reference count on the specified interface.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>After calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, you must decrement the reference count by using a method such as <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not rely on the return value of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, as it can sometimes be unstable.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=fullName&gt;</ph> to obtain an <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> value that represents an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use these methods and the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are not familiar with the details of this wrapper type, see <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The interface reference count to increment.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The new value of the reference count on the <ph id="ph1">&lt;code&gt;pUnk&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Allocates a block of memory of specified size from the COM task memory allocator.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> is one of two memory allocation API methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=fullName&gt;</ph> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method exposes the COM <bpt id="p1">[</bpt>CoTaskMemAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148626)</ept> function, which is referred to as the COM task memory allocator.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The size of the block of memory to be allocated.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>An integer representing the address of the block of memory allocated.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This memory must be released with <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>There is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> is one of two memory allocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=fullName&gt;</ph> is the other.) This method exposes the Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148628)</ept> function from Kernel32.dll.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> calls <ph id="ph2">`LocalAlloc`</ph>, it passes a <ph id="ph3">`LMEM_FIXED`</ph> flag, which causes the allocated memory to be locked in place.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, the allocated memory is not zero-filled.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The required number of bytes in memory.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A pointer to the newly allocated memory.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This memory must be released using the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>There is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> is one of two memory allocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=fullName&gt;</ph> is the other.) This method exposes the Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148628)</ept> function from Kernel32.dll.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> calls <ph id="ph2">`LocalAlloc`</ph>, it passes a <ph id="ph3">`LMEM_FIXED`</ph> flag, which causes the allocated memory to be locked in place.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, the allocated memory is not zero-filled.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example code, see <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The required number of bytes in memory.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A pointer to the newly allocated memory.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This memory must be released using the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>There is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A&gt;</ph> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if there are any RCWs available for cleanup; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Gets an interface pointer identified by the specified moniker.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A&gt;</ph> exposes the COM <ph id="ph2">`BindToMoniker`</ph> method, which produces an object that you can cast to any COM interface you require.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the same functionality as the <ph id="ph1">`GetObject`</ph> method in Visual Basic 6.0 and <ph id="ph2">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The moniker corresponding to the desired interface pointer.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>An object containing a reference to the interface pointer identified by the <ph id="ph1">&lt;code&gt;monikerName&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A moniker is a name, and in this case, the moniker is defined by an interface.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>An unrecognized HRESULT was returned by the unmanaged <ph id="ph1">`BindToMoniker`</ph> method.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Changes the strength of an object's <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> (CCW) handle.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A&gt;</ph> is used for object pooling functionality and should never be called by user code directly.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The object whose CCW holds a reference counted handle.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to change the strength of the handle on the <ph id="ph2">&lt;code&gt;otp&lt;/code&gt;</ph> parameter to weak, regardless of its reference count; <ph id="ph3">`false`</ph> to reset the handle strength on <ph id="ph4">&lt;code&gt;otp&lt;/code&gt;</ph> to be reference counted.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Notifies the runtime to clean up all <bpt id="p1">[</bpt>Runtime Callable Wrappers<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCWs) allocated in the current context.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>The interop system pumps messages while it attempts to clean up RCWs.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures that cleanup for single-threaded apartment (STA) RCWs happens in all applications, including applications that do not pump often enough.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some applications that do pump appropriately are very sensitive to where pumping occurs.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the interop system pumps messages in these applications, in places that are unexpected, , the application can encounter reentrancy issues that are difficult to diagnose.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, applications need to be able to control their own pumping for a particular STA and to control the clean-up of RCWs.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, developers often only control a subset of the threads in their application and thus cannot ensure that all threads are pumping appropriately.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>To solve this problem:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=fullName&gt;</ph> method to turn off automatic cleanup of RCWs, and the message pumping that occurs, on a per-thread basis.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows developers to opt out of automatic clean-up, and the corresponding message pumping.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A&gt;</ph> method to notify the runtime to clean up all RCWs that are allocated in the current context.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>This companion method allows developers to precisely control when the runtime performs cleanup in the current context.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> are not valid.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;destination&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed <ph id="ph1">&lt;xref href="System.IntPtr"&gt;&lt;/xref&gt;</ph> array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, the unmanaged data corresponding to the<ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed <ph id="ph1">&lt;xref href="System.IntPtr"&gt;&lt;/xref&gt;</ph> array.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the unmanaged data that corresponds to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> are not valid.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;destination&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> are not valid.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> or <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> are not valid.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;destination&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Copies data from an unmanaged memory pointer to a managed character array.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy from.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The array to copy to.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The zero-based index in the destination array where copying should start.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;startIndex&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> are not valid.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;destination&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> are not valid.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;destination&lt;/code&gt;</ph>, or <ph id="ph3">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The one-dimensional array to copy from.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source array where copying should start.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The memory pointer to copy to.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The number of array elements to copy.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;length&lt;/code&gt;</ph> are not valid.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;source&lt;/code&gt;</ph>, <ph id="ph2">&lt;code&gt;startIndex&lt;/code&gt;</ph>, <ph id="ph3">&lt;code&gt;destination&lt;/code&gt;</ph>, or <ph id="ph4">&lt;code&gt;length&lt;/code&gt;</ph> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Aggregates a managed object with the specified COM object.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The outer <ph id="ph1">`IUnknown`</ph> pointer.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>An object to aggregate.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The inner <ph id="ph1">`IUnknown`</ph> pointer of the managed object.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Aggregates a managed object of the specified type with the specified COM object.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The outer <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The managed object to aggregate.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The type of the managed object to aggregate.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Wraps the specified COM object in an object of the specified type.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A&gt;</ph> converts one COM class type, typically the generic <ph id="ph2">`__ComObject`</ph> type, to another COM class type.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The input COM object, represented by parameter <ph id="ph1">`o`</ph>, is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both the <ph id="ph1">`t`</ph> and <ph id="ph2">`o`</ph> parameters must be classes whose signatures are attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>Tlbimp.exe imports a COM <bpt id="p1">[</bpt>coclass<ept id="p1">](http://msdn.microsoft.com/en-us/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> as a managed class and an interface.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a coclass called <ph id="ph1">`MyCoclass`</ph> becomes a coclass interface called <ph id="ph2">`MyCoclass`</ph> and a managed class called <ph id="ph3">`MyCoclassClass`</ph>.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since <ph id="ph1">`t`</ph> must be a class, not an interface, be sure to specify the managed class (<ph id="ph2">`MyCoclassClass`</ph>) and not the coclass interface.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>You lose the identity of the input COM object because a new RCW instance wraps the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer exposed by the original RCW.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The object to be wrapped.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The type of wrapper to create.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The newly wrapped object that is an instance of the desired type.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> must derive from <ph id="ph2">`__ComObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> cannot be converted to the destination type because it does not support all required interfaces.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Wraps the specified COM object in an object of the specified type.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29&gt;</ph> converts a COM object of type <ph id="ph2">`T`</ph> to the <ph id="ph3">`TWrapper`</ph> COM class type.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The input COM object, represented by parameter <ph id="ph1">`o`</ph>, is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both the <ph id="ph1">`T`</ph> generic type parameter and the <ph id="ph2">`o`</ph> parameter must be classes whose signatures are attributed with the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=fullName&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>Tlbimp.exe imports a COM <bpt id="p1">[</bpt>coclass<ept id="p1">](http://msdn.microsoft.com/en-us/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> as a managed class and an interface.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a coclass called <ph id="ph1">`MyCoclass`</ph> becomes a coclass interface called <ph id="ph2">`MyCoclass`</ph> and a managed class called <ph id="ph3">`MyCoclassClass`</ph>.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because<ph id="ph1">`T`</ph> must be a class, not an interface, be sure to specify the managed class (<ph id="ph2">`MyCoclassClass`</ph>) and not the <ph id="ph3">`coclass`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>You lose the identity of the input COM object, because a new RCW instance wraps the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer exposed by the original RCW.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The object to be wrapped.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The type of object to wrap.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The type of object to return.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The newly wrapped object.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> must derive from <ph id="ph2">`__ComObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> cannot be converted to the <ph id="ph2">&lt;code&gt;TWrapper&lt;/code&gt;</ph> because it does not support all required interfaces.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Frees all substructures that the specified unmanaged memory block points to.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to free reference-type fields, such as strings, of an unmanaged structure.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike its fields, a structure can be a value type or a reference type.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=fullName&gt;</ph> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> function, which, in turn, frees an allocated string.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Type of a formatted class.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>This provides the layout information necessary to delete the buffer in the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;structureType&lt;/code&gt;</ph> has an automatic layout.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Use sequential or explicit instead.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Frees all substructures of a specified type that the specified unmanaged memory block points to.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to free reference type fields, such as strings, of an unmanaged structure.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike its fields, a structure can be a value type or a reference type.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value type structures that contain value type fields (all blittable) have no references whose memory must be freed.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=fullName&gt;</ph> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> function, which, in turn, frees an allocated string.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The type of the formatted structure.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>This provides the layout information necessary to delete the buffer in the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> has an automatic layout.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Use sequential or explicit instead.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Releases all references to a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) by setting its reference count to 0.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method releases the managed reference to a COM object.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method is equivalent to calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method in a loop until it returns 0 (zero).</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the RCW can still exist, waiting to be garbage-collected.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>The COM object cannot be used after it has been separated from its underlying RCW.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you try to call a method on the RCW after its reference count becomes 0, a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> will be thrown.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>The RCW to be released.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The new value of the reference count of the RCW associated with the <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> parameter, which is 0 (zero) if the release is successful.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is not a valid COM object.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Frees a <ph id="ph1">`BSTR`</ph> using the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> function.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>Like <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=fullName&gt;</ph>, you can use this method to deallocate memory.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> function, which frees memory allocated by any of the following unmanaged methods: <ph id="ph2">`SysAllocString`</ph>, <ph id="ph3">`SysAllocStringByteLen`</ph>, <ph id="ph4">`SysAllocStringLen`</ph>, <ph id="ph5">`SysReAllocString`</ph>, <ph id="ph6">`SysReAllocStringLen`</ph>.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call unmanaged methods such as these with platform invoke.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details, see <bpt id="p1">[</bpt>Consuming Unmanaged DLL Functions<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The address of the BSTR to be freed.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Frees a block of memory allocated by the unmanaged COM task memory allocator.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> to free any memory allocated by <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph>, or any equivalent unmanaged method.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`ptr`</ph> parameter is <ph id="ph2">`null`</ph>, the method does nothing.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> exposes the COM <bpt id="p1">[</bpt>CoTaskMemFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148638)</ept> function, which frees all bytes so that you can no longer use the memory that the <ph id="ph2">`ptr`</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>The address of the memory to be freed.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Frees memory previously allocated from the unmanaged memory of the process.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> to free any memory from the global heap allocated by <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph>, or any equivalent unmanaged API method.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`hglobal`</ph> parameter is <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=fullName&gt;</ph> the method does nothing.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> exposes the <bpt id="p1">[</bpt>LocalFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148640)</ept> function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by <ph id="ph2">`hglobal`</ph>.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation API methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The handle returned by the original matching call to <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has a GUID in the metadata, it is returned.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, a GUID is automatically generated.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>Class interfaces are the only exception because they do not correspond to a managed type.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A&gt;</ph> provides the same functionality as the <ph id="ph2">&lt;xref:System.Type.GUID%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>The type to generate a GUID for.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>An identifier for the specified type.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Returns a programmatic identifier (ProgID) for the specified type.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has a ProgID in the metadata, that ProgID is returned.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, a ProgID is generated based on the fully qualified name of the type.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>The type to get a ProgID for.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The ProgID of the specified type.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> parameter is not a class that can be create by COM.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The class must be public, have a public default constructor, and be COM visible.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Obtains a running instance of the specified object from the running object table (ROT).</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> exposes the COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (<ph id="ph2">`ProgID`</ph>) expected by this method.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>To obtain a running instance of a COM object without a registered <ph id="ph1">`ProgID`</ph>, use platform invoke to define the COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> function.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a description of platform invoke, see <bpt id="p1">[</bpt>Consuming Unmanaged DLL Functions<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>ProgID and CLSID</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Applications often use these human-readable strings instead of the numeric CLSIDs.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>The programmatic identifier (ProgID) of the object that was requested.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>The object that was requested; otherwise <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>You can cast this object to any COM interface that it supports.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The object was not found.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on the specified object.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Custom query interface access is enabled by default.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns an interface pointer that represents the requested interface on the specified object.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=fullName&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must adhere to the rules defined by COM when using raw COM interface pointers.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> on a managed object that is exported to COM to obtain an interface pointer for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (<ph id="ph1">`t`</ph>).</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=fullName&gt;</ph> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> method overload allows query interface customization by default.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify whether to apply query interface customization, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, and <bpt id="p3">[</bpt>Introducing the Class Interface<ept id="p3">](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> topics.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The object that provides the interface.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The type of interface that is requested.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>The interface pointer that represents the specified interface for the object.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> parameter is not an interface.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The type is not visible to COM.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> parameter is a generic type.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> parameter does not support the requested interface.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on the specified object.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Custom query interface access is controlled by the specified customization mode.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph>lets you specify whether to apply query interface customization.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> overload to apply query interface customization by default.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The object that provides the interface.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The type of interface that is requested.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>One of the enumeration values that indicates whether to apply an <ph id="ph1">`IUnknown::QueryInterface`</ph> customization that is supplied by an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ICustomQueryInterface"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>The interface pointer that represents the interface for the object.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> parameter is not an interface.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The type is not visible to COM.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> parameter is a generic type.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The object <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> does not support the requested interface.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on an object of the specified type.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Custom query interface access is enabled by default.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns an interface pointer that represents the <ph id="ph1">`TInterface`</ph> interface on the specified object.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Always use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=fullName&gt;</ph>method to decrement the reference count when you have finished with the pointer.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must adhere to the rules defined by COM when using raw COM interface pointers.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> on a managed object that is exported to COM to obtain an interface pointer for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> method overload allows query interface customization by default.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify whether to apply query interface customization, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, and <bpt id="p3">[</bpt>Introducing the Class Interface<ept id="p3">](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> topics.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The object that provides the interface.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>The type of <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>The type of interface to return.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>The interface pointer that represents the <ph id="ph1">&lt;code&gt;TInterface&lt;/code&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;TInterface&lt;/code&gt;</ph> parameter is not an interface.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>The type is not visible to COM.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> parameter is an open generic type.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> parameter does not support the <ph id="ph2">&lt;code&gt;TInterface&lt;/code&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The object that provides the interface.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>The type of interface that is requested.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The interface pointer specified by <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> that represents the interface for the specified object, or <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is not an interface.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The type is not visible to COM.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> does not support the requested interface.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Retrieves data that is referenced by the specified key from the specified COM object.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>All COM objects wrapped in a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> have an associated hash table, which <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A&gt;</ph> retrieves.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=fullName&gt;</ph> adds data to the hash table.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should never have to call either method from your code.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>The COM object that contains the data that you want.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>The key in the internal hash table of <ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> to retrieve the data from.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>The data represented by the <ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> parameter in the internal hash table of the <ph id="ph2">&lt;code&gt;obj&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> is not a COM object.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>Retrieves the virtual function table (v-table or VTBL) slot for a specified <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> type when that type is exposed to COM.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>The zero-based slot number returned by this method accounts for three <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> and possibly four <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> methods, making the value of the first available slot either 3 or 7.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> on a class interface by passing <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> from a class.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>An object that represents an interface method.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The VTBL slot <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> identifier when it is exposed to COM.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is not a <ph id="ph2">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is not an interface method.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>Converts an unmanaged function pointer to a delegate.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework 2.0 and later versions, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> methods to marshal delegates in both directions.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>With <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph>, <ph id="ph2">`ptr`</ph> is imported as a <ph id="ph3">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> can be obtained for a managed delegate by calling <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> and passed as a parameter; it can then be called from inside the unmanaged method.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> method has the following restrictions:</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generics are not supported in interop scenarios.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot pass an invalid function pointer to this method.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method only for pure unmanaged function pointers.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this method with function pointers obtained through C++ or from the <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this method to create a delegate from a function pointer to another managed delegate.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The unmanaged function pointer to be converted.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>The type of the delegate to be returned.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>A delegate instance that can be cast to the appropriate delegate type.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter is not a delegate or is generic.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Converts an unmanaged function pointer to a delegate of a specified type.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> and<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29&gt;</ph>methods to marshal delegates in both directions.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> method has the following restrictions:</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot pass an invalid function pointer to this method.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method only for pure unmanaged function pointers.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this method with function pointers obtained through C++ or from the <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this method to create a delegate from a function pointer to another managed delegate.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>The unmanaged function pointer to convert.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The type of the delegate to return.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>A instance of the specified delegate type.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;TDelegate&lt;/code&gt;</ph> generic parameter is not a delegate, or it is an open generic type.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns the zero-based, v-table number for an interface or a class.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>When used on a class, the slot number returned refers to the class interface for the class.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the class interface is auto-dual, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=fullName&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=fullName&gt;</ph> to pass slots within a specified range.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>A type that represents an interface or class.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The last VTBL slot of the interface when exposed to COM.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Retrieves a code that identifies the type of the exception that occurred.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A&gt;</ph> is exposed for compiler support of structured exception handling (SEH) only.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method is called before an exception is thrown, it returns 0x0.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>The type of the exception.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>Converts the specified HRESULT error code to a corresponding <ph id="ph1">&lt;xref href="System.Exception"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> method to get an <ph id="ph2">&lt;xref:System.Exception&gt;</ph> based on an HRESULT without having to call the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method and catch the exception.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/en-us/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> interface is used to construct the exception.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The HRESULT to be converted.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>An object that represents the converted HRESULT.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>Converts the specified HRESULT error code to a corresponding <ph id="ph1">&lt;xref href="System.Exception"&gt;&lt;/xref&gt;</ph> object, with additional error information passed in an <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/en-us/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> interface for the exception object.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> method to get an <ph id="ph2">&lt;xref:System.Exception&gt;</ph> based on an HRESULT without having to call the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method and catch the exception (thus avoiding the corresponding performance overhead).</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`errorInfo`</ph> parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method overload if you have custom error information that you have to supply in the conversion.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>The HRESULT to be converted.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>A pointer to the <ph id="ph1">`IErrorInfo`</ph> interface that provides more information about the error.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>You can specify <ph id="ph1">&lt;code&gt;IntPtr(0)&lt;/code&gt;</ph> to use the current <ph id="ph2">`IErrorInfo`</ph> interface, or <ph id="ph3">&lt;code&gt;IntPtr(-1)&lt;/code&gt;</ph> to ignore the current <ph id="ph4">`IErrorInfo`</ph> interface and construct the exception just from the error code.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>An object that represents the converted HRESULT and information obtained from <ph id="ph1">&lt;code&gt;errorInfo&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A&gt;</ph> is exposed for compiler support of structured exception handling (SEH) only.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>A pointer to an <bpt id="p1">[</bpt>EXCEPTION_POINTERS<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148648)</ept> structure.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Converts a delegate into a function pointer that is callable from unmanaged code.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate <ph id="ph1">`d`</ph> is converted to a function pointer that can be passed to unmanaged code using the <bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> calling convention.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must manually keep the delegate from being collected by the garbage collector from managed code.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector does not track references to unmanaged code.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>The delegate to be passed to unmanaged code.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> parameter is a generic type.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Converts a delegate of a specified type to a function pointer that is callable from unmanaged code.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate <ph id="ph1">`d`</ph> is converted to a function pointer that can be passed to unmanaged code by using the <bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> calling convention.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must manually keep the delegate from being collected by the garbage collector from managed code.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector does not track references to unmanaged code.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>The delegate to be passed to unmanaged code.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>The type of delegate to convert.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Returns the instance handle (HINSTANCE) for the specified module.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>When dynamic or in-memory, modules do not have an HINSTANCE.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>The module whose HINSTANCE is desired.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>The HINSTANCE for <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph>; or -1 if the module does not have an HINSTANCE.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>Converts the specified exception to an HRESULT.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> also sets up an <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.PreserveSigAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>Have the attributed method catch all exceptions and use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> method to return the appropriate HRESULT value.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>Allowing an exception to propagate outside the method produces incorrect behavior.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>(In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> method sets the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can cause unexpected results for methods like the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> methods that default to using the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> of the current thread if it is set.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>The exception to convert to an HRESULT.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>The HRESULT mapped to the supplied exception.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target function must have had the <ph id="ph1">`setLastError`</ph> metadata flag set.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">`SetLastError`</ph> field of the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName&gt;</ph> must be <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>The process for setting this flag depends on the source language used: C# and C++ are <ph id="ph1">`false`</ph> by default, but the <ph id="ph2">`Declare`</ph> statement in Visual Basic is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>The HRESULT corresponding to the last Win32 error code.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> interface from a managed object.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>In managed code, you seldom work directly with the <ph id="ph1">`IDispatch`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=fullName&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>The object whose <ph id="ph1">`IDispatch`</ph> interface is requested.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IDispatch`</ph> pointer for the <ph id="ph2">&lt;code&gt;o&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> does not support the requested interface.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> interface pointer from a managed object, if the caller is in the same context as that object.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The object whose <ph id="ph1">`IDispatch`</ph> interface is requested.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IDispatch`</ph> interface pointer for the specified object, or <ph id="ph2">`null`</ph> if the caller is not in the same context as the specified object.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> does not support the requested interface.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ComTypes.ITypeInfo"&gt;&lt;/xref&gt;</ph> interface from a managed type.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns a pointer to an <ph id="ph1">`ITypeInfo`</ph> implementation that is based on the original type.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling an object with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph> causes the reference count to increment on the interface pointer before the pointer is returned.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=fullName&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=fullName&gt;</ph> to replace standard interop marshaling behavior with this custom marshaler.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The type whose <ph id="ph1">`ITypeInfo`</ph> interface is being requested.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>A pointer to the <ph id="ph1">`ITypeInfo`</ph> interface for the <ph id="ph2">&lt;code&gt;t&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is not a visible type to COM.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>A type library is registered for the assembly that contains the type, but the type definition cannot be found.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface from a managed object.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>In managed code, you seldom work directly with the <ph id="ph1">`IUnknown`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=fullName&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use this method on a managed object to obtain an interface pointer to the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> for the object.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The object whose <ph id="ph1">`IUnknown`</ph> interface is requested.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IUnknown`</ph> pointer for the <ph id="ph2">&lt;code&gt;o&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Returns an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface from a managed object, if the caller is in the same context as that object.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The object whose <ph id="ph1">`IUnknown`</ph> interface is requested.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IUnknown`</ph> pointer for the specified object, or <ph id="ph2">`null`</ph> if the caller is not in the same context as the specified object.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.DllImportAttribute.SetLastError"&gt;&lt;/xref&gt;</ph> flag set.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> exposes the Win32 <bpt id="p1">[</bpt>GetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148657)</ept> function from Kernel32.DLL.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method exists because it is not safe to make a direct platform invoke call to <ph id="ph1">`GetLastError`</ph> to obtain this information.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to access this error code, you must call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> instead of writing your own platform invoke definition for <ph id="ph2">`GetLastError`</ph> and calling it.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime can make internal calls to APIs that overwrite the <ph id="ph1">`GetLastError`</ph> maintained by the operating system.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to obtain error codes only if you apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName&gt;</ph> to the method signature and set the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError&gt;</ph> field to<ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT">
          <source>The process for this varies depending upon the source language used: C# and C++ are <ph id="ph1">`false`</ph> by default, but the <ph id="ph2">`Declare`</ph> statement in Visual Basic is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>The last error code set by a call to the Win32 <bpt id="p1">[</bpt>SetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148656)</ept> function.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A&gt;</ph> is exposed for compiler support only.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>A pointer to the method to marshal.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>A pointer to the method signature.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>The number of bytes in <ph id="ph1">&lt;code&gt;pbSignature&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>A pointer to the function that will marshal a call from the <ph id="ph1">&lt;code&gt;pfnMethodToWrap&lt;/code&gt;</ph> parameter to unmanaged code.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>Retrieves a <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> object for the specified virtual function table (v-table or VTBL) slot.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value may be a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, or <ph id="ph3">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value depends on the type of managed member that exists in the given COM slot (hence the generalized return type <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> from which all three derive).</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>The zero-based slot number that is returned by this method accounts for three <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> and possibly four <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> methods, making the value of the first available slot either 3 or 7.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=fullName&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> to pass slots within a specified range.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`memberType`</ph> parameter is important only on return.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>It contains the type of the COM member (a regular method or a property accessor) that corresponds to the returned <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>The type for which the <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>The VTBL slot.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>On successful return, one of the enumeration values that specifies the type of the member.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>The object that represents the member at the specified VTBL slot.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is not visible from COM.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Converts an object to a COM VARIANT.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`pDstNativeVariant`</ph> parameter must point to sufficient memory to store the resulting VARIANT.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, the implementation of this method calls the <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> function on the raw memory that the <ph id="ph1">`pDstNativeVariant`</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>The object for which to get a COM VARIANT.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>A pointer to receive the VARIANT that corresponds to the <ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> parameter is a generic type.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>Converts an object of a specified type to a COM VARIANT.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`pDstNativeVariant`</ph> parameter must point to sufficient memory to store the resulting VARIANT.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, the implementation of this method calls <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> function on the raw memory that the <ph id="ph1">`pDstNativeVariant`</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>The object for which to get a COM VARIANT.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>A pointer to receive the VARIANT that corresponds to the <ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>The type of the object to convert.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Returns an instance of a type that represents a COM object by a pointer to its <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method wraps <ph id="ph1">`IUnknown`</ph> in a managed object.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>This has the effect of incrementing the reference count of the COM component.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`pUnk`</ph> parameter represents an <ph id="ph2">`IUnknown`</ph> interface pointer; however, because all COM interfaces derive directly or indirectly from <ph id="ph3">`IUnknown`</ph>, you can pass any COM interface to this method.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object returned by <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A&gt;</ph> is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, which the common language runtime manages as it does any other managed object.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of this wrapper is often a generic <ph id="ph1">`System.__ComObject`</ph> type, which is a hidden type used when the wrapper type is ambiguous.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can still make late-bound calls to such a generic type as long as the COM object implements the <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> interface.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>Likewise, you can cast the returned object to an appropriate COM interface.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements:</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implement the <bpt id="p1">[</bpt>IProvideClassInfo<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148012)</ept> interface for the COM object.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>Register the containing assembly with the <bpt id="p1">[</bpt>Regasm.exe (Assembly Registration Tool)<ept id="p1">](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>A pointer to the <ph id="ph1">`IUnknown`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>An object that represents the specified unmanaged COM object.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>Converts a COM VARIANT to an object.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the VARIANT type is VT_ERROR, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> returns an object of type <ph id="ph2">`Int32`</ph> instead of <ph id="ph3">`UInt32`</ph>.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>A pointer to a COM VARIANT.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>An object that corresponds to the <ph id="ph1">&lt;code&gt;pSrcNativeVariant&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;pSrcNativeVariant&lt;/code&gt;</ph> is not a valid VARIANT type.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;pSrcNativeVariant&lt;/code&gt;</ph> has an unsupported type.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>Converts a COM VARIANT to an object of a specified type.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> returns a managed object of type <ph id="ph2">`T`</ph> that corresponds to a raw pointer to an unmanaged VARIANT type.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> provides the opposite functionality of<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>A pointer to a COM VARIANT.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>The type to which to convert the COM VARIANT.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>An object of the specified type that corresponds to the <ph id="ph1">&lt;code&gt;pSrcNativeVariant&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;pSrcNativeVariant&lt;/code&gt;</ph> is not a valid VARIANT type.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;pSrcNativeVariant&lt;/code&gt;</ph> has an unsupported type.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>Converts an array of COM <bpt id="p1">[</bpt>VARIANTs<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148670)</ept> to an array of objects.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A&gt;</ph> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method returns an empty array when the <ph id="ph1">`cVars`</ph> parameter is 0.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object array (the return value) gets garbage collected as usual.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged input array or individual VARIANTs in the input array are not freed.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore it is your responsibility to free them as appropriate.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>A pointer to the first element of an array of COM VARIANTs.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>The count of COM VARIANTs in <ph id="ph1">&lt;code&gt;aSrcNativeVariant&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>An object array that corresponds to <ph id="ph1">&lt;code&gt;aSrcNativeVariant&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;cVars&lt;/code&gt;</ph> is a negative number.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Converts an array of COM VARIANTs to an array of a specified type.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29&gt;</ph> returns an array of <ph id="ph2">`T`</ph> that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method returns an empty array when the <ph id="ph1">`cVars`</ph> parameter is 0.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned array is garbage-collected as usual.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged input array or individual VARIANTs in the input array are not freed.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, it is your responsibility to free them as appropriate.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>A pointer to the first element of an array of COM VARIANTs.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>The count of COM VARIANTs in <ph id="ph1">&lt;code&gt;aSrcNativeVariant&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>The type of the array to return.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> objects that corresponds to <ph id="ph2">&lt;code&gt;aSrcNativeVariant&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;cVars&lt;/code&gt;</ph> is a negative number.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns the zero-based v-table number for an interface or a class.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>When used on a class, the slot number that is returned refers to the class interface for the class.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=fullName&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=fullName&gt;</ph> to pass slots within a specified range.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>A type that represents an interface.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>The first VTBL slot that contains user-defined methods.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>The first slot is 3 if the interface is based on <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>, and 7 if the interface is based on <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept>.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is not visible from COM.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>Converts a fiber cookie into the corresponding <ph id="ph1">&lt;xref href="System.Threading.Thread"&gt;&lt;/xref&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>They consist of a stack and register context.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>An integer that represents a fiber cookie.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>A thread that corresponds to the <ph id="ph1">&lt;code&gt;cookie&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;cookie&lt;/code&gt;</ph> parameter is 0.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>Returns a managed object of a specified type that represents a COM object.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`t`</ph> parameter must be either a COM-imported type or a subtype of a COM-imported type.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, <ph id="ph1">`t`</ph> must be a type whose metadata was imported by the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>This type must be a class and not an associated coclass interface, which carries the name of the COM class.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if Tlbimp.exe imports <ph id="ph1">`Myclass`</ph> as a class called <ph id="ph2">`MyclassClass`</ph> and as a coclass interface called <ph id="ph3">`Myclass`</ph>, you must use <ph id="ph4">`MyclassClass`</ph> (not <ph id="ph5">`Myclass`</ph>) with this method.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information about imported classes and coclass interfaces, see <bpt id="p1">[</bpt>Imported Type Conversion<ept id="p1">](http://msdn.microsoft.com/en-us/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)</ept>.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an object has already been obtained for the <ph id="ph1">`pUnk`</ph> parameter, <ph id="ph2">`t`</ph> is ignored and the existing object is returned.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`pUnk`</ph> represents an<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer; however, because all COM interfaces derive directly or indirectly from <ph id="ph2">`IUnknown`</ph>, you can pass any COM interface to this method.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object returned by <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A&gt;</ph> is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW), which the common language runtime manages as it does any other managed object.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>A pointer to the <ph id="ph1">`IUnknown`</ph> interface of the unmanaged object.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The type of the requested managed class.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>An instance of the class corresponding to the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the requested unmanaged COM object.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is not attributed with <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ComImportAttribute"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>Converts an unmanaged <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680)</ept> object into a managed <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.Type?displayProperty=fullName&gt;</ph> instance that is based on the original type.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=fullName&gt;</ph> to replace standard interop marshaling behavior with this custom marshaler.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool uses the custom marshaler to translate <ph id="ph1">`ITypeInfo`</ph> parameters to <ph id="ph2">&lt;xref:System.Type?displayProperty=fullName&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if you obtain an <ph id="ph1">`ITypeInfo`</ph> interface by some means other than Tlbimp.exe, you can use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> to manually perform the same translation.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ITypeInfo`</ph> interface to marshal.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>A managed type that represents the unmanaged <ph id="ph1">`ITypeInfo`</ph> object.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>Returns the type associated with the specified class identifier (CLSID).</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The CLSID of the type to return.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.__ComObject`</ph> regardless of whether the CLSID is valid.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also retrieve the name of the type represented by an <ph id="ph1">`ITypeInfo`</ph> object by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=fullName&gt;</ph> method and passing -1 for its first parameter.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>An object that represents an <ph id="ph1">`ITypeInfo`</ph> pointer.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>The name of the type that the <ph id="ph1">&lt;code&gt;pTI&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also retrieve the name of the type represented by an <ph id="ph1">`ITypeInfo`</ph> by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=fullName&gt;</ph> method and passing -1 for its first parameter.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>An object that represents an <ph id="ph1">`ITypeInfo`</ph> pointer.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>The name of the type that the <ph id="ph1">&lt;code&gt;typeInfo&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;typeInfo&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> extracts the LIBID directly from an existing type library.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>This action differs from that of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=fullName&gt;</ph> method, which calculates what the LIBID should be based on the current assembly.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about library identifiers, see <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source>The type library whose LIBID is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>The LIBID of the specified type library.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> extracts the LIBID directly from an existing type library.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>This action differs from that of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=fullName&gt;</ph> method, which calculates what the LIBID should be based on the current assembly.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about library identifiers, see <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>The type library whose LIBID is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>The LIBID of the type library that the <ph id="ph1">&lt;code&gt;pTLB&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>When assemblies are exported to type libraries, the type library is assigned a LIBID.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can set the LIBID explicitly by applying the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=fullName&gt;</ph> at the assembly level, or it can be generated automatically.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool calculates a LIBID value based on the identity of the assembly.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> returns the LIBID that is associated with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph>, if the attribute is applied.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A&gt;</ph> returns the calculated value.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> method to extract the actual LIBID from an existing type library.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept> topic for more information about library identifiers.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>The assembly from which the type library was exported.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>The LIBID that is assigned to a type library when it is exported from the specified assembly.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asm&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>Retrieves the LCID of a type library.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>The type library whose LCID is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>The LCID of the type library that the <ph id="ph1">&lt;code&gt;typelib&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>Retrieves the LCID of a type library.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The type library whose LCID is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The LCID of the type library that the <ph id="ph1">&lt;code&gt;pTLB&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>Retrieves the name of a type library.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name is not a file name.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also retrieve the type library name by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=fullName&gt;</ph> method and passing -1 for its first parameter.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>The type library whose name is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>The name of the type library that the <ph id="ph1">&lt;code&gt;typelib&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;typelib&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>Retrieves the name of a type library.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name is not a file name.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also retrieve the type library name by calling the<ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=fullName&gt;</ph> method and passing -1 for its first parameter.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>The type library whose name is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>The name of the type library that the <ph id="ph1">&lt;code&gt;pTLB&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>Retrieves the version number of a type library that will be exported from the specified assembly.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before exporting an assembly by using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibExporterFlags&gt;</ph> with the <ph id="ph2">`CallerResolvedReferences`</ph> value, you can use this method to retrieve the type library version from the assembly.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibVersionAttribute&gt;</ph> attribute to an exported assembly to explicitly control the version number of the generated type library, the type library will have the same version number as the assembly.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>A managed assembly.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>The major version number.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>The minor version number.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;inputAssembly&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>Creates a unique <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) object for a given <bpt id="p2">[</bpt>IUnknown<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A&gt;</ph> method ensures that you receive a unique RCW, because it does not match an <ph id="ph2">`IUnknown`</ph> pointer to an existing object.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method when you have to create a unique RCW that is not impacted by other code that calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>A managed pointer to an <ph id="ph1">`IUnknown`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>A unique RCW for the specified <ph id="ph1">`IUnknown`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A&gt;</ph> is exposed for compiler support only.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>A pointer to the method to marshal.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>A pointer to the method signature.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>The number of bytes in <ph id="ph1">&lt;code&gt;pbSignature&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source>A pointer to a function that will marshal a call from <ph id="ph1">&lt;code&gt;pfnMethodToWrap&lt;/code&gt;</ph> to managed code.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>Indicates whether a specified object represents a COM object.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsComObject%2A&gt;</ph> returns <ph id="ph2">`true`</ph> if the class type of the instance is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=fullName&gt;</ph> or if it derives directly or indirectly from a class attributed with <ph id="ph4">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two other methods also determine whether a specified object represents a COM object, but the requirements for returning <ph id="ph1">`true`</ph> differ from this method's requirements.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsImport%2A?displayProperty=fullName&gt;</ph> returns <ph id="ph2">`true`</ph> if the class (or interface) is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> directly; it does not return <ph id="ph4">`true`</ph> for derived types.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=fullName&gt;</ph> returns <ph id="ph2">`true`</ph> if the type is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> or derives from a type with the same GUID.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;code&gt;o&lt;/code&gt;</ph> parameter is a COM type; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>Indicates whether a type is visible to COM clients.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A&gt;</ph> enables you to check for COM visibility in one step.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Types that are not visible cannot be used from COM.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type is visible if it is <ph id="ph1">`public`</ph> and not hidden with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>The type to check for COM visibility.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the type is visible to COM; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A&gt;</ph> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the return value of this method is platform-dependent.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>The method to be checked.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>The number of bytes required to represent the method parameters in unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is not a <ph id="ph2">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>Returns the field offset of the unmanaged form of the managed class.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>Marshaling the structure can transform the layout and alter the offset.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`t`</ph> parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can obtain the size of the entire layout by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <bpt id="p1">[</bpt>Default Marshaling for Value Types<ept id="p1">](http://msdn.microsoft.com/en-us/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> may expose private fields.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>A value type or formatted reference type that specifies the managed class.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>You must apply the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.StructLayoutAttribute"&gt;&lt;/xref&gt;</ph> to the class.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>The field within the <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>The offset, in bytes, for the <ph id="ph1">&lt;code&gt;fieldName&lt;/code&gt;</ph> parameter within the specified class that is declared by platform invoke.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>The class cannot be exported as a structure or the field is nonpublic.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>Beginning with the .NET Framework version 2.0, the field may be private.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>Returns the field offset of the unmanaged form of a specified managed class.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29&gt;</ph> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>Marshaling the structure can transform the layout and alter the offset.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`T`</ph> generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can obtain the size of the entire layout by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information, see <bpt id="p1">[</bpt>Default Marshaling for Value Types<ept id="p1">](http://msdn.microsoft.com/en-us/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> may expose private fields.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>The name of the field in the <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>A managed value type or formatted reference type.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>You must apply the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.StructLayoutAttribute"&gt;&lt;/xref&gt;</ph> attribute to the class.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>The offset, in bytes, for the <ph id="ph1">&lt;code&gt;fieldName&lt;/code&gt;</ph> parameter within the specified class that is declared by platform invoke.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>Executes one-time method setup tasks without calling the method.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setup tasks provide early initialization and are performed automatically when the target method is invoked.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>First-time tasks include the following:</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>Verifying that the platform invoke metadata is correctly formatted.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT">
          <source>Verifying that all the managed types are valid parameters of platform invoke functions.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>Locating and loading the unmanaged DLL into the process.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Locating the entry point in the process.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> on a method outside of platform invoke has no effect.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>To execute setup tasks on all platform invoke methods in a type, use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>The method to be checked.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;m&lt;/code&gt;</ph> parameter is not a <ph id="ph2">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>Performs a pre-link check for all methods on a class.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> method invokes <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=fullName&gt;</ph> on every method for a given type.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> executes one-time method setup tasks without calling each method.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> only for platform invoke calls.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>The class whose methods are to be checked.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;c&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>Copies all characters up to the first null character from an unmanaged ANSI string to a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>, and widens each ANSI character to Unicode.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>The address of the first character of the unmanaged string.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>A managed string that holds a copy of the unmanaged ANSI string.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, the method returns a null string.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>Allocates a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph>, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>The address of the first character of the unmanaged string.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>The byte count of the input string to copy.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>A managed string that holds a copy of the native ANSI string if the value of the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter is not <ph id="ph2">`null`</ph>; otherwise, this method returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;len&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>Allocates a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> provides the opposite functionality of the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>For Unicode platforms, the address of the first Unicode character.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>For ANSI plaforms, the address of the first ANSI character.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter is not <ph id="ph2">`null`</ph>; otherwise, this method returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>Allocates a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> and copies the specified number of characters from a string stored in unmanaged memory into it.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>On Unicode platforms, this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>; on ANSI platforms, it calls <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>No transformations are done before these methods are called.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>For Unicode platforms, the address of the first Unicode character.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>For ANSI plaforms, the address of the first ANSI character.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>The number of characters to copy.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>A managed string that holds a copy of the native string if the value of the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter is not <ph id="ph2">`null`</ph>; otherwise, this method returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;len&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>Allocates a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> and copies a <bpt id="p1">[</bpt>binary string (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> stored in unmanaged memory into it.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call this method only on strings that were allocated with the unmanaged <bpt id="p1">[</bpt>SysAllocString<ept id="p1">](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx)</ept> and <bpt id="p2">[</bpt>SysAllocStringLen<ept id="p2">](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx)</ept> functions.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>The address of the first character of the unmanaged string.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>A managed string that holds a copy of the unmanaged string.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> equals <ph id="ph2">&lt;xref href="System.IntPtr.Zero"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>Allocates a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> and copies all characters up to the first null character from an unmanaged Unicode string into it.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>The address of the first character of the unmanaged string.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter is not <ph id="ph2">`null`</ph>; otherwise, this method returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>Allocates a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> and copies a specified number of characters from an unmanaged Unicode string into it.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>The address of the first character of the unmanaged string.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The number of Unicode characters to copy.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter is not <ph id="ph2">`null`</ph>; otherwise, this method returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Marshals data from an unmanaged block of memory to a managed object.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as an <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this overload method with value types.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>The object to which the data is to be copied.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>This must be an instance of a formatted class.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source>Structure layout is not sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>Structure is a boxed value type.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as an <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass a value type to this overload method.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the returned object is a boxed instance.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>The type of object to be created.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>This object must represent a formatted class or a structure.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>A managed object containing the data pointed to by the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;structureType&lt;/code&gt;</ph> parameter layout is not sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;structureType&lt;/code&gt;</ph> parameter is a generic type.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;structureType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>The class specified by <ph id="ph1">&lt;code&gt;structureType&lt;/code&gt;</ph> does not have an accessible default constructor.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=fullName&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass a value type to this method overload.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>The type of the object to which the data is to be copied.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>This must be a formatted class or a structure.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>A managed object that contains the data that the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>The layout of <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> is not sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>The class specified by <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> does not have an accessible default constructor.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>Marshals data from an unmanaged block of memory to a managed object of the specified type.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this method overload with value types.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>The object to which the data is to be copied.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source>The type of <ph id="ph1">&lt;code&gt;structure&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>This must be a formatted class.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>Structure layout is not sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>Requests a pointer to a specified interface from a COM object.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A&gt;</ph> method exposes the <bpt id="p1">[</bpt>IUnknown::QueryInterface<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=144867)</ept> method of a COM object, which attempts to obtain a specific interface pointer.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using <ph id="ph1">`QueryInterface`</ph> on a COM object is the same as performing a cast operation in managed code.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=fullName&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT">
          <source>To obtain an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> value that represents a <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer, you can call <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=fullName&gt;</ph>, or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>The interface to be queried.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>The interface identifier (IID) of the requested interface.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a reference to the returned interface.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>An HRESULT that indicates the success or failure of the call.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>Reads a single byte at a given offset (or index) from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>The byte read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>Reads a single byte at a given offset (or index) from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the source object.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>The byte read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>Reads a single byte from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> has an implied offset of 0.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve">
          <source>The byte read from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source>Reads a 16-bit signed integer from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> has an implied offset of 0.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int16`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer read from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>Reads a 16-bit signed integer at a given offset from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>Reads a 16-bit signed integer at a given offset from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the source object.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source>Reads a 32-bit signed integer from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> has an implied offset of 0.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int32`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer read from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>Reads a 32-bit signed integer at a given offset from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer read from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source>Reads a 32-bit signed integer at a given offset from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the source object.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve">
          <source>Reads a 64-bit signed integer from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> has an implied offset of 0.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int64`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer read from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>Reads a 64-bit signed integer at a given offset from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve">
          <source>Reads a 64-bit signed integer at a given offset from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the source object.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve">
          <source>Reads a processor native sized integer at a given offset from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source>The integer read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve">
          <source>Reads a processor native sized integer from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the source object.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before reading.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve">
          <source>The integer read from unmanaged memory at the given offset.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve">
          <source>Reads a processor native-sized integer from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> has an implied offset of 0.</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before reading its element values.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reading from unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory from which to read.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve">
          <source>The integer read from unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve">
          <source>A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve">
          <source>Resizes a block of memory previously allocated with <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph> is one of two memory reallocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method exposes the COM <bpt id="p1">[</bpt>CoTaskMemRealloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148778)</ept> function, which is referred to as the COM task memory allocator.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve">
          <source>A pointer to memory allocated with <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve">
          <source>The new size of the allocated block.</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve">
          <source>An integer representing the address of the reallocated block of memory.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve">
          <source>This memory must be released with <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve">
          <source>There is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve">
          <source>Resizes a block of memory previously allocated with <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> is one of two memory reallocation API methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=fullName&gt;</ph> is the other.)</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method exposes the Win32 <bpt id="p1">[</bpt>GlobalReAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148780)</ept> function from Kernel32.dll.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned pointer can differ from the original.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve">
          <source>A pointer to memory allocated with <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve">
          <source>The new size of the allocated block.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve">
          <source>This is not a pointer; it is the byte count you are requesting, cast to type <ph id="ph1">&lt;xref href="System.IntPtr"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve">
          <source>If you pass a pointer, it is treated as a size.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve">
          <source>A pointer to the reallocated memory.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve">
          <source>This memory must be released using <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve">
          <source>There is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve">
          <source>Decrements the reference count on the specified interface.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this value only for testing purposes.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only programs that call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=fullName&gt;</ph> should call <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> after the reference count has reached zero causes undefined behavior.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=fullName&gt;</ph> to obtain an <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> value that represents a <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer to release.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use these methods and the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> method on managed objects to release the COM interfaces represented by the managed object's <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve">
          <source>The interface to release.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve">
          <source>The new value of the reference count on the interface specified by the <ph id="ph1">&lt;code&gt;pUnk&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve">
          <source>Decrements the reference count of the <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) associated with the specified COM object.</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used to explicitly control the lifetime of a COM object used from managed code.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT">
          <source>The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method decrements the reference count of an RCW.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <ph id="ph1">&lt;xref:System.NullReferenceException?displayProperty=fullName&gt;</ph> if you attempt to use the object further.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> returns the number of remaining references.</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables you to force an RCW reference count release so that it occurs precisely when you want it to.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, improper use of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> may cause your application to fail, or may cause an access violation.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method on the RCW, the managed code will be unable to access the RCW and will raise an <ph id="ph2">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT">
          <source>A more serious error may occur if a call to the RCW is executing when the RCW is released.</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, there is a good chance that the thread making the call will cause an access violation.</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT">
          <source>This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM <bpt id="p1">[</bpt>CoCreateInstance<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=142894)</ept> function, which returns the same interface pointer every time it is called for singleton COM components.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method on the COM component, the other will be broken.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> only if it is absolutely required.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to call this method to ensure that a COM component is released at a determined time, consider using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> will release the underlying COM component regardless of how many times it has re-entered the CLR.</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT">
          <source>The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you could call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method in a loop until the value returned is zero.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT">
          <source>This achieves the same result as the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve">
          <source>The COM object to release.</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve">
          <source>The new value of the reference count of the RCW associated with <ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve">
          <source>This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is not a valid COM object.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve">
          <source>Releases the thread cache.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve">
          <source>Allocates an unmanaged <bpt id="p1">[</bpt>binary string (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> and copies the contents of a managed <ph id="ph1">&lt;xref href="System.Security.SecureString"&gt;&lt;/xref&gt;</ph> object into it.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the <ph id="ph1">`BSTR`</ph> when finished by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve">
          <source>The managed object to copy.</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.Security.SecureString"&gt;&lt;/xref&gt;</ph> object to a block of memory allocated from the unmanaged COM task allocator.</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT">
          <source>The characters of the string are copied as ANSI characters.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve">
          <source>The managed object to copy.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.Security.SecureString"&gt;&lt;/xref&gt;</ph> object to a block of memory allocated from the unmanaged COM task allocator.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT">
          <source>The characters of the string are copied as Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve">
          <source>The managed object to copy.</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.Security.SecureString"&gt;&lt;/xref&gt;</ph> into unmanaged memory, converting into ANSI format as it copies.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve">
          <source>The managed object to copy.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, to where the <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter was copied, or 0 if a null object was supplied.</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.Security.SecureString"&gt;&lt;/xref&gt;</ph> object into unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve">
          <source>The managed object to copy.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, where <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;code&gt;s&lt;/code&gt;</ph> is a <ph id="ph3">&lt;xref href="System.Security.SecureString"&gt;&lt;/xref&gt;</ph> object whose length is 0.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve">
          <source>Sets data referenced by the specified key in the specified COM object.</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT">
          <source>All COM objects wrapped in a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) have an associated hash table, to which <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A&gt;</ph> adds data.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=fullName&gt;</ph> retrieves data from the hash table.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should never have to call either method from your code.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve">
          <source>The COM object in which to store the data.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve">
          <source>The key in the internal hash table of the COM object in which to store the data.</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve">
          <source>The data to set.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the data was set successfully; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> is not a COM object.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve">
          <source>Returns the unmanaged size of an object in bytes.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method accepts an instance of a structure, which can be a reference type or a boxed value type.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT">
          <source>The layout must be sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The size returned is the size of the unmanaged object.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged and managed sizes of an object can differ.</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> method to determine how much unmanaged memory to allocate using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve">
          <source>The object whose size is to be returned.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>The size of the specified object in unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;structure&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve">
          <source>Returns the size of an unmanaged type in bytes.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method when you do not have a structure.</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT">
          <source>The layout must be sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The size returned is the size of the unmanaged type.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged and managed sizes of an object can differ.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve">
          <source>The type whose size is to be returned.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve">
          <source>The size of the specified type in unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter is a generic type.</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;t&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve">
          <source>Returns the size of an unmanaged type in bytes.</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method when you do not have a structure.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT">
          <source>The layout must be sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The size returned is the size of the unmanaged type.</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged and managed sizes of an object can differ.</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve">
          <source>The type whose size is to be returned.</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the type that is specified by the <ph id="ph1">&lt;code&gt;T&lt;/code&gt;</ph> generic type parameter.</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve">
          <source>Returns the unmanaged size of an object of a specified type in bytes.</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method accepts an instance of a structure, which can be a reference type or a boxed value type.</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT">
          <source>The layout must be sequential or explicit.</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT">
          <source>The size returned is the size of the unmanaged object.</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged and managed sizes of an object can differ.</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> method to determine how much unmanaged memory to allocate by using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve">
          <source>The object whose size is to be returned.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve">
          <source>The type of the <ph id="ph1">&lt;code&gt;structure&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the specified object in unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;structure&lt;/code&gt;</ph> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve">
          <source>Allocates a <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> and copies the contents of a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> into it.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the <ph id="ph1">`BSTR`</ph> when finished by calling <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve">
          <source>The managed string to be copied.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve">
          <source>An unmanaged pointer to the <ph id="ph1">`BSTR`</ph>, or 0 if <ph id="ph2">&lt;code&gt;s&lt;/code&gt;</ph> is null.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve">
          <source>The length for <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is out of range.</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT">
          <source>The characters of the string are copied as ANSI characters.</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve">
          <source>A managed string to be copied.</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve">
          <source>An integer representing a pointer to the block of memory allocated for the string, or 0 if <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT">
          <source>The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing.</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT">
          <source>On Windows 98, the characters are copied as ANSI characters.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT">
          <source>On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve">
          <source>A managed string to be copied.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve">
          <source>The allocated memory block, or 0 if <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve">
          <source>The length for <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is out of range.</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The characters of the string are copied as Unicode characters.</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve">
          <source>A managed string to be copied.</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve">
          <source>An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> into unmanaged memory, converting into ANSI format as it copies.</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve">
          <source>A managed string to be copied.</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, to where <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> into unmanaged memory, converting into ANSI format if required.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve">
          <source>A managed string to be copied.</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, to where the string was copied, or 0 if <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve">
          <source>There is insufficient memory available.</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve">
          <source>Copies the contents of a managed <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> into unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve">
          <source>A managed string to be copied.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve">
          <source>The address, in unmanaged memory, to where the <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve">
          <source>The method could not allocate enough native heap memory.</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve">
          <source>Marshals data from a managed object to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`structure`</ph> is a value type, it can be boxed or unboxed.</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it is boxed, it is unboxed before copying.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT">
          <source>A formatted class is a reference type whose layout is specified by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute, as either <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> copies the contents of <ph id="ph2">`structure`</ph> to the pre-allocated block of memory that the <ph id="ph3">`ptr`</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`structure`</ph> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <ph id="ph2">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>), the managed objects are kept alive with reference counts.</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT">
          <source>All other reference types (for example, strings and arrays) are marshaled to copies.</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT">
          <source>To release these managed or unmanaged objects, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=fullName&gt;</ph>method before you free the memory block.</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method to copy a different instance to the memory block at a later time, specify <ph id="ph2">`true`</ph> for <ph id="ph3">`fDeleteOld`</ph> to remove reference counts for reference types in the previous instance.</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the managed reference typesand unmanaged copies are effectively leaked.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The overall pattern for using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> is as follows:</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the first call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method after a memory block has been allocated, <ph id="ph2">`fDeleteOld`</ph> must be <ph id="ph3">`false`</ph>, because there are no contents to clear.</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`fDeleteOld`</ph> only if the block contains valid data.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you copy a different instance to the memory block, and the object contains reference types, <ph id="ph1">`fDeleteOld`</ph> must be <ph id="ph2">`true`</ph> to free reference types in the old contents.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the object contains reference types, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> method before you free the memory block.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pin an existing structure instead of copying it, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=fullName&gt;</ph> type to create a pinned handle for the structure.</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details on how to pin, see <bpt id="p1">[</bpt>Copying and Pinning<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve">
          <source>A managed object that holds the data to be marshaled.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve">
          <source>This object must be a structure or an instance of a formatted class.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory, which must be allocated before this method is called.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to call the <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)"&gt;&lt;/xref&gt;</ph> method on the <ph id="ph3">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before this method copies the data.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve">
          <source>The block must contain valid data.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve">
          <source>Note that passing <ph id="ph1">`false`</ph> when the memory block already contains data can lead to a memory leak.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;structure&lt;/code&gt;</ph> is a reference type that is not a formatted class.</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;structure&lt;/code&gt;</ph> is a generic type.</source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve">
          <source>Marshals data from a managed object of a specified type to an unmanaged block of memory.</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT">
          <source>A formatted class is a reference type whose layout is specified by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute, as either <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> copies the contents of <ph id="ph2">`structure`</ph> to the pre-allocated block of memory that the <ph id="ph3">`ptr`</ph> parameter points to.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`structure`</ph> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <ph id="ph2">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>), the managed objects are kept alive with reference counts.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT">
          <source>All other reference types (for example, strings and arrays) are marshaled to copies.</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT">
          <source>To release these managed or unmanaged objects, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29&gt;</ph> method before you free the memory block.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> method to copy a different instance to the memory block at a later time, specify <ph id="ph2">`true`</ph> for <ph id="ph3">`fDeleteOld`</ph> to remove reference counts for reference types in the previous instance.</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the managed reference types and unmanaged copies are effectively leaked.</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT">
          <source>The overall pattern for using<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> is as follows:</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the first call to the<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method after a memory block has been allocated, <ph id="ph2">`fDeleteOld`</ph> must be <ph id="ph3">`false`</ph>, because there are no contents to clear.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`fDeleteOld`</ph> only if the block contains valid data.</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you copy a different instance to the memory block, and the object contains reference types, <ph id="ph1">`fDeleteOld`</ph> must be <ph id="ph2">`true`</ph> to free reference types in the old contents.</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the object contains reference types, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> method before you free the memory block.</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pin an existing structure instead of copying it, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=fullName&gt;</ph> type to create a pinned handle for the structure.</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details on how to pin, see <bpt id="p1">[</bpt>Copying and Pinning<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve">
          <source>A managed object that holds the data to be marshaled.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve">
          <source>The object must be a structure or an instance of a formatted class.</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve">
          <source>A pointer to an unmanaged block of memory, which must be allocated before this method is called.</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to call the <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)"&gt;&lt;/xref&gt;</ph> method on the <ph id="ph3">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before this method copies the data.</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve">
          <source>The block must contain valid data.</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve">
          <source>Note that passing <ph id="ph1">`false`</ph> when the memory block already contains data can lead to a memory leak.</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve">
          <source>The type of the managed object.</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;structure&lt;/code&gt;</ph> is a reference type that is not a formatted class.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve">
          <source>Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems.</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve">
          <source>Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system.</source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve">
          <source>Throws an exception with a specific failure HRESULT value.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates an exception object for the specified failure HRESULT.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29&gt;</ph> method returns an exception based on the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread if one is set.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this happens, the <ph id="ph1">`errorCode`</ph> parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some failure HRESULTs map to defined exceptions, whereas others do not.</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the HRESULT maps to a defined exception, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> creates an instance of the exception and throws it.</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it creates an instance of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>, initializes the error code field with the HRESULT, and throws that exception.</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged <bpt id="p1">[</bpt>GetErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx)</ept> function.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Occasionally, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> might return an exception from a previous COM call.</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you can use the following workaround and pass <ph id="ph1">`IntPtr(-1)`</ph> as the second parameter (<ph id="ph2">`errorInfo`</ph>):</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve">
          <source>The HRESULT corresponding to the desired exception.</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve">
          <source>Throws an exception with a specific failure HRESULT, based on the specified <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface.</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates an exception object for the specified failure HRESULT.</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method releases the <ph id="ph2">`errorInfo`</ph> parameter, decreasing the COM reference count of the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface.</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method returns an exception based on the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread if one is set.</source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this happens, the <ph id="ph1">`errorCode`</ph> parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some failure HRESULTs map to defined exceptions, whereas others do not.</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the HRESULT maps to a defined exception, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> creates an instance of the exception and throws it.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it creates an instance of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException?displayProperty=fullName&gt;</ph>, initializes the error code field with the HRESULT, and throws that exception.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`errorInfo`</ph> parameter is used to retrieve extra information regarding the error.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve">
          <source>The HRESULT corresponding to the desired exception.</source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve">
          <source>A pointer to the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface that provides more information about the error.</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve">
          <source>You can specify <ph id="ph1">&lt;code&gt;IntPtr(0)&lt;/code&gt;</ph> to use the current <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface, or <ph id="ph2">&lt;code&gt;IntPtr(-1)&lt;/code&gt;</ph> to ignore the current <bpt id="p2">[</bpt>IErrorInfo<ept id="p2">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface and construct the exception just from the error code.</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve">
          <source>Gets the address of the element at the specified index inside the specified array.</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT">
          <source>The array must be pinned using a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> before it is passed to this method.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT">
          <source>For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve">
          <source>The array that contains the desired element.</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve">
          <source>The index in the <ph id="ph1">&lt;code&gt;arr&lt;/code&gt;</ph> parameter of the desired element.</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve">
          <source>The address of <ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> inside <ph id="ph2">&lt;code&gt;arr&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve">
          <source>Gets the address of the element at the specified index in an array of a specified type.</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The array must be pinned by using a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> before it is passed to this method.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT">
          <source>For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve">
          <source>The array that contains the desired element.</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve">
          <source>The index of the desired element in the <ph id="ph1">&lt;code&gt;arr&lt;/code&gt;</ph> array.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve">
          <source>The type of the array.</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve">
          <source>The address of <ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> in <ph id="ph2">&lt;code&gt;arr&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve">
          <source>Writes a single byte value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the target object.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve">
          <source>Writes a single byte value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve">
          <source>Writes a single byte value to unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve">
          <source>Writes a character as a 16-bit integer value to unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve">
          <source>Writes a 16-bit integer value to unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve">
          <source>The base address in the native heap to write to.</source>
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve">
          <source>Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the target object.</source>
        </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the target object.</source>
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve">
          <source>Writes a 32-bit signed integer value to unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve">
          <source>Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve">
          <source>Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the target object.</source>
        </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve">
          <source>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the target object.</source>
        </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve">
          <source>Writes a 64-bit signed integer value to unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve">
          <source>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory to write.</source>
        </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve">
          <source>Writes a processor native sized integer value into unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve">
          <source>The address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is not a recognized format.</source>
        </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve">
          <source>Writes a processor native-sized integer value to unmanaged memory at a specified offset.</source>
        </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</source>
        </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory to write to.</source>
        </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve">
          <source>Writes a processor native sized integer value to unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=fullName&gt;</ph>) to a separate managed array before setting its element values.</source>
        </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT">
          <source>Writing to unaligned memory locations is supported.</source>
        </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve">
          <source>The base address in unmanaged memory of the target object.</source>
        </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve">
          <source>An additional byte offset, which is added to the <ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> parameter before writing.</source>
        </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
        </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve">
          <source>Base address (<ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph>) plus offset byte (<ph id="ph2">&lt;code&gt;ofs&lt;/code&gt;</ph>) produces a null or invalid address.</source>
        </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;ptr&lt;/code&gt;</ph> is an <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve">
          <source>This method does not accept <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.ArrayWithOffset"&gt;&lt;/xref&gt;</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve">
          <source>Frees a <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> pointer that was allocated using the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> method first sets the contents of the BSTR to zero, and then frees the BSTR.</source>
        </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve">
          <source>The address of the <ph id="ph1">`BSTR`</ph> to free.</source>
        </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve">
          <source>The address of the unmanaged string to free.</source>
        </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve">
          <source>The address of the unmanaged string to free.</source>
        </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve">
          <source>The address of the unmanaged string to free.</source>
        </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve">
          <source>The address of the unmanaged string to free.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>