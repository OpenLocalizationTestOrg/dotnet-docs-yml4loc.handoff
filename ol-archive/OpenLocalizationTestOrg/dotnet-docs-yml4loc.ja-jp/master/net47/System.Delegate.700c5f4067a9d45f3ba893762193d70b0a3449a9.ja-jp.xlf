<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">49da96eaeed33a8edf35690343edfc3f61eebc87</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Delegate.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">57b101703ec3e8ceaf015f2d9ef15af7afdf5b5f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">761f9bc1c2ebfd3eb22f395b757a3849deaa3a95</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is the base class for delegate types.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class or from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is also not permissible to derive a new type from a delegate type.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is not considered a delegate type; it is a class used to derive delegate types.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most languages implement a <ph id="ph1">`delegate`</ph> keyword, and compilers for those languages are able to derive from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class; therefore, users should use the <ph id="ph3">`delegate`</ph> keyword provided by the language.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime provides an <ph id="ph1">`Invoke`</ph> method for each delegate type, with the same signature as the delegate.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Invoke`</ph> method is useful in <bpt id="p1">[</bpt>reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> when you want to find the signature of the delegate type.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime provides each delegate type with <ph id="ph1">`BeginInvoke`</ph> and <ph id="ph2">`EndInvoke`</ph> methods, to enable asynchronous invocation of the delegate.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about these methods, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>A delegate is an instance of a delegate type that has references to:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method of a type and a target object assignable to that type.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method of a type, with the hidden <ph id="ph1">`this`</ph> parameter exposed in the formal parameter list.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate is said to be an open instance delegate.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>A static method.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>A static method and a target object assignable to the first parameter of the method.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate is said to be closed over its first argument.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on delegate binding, see the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a delegate represents an open instance method, it stores a reference to the method's entry point.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate signature must include the hidden <ph id="ph1">`this`</ph> parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a delegate represents a static method, the delegate stores a reference to the method's entry point.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the delegate is invoked, the first argument of the static method receives the target object.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>An invocation list can contain duplicate methods.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>During an invocation, methods are invoked in the order in which they appear in the invocation list.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delegates are immutable; once created, the invocation list of a delegate does not change.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Combining operations, such as <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, do not alter existing delegates.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>A combining operation returns <ph id="ph1">`null`</ph> when the result of the operation is a delegate that does not reference at least one method.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>A combining operation returns an unchanged delegate when the requested operation has no effect.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>Managed languages use the <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> methods to implement delegate operations.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Examples include the <ph id="ph1">`AddHandler`</ph> and <ph id="ph2">`RemoveHandler`</ph> statements in Visual Basic and the += and -= operators on delegate types in C#.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, generic delegate types can have variant type parameters.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be combinable, the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, but the two delegates cannot be combined because the types do not match exactly.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Catching the exception in the caller does not alter this behavior.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The closest equivalent of a delegate in C or C++ is a function pointer.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>A delegate can represent a static method or an instance method.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike function pointers, delegates are object oriented and type safe.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Initializes a delegate that invokes the specified instance method on the specified class instance.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor cannot be used in application code.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a delegate by specifying the name of an instance method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name and a target object.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> method overload creates a delegate for an instance method with a specified name.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor creates delegates for instance methods only.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The class instance on which the delegate invokes <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The name of the instance method that the delegate represents.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>There was an error binding to the target method.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Initializes a delegate that invokes the specified static method from the specified class.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor cannot be used in application code.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a delegate by specifying the name of a static method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name but does not specify a target object.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> method overload creates a static delegate for a method with a specified name.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor creates delegates for static methods only.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> representing the class that defines <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The name of the static method that the delegate represents.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> represents an open generic type.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of the delegate.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>The clone has the same <ph id="ph1">&lt;xref:System.Type&gt;</ph>, target, method, and invocation list as the original delegate.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the field is a value type, a bit-by-bit copy of the field is performed.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>A shallow copy of the delegate.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Concatenates the invocation lists of an array of delegates.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`delegates`</ph> array contains entries that are <ph id="ph2">`null`</ph>, those entries are ignored.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be combinable, the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The array of delegates to combine.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">delegates</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`null`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">delegates</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">delegates</ph><ept id="p2">&lt;/code&gt;</ept> contains zero elements, or if every entry in <bpt id="p3">&lt;code&gt;</bpt><ph id="ph5">delegates</ph><ept id="p3">&lt;/code&gt;</ept> is <ph id="ph6">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Not all the non-null entries in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">delegates</ph><ept id="p1">&lt;/code&gt;</ept> are instances of the same delegate type.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Concatenates the invocation lists of two delegates.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be combinable, the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The delegate whose invocation list comes first.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The delegate whose invocation list comes last.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A new delegate with an invocation list that concatenates the invocation lists of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">a</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">b</ph><ept id="p2">&lt;/code&gt;</ept> in that order.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Returns <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">a</ph><ept id="p1">&lt;/code&gt;</ept> if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">b</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, returns <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">b</ph><ept id="p3">&lt;/code&gt;</ept> if <bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">a</ph><ept id="p4">&lt;/code&gt;</ept> is a null reference, and returns a null reference if both <bpt id="p5">&lt;code&gt;</bpt><ph id="ph6">a</ph><ept id="p5">&lt;/code&gt;</ept> and <bpt id="p6">&lt;code&gt;</bpt><ph id="ph7">b</ph><ept id="p6">&lt;/code&gt;</ept> are null references.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Both <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">a</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">b</ph><ept id="p2">&lt;/code&gt;</ept> are not <ph id="ph3">`null`</ph>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">a</ph><ept id="p3">&lt;/code&gt;</ept> and <bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">b</ph><ept id="p4">&lt;/code&gt;</ept> are not instances of the same delegate type.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method applies only if the current delegate is multicast (combinable).</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current implementation simply throws a <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">d</ph><ept id="p1">&lt;/code&gt;</ept>, or the current multicast (combinable) delegate if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">d</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Always thrown.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates delegates for static methods only.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> representing the class that implements <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The name of the static method that the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept> cannot be bound; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>That is, its <ph id="ph1">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a <ph id="ph2">`static`</ph> method (<ph id="ph3">`Shared`</ph> method in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;code&gt;throwOnBindFailure&lt;/code&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates delegates for static methods only.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> representing the class that implements <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The name of the static method that the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>That is, its <ph id="ph1">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a <ph id="ph2">`static`</ph> method (<ph id="ph3">`Shared`</ph> method in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, for example because it cannot be found.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates delegates for instance methods only.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The class instance on which <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept> is invoked.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The name of the instance method that the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not an instance method.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, for example because it cannot be found.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload and the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use them to create delegates for either static or instance methods, with or without a first argument.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload for better performance.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate type and the method must have compatible return types.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the most common case for static methods.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compatible Parameter Types and Return Type</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 1.0 and 1.1 the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Determining the Methods a Delegate Can Represent</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> representing the type of delegate to create.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> that is the first argument of the method the delegate represents.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For instance methods, it must be compatible with the instance type.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> describing the static or instance method the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept> cannot be bound; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified static or instance method, or <ph id="ph1">`null`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">throwOnBindFailure</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`false`</ph> and the delegate cannot be bound to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">method</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, and <ph id="ph2">&lt;code&gt;throwOnBindFailure&lt;/code&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeMethodInfo`</ph>.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates delegates for instance methods only.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The class instance on which <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept> is invoked.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The name of the instance method that the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept> cannot be bound; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not an instance method.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;code&gt;throwOnBindFailure&lt;/code&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compatible Parameter Types and Return Type</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> describing the static or instance method the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept> cannot be bound; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type to represent the specified static method.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, and <ph id="ph2">&lt;code&gt;throwOnBindFailure&lt;/code&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeMethodInfo`</ph>.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates delegates for instance methods only.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>The class instance on which <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept> is invoked.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>The name of the instance method that the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not an instance method.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, for example because it cannot be found.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>These two overloads provide the most flexible way to create delegates.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload for better performance.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate type and the method must have compatible return types.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the most common case for static methods.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compatible Parameter Types and Return Type</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>Determining the Methods a Delegate Can Represent</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>The object to which the delegate is bound, or <ph id="ph1">`null`</ph> to treat <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept> as <ph id="ph3">`static`</ph> (<ph id="ph4">`Shared`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> describing the static or instance method the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified static or instance method.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeMethodInfo`</ph>.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method creates delegates for static methods only.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> representing the class that implements <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>The name of the static method that the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;target&lt;/code&gt;</ph> is an open generic type.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>That is, its <ph id="ph1">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a <ph id="ph2">`static`</ph> method (<ph id="ph3">`Shared`</ph> method in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;code&gt;throwOnBindFailure&lt;/code&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type to represent the specified static method.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compatible Parameter Types and Return Type</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of delegate to create.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> describing the static or instance method the delegate is to represent.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Only static methods are supported in the .NET Framework version 1.0 and 1.1.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>A delegate of the specified type to represent the specified static method.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> does not inherit <ph id="ph2">&lt;xref href="System.MulticastDelegate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;type&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a static method, and the .NET Framework version is 1.0 or 1.1.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> cannot be bound.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;method&lt;/code&gt;</ph> is not a <ph id="ph2">`RuntimeMethodInfo`</ph>.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/en-us/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Invoke`</ph> method of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is not found.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The caller does not have the permissions necessary to access <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">method</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method calls the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph>, if the method represented by the current delegate does not require arguments.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The object returned by the method represented by the delegate.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>The number, order, or type of parameters listed in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> is invalid.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>One of the encapsulated methods throws an exception.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method implements the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph>, if the method represented by the current delegate does not require arguments.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The object returned by the method represented by the delegate.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The number, order, or type of parameters listed in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> is invalid.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>One of the encapsulated methods throws an exception.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>The methods and targets are compared for equality as follows:</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>The object to compare with the current delegate.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> and the current delegate have the same targets, methods, and invocation list; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the delegate.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value of this method must not be persisted for two reasons.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>A hash code for the delegate.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Returns the invocation list of the delegate.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each delegate in the array represents exactly one method.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>An array of delegates representing the invocation list of the current delegate.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Gets the static method represented by the current delegate.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method applies only if the current delegate represents a static method.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> describing the static method represented by the current delegate.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>Not supported.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>Not supported.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Not supported.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>This method is not supported.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Gets the method represented by the delegate.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> describing the method represented by the delegate.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Determines whether the specified delegates are equal.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>The methods and targets are compared for equality as follows:</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>The first delegate to compare.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>The second delegate to compare.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">d1</ph><ept id="p1">&lt;/code&gt;</ept> is equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">d2</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Determines whether the specified delegates are not equal.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>The methods and targets are compared for equality as follows:</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The first delegate to compare.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The second delegate to compare.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">d1</ph><ept id="p1">&lt;/code&gt;</ept> is not equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">d2</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, the last occurrence is removed.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">source</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>A new delegate with an invocation list formed by taking the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">source</ph><ept id="p1">&lt;/code&gt;</ept> and removing the last occurrence of the invocation list of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept>, if the invocation list of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found within the invocation list of <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">source</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>Returns <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">source</ph><ept id="p1">&lt;/code&gt;</ept> if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph> or if the invocation list of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p3">&lt;/code&gt;</ept> is not found within the invocation list of <bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">source</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Returns a null reference if the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is equal to the invocation list of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">source</ph><ept id="p2">&lt;/code&gt;</ept> or if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">source</ph><ept id="p3">&lt;/code&gt;</ept> is a null reference.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>The delegate types do not match.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, all occurrences are removed.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">source</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>A new delegate with an invocation list formed by taking the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">source</ph><ept id="p1">&lt;/code&gt;</ept> and removing all occurrences of the invocation list of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept>, if the invocation list of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p3">&lt;/code&gt;</ept> is found within the invocation list of <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">source</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>Returns <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">source</ph><ept id="p1">&lt;/code&gt;</ept> if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph> or if the invocation list of <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p3">&lt;/code&gt;</ept> is not found within the invocation list of <bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">source</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>Returns a null reference if the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is equal to the invocation list of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">source</ph><ept id="p2">&lt;/code&gt;</ept>, if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">source</ph><ept id="p3">&lt;/code&gt;</ept> contains only a series of invocation lists that are equal to the invocation list of <bpt id="p4">&lt;code&gt;</bpt><ph id="ph4">value</ph><ept id="p4">&lt;/code&gt;</ept>, or if <bpt id="p5">&lt;code&gt;</bpt><ph id="ph5">source</ph><ept id="p5">&lt;/code&gt;</ept> is a null reference.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The delegate types do not match.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Removes the invocation list of a delegate from the invocation list of another delegate.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of <ph id="ph2">`value`</ph> is said to occur within the current delegate's invocation list.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the current delegate's invocation list, the last occurrence is removed.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>, if the invocation list of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept> is found within the current delegate's invocation list.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>Returns the current delegate if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph> or if the invocation list of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p2">&lt;/code&gt;</ept> is not found within the current delegate's invocation list.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`null`</ph> if the invocation list of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> is equal to the current delegate's invocation list.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>Gets the class instance on which the current delegate invokes the instance method.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <ph id="ph1">`null`</ph> if the delegate represents a static method.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>